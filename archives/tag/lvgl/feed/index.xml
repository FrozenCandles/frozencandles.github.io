<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>LVGL归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/lvgl/feed?simply_static_page=3733" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Mon, 12 Dec 2022 12:10:10 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>LVGL归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>LVGL库入门教程06-动画</title>
		<link>/archives/425</link>
					<comments>/archives/425#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Tue, 28 Jun 2022 12:35:06 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=425</guid>

					<description><![CDATA[<p>动画可以说是 LVGL 中的特色之一，不过在使用动画&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/425">LVGL库入门教程06-动画</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>动画可以说是 LVGL 中的特色之一，不过在使用动画前，请确保单片机具有足够的性能来维持足够的帧率。</p>
<h2>transition：过渡动画</h2>
<p>当一个控件的状态发生改变时，可以让样式也发生变化以提醒用户。通过过渡动画(transition)可以让样式的改变更自然。例如，按钮在点击时，以及开关在切换时，都具有一小段的过渡动画。</p>
<p>过渡动画使用 <code>lv_style_transition_dsc_t</code> 结构描述。为了要设置过渡动画，需要提供以下信息：</p>
<ul>
<li>哪些属性需要过渡</li>
<li>过渡前的延时</li>
<li>过渡持续的时间</li>
<li>过渡动画（以回调函数的形式提供）</li>
</ul>
<p>这些信息和结构成员是一一对应的。除了直接给结构成员赋值外，也可以使用以下初始化函数一次性设置：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_style_transition_dsc_init</span><span class="hljs-params">(
                <span class="hljs-keyword">lv_style_transition_dsc_t</span>* tr, 
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_style_prop_t</span> props[],
                <span class="hljs-keyword">lv_anim_path_cb_t</span> path_cb, 
                <span class="hljs-keyword">uint32_t</span> time, 
                <span class="hljs-keyword">uint32_t</span> delay, 
                <span class="hljs-keyword">void</span>* user_data)</span></span>;
</pre></div>
<p>第一个参数需要提供被初始化的过渡动画结构，第二个参数数组和字符串一样需要以 <code>0</code> 结尾。例如，假设需要实现这样一个过渡效果：点击时背景颜色发生改变并拉长，那么相应的初始化过程为：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_transition_dsc_t</span> trans;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_style_prop_t</span> trans_props[] = {
    LV_STYLE_WIDTH, LV_STYLE_HEIGHT, LV_STYLE_BG_COLOR, <span class="hljs-number">0</span>,
};
<span class="hljs-built_in">lv_style_transition_dsc_init</span>(&amp;trans, trans_props, 
            lv_anim_path_ease_in_out, <span class="hljs-number">500</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);
</pre></div>
<p>这里使用的动画效果函数为 <code>lv_anim_path_ease_in_out()</code> ，这是一个内置的过渡效果，与之类似的过渡函数可以参考下表：</p>
<table>
<thead>
<tr>
<th>动画函数</th>
<th>过渡效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lv_anim_path_linear</code></td>
<td>等速过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_ease_in</code></td>
<td>先慢后快的过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_ease_out</code></td>
<td>先快后慢的过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_ease_in_out</code></td>
<td>先慢、后快、结尾再变慢的过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_overshoot</code></td>
<td>幅度会稍微过头一些再弹回的过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_bounce</code></td>
<td>和上一个类似，不过会比较快地多弹几次</td>
</tr>
<tr>
<td><code>lv_anim_path_step</code></td>
<td>一步到位，和没动画的区别在于多了个延时</td>
</tr>
</tbody>
</table>
<p>过渡动画是控件样式的一部分，可以将初始化得到的过渡动画描述应用到样式上：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_trans;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_trans);
<span class="hljs-built_in">lv_style_set_transition</span>(&amp;style_trans, &amp;trans);
</pre></div>
<p>过渡动画只有在两种样式切换时才会发生。例如，如果让以上样式应用在按下状态下：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_bg_color</span>(&amp;style_trans, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED));
<span class="hljs-built_in">lv_style_set_width</span>(&amp;style_trans, <span class="hljs-number">150</span>);
<span class="hljs-built_in">lv_style_set_height</span>(&amp;style_trans, <span class="hljs-number">60</span>);
<span class="hljs-built_in">lv_obj_add_style</span>(obj, &amp;style_trans, LV_STATE_PRESSED);
</pre></div>
<p>那么只有在从其它状态变为按下时才会发生过渡：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-transition.gif" alt="image" width="240"></figure>
<p>注意松开时样式是突然转变的。如果要给这部分也添加一个过渡效果，可以给默认状态下的控件添加一个包含过渡的样式。</p>
<h2>animate：通用动画</h2>
<p>过渡只有在状态改变时才会发生，而动画可以在任意时刻进行。除此之外，两者的区别还有：过渡只是样式的一部分，而动画和样式之间是独立的。</p>
<p>实际上，过渡的底层也使用的是动画。</p>
<h3>创建动画</h3>
<p>为了创建动画，需要像样式一样声明一个动画类型并初始化：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_anim_t</span> anim;
<span class="hljs-built_in">lv_anim_init</span>(&amp;anim);
</pre></div>
<p>由于动画是立即执行的，因此可以使用自动变量存储。然后，需要明确该动画将作用于哪一个控件：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_set_var</span>(&amp;anim, obj);
</pre></div>
<p>接下来，可以设置动画的各种轨迹，包括：</p>
<ul>
<li>动画需要改变什么属性</li>
<li>这些属性改变的范围</li>
<li>动画效果</li>
<li>延时和持续时间</li>
</ul>
<p>动画的这些属性和过渡是类似的。例如，假设想做一个控件下落的动画，那么需要提供一个改变 y 坐标值的回调函数，这个函数可以直接使用 <code>lv_obj_set_y()</code> ，然后设定改变的始末值和运动轨迹，对应的代码为：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_set_exec_cb</span>(&amp;anim, (<span class="hljs-keyword">lv_anim_exec_xcb_t</span>)lv_obj_set_y);
<span class="hljs-built_in">lv_anim_set_values</span>(&amp;anim, <span class="hljs-number">-100</span>, <span class="hljs-number">100</span>);
<span class="hljs-built_in">lv_anim_set_path_cb</span>(&amp;anim, lv_anim_path_bounce);
<span class="hljs-built_in">lv_anim_set_time</span>(&amp;anim, <span class="hljs-number">1000</span>);
<span class="hljs-built_in">lv_anim_set_delay</span>(&amp;anim, <span class="hljs-number">1000</span>);
</pre></div>
<p>然后，可以在必要的时候执行动画：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_start</span>(&amp;anim);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-animation-1.gif" alt="image" width="230"></figure>
<blockquote>
<p><strong>关于延迟渲染</strong></p>
<p>之前说过，样式是延迟渲染的，因此样式变量需要使用 <code>static</code> 存储类型修饰符；而动画不是，动画从创建到执行是立即发生的。这也很好理解：样式在创建的过程中可能发生多次修改，因此需要确定最终的表现结果如何，再着手绘制，否则整个控件可能会重绘多次，占用大量无效的资源。</p>
<p>这种特点可能会带来许多意想不到的问题。例如，假设在 <code>lv_anim_set_values()</code> 函数中去获取一个控件的位置、宽度等信息，由于它们都属于样式的一部分，此时还没有实际计算，因此得到的可能是默认值，造成动画始末效果偏离预期轨迹。</p>
<p>要解决这个问题，要么手动设置具体的值，要么让动画等到实际渲染发生了再执行，例如将其作为事件回调函数中的一部分。</p>
</blockquote>
<h3>更复杂的动画</h3>
<p>以上创建的动画是单次不重复的，LVGL 提供了许多函数，可以为动画设置更复杂的属性。</p>
<p>这里介绍一个控件 bar ，它实质上就是没有 knob 部分的滑块，可以借用该控件来创建一个进度条(progress bar)动画。以下创建一个 bar 并将它的模式设定为 <code>LV_BAR_MODE_RANGE</code> ，这样就可以同时修改 indicator 两端的位置了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* bar = <span class="hljs-built_in">lv_bar_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_bar_set_mode</span>(bar, LV_BAR_MODE_RANGE);
</pre></div>
<p>这里使用官方文档中提供的一个样式来使外观更好看，具体细节就无需解释了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_bg;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_indic;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_bg);
<span class="hljs-built_in">lv_style_set_border_color</span>(&amp;style_bg, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
<span class="hljs-built_in">lv_style_set_border_width</span>(&amp;style_bg, <span class="hljs-number">2</span>);
<span class="hljs-built_in">lv_style_set_pad_all</span>(&amp;style_bg, <span class="hljs-number">6</span>);
<span class="hljs-built_in">lv_style_set_radius</span>(&amp;style_bg, <span class="hljs-number">6</span>);
<span class="hljs-built_in">lv_style_set_anim_time</span>(&amp;style_bg, <span class="hljs-number">1000</span>);
<span class="hljs-built_in">lv_style_init</span>(&amp;style_indic);
<span class="hljs-built_in">lv_style_set_bg_opa</span>(&amp;style_indic, LV_OPA_COVER);
<span class="hljs-built_in">lv_style_set_bg_color</span>(&amp;style_indic, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
<span class="hljs-built_in">lv_style_set_radius</span>(&amp;style_indic, <span class="hljs-number">3</span>);
<span class="hljs-built_in">lv_obj_remove_style_all</span>(bar);
<span class="hljs-built_in">lv_obj_add_style</span>(bar, &amp;style_bg, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_add_style</span>(bar, &amp;style_indic, LV_PART_INDICATOR);
<span class="hljs-built_in">lv_obj_set_size</span>(bar, <span class="hljs-number">200</span>, <span class="hljs-number">20</span>);
</pre></div>
<p>然后就可以确定动画效果了。例如，这里期望的动画效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-animation-2.gif" alt="image" width="250"></figure>
<p>那么首先可以编写一个改变属性的回调函数，例如改变 indicator 的范围：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anim_progress_load</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* obj, <span class="hljs-keyword">int32_t</span> v)</span> </span>{
    <span class="hljs-built_in">lv_bar_set_start_value</span>(obj, v, LV_ANIM_ON);
    <span class="hljs-built_in">lv_bar_set_value</span>(obj, <span class="hljs-number">20</span> + v, LV_ANIM_ON);
}
</pre></div>
<p>这些值在 0~80 范围内等速改变，持续时间 1.5 秒，无延时，对应的代码为：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_set_exec_cb</span>(&amp;anim, anim_progress_load);
<span class="hljs-built_in">lv_anim_set_values</span>(&amp;anim, <span class="hljs-number">0</span>, <span class="hljs-number">80</span>);
<span class="hljs-built_in">lv_anim_set_path_cb</span>(&amp;anim, lv_anim_path_linear);
<span class="hljs-built_in">lv_anim_set_time</span>(&amp;anim, <span class="hljs-number">1500</span>);
<span class="hljs-built_in">lv_anim_set_delay</span>(&amp;anim, <span class="hljs-number">0</span>);
</pre></div>
<p>然后这里为其添加一个倒退和重复效果，这样动画就能来回播放了：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_set_playback_time</span>(&amp;anim, <span class="hljs-number">1500</span>);
<span class="hljs-built_in">lv_anim_set_repeat_count</span>(&amp;anim, LV_ANIM_REPEAT_INFINITE);
</pre></div>
<p>实现的进度条动画就像以上 gif 展示的一样。除此之外，还可以修改更多动画的细节，例如：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>设置内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lv_anim_set_start_cb(anim, start_cb)</code></td>
<td>在延时后、开始前执行一个函数</td>
</tr>
<tr>
<td><code>lv_anim_set_playback_delay(anim, delay)</code></td>
<td>设置动画倒退前的延时</td>
</tr>
<tr>
<td><code>lv_anim_set_repeat_delay(anim, delay)</code></td>
<td>设置动画重复前的延时</td>
</tr>
<tr>
<td><code>lv_anim_set_early_apply(&amp;a, bool)</code></td>
<td>是否将起始值应用到动画开始前，使动画执行时不会太突兀</td>
</tr>
</tbody>
</table>
<p>更多的细节可以参考官方文档。</p>
<h3>组合动画效果</h3>
<p>有时候需要同时播放较多动画，此时如果逐个播放的话，需要逐个为动画设计延时，不方便安排。此时，可以使用 LVGL 提供的时间线(timeline)统一安排各个动画。</p>
<p>时间线的创建非常简单。首先，创建一系列动画，但先不调用 <code>lv_anim_start()</code> 让动画开始。</p>
<p>其次，创建一个时间线并将各个动画添加到时间线的某一时刻处：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_anim_timeline_t</span>* anim_timeline = <span class="hljs-built_in">lv_anim_timeline_create</span>();
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">0</span>, &amp;anim_axis);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">100</span>, &amp;anim_obj_01);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">1100</span>, &amp;anim_obj_02);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">2100</span>, &amp;anim_obj_03);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">300</span>, &amp;anim_label_01);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">1300</span>, &amp;anim_label_02);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">2300</span>, &amp;anim_label_03);
</pre></div>
<p>使用时间线时，无需为动画设计延时，只需要关注动画会在什么时刻播放，延时便会自动计算。</p>
<p>添加完毕后，再调用时间线的执行函数就可以了：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_timeline_start</span>(anim_timeline);
</pre></div>
<p>这样就可以创建很复杂的组合动画效果了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-timeline.gif" alt="image" width="230"></figure>
<p>使用时间线可以方便管理所有动画，可以将时间线上包含的所有动画停播、倒放、跳转等。以下列出了一些常用的时间线控制函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lv_anim_timeline_stop(timeline)</code></td>
<td>暂停播放当前的所有动画</td>
</tr>
<tr>
<td><code>lv_anim_timeline_set_reverse(timeline, bool)</code></td>
<td>设置接下来的播放方向</td>
</tr>
<tr>
<td><code>lv_anim_timeline_set_progress(timeline, progress)</code></td>
<td>跳转到播放进度</td>
</tr>
</tbody>
</table>
<p>如果需要倒放，在设置了播放方向后还需要调用 <code>lv_anim_timeline_start()</code> 重新播放，并且会从当前位置倒放。</p>
<h2>scroll：滚动动画</h2>
<h3>滚动的特点</h3>
<p>滚动也是常见的一种动画效果。如果一个容器的尺寸不足以容纳它包含的控件，那么它就可以通过滚动来展示包含控件的所有部分。</p>
<p>为了使一个控件是可滚动的，它需要拥有标志 <code>LV_OBJ_FLAG_SCROLLABLE</code> 。清除该标志可以隐藏子控件的溢出部分。</p>
<p>滚动是可以冒泡的，如果一个控件已经滚动到底，再次对其尝试滚动将使滚动事件传播到父容器上。可以通过清除 <code>LV_OBJ_FLAG_SCROLL_CHAIN</code> 标志位去除这个性质。</p>
<p>可以通过 <code>lv_obj_set_scroll_dir()</code> 限制滚动的方向。例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_scroll_dir</span>(obj, LV_DIR_RIGHT);
</pre></div>
<p>那么就只能向右滚动到底，不能向左折回。</p>
<p>还可以通过以下几个函数利用代码执行滚动：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_scroll_to</span>(obj, x, y, anim_en);
<span class="hljs-built_in">lv_obj_scroll_by</span>(obj, x, y, anim_en);
<span class="hljs-built_in">lv_obj_scroll_to_view</span>(child, anim_en);
</pre></div>
<p>注意前两个函数的区别：前者是滚动到相应的位置，多次调用只有第一次实际有效；后者是模拟滚动的操作，实际滚动方向是相反的，并且多次调用效果可以叠加。除此之外，后者甚至可以滚动到超出子控件的范围之外。最后一个函数自动滚动到合适的位置，确保子控件可视。</p>
<p>这几个函数都不受滚动方向的约束。它们都具有第三个参数，用于指定滚动时是否提供滚动动画。</p>
<h3>滚动动画</h3>
<p>滚动是有动画的，默认情况下，滚动动画的特点表现在以下几点：</p>
<ul>
<li>滚动是具有惯性的，意思是当输入设备停止交互时，控件还会继续向前滚动一小段距离。可以通过清除 <code>LV_OBJ_FLAG_SCROLL_MOMENTUM</code> 标志位取消这个特征</li>
<li>滚动是具有弹性的，当滚动到底时，继续尝试滚动会使控件超出一定范围，松开后回弹。可以通过清除 <code>LV_OBJ_FLAG_SCROLL_ELASTIC</code> 标志位取消这个特征</li>
<li>除此之外，以上介绍的两个代码实现滚动的函数，如果在第三个参数中应用滚动，那么会发生一小段 easy-out 的切换动画</li>
</ul>
<p>还可以设置一种特殊的滚动效果 snap ，它使滚动时可以自动对齐。为了启用这种效果，需要添加 <code>LV_OBJ_FLAG_SNAPPABLE</code> 标志位，然后设置对齐的方式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_scroll_snap_x</span>(cont, LV_SCROLL_SNAP_START);
</pre></div>
<p>这样便可以按开始位置对齐了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-scroll-snap.gif" alt="image" width="220"></figure>
<p>还可以配合 <code>LV_OBJ_FLAG_SCROLL_ONE</code> 标志位一次只滚过最多一个控件的位置。</p>
<hr>
<p>在滚动时，会触发 <code>LV_EVENT_SCROLL</code> 事件，可以通过在该事件回调函数中对包含的子控件做变换，实现更复杂的滚动效果。</p>
<p>例如，以下在事件回调函数内，根据每个子控件当前位置的纵坐标对横坐标做一些变换：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">scrool_widget_cb</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span> </span>{
    <span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_event_get_target</span>(e);
    <span class="hljs-keyword">uint32_t</span> child_cnt = <span class="hljs-built_in">lv_obj_get_child_cnt</span>(cont);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; child_cnt; i++) {
        <span class="hljs-keyword">lv_obj_t</span>* child = <span class="hljs-built_in">lv_obj_get_child</span>(cont, i);
        <span class="hljs-built_in">lv_obj_set_style_translate_x</span>(child, child-&gt;coords.y1 * <span class="hljs-number">0.5</span> - <span class="hljs-number">60</span>, <span class="hljs-number">0</span>);
    }
}
</pre></div>
<p>然后让每次滚动时都做以上变换：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_add_event_cb</span>(cont, scrool_widget_cb, LV_EVENT_SCROLL, <span class="hljs-literal">NULL</span>);
</pre></div>
<p>这样就能实现斜方向的滚动效果了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-scroll-slope.gif" alt="image" width="210"></figure>
<p>这里由于仅在事件中才修改按钮的水平位置，因此一开始控件的摆放不是倾斜的。要解决这个问题，可以添加以下代码：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_scroll_to_view</span>(<span class="hljs-built_in">lv_obj_get_child</span>(cont, <span class="hljs-number">0</span>), LV_ANIM_OFF);
<span class="hljs-built_in">lv_event_send</span>(cont, LV_EVENT_SCROLL, <span class="hljs-literal">NULL</span>);
</pre></div>
<p>前者使各个控件的坐标被计算，后者手动触发事件回调函数，利用计算出的坐标执行位置变换。</p>
<p>LVGL 的官方文档还给出了一个示例，可以实现类似圆形的旋转滚动，效果非常不错，不过涉及的计算较多，感兴趣的可以自行阅读官方文档。</p>
<h3>滚动条</h3>
<p>如果一个控件可以发生滚动，那么它就具有滚动条(scrollbar)。可以通过 <code>lv_obj_set_scrollbar_mode()</code> 函数修改滚动条的模式。例如，使用 <code>LV_SCROLLBAR_MODE_OFF</code> 模式可以使滚动条完全消失，就像上一张 gif 显示的那样。</p>
<p>滚动条是一个控件的 <code>LV_PART_SCROLLBAR</code> 部分，可以通过选择器给滚动条加上不同的样式。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/overview/animation.html">https://docs.lvgl.io/master/overview/animation.html</a></p>
<p><a href="https://docs.lvgl.io/master/overview/scroll.html">https://docs.lvgl.io/master/overview/scroll.html</a></p>
<p><a rel="nofollow" href="/archives/425">LVGL库入门教程06-动画</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/425/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程05-颜色和图像</title>
		<link>/archives/383</link>
					<comments>/archives/383#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 24 Jun 2022 01:49:34 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=383</guid>

					<description><![CDATA[<p>颜色 构造颜色 在 LVGL 中，颜色以结构 lv_&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/383">LVGL库入门教程05-颜色和图像</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>颜色</h2>
<h3>构造颜色</h3>
<p>在 LVGL 中，颜色以结构 <code>lv_color_t</code> 表示。在最开始移植整个工程时，曾经在 <code>lv_conf.h</code> 中修改过颜色深度：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/*Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888)*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_COLOR_DEPTH 32</span>
</pre></div>
<p>LVGL 会自动根据所选的颜色深度创建合适的颜色结构。在接下来几处位置还有几个与颜色有关的配置选项，可以参照注释修改。</p>
<p>例如，16 位 big-endian 的颜色定义为：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
        <span class="hljs-keyword">uint16_t</span> blue  : <span class="hljs-number">5</span>;
        <span class="hljs-keyword">uint16_t</span> green : <span class="hljs-number">6</span>;
        <span class="hljs-keyword">uint16_t</span> red   : <span class="hljs-number">5</span>;
    } ch;
    <span class="hljs-keyword">uint16_t</span> full;
} <span class="hljs-keyword">lv_color16_t</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">lv_color16_t</span> <span class="hljs-keyword">lv_color_t</span>;
</pre></div>
<p>那么就可以根据该结构创建合适的颜色值了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> orange = {
    .ch = {
        .red   = <span class="hljs-number">0b11111</span>,
        .green = <span class="hljs-number">0b101001</span>,
        .blue  = <span class="hljs-number">0</span>
    }
};
</pre></div>
<p>直接创建 RGB565 的颜色格式有点难以调色，不过可以借用以下函数从十六位颜色中生成合适的颜色值：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> orange = <span class="hljs-built_in">lv_color_make</span>(<span class="hljs-number">0xFF</span>, <span class="hljs-number">0xA5</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 从颜色通道创建</span>
<span class="hljs-keyword">lv_color_t</span> aqua = <span class="hljs-built_in">lv_color_hex</span>(<span class="hljs-number">0x00FFFF</span>);          <span class="hljs-comment">// 从十六进制创建</span>
<span class="hljs-keyword">lv_color_t</span> lightgrey = <span class="hljs-built_in">lv_color_hex3</span>(<span class="hljs-number">0xddd</span>);       <span class="hljs-comment">// 从十六进制简写创建</span>
</pre></div>
<p>这些颜色在创建时，每种颜色通道的值都使用 0~255 表示即可，创建过程中会自动转换为合适的颜色值。</p>
<p>LVGL 还提供了 HSV 格式的颜色支持，</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> red = <span class="hljs-built_in">lv_color_hsv_to_rgb</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);   <span class="hljs-comment">// 从 HSV 颜色空间创建颜色</span>
<span class="hljs-keyword">lv_color_hsv_t</span> blue = <span class="hljs-built_in">lv_color_rgb_to_hsv</span>(r, g, b);  <span class="hljs-comment">// 将 RGB 颜色转换为 HSV 颜色</span>
</pre></div>
<p>除此之外，<code>lv_color_t</code> 、RGB 颜色、HSV 颜色之间也能互相转换。</p>
<hr>
<p>如果觉得 16 进制的颜色还是不够直观，还可以使用调色板功能。LVGL 提供了常用颜色的色值表示，可以直接使用、微调、混合这些颜色。</p>
<p>例如，以下直接调出了一个紫色：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> purple = <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_PURPLE)
</pre></div>
<p>如果觉得默认的紫色太深或太浅的话，还可以在调色板中更改亮度：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> dark_purple = <span class="hljs-built_in">lv_palette_darken</span>(LV_PALETTE_PURPLE, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 调深两级，最多可以调深或浅 4 级</span>
<span class="hljs-keyword">lv_color_t</span> light_purple = <span class="hljs-built_in">lv_color_lighten</span>(purple, <span class="hljs-number">60</span>);  <span class="hljs-comment">// 调浅一些，调到 255 就变成纯白</span>
</pre></div>
<p>甚至还可以将两种颜色混合：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> orange = <span class="hljs-built_in">lv_color_mix</span>(red, yellow, <span class="hljs-number">156</span>);
</pre></div>
<p>比例的取值为 0~255 ，例如设定为 0 就是全红，128 就是红黄各占一半等。</p>
<p>可以将一个颜色类型直接应用到以下样式属性中：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bg_color</code></td>
<td>背景颜色</td>
</tr>
<tr>
<td><code>border_color</code></td>
<td>边框颜色</td>
</tr>
<tr>
<td><code>outline_color</code></td>
<td>轮廓颜色</td>
</tr>
<tr>
<td><code>shadow_color</code></td>
<td>阴影颜色</td>
</tr>
<tr>
<td><code>text_color</code></td>
<td>文本颜色</td>
</tr>
</tbody>
</table>
<p>以及上一节提到的直线和弧线颜色。</p>
<h3>透明度</h3>
<p>有时候两个控件间可能发生重叠，这个时候就可以给它们设置一个透明度。</p>
<p>透明度使用类型 <code>lv_opa_t</code> 表示，LVGL 预定义了几个表示透明度的宏：<code>LV_OPA_TRANSP</code> 表示完全透明，<code>LV_OPA_COVER </code> 表示完全不透明，其余的 <code>LV_OPA_10 </code> ~ <code>LV_OPA_90 </code> 整十表示的透明度依次递减。</p>
<p>可以将透明度应用到以下样式属性中：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bg_opa</code></td>
<td>背景透明度</td>
</tr>
<tr>
<td><code>border_opa</code></td>
<td>边框透明度</td>
</tr>
<tr>
<td><code>outline_opa</code></td>
<td>轮廓透明度</td>
</tr>
<tr>
<td><code>shadow_opa</code></td>
<td>阴影透明度</td>
</tr>
<tr>
<td><code>text_opa</code></td>
<td>文本透明度</td>
</tr>
<tr>
<td><code>opa</code></td>
<td>整体透明度</td>
</tr>
</tbody>
</table>
<p>以及直线和弧线透明度。例如，以下创建了两个部分重叠的控件，并在一个的背景上加透明度：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_grass;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_grass);
<span class="hljs-built_in">lv_style_set_opa</span>(&amp;style_grass, LV_OPA_30);
<span class="hljs-keyword">lv_obj_t</span>* obj = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-keyword">lv_obj_t</span>* cover = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_add_style</span>(cover, &amp;style_grass, <span class="hljs-number">0</span>);
</pre></div>
<p>这样就可以看见被遮挡的控件了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-opacity.jpg" alt="image" width="140"></figure>
<p>注意需要给上层，即后创建的的控件加透明度才会有这样的效果。透明度其实就是为控件重新调色，因此不是 32 位颜色的屏幕也可以使用透明度。</p>
<p><code>lv_opa_t</code> 类型的本质就是 8 位无符号整数，因此可以自行创建一个透明度数值，设为 255 就代表完全透明；还可以将透明度应用到 <code>lv_color_mix()</code> 的第三个参数上。</p>
<h3>渐变色</h3>
<p>可以使用渐变色给控件加上更美观的效果。</p>
<p>只有背景颜色能设置渐变色。一个渐变色的效果由以下几个属性支配：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bg_color</code></td>
<td>主要颜色</td>
</tr>
<tr>
<td><code>bg_grad_color</code></td>
<td>渐变颜色</td>
</tr>
<tr>
<td><code>bg_grad_dir</code></td>
<td>渐变方向</td>
</tr>
<tr>
<td><code>bg_main_stop</code></td>
<td>渐变开始位置</td>
</tr>
<tr>
<td><code>bg_grad_stop</code></td>
<td>渐变结束位置</td>
</tr>
<tr>
<td><code>bg_dither_mode</code></td>
<td>渲染模式</td>
</tr>
</tbody>
</table>
<p>当确定了渐变方向后，渐变从 <code>bg_main_stop</code> 位置开始，由 <code>bg_color</code> 过度到 <code>bg_grad_color</code> ，在 <code>bg_grad_stop</code> 位置结束。这里的位置是由比例衡量的，渐变区域在每个方向都被划分为 256 份，例如 128 代表中间位置，255 代表结束位置等。</p>
<p>例如，以下代码：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* obj01 = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_style_bg_color</span>(obj01, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_color</span>(obj01, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_dir</span>(obj01, LV_GRAD_DIR_HOR, <span class="hljs-number">0</span>);
</pre></div>
<p>渐变效果为水平方向从蓝色一直渐变到红色：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-grad-color-1.jpg" alt="image" width="120"></figure>
<p>再如，以下代码：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* obj02 = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_style_bg_color</span>(obj02, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_GREEN), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_color</span>(obj02, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_PURPLE), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_stop</span>(obj02, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_dir</span>(obj02, LV_GRAD_DIR_VER, <span class="hljs-number">0</span>);
</pre></div>
<p>渐变效果为竖直方向从绿色一直渐变到紫色，但实际渐变区域只有上半部分：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-grad-color-2.jpg" alt="image" width="120"></figure>
<p>还可以使用简写属性 <code>bg_grad</code> 设置完整的渐变属性。这种情况下，渐变使用结构 <code>lv_grad_dsc_t</code> 描述：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">lv_gradient_stop_t</span> stops[LV_GRADIENT_MAX_STOPS];
    <span class="hljs-keyword">uint8_t</span>            stops_count;
    <span class="hljs-keyword">lv_grad_dir_t</span>      dir    : <span class="hljs-number">3</span>;
    <span class="hljs-keyword">lv_dither_mode_t</span>   dither : <span class="hljs-number">3</span>;
} <span class="hljs-keyword">lv_grad_dsc_t</span>;
</pre></div>
<p>宏 <code>LV_GRADIENT_MAX_STOPS</code> 决定了最大拥有的渐变颜色数，可以在 <code>lv_conf_internal.h</code> 大约 377 行修改该宏的数量：</p>
<div class="hljs codeblock"><pre><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LV_GRADIENT_MAX_STOPS</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_LV_GRADIENT_MAX_STOPS</span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_GRADIENT_MAX_STOPS CONFIG_LV_GRADIENT_MAX_STOPS</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_GRADIENT_MAX_STOPS 3</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</pre></div>
<p>然后就可以自定义多种颜色的渐变了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_grad_dsc_t</span> grad_sunset;
grad_sunset.stops[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">lv_gradient_stop_t</span>){ .color = <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED), .frac = <span class="hljs-number">96</span> };
grad_sunset.stops[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">lv_gradient_stop_t</span>){ .color = <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_ORANGE), .frac = <span class="hljs-number">128</span> };
grad_sunset.stops[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">lv_gradient_stop_t</span>){ .color = <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE), .frac = <span class="hljs-number">216</span> };
grad_sunset.stops_count = <span class="hljs-number">3</span>;
grad_sunset.dir = LV_GRAD_DIR_VER;
<span class="hljs-keyword">lv_obj_t</span>* obj03 = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_style_bg_grad</span>(obj03, &amp;grad_sunset, <span class="hljs-number">0</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-grad-color-3.jpg" alt="image" width="120"></figure>
<h3>颜色的其它内容</h3>
<p>LVGL 还提供了许多处理颜色的滤镜。可以使用样式属性 <code>blend_mode</code> 设置颜色和背景色的融合。例如，以下将控件的颜色设置为背景色的反色：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_style_blend_mode</span>(obj03, LV_BLEND_MODE_SUBTRACTIVE, <span class="hljs-number">0</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-blend-mode-subtract.jpg" alt="image" width="120"></figure>
<p>注意边框的颜色也变成反色了。</p>
<!-- 还可以使用样式属性 `color_filter_dsc` 和 `color_filter_opa` 为控件叠上一层颜色滤镜。这种情况下，滤镜使用以下结构描述：

```cpp
typedef struct _lv_color_filter_dsc_t {
    lv_color_filter_cb_t filter_cb;
    void * user_data;
} lv_color_filter_dsc_t;
```

这里需要提供一个回调函数 `filter_cb` 给它。
-->
<p>最后，LVGL 中还要一个控件 color wheel ，可以快速创建一个颜色选择器。它的默认表现形式为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-colorwheel.gif" alt="image" width="160"></figure>
<p>它类似于圆弧，并可以通过长按切换模式。可以使用函数 <code>lv_colorwheel_get_rgb()</code> 获取当前选择的颜色。</p>
<h2>图片</h2>
<h3>创建图片</h3>
<p>图片可以以两种方式存储：一是作为一个数组之类的变量，二是通过二进制文件的形式存储。由于还没有介绍文件相关的内容，这里仅介绍使用数组的方式来存储并使用图片。</p>
<p>LVGL 已经提供了在线图片转换器，可以直接在 <a href="https://lvgl.io/tools/imageconverter">https://lvgl.io/tools/imageconverter</a> 将一般的 PNG 或 JPG 图片转换为符合要求的 C 语言对象：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-image-converter.jpg" alt="image" width="650"></figure>
<p>注意转换完成后得到的是一个完整的源文件，文件名同时也是图片的变量名。以上唯一值的注意的一点是图片所用的颜色格式，一般来说颜色格式可以分为以下几类：</p>
<ol>
<li>True color ：自动适配当前项目使用的颜色深度</li>
<li>Indexed ：从调色板创建较少的颜色数目</li>
<li>Alpha only ：单色图像，只使用透明度</li>
<li>Raw ：使用图像原本的颜色格式</li>
</ol>
<p>最后一个 RBG565-A8 就不必多说了。值的注意的是，以上有一种叫“Chroma key” 的颜色格式，它对应 <code>lv_conf.h</code> 的第 42 行的配置，注释是这样说的：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/*Images pixels with this color will not be drawn if they are chroma keyed)*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_COLOR_CHROMA_KEY lv_color_hex(0x00ff00)         <span class="hljs-comment">/*pure green*/</span></span>
</pre></div>
<p>更多有关于此的介绍可以阅读维基百科 <a href="https://en.wikipedia.org/wiki/Chroma_key">https://en.wikipedia.org/wiki/Chroma_key</a></p>
<p>转换完成后，将得到的源文件添加到当前工程内，然后通过以下几行代码就可以显示该图像：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">LV_IMG_DECLARE</span>(lvgl_logo);
<span class="hljs-keyword">lv_obj_t</span>* img01 = <span class="hljs-built_in">lv_img_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_img_set_src</span>(img01, &amp;lvgl_logo);
</pre></div>
<p>这里第一个宏的作用本质就是一个 <code>extern</code> 语句。显示的效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-image-create.jpg" alt="image" width="200"></figure>
<p>注意这里在模拟器上创建的图片是具有透明度的。</p>
<h3>图片的属性</h3>
<p>像直线和圆弧一样，图片对象也是有特殊的属性的，不过比较少：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>img_opa</code></td>
<td>图片透明度</td>
</tr>
<tr>
<td><code>img_recolor</code></td>
<td>可以给图片加上一层颜色滤镜</td>
</tr>
<tr>
<td><code>img_recolor_opa</code></td>
<td>这层滤镜的透明度</td>
</tr>
</tbody>
</table>
<p>默认情况下，图片控件会自动调整宽度以适应图片大小。如果控件过小，那么图片的额外部分会被去除；如果控件过大，那么图片会像地砖一样重复铺开来填补剩下的区域。</p>
<p>可以通过 <code>lv_img_set_offset_x(img, x_ofs)</code> 与 y 轴对应的函数给图片设置一个偏移量来修改显示范围。例如，可以通过偏移量结合控件宽度来裁剪图片：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_img_set_offset_x</span>(img01, <span class="hljs-number">-2</span>);
<span class="hljs-built_in">lv_img_set_offset_y</span>(img01, <span class="hljs-number">-7</span>);
<span class="hljs-built_in">lv_obj_set_size</span>(img01, <span class="hljs-number">74</span>, <span class="hljs-number">74</span>);
</pre></div>
<p>这里通过负值来将图片向左上角偏移，从而框选出合适的区域：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-image-clip.jpg" alt="image" width="80"></figure>
<h3>图片按钮</h3>
<p>最后再介绍一个内容，可以通过图片来创建一个按钮。这种情况下，需要准备三张图片，分别描述按钮的左边、中间和右边。</p>
<p>例如，以下准备图片如下：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-imgbtn_left.png" alt="image" height="54">&nbsp;<img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-imgbtn_mid.png" alt="image" height="54">&nbsp;<img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-imgbtn_right.png" alt="image" height="54"></figure>
<p>由于标签的宽度是不确定的，因此中间的图片必须是水平可平铺的。将其转换为对应的图片格式后，可以通过以下代码创建一个图片按钮：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* imgbtn = <span class="hljs-built_in">lv_imgbtn_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_imgbtn_set_src</span>(imgbtn, LV_IMGBTN_STATE_RELEASED, &amp;imgbtn_left, &amp;imgbtn_mid, &amp;imgbtn_right);
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(imgbtn);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"Image Button"</span>);
<span class="hljs-built_in">lv_obj_set_style_img_recolor_opa</span>(imgbtn, LV_OPA_30, LV_STATE_PRESSED);
<span class="hljs-built_in">lv_obj_set_style_img_recolor</span>(imgbtn, <span class="hljs-built_in">lv_color_black</span>(), LV_STATE_PRESSED);
</pre></div>
<p>注意在创建的过程中，将以上图片应用到按钮的普通状态（即什么事件都没有的状态）的外观中。这里通过给点击事件加上一层深色的滤镜使点击时外观可以发生改变：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-imagebutton-press.gif" alt="image" width="200"></figure>
<p>这样按钮就可以变得很花哨了。</p>
<p>以上对于图片的介绍比较简单，不过也基本足以应付一般的使用场景了。更多细节可以参考官方文档。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/overview/color.html">https://docs.lvgl.io/master/overview/color.html</a></p>
<p>颜色参考文档</p>
<p><a href="https://docs.lvgl.io/master/overview/image.html">https://docs.lvgl.io/master/overview/image.html</a><br>
<a href="https://docs.lvgl.io/master/widgets/core/img.html">https://docs.lvgl.io/master/widgets/core/img.html</a></p>
<p>有关图片及图片控件的完整使用描述</p>



<p></p>
<p><a rel="nofollow" href="/archives/383">LVGL库入门教程05-颜色和图像</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/383/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程04-样式</title>
		<link>/archives/361</link>
					<comments>/archives/361#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sat, 18 Jun 2022 02:53:33 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=361</guid>

					<description><![CDATA[<p>LVGL样式概述 创建样式 在 LVGL 中，样式都&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/361">LVGL库入门教程04-样式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>LVGL样式概述</h2>
<h3>创建样式</h3>
<p>在 LVGL 中，样式都是以对象的方式存在，一个对象可以描述一种样式。每个控件都可以独立添加样式，创建的样式之间互不影响。</p>
<p>可以使用 <code>lv_style_t</code> 类型创建一个样式并初始化：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style;
<span class="hljs-built_in">lv_style_init</span>(&amp;style);
</pre></div>
<p>样式是延迟渲染的，因此需要使用 <code>static</code> 存储类别说明符或将其声明为全局变量。</p>
<p>样式是多方面的，不仅包括颜色和形状，还包括边距、边框，甚至动画变换效果等细节。</p>
<blockquote>
<p>LVGL 中的样式从 CSS 中吸取了很多灵感，因此对样式的操作都类似 CSS</p>
</blockquote>
<p>接下来，可以对得到的样式对象设置一些样式规则：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/* ... create and init style ... */</span>
<span class="hljs-built_in">lv_style_set_radius</span>(&amp;style_btn_safe, <span class="hljs-number">15</span>);
<span class="hljs-built_in">lv_style_set_bg_opa</span>(&amp;style_btn_safe, LV_OPA_COVER);
<span class="hljs-built_in">lv_style_set_bg_color</span>(&amp;style_btn_safe, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_GREEN));
<span class="hljs-built_in">lv_style_set_border_width</span>(&amp;style_btn_safe, <span class="hljs-number">5</span>);
</pre></div>
<p>所有的设置样式函数都是 <code>lv_style_set_...()</code> 形式，完整的样式规则将在之后介绍。未指定的样式规则将保持控件的默认样式。</p>
<p>然后就可以将样式分配给控件，例如，以下创建了一个按钮并利用 <code>lv_obj_add_style()</code> 函数设置其样式为刚才创建的样式了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_size</span>(btn, <span class="hljs-number">120</span>, <span class="hljs-number">50</span>);
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"Button"</span>);
<span class="hljs-built_in">lv_obj_add_style</span>(btn, &amp;style_btn_safe, <span class="hljs-number">0</span>);
</pre></div>
<p>这样按钮的外观就会被改变了，效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-style-init.jpg" alt="image" width="160"></figure>
<p>以上修改了按钮的颜色，如果对颜色的创建过程不太理解也不要紧，以后会介绍颜色的代码描述。可以简单地将 GREEN 改成其它颜色名来改变不同的颜色。设置样式的函数最后有一个参数 <code>0</code> ，它代表的是样式的选择器，将会在接下来介绍。</p>
<p>一个文件内可以创建多种不同的样式对象，这样同一个界面中按钮可以表现出多种不同的样式。</p>
<h3>样式的级联</h3>
<p>所谓“级联”(cascading)，指的是将多个样式分配给一个对象。此时如果多个样式间设置的样式属性有重复，那么将使用最后设置的样式值。也就是说，后设置的样式具有更高的优先级。</p>
<p>控件在创建时可以视为同时添加了一个默认的样式，因此在代码中指定的任意样式都会覆盖默认的样式。</p>
<p>还有一种特殊的局部样式(local styles)，局部样式具有最高的优先级，但只对单个控件有效。局部样式的创建类似如下：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_style_bg_color</span>(btn, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED), <span class="hljs-number">0</span>);
</pre></div>
<p>它们都是 <code>lv_obj_set_style_...()</code> 形式的函数。</p>
<p>局部样式一旦被设置，只能再次通过局部样式修改回来。因此，局部样式需要谨慎使用。</p>
<h3>选择器</h3>
<p>LVGL 的选择器(selector)与 CSS 不同。在 CSS 中，样式通过选择器选择需要作用的元素；而 LVGL 中，样式通过选择器作用于控件的部分。</p>
<p>要明白什么是控件的部分，需要分析控件的组成。例如，以下代码可以创建一个滑块(slider)控件：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* slider01 = <span class="hljs-built_in">lv_slider_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
</pre></div>
<p>滑块是一种调整类型的控件，用户可以通过拖动它的把手(knob)来调节滑块当前的数值。滑块默认的表现形式为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-slider-create.gif" alt="alt" width="280"></figure>
<p>仔细观察滑块的组成，滑块可以由主体外形、把手(knob)和进度指示条(indicator)组成。可以通过选择器单独设置这三个构成部分的样式。例如，假设需要更改这三个部分的样式，就可以通过选择器分别指定修改的结构：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_slider_main;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_slider_main);
<span class="hljs-built_in">lv_style_set_bg_opa</span>(&amp;style_slider_main, LV_OPA_COVER);
<span class="hljs-built_in">lv_style_set_bg_color</span>(&amp;style_slider_main, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_YELLOW));
<span class="hljs-comment">/* using selectors */</span>
<span class="hljs-built_in">lv_obj_add_style</span>(slider01, &amp;style_slider_main, LV_PART_MAIN);
<span class="hljs-built_in">lv_obj_set_style_radius</span>(slider01, <span class="hljs-number">0</span>, LV_PART_KNOB);
<span class="hljs-built_in">lv_obj_set_style_bg_color</span>(slider01, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED), LV_PART_INDICATOR);
</pre></div>
<p>这里分别使用全局样式和局部样式修改控件的各个部分。修改之后，把手部分变成了方形，主体和进度进度的颜色都发生了变化：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-slider-style.jpg" alt="image" width="280"></figure>
<p>选择器的一个更妙的用途是和控件状态做按位或运算，从而可以修改某个部分在某个状态下的样式。例如，选择器</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_add_style</span>(slider01, &amp;style_slider_main, 
                 LV_PART_MAIN | LV_STATE_PRESSED);
</pre></div>
<p>使滑块的主体只有在按下时才会使用该样式（颜色被改变）：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-slider-state-style.gif" alt="image" width="280"></figure>
<p>LVGL 的选择器在表现形式上效果非常像 CSS 的伪元素和伪类选择器。</p>
<p>滑块在拖动过程中，会不断触发 <code>LV_EVENT_VALUE_CHANGED</code> 事件，可以使用函数</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">lv_slider_get_value</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_obj_t</span>* obj)</span></span>;
</pre></div>
<p>获取当前获取的滑块数值（介于 0~100 ）。更多的滑块 API 可以参考官方文档的介绍。</p>
<p>接下来详细地介绍样式可以设置的一些属性。</p>
<h2>样式属性</h2>
<h3>尺寸和位置</h3>
<p>要理解尺寸和位置是如何起作用的，首先要理解 LVGL 的盒子模型。官方文档给出了一张图，可以很好地描述一个控件的框架结构：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-boxmodel.png" alt="image" width="460"></figure>
<p>在设置尺寸的时候，长和宽指的是包括边框(border)厚度的长宽，也就是不包括轮廓(outline)的总长宽。</p>
<p>在设置位置的时候，设置的坐标指的是 border 左上角相对父容器的 Content area 的坐标，也就是说如果设置坐标为 0 的话，轮廓(outline)可能会被父容器的边框(border)遮盖。</p>
<p>下表总结了尺寸与位置有关的可用属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>width</code></td>
<td>宽度</td>
<td>由控件类别决定</td>
</tr>
<tr>
<td><code>min_width</code></td>
<td>最小宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>max_width</code></td>
<td>最大宽度</td>
<td>屏幕的宽度</td>
</tr>
<tr>
<td><code>height</code></td>
<td>高度</td>
<td>由控件类别决定</td>
</tr>
<tr>
<td><code>min_height</code></td>
<td>最小宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>max_height</code></td>
<td>最大宽度</td>
<td>屏幕的高度</td>
</tr>
<tr>
<td><code>align</code></td>
<td>对齐方式</td>
<td>左上方</td>
</tr>
<tr>
<td><code>x</code></td>
<td>对齐后在水平方向的偏移量</td>
<td>0</td>
</tr>
<tr>
<td><code>y</code></td>
<td>对齐后在竖直方向的偏移量</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>注意这里有一个最小或最大的宽度和高度，在上一节介绍 flex 和 grid 布局时就展示过控件宽度随布局自动调整的情况，因此可以给它们提供一个阈值防止过大或过小。</p>
<p>不过上一节还有一个地方没有提到：在设置宽度和高度时，除了使用确定的数值外，还可以使用百分比值 <code>lv_pct(x)</code> 来设置控件相对父容器的 Content area 的大小或位置。例如，样式</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_width</span>(&amp;style, <span class="hljs-built_in">lv_pct</span>(<span class="hljs-number">25</span>));
<span class="hljs-built_in">lv_style_set_x</span>(&amp;style, <span class="hljs-built_in">lv_pct</span>(<span class="hljs-number">50</span>));
</pre></div>
<p>可以让一个控件的水平尺寸占据父容器的 1/2~3/4 的位置：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-position-pct.jpg" alt="image" width="360"></figure>
<p>对于父容器而言，还可以使用 <code>LV_SIZE_CONTENT</code> 特殊单位调整其尺寸至可以容纳所有包含控件的合适值。例如，按钮就是一个这样的容器，它的默认样式就通过该值使得其宽度和高度可以自动适应包含的标签尺寸。</p>
<h3>边框和边距</h3>
<p>上图展示的文本框就有一个深灰色的边框。边框就无需额外描述了，与边框有关的样式属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>border_width</code></td>
<td>边框宽度，只能用绝对宽度描述</td>
<td>0</td>
</tr>
<tr>
<td><code>border_side</code></td>
<td>绘制哪些部分的边框</td>
<td><code>LV_SIDE_ALL</code></td>
</tr>
<tr>
<td><code>border_post</code></td>
<td>绘制顺序，设置 <code>true</code> 表示包含的子控件绘制完成了再绘制边框</td>
<td><code>false</code></td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>边框和主体部分之间被边距(padding)隔开。和边距有关的样式属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>pad_top</td>
<td>上边距</td>
<td>0</td>
</tr>
<tr>
<td>pad_bottom</td>
<td>下边距</td>
<td>0</td>
</tr>
<tr>
<td>pad_left</td>
<td>左边距</td>
<td>0</td>
</tr>
<tr>
<td>pad_right</td>
<td>右边距</td>
<td>0</td>
</tr>
<tr>
<td>pad_row</td>
<td>当控件拥有布局时，每行间的间距</td>
<td>0</td>
</tr>
<tr>
<td>pad_column</td>
<td>当控件拥有布局时，每列间的间距</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>不过在设置布局时，还提供了几个简写属性：可以使用 <code>...pad_all()</code> 一并设置上下左右的边距；或使用 <code>...pad_hor()</code> 和 <code>...pad_ver()</code> 设置水平和垂直的边距；还可以使用 <code>...pad_gap()</code> 设置行和列的间距。</p>
<h3>轮廓</h3>
<p>轮廓(outline)类似边框，但轮廓并不算在一个控件的主体内，因此设置坐标、尺寸等属性时都不包含轮廓的尺寸。</p>
<p>轮廓可设置的属性远比边框少。下表列出了轮廓的一些属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>outline_width</code></td>
<td>轮廓宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>outline_pad</code></td>
<td>轮廓到主体的间距</td>
<td>0</td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>轮廓和边框最根本的差异是两者不是同一个东西，因此可以在同一个元素同时使用不同样式的轮廓的边框来实现一些有趣的效果，例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_radius</span>(&amp;style, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_style_set_border_color</span>(&amp;style, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_GREY));
<span class="hljs-built_in">lv_style_set_border_width</span>(&amp;style, <span class="hljs-number">5</span>);
<span class="hljs-built_in">lv_style_set_border_opa</span>(&amp;style, LV_OPA_COVER);
<span class="hljs-built_in">lv_style_set_border_side</span>(&amp;style, LV_BORDER_SIDE_BOTTOM | LV_BORDER_SIDE_RIGHT);
<span class="hljs-built_in">lv_style_set_outline_width</span>(&amp;style, <span class="hljs-number">4</span>);
<span class="hljs-built_in">lv_style_set_outline_pad</span>(&amp;style, <span class="hljs-number">1</span>);
<span class="hljs-built_in">lv_style_set_outline_color</span>(&amp;style, <span class="hljs-built_in">lv_palette_lighten</span>(LV_PALETTE_GREY, <span class="hljs-number">1</span>));
</pre></div>
<p>表现效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-outline-style.jpg" alt="image" width="230"></figure>
<h3>阴影</h3>
<p>阴影可以使控件看起来有立体感。下表列出了设置阴影的一些属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shadow_width</code></td>
<td>设置阴影的模糊半径</td>
<td>0</td>
</tr>
<tr>
<td><code>shadow_ofs_x</code></td>
<td>设置阴影的水平偏移量</td>
<td>0</td>
</tr>
<tr>
<td><code>shadow_ofs_y</code></td>
<td>设置阴影的垂直偏移量</td>
<td>0</td>
</tr>
<tr>
<td><code>shadow_spread</code></td>
<td>设置阴影的放大量</td>
<td>0</td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>例如，以下设置模糊半径为 50 的蓝色阴影：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_shadow_width</span>(&amp;style, <span class="hljs-number">50</span>);
<span class="hljs-built_in">lv_style_set_shadow_color</span>(&amp;style, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-shadow-style-1.jpg" alt="image" width="200"></figure>
<p>以下设置放大有偏移的红色阴影：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_shadow_color</span>(&amp;style, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED))
<span class="hljs-built_in">lv_style_set_shadow_width</span>(&amp;style, <span class="hljs-number">15</span>)
<span class="hljs-built_in">lv_style_set_shadow_ofs_x</span>(&amp;style, <span class="hljs-number">10</span>)
<span class="hljs-built_in">lv_style_set_shadow_ofs_y</span>(&amp;style, <span class="hljs-number">20</span>)
<span class="hljs-built_in">lv_style_set_shadow_spread</span>(&amp;style, <span class="hljs-number">10</span>)
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-shadow-style.jpg" alt="image" width="220"></figure>
<p>LVGL 中无法给同一个控件设置多个阴影叠加，从而实现更复杂的效果，这是比较可惜的一点。</p>
<h3>文本样式</h3>
<p>在创建控件时经常要使用文字，下表列出了能影响文字效果的一些属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text_font</code></td>
<td>设置文字的字体</td>
<td>默认字体</td>
</tr>
<tr>
<td><code>text_letter_space</code></td>
<td>字符间隔</td>
<td>0</td>
</tr>
<tr>
<td><code>text_line_space</code></td>
<td>设置多行文本的行间距</td>
<td>0</td>
</tr>
<tr>
<td><code>text_decor</code></td>
<td>设置文本装饰（下划线或删除线）</td>
<td><code>LV_TEXT_DECOR_NONE</code></td>
</tr>
<tr>
<td><code>text_align</code></td>
<td>设置文本对齐方式</td>
<td><code>LV_TEXT_ALIGN_AUTO</code></td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>需要注意的是，文本的样式是可继承的，意思是如果子控件没有特别指定的话，它会使用父容器设置的文本样式。</p>
<p>在一段文本内可能存在许多种样式，对此，可以使用类似 CSS 的 span 来拆分样式在文本内的作用域。为了创建 span ，首先需要创建一个 span-group ：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* spangroup = <span class="hljs-built_in">lv_spangroup_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_size</span>(spangroup, <span class="hljs-number">160</span>, LV_SIZE_CONTENT);
</pre></div>
<p>创建的 span-group 和一般的控件没什么区别，可以给它添加一些样式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_style_border_color</span>(spangroup, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_border_width</span>(spangroup, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_pad_all</span>(spangroup, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);
</pre></div>
<p>span-group 提供的以下函数使得它相比标签更适合用来处理大段的文本：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lv_spangroup_set_align(obj, align)</code></td>
<td>设置文本的对齐</td>
</tr>
<tr>
<td><code>lv_spangroup_set_overflow(obj, overflow)</code></td>
<td>控制溢出文本的处理方式</td>
</tr>
<tr>
<td><code>lv_spangroup_set_indent(obj, indent)</code></td>
<td>设置文本的首行缩进，单位为像素</td>
</tr>
<tr>
<td><code>lv_spangroup_set_mode(obj, mode)</code></td>
<td>设置对多行文本的折行处理，可以参见枚举 <code>lv_span_mode_t</code></td>
</tr>
</tbody>
</table>
<p>有了 span-group 以后，可以使用以下代码从中创建一个 span 并设置文本：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_span_t</span>* span = <span class="hljs-built_in">lv_spangroup_new_span</span>(spangroup);
<span class="hljs-built_in">lv_span_set_text</span>(span, <span class="hljs-string">"LVGL is an open-source graphics library"</span>);
</pre></div>
<p>每一个 span 都提供了一个独立的样式接口，可以单独设置范围内文本的样式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_text_color</span>(&amp;span-&gt;style, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
</pre></div>
<p>一个 span-group 可以创建多个 span ，并且它们的样式效果互不影响：</p>
<div class="hljs codeblock"><pre>span = <span class="hljs-built_in">lv_spangroup_new_span</span>(spangroup);
<span class="hljs-built_in">lv_span_set_text</span>(span, <span class="hljs-string">"providing everything"</span>);
<span class="hljs-built_in">lv_style_set_text_decor</span>(&amp;span-&gt;style, LV_TEXT_DECOR_UNDERLINE);
<span class="hljs-built_in">lv_style_set_text_font</span>(&amp;span-&gt;style, &amp;lv_font_montserrat_20);
<span class="hljs-comment">/* ... */</span>
span = <span class="hljs-built_in">lv_spangroup_new_span</span>(spangroup);
<span class="hljs-built_in">lv_span_set_text</span>(span, <span class="hljs-string">"to create embedded GUI"</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-spangroup.jpg" alt="image" width="210"></figure>
<p>可以注意到默认的 span-group 是没什么样式的。span-group 还有很多的 API ，具体可以参照官方文档的相关介绍。</p>
<h3>其它样式</h3>
<p>下表列出了一些其它的样式属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>radius</code></td>
<td>设置控件的圆角，该属性会一并影响边框和轮廓</td>
<td>0，即无圆角</td>
</tr>
<tr>
<td><code>clip_corner</code></td>
<td>如果有圆角，是否要将 Content-aera 超出圆角的部分去除</td>
<td>否</td>
</tr>
<tr>
<td><code>layout</code></td>
<td>设置控件的布局方式</td>
<td>0</td>
</tr>
<tr>
<td><code>base_dir</code></td>
<td>设置文字的书写方向，它会同时影响布局的方向</td>
<td>默认书写方向</td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>在设置半径时可以使用百分数，例如 <code>lv_pct(50)</code> 将使控件变成圆形。</p>
<p>以上列出了大部分的样式属性，但是除了颜色外还有许多样式没有介绍，例如变换、动画、渐变等，这些留到之后介绍。LVGL 中还存在一些特殊的样式，它们是为相应的控件设计的，接下来介绍这些控件及样式。</p>
<h2>基本图形：直线和弧线</h2>
<h3>直线</h3>
<p>LVGL 中的直线(line)实际上指的是折线，因为它可以一次性连续绘制多条相接的线段。为了绘制折线，首先要准备一些端点的坐标：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_point_t</span> line_points[] = { {<span class="hljs-number">217</span>, <span class="hljs-number">36</span>}, {<span class="hljs-number">35</span>, <span class="hljs-number">49</span>}, {<span class="hljs-number">281</span>, <span class="hljs-number">163</span>}, {<span class="hljs-number">110</span>, <span class="hljs-number">162</span>}, {<span class="hljs-number">257</span>, <span class="hljs-number">111</span>} };
</pre></div>
<p>然后可以通过这些端点来创建折线：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* line1 = <span class="hljs-built_in">lv_line_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_line_set_points</span>(line1, line_points, <span class="hljs-number">5</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-line-create.jpg" alt="image" width="220"></figure>
<p>创建的折线作为一个整体，实际上也是一个控件，当然可以给它加上各种属性：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_line;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_line);
<span class="hljs-built_in">lv_style_set_align</span>(&amp;style_line, LV_ALIGN_TOP_MID);
<span class="hljs-built_in">lv_style_set_border_width</span>(&amp;style_line, <span class="hljs-number">4</span>);
<span class="hljs-built_in">lv_obj_add_style</span>(line01, &amp;style_line, <span class="hljs-number">0</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-line-style.jpg" alt="image" width="220"></figure>
<p>折线拥有一些特殊的样式属性，是其它控件所没有的。下表列出了折线的特殊属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>line_width</code></td>
<td>设置线段宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>line_dash_width</code></td>
<td>设置虚线实部分的距离</td>
<td>0</td>
</tr>
<tr>
<td><code>line_dash_gap</code></td>
<td>设置虚线虚部分的距离</td>
<td>0</td>
</tr>
<tr>
<td><code>line_rounded</code></td>
<td>设置线段端点是否为圆角</td>
<td>否</td>
</tr>
<tr>
<td><code>line_color</code></td>
<td>设置线段颜色</td>
<td>黑色</td>
</tr>
<tr>
<td><code>line_opa</code></td>
<td>设置颜色透明度</td>
<td>不透明</td>
</tr>
</tbody>
</table>
<p>注意，虚线只对水平和垂直的线段有效，并且只有两个属性都不为 0 才有虚线的效果。</p>
<p>例如，样式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_line_color</span>(&amp;style_line, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
<span class="hljs-built_in">lv_style_set_line_width</span>(&amp;style_line, <span class="hljs-number">8</span>);
</pre></div>
<p>表现效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-style-line-1.jpg" alt="image" width="260"></figure>
<p>如果再添加上：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_line_dash_width</span>(&amp;style_line, <span class="hljs-number">10</span>)
<span class="hljs-built_in">lv_style_set_line_dash_gap</span>(&amp;style_line, <span class="hljs-number">5</span>)
<span class="hljs-built_in">lv_style_set_line_rounded</span>(&amp;style_line, <span class="hljs-literal">true</span>);
</pre></div>
<p>那么效果就变成：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-style-line-2.jpg" alt="image" width="260"></figure>
<p>关于折线还有一个函数 <code>lv_line_set_y_invert(lv_obj_t *obj, bool en)</code> 可以用来控制绘制的折线垂直翻转（即翻转 y 轴）。除此之外折线并没有什么可以介绍的。在后续还会介绍图表，可以绘制更美观的折线效果。</p>
<h3>圆弧</h3>
<p>LVGL 中的圆弧(arc)尽管和直线同属于基础控件，但圆弧的功能远比直线丰富，甚至 API 比起滑块这些复杂的控件都多。</p>
<p>首先简单创建一个圆弧，查看它的默认效果：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* arc01 = <span class="hljs-built_in">lv_arc_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
</pre></div>
<p>默认的效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-create.jpg" alt="image" width="140"></figure>
<p>可以看出圆弧的在默认情况下，它的表现形式实际上就是弧形的滑块。如果想要得到纯粹的圆弧，可以将圆弧的把手删除：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_remove_style</span>(arc01, <span class="hljs-literal">NULL</span>, LV_PART_KNOB);
<span class="hljs-built_in">lv_obj_clear_flag</span>(arc01, LV_OBJ_FLAG_CLICKABLE);
</pre></div>
<p>这里做了两件事：首先是将把手的样式删除，这里第二个参数 <code>NULL</code> 表示删去全部样式；其次将圆弧的可点击标志位清除，使它不再能接收用户的点击事件。这样圆弧看起来就纯粹多了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-remove-knob.jpg" alt="image" width="140"></figure>
<p>还可以进一步删去圆弧的指示条(indicator)，让它更像传统的圆弧。</p>
<p>默认的圆弧是开口向下的 270° 圆弧。为了设置圆弧的形状，可以使用函数</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_arc_set_angles</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">uint16_t</span> start, <span class="hljs-keyword">uint16_t</span> end)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_arc_set_bg_angles</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">uint16_t</span> start, <span class="hljs-keyword">uint16_t</span> end)</span></span>;
</pre></div>
<p>分别修改前景和背景的圆弧起止范围，单位为角度。注意，圆弧的角度 0° 是正右方向，90° 是正下方向，以此类推。这两个函数都有单独设置起或止位置的版本。例如，设置</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_arc_set_bg_angles</span>(arc01, <span class="hljs-number">0</span>, <span class="hljs-number">270</span>);
<span class="hljs-built_in">lv_arc_set_end_angle</span>(arc01, <span class="hljs-number">180</span>);
</pre></div>
<p>可以将圆弧的角度调整为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-angles.jpg" alt="image" width="140"></figure>
<p>圆弧也像直线一样具有特殊的样式，下表列出了圆弧具有的样式属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arc_width</code></td>
<td>设置圆弧宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>arc_rounded</code></td>
<td>设置圆弧端点是否为圆角</td>
<td>否</td>
</tr>
<tr>
<td><code>arc_color</code></td>
<td>设置圆弧颜色</td>
<td>黑色</td>
</tr>
<tr>
<td><code>arc_opa</code></td>
<td>设置圆弧透明度</td>
<td>不透明</td>
</tr>
<tr>
<td><code>arc_img_src</code></td>
<td>设置圆弧填充图片</td>
<td>无填充图片</td>
</tr>
</tbody>
</table>
<p>以上是官方文档的介绍，但这个默认值显然与实际不符。之所以会这样，原因是在 <code>lv_conf.h</code> 大约 514 行，启用过默认的样式：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/*A simple, impressive and very complete theme*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_USE_THEME_DEFAULT 1</span>
</pre></div>
<p>而该样式在初始化时，就会修改包括圆弧在内的一些样式，因此圆弧、按钮等控件才默认表现为这个模样。</p>
<p>圆弧可以作为一个基准让控件对齐。例如，可以使用</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_arc_rotate_obj_to_angle</span>(arc01, label, <span class="hljs-number">25</span>);
</pre></div>
<p>让一个标签旋转对齐圆弧的把手，第三个参数为半径的偏移量，效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-align.jpg" alt="image" width="140"></figure>
<p>与其说是对齐把手，更准确的说法是对齐圆弧当前的值。例如，可以通过以下函数改变圆弧的值：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_arc_set_value</span>(arc01, <span class="hljs-number">20</span>);
</pre></div>
<p>这样效果就很明显了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-rotate-align.jpg" alt="image" width="140"></figure>
<p>圆弧默认的取值范围是 0~100 ，也可以通过 <code>lv_arc_set_range(obj, min, max)</code> 函数修改这一取值范围。除此之外，还有另一个函数 <code>lv_arc_align_obj_to_angle(obj, obj_to_align, r_offset)</code> 只对齐控件而不发生旋转。另外需要注意，应该先对齐圆弧后，再设置标签的对齐，否则标签会因为不是包含关系而不随之更新位置。</p>
<p>总体来说，圆弧因为不是纯粹的圆弧，因此它具有滑块的各种特征，例如可以响应 <code>LV_EVENT_VALUE_CHANGED </code> 事件，可以使用 <code>lv_arc_get_value(obj)</code> 获取值等。</p>

<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/overview/style.html">https://docs.lvgl.io/master/overview/style.html</a></p>
<p>官方文档——样式简介</p>
<p><a href="https://docs.lvgl.io/master/overview/style-props.html">https://docs.lvgl.io/master/overview/style-props.html</a></p>
<p>官方文档——所有的样式属性简介</p>
<p><a rel="nofollow" href="/archives/361">LVGL库入门教程04-样式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/361/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程03-布局方式</title>
		<link>/archives/342</link>
					<comments>/archives/342#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 16 Jun 2022 02:37:24 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=342</guid>

					<description><![CDATA[<p>LVGL的布局 上一节介绍了如何在 LVGL 中创建&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/342">LVGL库入门教程03-布局方式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>LVGL的布局</h2>
<p>上一节介绍了如何在 LVGL 中创建控件。如果在创建控件时不给控件安排布局，那么控件默认会被放在父容器的左上角。</p>
<p>可以使用 <code>lv_obj_set_pos(obj, x, y)</code> 调整一个控件的位置（或者使用类似的函数单独调整一个方向的坐标），将它放在相对父容器左上角的合适位置。不过这种布局方式非常死板，因为绝对坐标一旦设定就不能自动调整；而且当控件数量较多时，也很难确定合适的坐标值。</p>
<p>上一节介绍过，可以使用 <code>lv_obj_align(obj, align, x_ofs, y_ofs)</code> 设置一个控件相对父容器的对齐，并用以下图片展示所有的对齐方式：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-align.png" alt="image" width="600"></figure>
<p>从图片中可以看到，控件之间不仅可以内对齐，也可以外对齐。如果两个控件间没有包含关系也不要紧，可以使用 <code>lv_obj_align_to(obj, base, align, x_ofs, y_ofs);</code> 设置两个控件的相对对齐方式。</p>
<p>这种对齐的方式对于控件不多的情况下来说是足够了，但是有些时候需要对很多并列的控件布局（例如，一个计算机界面的所有按钮）。这个时候常规的对齐方式就难以满足需求了。</p>
<p>因此，LVGL 提供了两种更复杂的布局方式：</p>
<ul>
<li>flex（弹性盒子）</li>
<li>grid（网格）</li>
</ul>
<p>这两种布局和 CSS3 新增的 flex 布局和 grid 布局比较相似，如果熟悉 CSS 的话对它们应该不会陌生。</p>
<h2>flex布局</h2>
<p>flex 是一个实验性质的布局，首先需要确定已经在 <code>lv_conf.h</code> 大约 588 行的位置启用了 flex 布局：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/*A layout similar to Flexbox in CSS.*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_USE_FLEX 1</span>
</pre></div>
<p>后续介绍的 grid 布局也是如此。</p>
<h3>创建flex布局</h3>
<p>如果不添加任何布局方式，那么所有的控件都会堆放在左上角。flex 布局可以将一些控件按行或列均匀布局，并且可以自动调整它们的间距。</p>
<p>可以给一个容器设置一个 flex-flow 属性，这样容器就可以使用 flex 布局方式：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_ROW);
</pre></div>
<p>对于设置了 flex 布局的容器，在其中创建的元素都会在一个坐标轴上均匀排布。例如，以下使用 <code>for</code> 循环创建多个控件：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">300</span>, <span class="hljs-number">75</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
    <span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
    <span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
    <span class="hljs-built_in">lv_label_set_text_fmt</span>(label, <span class="hljs-string">"%d"</span>, i + <span class="hljs-number">1</span>);
}
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-flow.jpg" alt="image" width="300"></figure>
<p>尽管没有设置按钮的位置，但是每一个按钮都会在水平位置上均匀排布。如果要让排布时不超过父容器的最大宽度，可以使用 <code>LV_FLEX_FLOW_ROW_WRAP</code> 折行。</p>
<p>也可以使用按列的方式排布控件。可以通过 <code>lv_flex_flow_t</code> 枚举类型检查更多的 flex 布局形式。</p>
<h3>flex布局的对齐</h3>
<p>以上 flex 布局中，各控件的尺寸和间距都是固定的，并且第一个控件依然会出现在左上角。如果</p>
<p>可以使用</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_flex_align</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> * obj, 
                           <span class="hljs-keyword">lv_flex_align_t</span> main_place, 
                           <span class="hljs-keyword">lv_flex_align_t</span> cross_place,
                           <span class="hljs-keyword">lv_flex_align_t</span> track_place)</span></span>;
</pre></div>
<p>设置 flex 布局的对齐方式。该函数一次性会设置三个方面的对齐：</p>
<ul>
<li><code>main_place</code> ：设置行或列的对齐</li>
<li><code>cross_place</code> ：设置控件在一行或一列内的对齐（当控件高度或宽度不一致时就可以看出效果）</li>
<li><code>track_place</code> ：flex-flow 方向上的对齐</li>
</ul>
<p>如果接触过 CSS 的话，可以明白这些对齐方式实际上就是 CSS 里的 <code>justify-content</code> 、<code>align-items</code> 和 <code>align-content</code> 。</p>
<p>例如，以下调用</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_ROW_WRAP);
<span class="hljs-built_in">lv_obj_set_flex_align</span>(cont, LV_FLEX_ALIGN_SPACE_EVENLY, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
</pre></div>
<p>创建的每个控件之间在水平方向上均匀对齐、行内上下居中对齐，并作为一个整体上下居中对齐，效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-align-1.jpg" alt="image" width="240"></figure>
<p>又如，以下调用：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_ROW_WRAP);
<span class="hljs-built_in">lv_obj_set_flex_align</span>(cont, LV_FLEX_ALIGN_SPACE_BETWEEN, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
</pre></div>
<p>创建的每个控件之间在水平方向上两端对齐、行内顶端对齐，并作为一个整体顶端对齐，效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-align-2.jpg" alt="image" width="240"></figure>
<p>flex 布局还可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_flex_grow</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">uint8_t</span> grow)</span></span>;
</pre></div>
<p>动态调整各个控件的相对宽度，实现更灵活的布局规则。例如，以下代码在一个 flex-flow 框架内创建了 4 个按钮，并将第二个按钮的相对宽度设置为其它按钮的两倍：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
    <span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
    <span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
    <span class="hljs-built_in">lv_label_set_text_fmt</span>(label, <span class="hljs-string">"%d"</span>, i);
    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)
        <span class="hljs-built_in">lv_obj_set_flex_grow</span>(btn, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">lv_obj_set_flex_grow</span>(btn, <span class="hljs-number">1</span>);
}
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-grow.jpg" alt="image" width="210"></figure>
<p>以下利用相对宽度创建了一个更复杂的类似数字输入键盘的布局规则：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_ROW_WRAP);
<span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">160</span>, <span class="hljs-number">180</span>);
<span class="hljs-built_in">lv_obj_set_flex_align</span>(cont, LV_FLEX_ALIGN_SPACE_BETWEEN, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
<span class="hljs-built_in">lv_obj_set_style_base_dir</span>(cont, LV_BASE_DIR_RTL, <span class="hljs-number">0</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int8_t</span> i = <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    <span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
    <span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
    <span class="hljs-built_in">lv_label_set_text_fmt</span>(label, <span class="hljs-string">"%d"</span>, i);
}
<span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
<span class="hljs-built_in">lv_obj_set_flex_grow</span>(btn, <span class="hljs-number">2</span>);
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"OK"</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-layout.jpg" alt="alt" width="160"></figure>
<p>这里使用 <code>lv_obj_set_style_base_dir()</code> 函数设置从右向左的书写方式，因此滚动条才会出现在左侧。后续介绍样式时还会介绍更多类似函数。</p>
<p>一般情况下 flex-grow 和带 wrap 的 flex-flow 是冲突的，也就是说所有设置了 flex-grow 的控件都会在同一行布局，但它们的宽度可能变得很窄。因此，以上的各个数字按钮相对宽度并不一致。</p>
<p>使用这种布局创建键盘非常别扭，不过好在 LVGL 提供了另一种形式的布局：grid 。</p>
<h2>grid布局</h2>
<h3>创建grid布局</h3>
<p>grid 布局是一种网格形式的布局，可以按行或列来对齐控件。</p>
<p>为了创建网格布局，首先要给出格子的长度和宽度。一般来说，可以通过两个数组分别描述网格每一行的宽度和每一列的宽度：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_coord_t</span> col_size[] = { <span class="hljs-number">60</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, LV_GRID_TEMPLATE_LAST };
<span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_coord_t</span> row_size[] = { <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, LV_GRID_TEMPLATE_LAST };
</pre></div>
<p>每一个数组都需要以 <code>LV_GRID_TEMPLATE_LAST</code> 结尾。然后就可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_grid_dsc_array</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_coord_t</span> col_dsc[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_coord_t</span> row_dsc[])</span>
</span></pre></div>
<p>函数为一个容器设置网格划分。</p>
<blockquote>
<p>注意，创建的数组一定要声明为 <code>static</code> 或全局变量，因为这部分数据在后续渲染时才会被用上。</p>
</blockquote>
<p>划分好了网格以后，接下来就可以使用以下函数：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_grid_cell</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> * obj, 
    <span class="hljs-keyword">lv_grid_align_t</span> x_align, <span class="hljs-keyword">uint8_t</span> col_pos, <span class="hljs-keyword">uint8_t</span> col_span,
    <span class="hljs-keyword">lv_grid_align_t</span> y_align, <span class="hljs-keyword">uint8_t</span> row_pos, <span class="hljs-keyword">uint8_t</span> row_span)</span></span>;
</pre></div>
<p>将每一个控件摆放在合适的网格位置。<code>align</code> 指定每一个放置在网格上的控件相对格线的对齐；<code>pos</code> 指定控件放置在哪个格子里，最左上角的格子位置为 (0, 0) ；有的控件可能占据不止一个格子的位置，那么就需要使用 <code>span</code> 来跨越多格。</p>
<p>例如，以下代码：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
    <span class="hljs-keyword">uint8_t</span> col = i % <span class="hljs-number">3</span>;
    <span class="hljs-keyword">uint8_t</span> row = i / <span class="hljs-number">3</span>;
    <span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
    <span class="hljs-built_in">lv_obj_set_grid_cell</span>(btn, LV_GRID_ALIGN_STRETCH, col, <span class="hljs-number">1</span>,
                              LV_GRID_ALIGN_STRETCH, row, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
    <span class="hljs-built_in">lv_label_set_text_fmt</span>(label, <span class="hljs-string">"r%d c%d"</span>, row, col);
    <span class="hljs-built_in">lv_obj_center</span>(label);
}
</pre></div>
<p>得到的网格为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-grid-desc.jpg" alt="image" width="270"></figure>
<p>这里使用 <code>LV_GRID_ALIGN_STRETCH</code> 让网格内的控件尺寸伸展至网格大小，使网格布局的特点更加明显。</p>
<h3>grid布局的对齐</h3>
<p>使用网格布局时，每个格子内的控件在创建时都可以在网格内对齐。除此之外，还可以设置网格自身的对齐方式：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_grid_align</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> * obj, <span class="hljs-keyword">lv_grid_align_t</span> column_align, <span class="hljs-keyword">lv_grid_align_t</span> row_align)</span></span>;
</pre></div>
<p>网格在横向和竖向对齐摆放时，对齐方式都类似于 flex ，因此可以认为 grid 是一种二维的 flex 布局。</p>
<p>例如，如果略微修改以上代码，添加如下语句：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_grid_align</span>(cont, LV_GRID_ALIGN_SPACE_BETWEEN, LV_GRID_ALIGN_END);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
    <span class="hljs-comment">/* ... */</span>
    <span class="hljs-built_in">lv_obj_set_grid_cell</span>(btn, LV_GRID_ALIGN_START, col, <span class="hljs-number">1</span>,
                              LV_GRID_ALIGN_START, row, <span class="hljs-number">1</span>);
    <span class="hljs-comment">/* ... */</span>
}
</pre></div>
<p>这里去除了控件尺寸的伸展，使网格的对齐特点更明显：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-grid-align.jpg" alt="image" width="270"></figure>
<hr>
<p>网格也可以使用相对大小，具体做法是利用 <code>LV_GRID_FR(x)</code> 宏计算相对宽度。例如，以下定义了一个这样的宽度数组：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_coord_t</span> col_pos[] = { <span class="hljs-built_in">LV_GRID_FR</span>(<span class="hljs-number">1</span>), <span class="hljs-number">60</span>, <span class="hljs-built_in">LV_GRID_FR</span>(<span class="hljs-number">2</span>), LV_GRID_TEMPLATE_LAST };
</pre></div>
<p>那么第二列的宽度是绝对宽度 60 ，剩余的宽度被划分为 3 份：第一列占 1 份，第三列占 2 份。这种形式创建的网格可以适应容器的尺寸大小：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-grid-devide.jpg" alt="image" width="270"></figure>
<h2>组合控件</h2>
<h3>复选框</h3>
<p>复选框(ckeckbox)是一种类似开关，但是带有标签的控件。可以使用以下代码创建复选框并设置标签文本：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* check = <span class="hljs-built_in">lv_checkbox_create</span>(cont);
<span class="hljs-built_in">lv_checkbox_set_text</span>(check, <span class="hljs-string">"Use DMA"</span>);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-checkbox-create.gif" alt="image" width="180"></figure>
<p>一般用复选框并列表示一些“是/否”的选项，因此多个并列的复选项很适合使用 flex 布局表现。复选框可以通过状态 <code>LV_STATE_CHECKED</code> 检查是否被勾选。</p>
<p>LVGL 中没有提供单选按钮(radio button)这一控件，不过可以使用复选框表示单选按钮。单选按钮在同一时间内只有且必须有一个选择框被选中。首先创建一个框架并使用列模式的 flex 布局：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">140</span>, <span class="hljs-number">200</span>);
<span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_COLUMN);
<span class="hljs-built_in">lv_obj_set_flex_align</span>(cont, LV_FLEX_ALIGN_SPACE_EVENLY, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER);
</pre></div>
<p>然后可以在其中创建一些复选框：</p>
<div class="hljs codeblock"><pre><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHECKBOX_ITEMS 4</span>
<span class="hljs-keyword">char</span>* checkbox_labels[CHECKBOX_ITEMS] = {
    <span class="hljs-string">"Use parity bits"</span>, <span class="hljs-string">"Use stop bit"</span>, <span class="hljs-string">"Auto send"</span>, <span class="hljs-string">"Debug mode"</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; CHECKBOX_ITEMS; i++) {
    <span class="hljs-keyword">lv_obj_t</span>* check = <span class="hljs-built_in">lv_checkbox_create</span>(cont);
    <span class="hljs-built_in">lv_checkbox_set_text</span>(check, checkbox_labels[i]);
}
</pre></div>
<p>为了实现单选按钮的效果，需要在点击事件中清除上一个被选中的选择框。这里介绍一个技巧如何获取事件控件的父容器。如果一个控件被设置了冒泡事件标志 <code>LV_OBJ_FLAG_EVENT_BUBBLE</code> ，那么该控件被点击时，事件将会由它的父容器触发（如果父容器也设置了这一标志位，那么事件还会继续向上冒泡）。</p>
<p>可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span>* <span class="hljs-title">lv_event_get_current_target</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span></span>;
</pre></div>
<p>获取最终触发真正送出事件的控件（也就是冒泡后的父控件），而之前介绍的 <code>lv_event_get_target()</code> 函数则获取的是最先触发事件的控件（也就是子控件）。这样通过设置合适的冒泡层数，就可以同时获取控件与它的父容器了。</p>
<p>了解了这一特性后，就可以编写合适的代码了。首先定义一个全局变量 <code>checked_index</code> 记录单选按钮组此刻选中的按钮索引号，并作为用户数据传给回调函数中：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> checked_index = <span class="hljs-number">0</span>;
<span class="hljs-comment">/* ... */</span>
<span class="hljs-built_in">lv_obj_add_event_cb</span>(cont, radio_checked_cb, LV_EVENT_CLICKED, &amp;checked_index);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; CHECKBOX_ITEMS; i++) {
    <span class="hljs-comment">/* ... */</span>
    <span class="hljs-built_in">lv_obj_add_flag</span>(check, LV_OBJ_FLAG_EVENT_BUBBLE);
}
</pre></div>
<p>由于事件最终由父容器触发，因此要给父容器提供回调函数。然后，在回调函数中通过父容器与索引值取消上一个被点击的选择框选择，选择点击的选择框并更新索引值：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radio_checked_cb</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span> </span>{
    <span class="hljs-keyword">uint8_t</span>* post_checked_index = <span class="hljs-built_in">lv_event_get_user_data</span>(e);
    <span class="hljs-keyword">lv_obj_t</span>* target = <span class="hljs-built_in">lv_event_get_target</span>(e);
    <span class="hljs-keyword">lv_obj_t</span>* parent = <span class="hljs-built_in">lv_event_get_current_target</span>(e);
    <span class="hljs-keyword">if</span> (target == parent) 
        <span class="hljs-keyword">return</span>;
    <span class="hljs-built_in">lv_obj_clear_state</span>(<span class="hljs-built_in">lv_obj_get_child</span>(parent, *post_checked_index), LV_STATE_CHECKED);
    <span class="hljs-built_in">lv_obj_add_state</span>(target, LV_STATE_CHECKED);
    *post_checked_index = <span class="hljs-built_in">lv_obj_get_index</span>(target);
}
</pre></div>
<p>由于父容器也拥有点击事件，因此首先要判断事件是否是由选择框触发的。这种事件处理方式非常简洁高效，而且无需定义额外的辅助数组。</p>
<p>这样就可以使用复选框代替单选按钮了，并且这样的回调函数是可以复用的，如果有另一组单选按钮也可以使用类似的方式提供响应：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-checkbox-as-radio.gif" alt="image" width="200"></figure>
<h2>列表</h2>
<p>LVGL 的列表(list)表现形式更像大多数界面提供的标题栏菜单。这里先介绍列表仅仅是因为它比较简单。列表的核心函数只有 3 个：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span> *<span class="hljs-title">lv_list_create</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *parent)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span> *<span class="hljs-title">lv_list_add_text</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *list, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *txt)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span> *<span class="hljs-title">lv_list_add_btn</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *list, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *icon, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *txt)</span></span>;
</pre></div>
<p>以下应用这三个函数创建一个列表：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* list = <span class="hljs-built_in">lv_list_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_list_add_text</span>(list, <span class="hljs-string">"group1"</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
    <span class="hljs-built_in">lv_list_add_btn</span>(list, <span class="hljs-literal">NULL</span>, <span class="hljs-string">"item"</span>);
<span class="hljs-built_in">lv_list_add_text</span>(list, <span class="hljs-string">"group2"</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
    <span class="hljs-built_in">lv_list_add_btn</span>(list, <span class="hljs-literal">NULL</span>, <span class="hljs-string">"item"</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-list-create.jpg" alt="image" width="190"></figure>
<p>默认创建的列表尺寸较大，可以手动调整尺寸大小。</p>
<p>列表中的按钮和一般创建的按钮没有区别，可以给返回值提供回调函数。按钮在创建时还可以指定按钮的图标，图标的本质就是 Unicode 中的特殊符号，在 <code>lvgl/src/font/lv_symbol_def.h</code> 中可以查看提供的特殊符号。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/layouts/index.html">https://docs.lvgl.io/master/layouts/index.html</a></p>
<p>官方文档——布局部分。</p>
<p><a rel="nofollow" href="/archives/342">LVGL库入门教程03-布局方式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/342/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程02-基本控件与交互</title>
		<link>/archives/316</link>
					<comments>/archives/316#comments</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Tue, 14 Jun 2022 08:49:13 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=316</guid>

					<description><![CDATA[<p>LVGL 本质上是一个 GUI 库，它包含大量的控件&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/316">LVGL库入门教程02-基本控件与交互</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>LVGL 本质上是一个 GUI 库，它包含大量的控件(widget)，即按钮、标签、滑块、菜单栏这种具有一定人机交互特征的组合图形。LVGL 在设计时，采用了一定面向对象编程的设计思路，有效降低了代码编写的难度。</p>
<p>LVGL 和大多数 GUI 库的工作方式都是类似的，其代码编写的基础思路为：</p>
<ul>
<li>创建 GUI 根窗体对象</li>
<li>在窗体上绘制各种控件</li>
<li>为控件编写响应函数函数</li>
<li>在主事件循环中等待用户触发事件响应</li>
</ul>
<p>如果之前有 GUI 库的使用经验的话，应该可以比较容易明白 LVGL 代码的编写思路。</p>
<h2>标签</h2>
<p>标签(label)应该是 GUI 最简单也是最基础的控件之一。标签的作用就是显示一小段说明文字。接下来通过介绍标签来介绍 LVGL 控件的创建、布局与设置属性。</p>
<h3>标签的创建</h3>
<p>通过以下函数可以创建一个标签：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span>* <span class="hljs-title">lv_label_create</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* parent)</span></span>;
</pre></div>
<p><code>lv_obj_t</code> 是 LVGL 所有控件的通用类型，包括根窗体在内的所有控件都使用该结构描述。</p>
<p>参数 <code>parent</code> 指定了标签需要被放在哪一个父容器中。由于一个较大的项目内会存在许多控件，因此往往需要将一个较大的窗口划分为若干结构，每一个结构放入用途相似的的控件，使用户更易熟悉如何操作。例如，一个文本编辑器窗口可能会按功能分为顶层菜单栏、侧边导航栏、底部状态栏以及中间的编辑区，每个区域的控件都可以安排在各栏内统一调整。</p>
<p>最基本的父容器就是整个显示屏窗口对象，可以使用 <code>lv_scr_act()</code> 函数获取当前的窗口对象。操作系统上的窗口可以设置一些属性，例如窗口大小、标题文字、图标等，不过嵌入式屏幕往往是固定的，因此窗口对象一般只作控件的父容器使用。</p>
<p>使用以下代码就可以在当前窗口中创建一个标签了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* label01 = <span class="hljs-built_in">lv_label_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
</pre></div>
<p>创建得到的标签没有任何可显示的内容，可以调用 <code>lv_label_set_text()</code> 为标签添加上文字：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_label_set_text</span>(label01, <span class="hljs-string">"Hello, world!"</span>);
</pre></div>
<p>这样就可以在屏幕中显示一些文本了。LVGL 支持直接显示 Unicode 文字，只要在源文件使用 UTF-8 编码即可。如果要显示变量的值，LVGL 也提供了 <code>lv_label_set_text_fmt()</code> 函数，可以直接格式化文本。</p>
<p>接下来编译工程并下载，就可以看到显示的效果了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-getstart-label-create.jpg" alt="-" width="320"></figure>
<h3>标签的布局</h3>
<p>以上创建的标签默认放在屏幕的左上角，并且如果创建多个标签等控件，它们都会被重叠放置在左上角。如果需要将控件安排到合适的位置，就需要安排它们的布局。一般情况下，可以用以下函数重新调整一个控件的布局：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_align</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_align_t</span> align, <span class="hljs-keyword">lv_coord_t</span> x_ofs, <span class="hljs-keyword">lv_coord_t</span> y_ofs)</span></span>;
</pre></div>
<p><code>align</code> 指定了控件的对齐方式，可以检查枚举类型 <code>lv_align_t</code> 来获取支持的对齐方式。<code>x_ofs</code> 和 <code>y_ofs</code> 是对齐后的额外偏移量，正值表示额外向右下偏移。</p>
<blockquote>
<p>LVGL 包含了许多枚举类型，如果不知道该如何传值，可以查看头文件包含的枚举值。</p>
<p>和大多数 GUI 库一样，屏幕的左上角为坐标原点 (0, 0) ，往右为 x 轴正向，往下为 y 轴正向，坐标的单位为像素或分辨率。</p>
</blockquote>
<p>例如，如果额外给以上标签添加对齐：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_align</span>(label01, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">-30</span>);
</pre></div>
<p>那么它就会出现在屏幕中间向上 30 像素的位置：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-getstart-label-align.jpg" alt="-" width="320"></figure>
<p>如果要创建更灵活的布局，可以使用 <code>lv_obj_create()</code> 创建一个基本对象。这种直接创建的基本对象一般用作框架，然后通过嵌套框架的形式组织对齐，例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/* outer widget align */</span>
<span class="hljs-keyword">lv_obj_t</span>* cont_top = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-keyword">lv_obj_t</span>* cont_bottom = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_align</span>(cont_top, LV_ALIGN_TOP_LEFT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_align</span>(cont_bottom, LV_ALIGN_BOTTOM_RIGHT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-comment">/* inner widget align */</span>
<span class="hljs-keyword">lv_obj_t</span>* label_top = <span class="hljs-built_in">lv_label_create</span>(cont_top);
<span class="hljs-built_in">lv_label_set_text</span>(label_top, <span class="hljs-string">"At Top Left"</span>);
<span class="hljs-built_in">lv_obj_align</span>(label_top, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">lv_obj_t</span>* label_bottom = <span class="hljs-built_in">lv_label_create</span>(cont_bottom);
<span class="hljs-built_in">lv_label_set_text</span>(label_bottom, <span class="hljs-string">"At Bottom Right"</span>);
<span class="hljs-built_in">lv_obj_align</span>(label_bottom, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</pre></div>
<p>这里先将外层的框架在屏幕上对齐，然后再在框内创建标签，让标签在框架内对齐。效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-getstart-object-align.jpg" alt="!" width="320"></figure>
<p>通过这种嵌套的对齐方式，可以先让一些基础控件在框架内对齐，然后再让框架之间相对对齐。这种对齐方式更灵活，而且方便日后调整各个控件的相对位置。</p>
<p>LVGL 的所有控件都是以这种相对位置的形式组织的。官方文档提供了一张图片，可以很清楚地描述所有的相对对齐方式：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-align.png" alt="alt" width="600"></figure>
<p>由于居中对齐经常用到，可以直接使用 <code>lv_obj_center(*obj*)</code> 函数设置无偏移的居中对齐。</p>
<p>默认的基本控件是有样式的，并且注意到它们长宽都是固定的，如果包含的控件过长，它还会提供一个滚动条。如果需要调整控件的尺寸，可以使用函数，<code>lv_obj_set_width()</code> 和 <code>lv_obj_set_height()</code> 分别调整长宽，或使用 <code>lv_obj_set_size()</code> 一并调整：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(cont);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"Helllllo, world!"</span>);
<span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">160</span>, <span class="hljs-number">50</span>);
<span class="hljs-built_in">lv_obj_center</span>(cont);
<span class="hljs-built_in">lv_obj_center</span>(label);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-getstart-object-resize.jpg" alt="!" width="320"></figure>
<p>所有的控件都具有宽度和高度基本属性，因此这几个函数对任意的控件都有效。</p>
<h3>标签的长模式和颜色调整</h3>
<p>框架包含的控件过长会提供一个滚动条，确保包含的内容都可见。标签在创建时，它的宽度会适应包含文本的宽度。如果给一个标签重新调整尺寸，使得它的宽度小于文本的宽度，那么它包含的文本就会自动折叠：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* label01 = <span class="hljs-built_in">lv_label_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_label_set_text</span>(label01, <span class="hljs-string">"A very loooooooooooooooong text"</span>);
<span class="hljs-built_in">lv_obj_set_width</span>(label01, <span class="hljs-number">100</span>);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-label-too-long.jpg" alt="!" width="170"></figure>
<p>如果文本确实过长，超过了标签的长宽极限，那么可以使用函数</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_label_set_long_mode</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> * obj, <span class="hljs-keyword">lv_label_long_mode_t</span> long_mode)</span></span>;
</pre></div>
<p>给标签设置一个长模式。标签一共有 5 种长模式，每种模式的表现形式如下：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LV_LABEL_LONG_WRAP</code></td>
<td>将过宽的文本换行，以多行的方式显示所有文本</td>
</tr>
<tr>
<td><code>LV_LABEL_LONG_DOT</code></td>
<td>将过长的文本隐藏并以省略号代替</td>
</tr>
<tr>
<td><code>LV_LABEL_LONG_SCROLL</code></td>
<td>将文本来回滚动显示</td>
</tr>
<tr>
<td><code>LV_LABEL_LONG_SCROLL_CIRCULAR</code></td>
<td>将文本循环滚动显示</td>
</tr>
<tr>
<td><code>LV_LABEL_LONG_CLIP</code></td>
<td>去除过长部分的文本</td>
</tr>
</tbody>
</table>
<p>如果文本显示时有多行，那么可以使用</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_style_text_align</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_text_align_t</span> value, <span class="hljs-keyword">lv_style_selector_t</span> selector)</span></span>;
</pre></div>
<p>将文本垂直对齐。第三个参数 <code>selector</code> 是设置样式用的，这里可以暂时不用理会。</p>
<p>以下动图展示了三种长模式：显示省略号、换行并居中对齐，以及循环滚动：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-label-long-mode.gif" alt="!" width="300"></figure>
<blockquote>
<p>需要注意的是，除了滚动以外的其它模式如果没有明确高度，都会在文本过长时优先尝试调整标签高度。</p>
</blockquote>
<p>滚动是一种特殊的动画，在后续介绍到动画时还可以创建更丰富的动画效果，可以自行调整文本的滚动行为。</p>
<hr>
<p>标签的文本可以改变颜色。LVGL 里，调整颜色是通过特殊格式的文本作用的。为了改变颜色，首先需要启用这一模式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_label_set_recolor</span>(label01, <span class="hljs-literal">true</span>);
</pre></div>
<p>重新调整颜色的文本格式为：</p>
<div class="hljs codeblock"><pre>#RRGGBB <em>text</em>#
</pre></div>
<p>这样 <em><code>text</code></em> 对应的文本就会显示为 <code>#RRGGBB</code> 对应的色值。如果屏幕使用的是 16bit 的颜色也不要紧，LVGL 会自动转换颜色。</p>
<p>例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_label_set_text</span>(label01, <span class="hljs-string">"#0000ff Re-color# #ff00ff text# #ff0000 of a# label."</span>);
</pre></div>
<p>显示效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-label-recolor.jpg" alt="alt" width="220"></figure>
<h2>按钮</h2>
<p>按钮(button)也是一个比较基础的控件。按钮除了可以显示一些提示文字外，还可以点击并获取响应。接下来通过介绍按钮来介绍为控件绑定事件的一般方式。</p>
<h3>按钮的创建和事件绑定</h3>
<p>按钮的创建和布局方式都与标签类似：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* btn01 = <span class="hljs-built_in">lv_btn_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_align</span>(btn01, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">-40</span>);
</pre></div>
<p>但是注意，创建得到的按钮只是一个简单的形状。为了给它添加说明文本，需要在其中创建一个标签：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* label01 = <span class="hljs-built_in">lv_label_create</span>(btn01);
<span class="hljs-built_in">lv_label_set_text</span>(label01, <span class="hljs-string">"Button"</span>);
<span class="hljs-built_in">lv_obj_center</span>(label01);
</pre></div>
<p>显示的效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-button-create.jpg" alt="alt" width="210"></figure>
<p>按钮不同于框架，按钮会自动调整宽高来适应其包含的标签大小。</p>
<p>创建的按钮已经默认具有点击动画，不过还无法对点击作出回应。接下来需要给按钮添加回调函数。可以使用以下函数为按钮绑定回调函数：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_add_event_cb</span>(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_event_cb_t</span> event_cb, <span class="hljs-keyword">lv_event_code_t</span> filter, <span class="hljs-keyword">void</span>* user_data);
</pre></div>
<p>任意可交互控件都可以使用该函数添加回调函数。这里不用管该函数的返回值。<code>event_cb</code> 是事件的回调函数，<code>filter</code> 决定按钮会对哪些事件作出响应，可以在 <code>user_data</code> 传入一些自定义的数据。</p>
<p>检查类型 <code>lv_event_cb_t</code> 的定义就可以明白如何编写回调函数。回调函数有且仅有一个 <code>lv_event_t</code> 类型的参数。该类型是一个比较复杂的结构类型，目前只需要明白它包括的结构成员包括自定义数据 <code>user_data</code> 即可。</p>
<p>例如，以下创建了一个简单的回调函数：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">button_clicked_cb</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> count = <span class="hljs-number">0</span>;
    count++;
    <span class="hljs-built_in">lv_label_set_text_fmt</span>((<span class="hljs-keyword">lv_obj_t</span>*)e-&gt;user_data, <span class="hljs-string">"Clicked: %d"</span>, count);
}
</pre></div>
<p>这里通过自定义参数来修改外部标签的文本。那么在绑定时，就需要这样传入参数：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_add_event_cb</span>(btn01, button_simple_cb, LV_EVENT_CLICKED, label01);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-button-click.gif" alt="alt" width="230"></figure>
<p>这里让按钮只对点击事件产生响应。如果要让按钮对多个事件响应的话，需要先让按钮对所有事件 <code>LV_EVENT_ALL</code> 产生响应的话，然后在回调函数内进一步判断事件类型：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_event_code_t</span> code = <span class="hljs-built_in">lv_event_get_code</span>(e);
<span class="hljs-keyword">if</span> (code == LV_EVENT_CLICKED) {
    <span class="hljs-comment">/* ... event handler ... */</span>
}
</pre></div>
<p>这就像在中断函数内判断中断源一样。</p>
<p>不过以上回调还可以使用另一种不传入用户参数的形式完成。首先，通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span>* <span class="hljs-title">lv_event_get_target</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span></span>;
</pre></div>
<p>可以获取产生事件的控件，然后通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span>* <span class="hljs-title">lv_obj_get_child</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">int32_t</span> id)</span></span>;
</pre></div>
<p>获取该控件的子控件。在创建控件时，需要传入父容器控件，创建时父容器也会通过 <code>id</code> 记录包含的子控件，创建最早的控件 id 就是 0 ，第二早的 id 是 1 ，最晚的 id 还可以表示为 -1 等。这样就可以在事件回调函数内获取被点击按钮的标签控件对象了。</p>
<h3>控件的通用行为</h3>
<p>LVGL 中，可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_add_flag</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_obj_flag_t</span> f)</span></span>;
</pre></div>
<p>为控件设置一些通用的标志，来改变控件的行为。</p>
<p>例如，以上按钮都是普遍的按钮，它们通过点击来触发响应。但是还有一部分按钮，像控制键是通过点击来切换启用/关闭状态的。那么此时就可以给按钮添加一个这样的标志：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* btn02 = <span class="hljs-built_in">lv_btn_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_add_flag</span>(btn02, LV_OBJ_FLAG_CHECKABLE);
</pre></div>
<p>这样创建的按钮可以对 <code>LV_EVENT_VALUE_CHANGED</code> 这个特殊的事件响应，而普通的按钮不行。不仅如此，切换之后的部分样式也会发生改变：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-button-toggle.gif" alt="alt" width="230"></figure>
<p>可以给一个控件添加多个标志，只需要使用按位或运算符 <code>|</code> 连接起来即可。还可以清除一个控件的标志。例如，如果给一个框架清除可滚动的标志，那么当它包含长文本时就不再可以滚动显示全部内容：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(cont);
<span class="hljs-built_in">lv_obj_clear_flag</span>(cont, LV_OBJ_FLAG_SCROLLABLE);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"A label contains very long text"</span>);
<span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">160</span>, <span class="hljs-number">50</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-obj-unscrollable.jpg" alt="alt" width="230"></figure>
<p>标志是一个很重要的内容，通过为控件加上各种标志，可以自定义更多抽象的控件类型。例如，具有 <code>LV_OBJ_FLAG_CLICKABLE</code> 标志的控件可以响应点击事件，这种响应不仅包括回调函数，还关系着点击时的动画效果。LVGL 一共提供了 27 个独立的标志，其中有 8 个可供用户自定义。可以检查 <code>lv_obj_flag_t</code> 枚举定义来查看包含的所有标志位。</p>
<h2>开关</h2>
<h3>开关的创建</h3>
<p>以上创建的通过点击来切换启用/关闭状态的按钮可以使用开关(switch)代替。创建开关和创建其它控件类似：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* sw = <span class="hljs-built_in">lv_switch_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
</pre></div>
<p>开关的效果如下，通过单击可以切换开关状态：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-switch-create.gif" alt="alt" width="220"></figure>
<p>开关具有标志 <code>LV_OBJ_FLAG_CHECKABLE</code> ，因此可以响应事件 <code>LV_EVENT_VALUE_CHANGED</code> 。</p>
<h3>开关的状态</h3>
<p>一个控件可以具有多种标志，标志就是控件的抽象接口，决定了控件具有哪些行为。控件还具有多种不同的状态，在每种状态下，它的样式都是不一样的。可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_add_state</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_state_t</span> state)</span></span>;
</pre></div>
<p>给一个控件设置不同的状态来切换样式。例如，如果给开关设置状态 <code>LV_STATE_CHECKED</code> ，它会表现出打开的状态。不同状态下控件接收的响应也不一样，例如如果给开关加上 <code>LV_STATE_DISABLED</code> 的状态，点击时它就无法接收任何响应，连样式也不会再切换了。</p>
<p>可以在响应函数内通过 <code>lv_obj_has_state(obj, state)</code> 来判断一个控件处于什么状态，从而决定执行什么样的代码。这种方式更贴合控件的行为。</p>
<p>每个控件都有 9 种独立的状态，还有 4 种状态可以由用户自由定义，这些状态都被放在头文件 <code>lv_obj.h</code> 中。可以使用按位与运算符 <code>|</code> 给一个控件添加多个状态。例如，可以给一个开关设置为既开启又只读 <code>LV_STATE_CHECKED | LV_STATE_DISABLED</code> ，那么它的样式就会表现为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-switch-check-disable.jpg" alt="alt" width="130"></figure>
<p>状态是在标志之上的概念，在不同的状态下控件可能具有不同的标志。</p>
<h2>基本交互控件</h2>
<h3>下拉列表</h3>
<p>下拉列表(drop-down list)也是一个非常简单的控件。下拉列表在点击后会出现一些选项，点击选择后就可以触发一些事件。</p>
<p>可以通过 <code>lv_dropdown_set_options()</code> 为下拉列表创建列表项：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* drop01 = <span class="hljs-built_in">lv_dropdown_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_dropdown_set_options</span>(drop01, <span class="hljs-string">"STM32F1\n"</span>
                                <span class="hljs-string">"STM32F4\n"</span>
                                <span class="hljs-string">"STM32H7\n"</span>
                                <span class="hljs-string">"STM8"</span>);
</pre></div>
<p>LVGL 会自动拆分多行本文的每一行并分别创建一个列表项。下拉列表默认的行为是展示第一个列表项，并通过用户选择来切换展示的列表项：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-dropdown-create.gif" alt="alt" width="230"></figure>
<p>下拉列表在选择列表项时会触发 <code>LV_EVENT_VALUE_CHANGED</code> 事件，可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint16_t</span> <span class="hljs-title">lv_dropdown_get_selected</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_obj_t</span>* obj)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_dropdown_get_selected_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">char</span>* buf, <span class="hljs-keyword">uint32_t</span> buf_size)</span></span>;
</pre></div>
<p>来获取当前选中列表项索引或文本，如果要获取文本的话需要自行准备一个文本缓冲区。</p>
<p>下拉列表可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_dropdown_set_text</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* txt)</span>
</span></pre></div>
<p>给它设置一个固定的文本，这样的下拉列表可以充当下拉菜单使用。</p>
<p>下拉列表还可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_dropdown_set_dir</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_dir_t</span> dir)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_dropdown_set_symbol</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* symbol)</span></span>;
</pre></div>
<p>修改列表项出现的位置和下拉列表右侧的符号，由此可以组合出上拉列表、左拉列表等。</p>
<h3>滚动列表</h3>
<p>滚动列表(roller)和下拉列表类似，不过它是通过滚动来切换选择的列表项的。</p>
<p>滚动列表的创建、事件响应和获取选中值的方式都和下拉列表类似。以下是滚动列表的创建方式：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* roller01 = <span class="hljs-built_in">lv_roller_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_roller_set_options</span>(roller01,
                      <span class="hljs-string">"Monday\nTuesday\nWednesday\n"</span>
                      <span class="hljs-string">"Thursday\nFriday\nSaturday\nSunday"</span>,
                      LV_ROLLER_MODE_INFINITE);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-roller-create.gif" alt="alt" width="240"></figure>
<p>在设置列表项时滚动列表多了一个参数，代表滚动到底后需要停止还是循环往复。滚动列表非常适合用于列表项稍微有些多，没有足够的空间展示所有列表项的情况。因此，滚动列表还可以使用函数</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_roller_set_visible_row_count</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">uint8_t</span> row_cnt)</span></span>;
</pre></div>
<p>设置可见的列表项个数。如果设置为偶数，那么会有两个列表项只显示一半，就像动图中展示的一样。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/widgets/index.html">https://docs.lvgl.io/master/widgets/index.html</a></p>
<p>LVGL 官方文档——控件。在此可以查看更多文中没有提到的控件类型和使用细节，并查看官方编写的示例代码。</p>
<p><a rel="nofollow" href="/archives/316">LVGL库入门教程02-基本控件与交互</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/316/feed</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程01-移植到STM32</title>
		<link>/archives/307</link>
					<comments>/archives/307#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 13 Jun 2022 02:55:21 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<category><![CDATA[STM32]]></category>
		<guid isPermaLink="false">/?p=307</guid>

					<description><![CDATA[<p>LVGL库简介 LVGL(Light and Ver&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/307">LVGL库入门教程01-移植到STM32</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>LVGL库简介</h2>
<p>LVGL(Light and Versatile Graphics Library)是一个免费、开源的嵌入式图形库，可以创建丰富、美观的界面，具有许多可以自定义样式的控件，支持按键或触摸响应，支持中文字符，并且内存占用较低。可以在 <a href="https://lvgl.io/demos">https://lvgl.io/demos</a> 使用网页端体验 LVGL 的动态效果，再决定是否需要使用 LVGL 。</p>
<p>LVGL 使用 C 语言编写，可以用在树莓派、ESP32 、STM32 等单片机上，并支持各种中大型屏幕（只需要提供屏幕的绘图 API 即可）。LVGL 的官网地址为：<a href="https://lvgl.io/">https://lvgl.io/</a> ，GitHub 地址为：<a href="https://github.com/lvgl/lvgl">https://github.com/lvgl/lvgl</a> 。</p>
<p>LVGL 提供了许多示例程序，还提供了 PC 端的模拟器，这都加快了 LVGL 的开发效率。</p>
<h2>移植LVGL</h2>
<p>LVGL 并没有只针对哪一个单片机和哪一个屏幕，事实上它甚至在 PC 机也能运行的起来。完整的 LVGL 的移植可以参考官方文档的介绍 <a href="https://docs.lvgl.io/master/porting/index.html">https://docs.lvgl.io/master/porting/index.html</a> 。在移植前，请自行了解单片机及屏幕的使用方法并提供接口程序。</p>
<h3>建立工程</h3>
<p>接下来以 STM32 系列单片机为例介绍 LVGL 的移植，不同单片机的移植过程也可以参考以下步骤。下表给出了 LVGL 所需的配置，在使用 LVGL 前请确保单片机性能满足要求：</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Minimal</strong></th>
<th><strong>Recommended</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Architecture</strong></td>
<td>16, 32 or 64 bit microcontroller or processor</td>
<td></td>
</tr>
<tr>
<td><strong>Clock</strong></td>
<td>&gt; 16 MHz</td>
<td>&gt; 48 MHz</td>
</tr>
<tr>
<td><strong>Flash/ROM</strong></td>
<td>&gt; 64 kB</td>
<td>&gt; 180 kB</td>
</tr>
<tr>
<td><strong>Static RAM</strong></td>
<td>&gt; 16 kB</td>
<td>&gt; 48 kB</td>
</tr>
<tr>
<td><strong>Draw buffer</strong></td>
<td>&gt; 1 ×<em>hor. res.</em> pixels</td>
<td>&gt; 1/10 screen size</td>
</tr>
<tr>
<td><strong>Compiler</strong></td>
<td>C99 or newer</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote><p>注意：使用 Keil5 请开启“C99 Mode”，否则会编译不通过。还在使用 Keil4 的请升级或更换编译器。</p></blockquote>
<p>首先，在 <a href="https://github.com/lvgl/lvgl">https://github.com/lvgl/lvgl</a> 下载或克隆整个工程。LVGL 的最新版本是 LVGL 8.2 ，注意 LVGL 7 已经不再更新，LVGL 7 和 8 之间库结构发生较大改变，编写出的代码并不很兼容，并且 LVGL 7 的示例代码和模拟器似乎已经在 GitHub 上下架了。本教程以 LVGL 8 为例，移植 LVGL 7 的话可以参考，但一些细节需要注意调整。建议使用最新版本，否则无法得到完整的工具链支持。</p>
<blockquote><p>使用 Keil 的开发者请注意，LVGL 8 似乎不能在 ARM CC v5 下编译成功，请更新编译器版本为 ARM CC v6 。</p>
<p>使用 STM32 的开发者还需要注意，STM32 标准库无法使用 ARM CC v6 编译，请使用 HAL 库或更换编译工具链（如 LLVM-clang 或 GCC-none-eabi ）</p></blockquote>
<p>接下来自行准备一个单片机工程，在 <code>User</code> 或其它等效的目录中，然后新建目录 <code>lvgl</code> 并进入，从克隆得到的 LVGL 工程中复制以下文件或目录到其中：</p>
<div class="codeblock code-template">
	examples<br />
src<br />
lvgl.h<br />
lv_conf_template.h</div>
<p>如果不需要使用官方提供的示例代码，可以不复制 <code>demos</code> 目录。</p>
<p>接下来，将 <code>lv_conf_template.h</code> 重命名为 <code>lv_conf.h</code> ，并移动到上一级目录中。</p>
<blockquote><p>注意：LVGL 库的目录比较复杂，头文件引用相对混乱，在没有充分明白正在做什么之前，请不要随意修改文件夹名或变更文件位置。</p></blockquote>
<p>回到上一级目录，打开 <code>lv_conf.h</code> ，将开头的 <code>#if 0</code> 条件编译取消，启用文件包含的配置：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/* clang-format off */</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;"> </span><span style="color: #a8a8a8;">/*Set it to "1" to enable content*/</span></div>
</div>
<p>该配置文件还有几处需要调整的地方，首先最前面（第 27 行）的一个宏定义表示显示屏的颜色深度，需要根据不同的显示屏做调整：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/*Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888)*/</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_COLOR_DEPTH</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">16</span></div>
</div>
<p>如果屏幕的颜色深度不一致，一定要修改该宏。LVGL 会根据该宏创建合适的颜色定义，如果与实际不一致会造成显示时颜色错乱。</p>
<blockquote><p>如果设置为 8 ，代表使用 8 位的颜色，其中 RBG 色值各占 3 、3 、2 位；如果设置为 16 ，则 RBG 色值各占 5 、6 、5 位，这是许多 TFT 屏采用的颜色格式；32 则是大多数 PC 机和移动设备都使用的带透明度的 32bit 位图，RGB 色值和透明度各占一个字节。</p></blockquote>
<p>第 52 行中还有一处表示最大占用内存量的宏，可以根据实际单片机的情况自行修改，只要保证大于注释中写的 2kB 就行。</p>
<div class="vscode-block">
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/*Size of the memory available for `lv_mem_alloc()` in bytes (&gt;= 2kB)*/</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_MEM_SIZE</span><span style="color: #403f53;"> (</span><span style="color: #aa0982;">32U</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1024U</span><span style="color: #403f53;">) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">/*[bytes]*/</span></div>
</div>
<p>除此之外，在第 273 和 280 行还有这么两个宏定义，如果将它们设置为 <code>1</code> ，那么可以在屏幕的左下角和右下角显示当前内存占用和帧率，非常适合性能分析：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_USE_PERF_MONITOR</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_USE_MEM_MONITOR</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span></div>
</div>
<p>其它设置可以对照注释和文档修改。</p>
<p>接下来开始导入工程文件，这一步需要将 <code>lvgl/src</code> 中除了 <code>draw</code> 目录中的所有文件全部导入，而 <code>draw</code> 目录中除了根目录的 <code>.c</code> 文件外，只导入 <code>sw</code> 目录中的源文件。LVGL 8 的目录深度较大，请耐心添加，细心检查，不要遗漏文件。</p>
<p>使用 STM32 单片机的话还需要注意在启动文件中修改堆、栈大小，至少各设置 8kB 空间：</p>
<div class="vscode-block">
<div><span style="color: #403f53;">Stack_Size &nbsp; &nbsp; &nbsp;</span><span style="color: #994cc3;font-weight: bold;">EQU</span><span style="color: #403f53;"> &nbsp; &nbsp; 0x00002000</span></div>
<div><span style="color: #403f53;">Heap_Size &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">EQU</span><span style="color: #403f53;"> &nbsp; &nbsp; 0x00002000</span></div>
</div>
<p>全部添加完成之后，尝试编译整个工程，应该是可以零 error 通过了。</p>
<blockquote><p>使用 ARM CC v6 可能会发生 <code>__aeabi_assert</code> 符号未定义的问题，可以在整个项目管理中提前定义宏 <code>NDEBUG</code> 禁用该符号。</p></blockquote>
<h3>显示设备的API对接</h3>
<p>LVGL 只提供了绘图的算法，其它内容需要自行编写。LVGL 提供的接口在 <code>lvgl/examples/porting</code> 目录中，该目录有如下文件：</p>
<ul>
<li><code>lv_port_disp</code> ：显示设备接口</li>
<li><code>lv_port_indev</code> ：输入设备接口</li>
<li><code>lv_port_fs</code> ：文件系统接口</li>
</ul>
<p>将各个文件名结尾的 <code>template</code> 去除。接下来先编写显示设备的接口，至少确保能显示一些东西来。</p>
<hr>
<p>在 <code>lv_port_disp.c</code> 及其头文件中，首先需要去除条件编译，启用这部分内容：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/*Copy this file as "lv_port_disp.h" and set this value to "1" to enable content*/</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span></div>
</div>
<p>由于之前重命名过头文件，因此在源文件中也需要修改对应的名称：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">include</span><span style="color: #403f53;"> </span><span style="color: #111111;">"</span><span style="color: #c96765;">lv_port_disp.h</span><span style="color: #111111;">"</span></div>
</div>
<p>源文件在宏定义区域中有两个宏定义，需要修改为实际的显示屏尺寸。改过了之后记得把 <code>#warning</code> 预处理语句去除了：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">ifndef</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">MY_DISP_HOR_RES</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;">#warning Please define or replace the macro MY_DISP_HOR_RES with the actual screen width, default value 320 is used for now.</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">MY_DISP_HOR_RES</span><span style="color: #403f53;"> &nbsp; &nbsp;</span><span style="color: #aa0982;">320</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">endif</span></div>
<div><span style="color: #a8a8a8;">/* ... same as above ... */</span></div>
</div>
<p><code>lv_port_disp_init()</code> 是一个最顶层的初始化显示设备的函数，在主函数中需要调用它一次性初始化显示设备的功能。该函数的修改方式注释里已经写的较为清楚了，接下来提供一个修改示例。</p>
<p>首先将 91~102 行的两个提供显示缓存的语句全部注释或删除，只保留 <code>/* Example for 1) */</code> 。然后修改 114~115 行的两个数值为实际的屏幕清晰度。</p>
<div class="vscode-block">
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* Example for 1) */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_disp_draw_buf_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">draw_buf_dsc_1</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_color_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">buf_1</span><span style="color: #403f53;">[MY_DISP_HOR_RES </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">];</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_disp_draw_buf_init</span><span style="color: #403f53;">(</span><span style="color: #0c969b;">&amp;</span><span style="color: #403f53;">draw_buf_dsc_1, </span><span style="color: #4876d6;">buf_1</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">NULL</span><span style="color: #403f53;">, MY_DISP_HOR_RES </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/*Set the resolution of the display*/</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">disp_drv</span><span style="color: #403f53;">.hor_res </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">320</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">disp_drv</span><span style="color: #403f53;">.ver_res </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">240</span><span style="color: #403f53;">;</span></div>
</div>
<p>该文件内还有两个函数 <code>disp_init()</code> 和 <code>disp_flush()</code> ，需要提供实际显示设备的接口。</p>
<p><code>disp_init()</code> 中，需要提供屏幕的初始化代码，如果已经在外部初始化过可以忽略。</p>
<p><code>disp_flush()</code> 中，需要在注释的位置根据提供的参数绘制一个像素点，。这一过程也可以使用填充函数获得更快的速度，甚至可以使用 GPU 等加速等方式完成，具体如何编写代码可以参考注释。例如，测试用的屏幕是这样逐个绘制像素点，从而填充一块区域的：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/* ... */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">for</span><span style="color: #403f53;">(y </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> area</span><span style="color: #0c969b;">-</span><span style="color: #994cc3;">&gt;</span><span style="color: #403f53;">y1; y </span><span style="color: #994cc3;">&lt;=</span><span style="color: #403f53;"> area</span><span style="color: #0c969b;">-</span><span style="color: #994cc3;">&gt;</span><span style="color: #403f53;">y2; y</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">for</span><span style="color: #403f53;">(x </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">area</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">x1</span><span style="color: #403f53;">; x </span><span style="color: #994cc3;">&lt;=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">area</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">x2</span><span style="color: #403f53;">; x</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">ILI9341_SetFrontColor(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">ili9341, color_p-&gt;full)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">ILI9341_DrawPixel(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">ili9341, x, y)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; color_p</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #a8a8a8;">/* ... */</span></div>
</div>
<p>至此，API 移植便结束了。接下来可以编写程序测试 LVGL 的效果了。</p>
<h3>LVGL的初始化</h3>
<p>在使用 LVGL 前，需要调用以下两个函数完成 LVGL 库的初始化以及 LVGL 显示设备接口的初始化：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">lv_init</span><span style="color: #403f53;">();</span></div>
<div><span style="color: #4876d6;">lv_port_disp_init</span><span style="color: #403f53;">();</span></div>
</div>
<p>然后就可以绘制图形了。这里提供了一段简单的代码，可以绘制一个按钮：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> btn </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_btn_create</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">lv_scr_act</span><span style="color: #403f53;">()); </span></div>
<div><span style="color: #4876d6;">lv_obj_set_pos</span><span style="color: #403f53;">(btn, </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">lv_obj_set_size</span><span style="color: #403f53;">(btn, </span><span style="color: #aa0982;">120</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">50</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> label </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_label_create</span><span style="color: #403f53;">(btn);</span></div>
<div><span style="color: #4876d6;">lv_label_set_text</span><span style="color: #403f53;">(label, </span><span style="color: #111111;">"</span><span style="color: #c96765;">Button</span><span style="color: #111111;">"</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">lv_obj_center</span><span style="color: #403f53;">(label);</span></div>
</div>
<p>绘制完之后，还需要在主循环中调用 <code>lv_task_handler()</code> 函数，这样绘制的内容才能实时更新到屏幕上：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> (</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* ... */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_task_handler()</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>然后将编译得到的结果下载到单片机内，就可以在屏幕上看到一个按钮了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-01-disp-test.jpg" alt="-" width="360"></figure>
<h2>LVGL输入设备移植</h2>
<p>上文介绍了如何移植显示设备。但是 LVGL 是一个用户界面库，光有显示设备，不能做一些用户交互的功能还是不太够，因此就需要使用输入设备。</p>
<p>LVGL 支持 5 种类型的输入设备：</p>
<ul>
<li>Touchpad ：触摸屏</li>
<li>Mouse ：鼠标</li>
<li>Keypad ：键盘</li>
<li>Encoder ：编码器</li>
<li>Button ：按键</li>
</ul>
<p>在移植时，不要搞错了输入设备的类型，否则 LVGL 无法对输入作出响应。</p>
<p>LVGL 对输入设备的接口全部存放在 <code>lv_port_indev.c</code> 及其头文件中。接下来以触摸屏为例介绍输入设备的移植，不同设备的 API 有一定区别，在移植时请以官方文档为主。</p>
<p>首先，需要去掉两个文件中的 <code>#if 0</code> 条件编译，启用两个文件。</p>
<p>在 <code>lv_port_indev.c</code> 中，包含了 5 种设备的 API ，但它们不可能都用到，因此需要裁剪无用的函数和定义。尤其是在初始化函数 <code>lv_port_indev_init()</code> 中，如果不去除无用设备的初始化语句，那么在调用时可能会出现问题。</p>
<p>源码在注释中已经着重强调了不同 API 的分区，只需要根据分区保留需要的代码即可。</p>
<p>根据代码的思路（精简后的源码不长，而且抽象程度较高，完全可以读懂），接下来实现三个函数的功能。</p>
<p>首先是 <code>touchpad_init()</code> ，在这里需要对输入设备做初始化，就像上文对触摸屏做初始化一样。</p>
<p>在 <code>touchpad_is_pressed()</code> 中，需要提供一个显示屏触摸函数，判断是否发生了触摸事件：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">bool</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">touchpad_is_pressed</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">XPT2046_TouchDetect()</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">==</span><span style="color: #403f53;"> TOUCH_PRESSED)</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">true</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">false</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>如果发生了触摸事件，那么会进入 <code>touchpad_get_xy()</code> 函数中，获取触摸点坐标：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">touchpad_get_xy</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">lv_coord_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">lv_coord_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> XPT2046_Coordinate </span><span style="color: #4876d6;">coord</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> { </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">, </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">, </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">, </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;"> };</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">XPT2046_Get_TouchedPoint(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">xpt2046, </span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">coord</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; (</span><span style="color: #0c969b;">*</span><span style="color: #403f53;">x</span><span style="color: #403f53;">) </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">coord</span><span style="color: #403f53;">.</span><span style="color: #4876d6;">x</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; (</span><span style="color: #0c969b;">*</span><span style="color: #403f53;">y</span><span style="color: #403f53;">) </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">coord</span><span style="color: #403f53;">.</span><span style="color: #4876d6;">y</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>如果这几个函数都编写正确，那么理论上已经可以实现输入功能了。不过在此之前，还有一个关键的步骤：LVGL 使用一个 tick 系统管理全局事件，它就像 LVGL 的心跳一样，如果没有这个心跳就无法检测事件。</p>
<p>为了给 LVGL 提供心跳，需要不断调用 <code>lv_tick_inc()</code> 函数，该函数的参数为每次心跳的毫秒间隔：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> (</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_tick_inc(</span><span style="color: #aa0982;">1</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_task_handler()</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">delay_ms(</span><span style="color: #aa0982;">1</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>使用单片机时更推荐使用定时器完成该函数的调用，设置定时器溢出时间为 1 毫秒后在定时器中断函数内调用它。</p>
<hr>
<p>接下来提供一个示例，可以检测输入设备是否能正常使用。首先在 <code>main</code> 函数的开头执行输入设备的初始化：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">lv_port_indev_init</span><span style="color: #403f53;">();</span></div>
</div>
<p>然后编写如下函数：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">btn_event_cb</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">lv_event_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> e) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_event_code_t</span><span style="color: #403f53;"> code </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_event_get_code(e)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> btn </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_event_get_target(e)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (code </span><span style="color: #994cc3;">==</span><span style="color: #403f53;"> LV_EVENT_CLICKED) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> cnt </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; cnt</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> label </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_obj_get_child(btn, </span><span style="color: #aa0982;">0</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">lv_label_set_text_fmt(label, </span><span style="color: #111111;">"</span><span style="color: #c96765;">Button: </span><span style="color: #4876d6;">%d</span><span style="color: #111111;">"</span><span style="color: #4876d6;">, cnt)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">}</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_example</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> btn </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_btn_create(lv_scr_act())</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_set_pos(btn, </span><span style="color: #aa0982;">10</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">10</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_set_size(btn, </span><span style="color: #aa0982;">120</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">50</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_add_event_cb(btn, btn_event_cb, LV_EVENT_ALL, NULL)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> label </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_label_create(btn)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_label_set_text(label, </span><span style="color: #111111;">"</span><span style="color: #c96765;">Button</span><span style="color: #111111;">"</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_center(label)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>在主函数中调用 <code>lv_example()</code> ，编译后下载到单片机内，可以得到一个和上一个示例相同的按钮，但是每次点击之后，按钮的文本都会发生变化：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-01-indev-test.jpg" alt="-" width="360"></figure>
<h2>使用LVGL模拟器</h2>
<p>LVGL 是一个图形库，那么在绘制图形时就免不了需要对绘制结果做一些微调。那么每次微调都需要将程序下载到单片机去显然是麻烦的选择，不过幸好 LVGL 提供了模拟器，可以在 PC 端上直接生成可交互的界面，无需下载即可查看绘制效果。</p>
<p>LVGL 可以在各个平台上模拟，完整的模拟器使用指南可以参照 <a href="https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html">https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html</a> 。接下来以 Windows 平台基于 Visual Studio 的模拟为例介绍通用的使用方法。</p>
<p>首先，在 <a href="https://github.com/lvgl/lv_port_win_visual_studio">https://github.com/lvgl/lv_port_win_visual_studio</a> 中下载 Visual Studio 工程源码。注意，在 <code>LVGL.Simulator</code> 目录中包含 3 个外部的仓库，需要将它们一并下载并放在正确的位置。</p>
<p>然后，使用 Visual Studio 打开 <code>LVGL.Simulator.sln</code> 工程，点击编译即可得到 GUI 可执行文件。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-01-simulation-test.jpg" alt="-" width="770"></figure>
<p>LVGL 模拟器的屏幕大小可能与实际屏幕大小不符，需要在主函数最前部分 <code>lv_win32_init</code> 初始化时做一些调整。</p>
<p>需要注意的是，Visual Studio 提供的模拟器是使用 C++ 编写的，如果需要自定义函数，需要在头文件中使用</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">ifdef</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">__cplusplus</span></div>
<div><span style="color: #994cc3;font-weight: bold;">extern</span><span style="color: #403f53;"> </span><span style="color: #111111;">"</span><span style="color: #c96765;">C</span><span style="color: #111111;">"</span><span style="color: #403f53;"> {</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">endif</span></div>
<div><span style="color: #a8a8a8;">/* ... function prototypes ... */</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">ifdef</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">__cplusplus</span></div>
<div><span style="color: #403f53;">}</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">endif</span></div>
</div>
<p>将函数原型包围起来，否则在使用 C 语言符号时会出错。</p>
<p><a rel="nofollow" href="/archives/307">LVGL库入门教程01-移植到STM32</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/307/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
