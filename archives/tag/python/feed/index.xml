<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Python归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/python/feed?simply_static_page=3743" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Thu, 11 May 2023 15:19:15 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>Python归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>机器学习-参数选择与模型验证</title>
		<link>/archives/1081</link>
					<comments>/archives/1081#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sat, 15 Apr 2023 09:29:37 +0000</pubDate>
				<category><![CDATA[机器学习]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1081</guid>

					<description><![CDATA[<p>在很多时候并不能直接将数据以可视化的形式表达出来，这&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1081">机器学习-参数选择与模型验证</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>在很多时候并不能直接将数据以可视化的形式表达出来，这就意味着无法以直观的方式检验模型的分类效果。本节介绍机器学习中常用的模型验证方法以及如何选择恰当的超参数。</p>

<h2>模型检验方法</h2>

<h3>交叉验证</h3>

<p>最简单验证模型的方法就是调用模型的 <code>.score()</code> 方法，检查给定数据的准确率。例如，对于以下数据：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-output-demo-data-1.png" alt="" width="380">
</figure>

<p>接下来建立一个决策树模型并用 <code>.score()</code> 方法检查训练数据的准确率：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>tree <span token="keyword">import</span> DecisionTreeClassifier</div><br><div>model <span style="color: #7c4dff;">=</span> DecisionTreeClassifier<span token="symbol">()</span></div><div>model<span token="symbol">.</span>fit<span token="symbol">(</span>X<span token="symbol">,</span> y_true<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><div class="sklearn-model"><p>DecisionTreeClassifier()</p></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>model<span token="symbol">.</span>score<span token="symbol">(</span>X<span token="symbol">,</span> y_true<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1.0</div>
</div>

<p>结果显示模型的准确率是 100% 。当然，这种验证方法是不合理的，因为以上并没有对决策树模型做任何约束，此时可能已经发生了过拟合，因此可以 100% 拟合训练数据。</p>

<p>解决过拟合的一种思路是引入测试数据，测试数据不供模型学习，可以防止过拟合的影响。但是有时不易获取测试数据，这就需要将现有数据拆分为训练集和测试集：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>model_selection <span token="keyword">import</span> train_test_split </div><br><div>X_train<span token="symbol">,</span> X_test<span token="symbol">,</span> y_train<span token="symbol">,</span> y_test <span style="color: #7c4dff;">=</span> train_test_split<span token="symbol">(</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; X<span token="symbol">,</span> y_true<span token="symbol">,</span> <span style="color: #e53935;">random_state</span><span style="color: #7c4dff;">=</span><span token="number">6</span><span token="symbol">,</span> <span style="color: #e53935;">train_size</span><span style="color: #7c4dff;">=</span><span token="number">0.7</span><span token="symbol">)</span></div></div>
    <div class="jupyter-separator"></div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>model<span token="symbol">.</span>fit<span token="symbol">(</span>X_train<span token="symbol">,</span> y_train<span token="symbol">)</span></div><div>model<span token="symbol">.</span>score<span token="symbol">(</span>X_test<span token="symbol">,</span> y_test<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.9142857142857143</div>
</div>

<p>以上函数将现有数据拆分为训练集和测试集，其中训练集占所有数据的 70% 。对测试集应用 <code>.score()</code> 方法的结果表明，模型的准确率为 91.4% ，更接近模型真实的准确率。</p>

<p>直接将数据分为训练集和测试集的缺点是模型失去了一部分可用于训练的数据，且这部分数据中可能包含某些关键的信息（比如支持向量）。一个更好的思路是将数据集划分为若干部分，每次将一个部分用于检验，其它部分用于训练，这样数据集的每个部分都能用于训练和检验。这种策略称为<strong>交叉验证</strong>(cross validation)。下图展示了一个 4 轮交叉验证的构成：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-cross-validation.png" alt="" width="320">
</figure>

<p>手动拆分数据比较繁琐，不过可以借助 Scikit-Learn 提供的工具来处理：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>model_selection <span token="keyword">import</span> cross_val_score</div><br><div>scores <span style="color: #7c4dff;">=</span> cross_val_score<span token="symbol">(</span>model<span token="symbol">,</span> X<span token="symbol">,</span> y_true<span token="symbol">,</span> <span style="color: #e53935;">cv</span><span style="color: #7c4dff;">=</span><span token="number">5</span><span token="symbol">)</span></div><div>scores</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0.975, 0.9  , 0.975, 0.875, 0.925])</div>
</div>

<p>可以通过 <code><em>cv</em></code> 参数修改交叉验证的轮数，默认采用 5 轮交叉验证。对每轮交叉验证的准确率取均值，就非常接近实际的准确率了：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>scores<span token="symbol">.</span>mean<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.93</div>
</div>

<p>一种极端的情况是将交叉验证的轮数设置为和样本的个数一样多，这种情况下每次只使用一个样本用于验证，而其它的样本都用于训练，这称为留一(leave-one-out, LOO)交叉检验。要使用留一交叉验证不能直接将 <code><em>cv</em></code> 设置为样本的大小，而是需要借助 <code>LeaveOneOut</code> 类：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>model_selection <span token="keyword">import</span> LeaveOneOut</div><div>scores <span style="color: #7c4dff;">=</span> cross_val_score<span token="symbol">(</span>model<span token="symbol">,</span> X<span token="symbol">,</span> y_true<span token="symbol">,</span> <span style="color: #e53935;">cv</span><span style="color: #7c4dff;">=</span>LeaveOneOut<span token="symbol">())</span></div><div>scores<span token="symbol">.</span>mean<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.925</div>
</div>

<p>在之前的学习中认识了模型的过拟合现象。过拟合现象就是随着模型的复杂度上升，虽然对数据的拟合效果变好，但是模型的泛化程度下降，对新的数据不能很好地处理。反应在交叉验证下，就是训练集效果越来越好，但是测试集效果反而越来越差：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-cross-validation-overfitting.png" alt="">
</figure>

<p>这个曲线同时表明训练集的准确率总是比验证集的准确率高，并且随着模型复杂度的提升，训练集的准确率越来越高，甚至趋近 100% ；而验证集的准确率增长到某个值后反而开始下降。</p>

<h3>混淆矩阵</h3>

<p>以上均使用准确率作为衡量模型好坏的指标，但这可能会导致一些问题。一个准确率较高的模型不一定效果就好。例如，对于以下数据：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-output-demo-data-2.png" alt="" width=350>
</figure>

<p>假设使用逻辑回归模型拟合这些数据，并且不对数据添加额外特征，那么得到模型的准确率为：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>linear_model <span token="keyword">import</span> LogisticRegression</div><div>model <span style="color: #7c4dff;">=</span> LogisticRegression<span token="symbol">().</span>fit<span token="symbol">(</span>X<span token="symbol">,</span> y_true<span token="symbol">)</span></div><div>cross_val_score<span token="symbol">(</span>model<span token="symbol">,</span> X<span token="symbol">,</span> y_true<span token="symbol">).</span>mean<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.8181818181818183</div>
</div>

<p>82% 的准确率看似不错，但是注意到准确率会存在以下问题：对于二分类问题，如果两个分类样本数相近，那么即便模型随便预测，总体的准确率也接近 50% ；如果两个分类样本数相差较大，那么模型只要倾向于预测样本数较多的那个分类，准确率就不会差。例如对于以上数据，假设某个模型均预测为蓝色类别，那么它的准确率为：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>metrics <span token="keyword">import</span> accuracy_score</div><div>accuracy_score<span token="symbol">(</span>y_true<span token="symbol">,</span> np<span token="symbol">.</span>zeros_like<span token="symbol">(</span>y_true<span token="symbol">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.8909090909090909</div>
</div>

<p>结果甚至比逻辑回归还要好，但这种模型肯定是完全没有研究和使用价值的。</p>

<p>对于二分类模型，只有预测正确(True)和错误(False)的可能。记两种类别为正类(Positive)和负类(Negative)，那么一个模型的预测结果只有以下四种情况：</p>

<table>
    <tr>
        <th></th>
        <th>Positive（预测真）</th>
        <th>Negative（预测假）</th>
    </tr>
    <tr>
        <th>True（实际真）</th>
        <td>True Positive(TF) 正确肯定</td>
        <td>False Negative(FN) 漏报</td>
    </tr>
    <tr>
        <th>False（实际假）</th>
        <td>False Positive(FP) 虚报</td>
        <td>True Negative(TN) 正确否定</td>
    </tr>
</table>

<p>所有的评估参数都由该表中的元素组成，该表也被称为<strong>混淆矩阵</strong>(confusion matrix)。在之前一直使用准确(accuracy)率衡量模型，它的公式如下：</p>

<div class="math">
\\[
    \text{accuracy} = \frac{\text{True}}{\text{All}} = \frac{\text{TP}+\text{TN}}{\text{TP}+\text{FN}+\text{TN}+\text{FP}}
\\]
</div>

<p>这个公式的问题就在于它同时考虑了正类和反类，但两者的重要性是不一样的：样本多的类别对准确率的影响更大，但并不意味着模型应该优先满足样本多的类别的准确率。如果模型更关心正类的分类质量，那么有两个指标可以说明正类的分类效果好坏：</p>

<p>精确(precision)率：<strong>精确率</strong>用于衡量预测为正类的样本预测对的概率，即：</p>

<div class="math">
\\[
    \text{precision} = \frac{\text{True}}{\text{Predicted Positive}} = \frac{\text{TP}}{\text{TP}+\text{FP}}
\\]
</div>

<p>如果模型的精确率高，说明预测的正类大多都预测对了。不过也不能一昧只提高精确率，那样的话模型为了确保预测的正类是对的，会倾向于减少预测为正类的样本数量。另一个指标<strong>召回率</strong>(recall)用于衡量实际为正类的样本预测对的概率，即：</p>

<div class="math">
\\[
    \text{recall} = \frac{\text{True}}{\text{Actual Positive}} = \frac{\text{TP}}{\text{TP}+\text{FP}}
\\]
</div>

<p>召回率高说明实际的正类大多都找出来了。同样，一昧提高召回率也会使得模型为了尽可能找出所有正类，倾向于增加预测为正类的样本数量。</p>

<p>容易看出，精确率和召回率之间具有互补关系：如果一个模型的精确率和召回率都很高，说明模型既能找出数据集中的正类，同时也能排除不属于正类的样本（找出所有的负类），那么这个模型的效果很好。通过组合精确率和召回率可以得到一个比较通用的指标，例如常用的 <span class="math">\\( F_1 \\)</span> 分数：</p>

<div class="math">
\\[
    F_1 = \frac{2}{ \displaystyle{\frac{1}{\text{precision}}} + \displaystyle{\frac{1}{\text{recall}}} }
\\]
</div>

<p><span class="math">\\( F_1 \\)</span> 分数使用调和平均数组合这两个指标。调和平均数是总体各统计变量倒数的算术平均数的倒数，由于不知道精确率和召回率哪个指标对总体的贡献更大，因此不能使用加权平均值，而调和平均数会赋予低值更高的权重，只有当召回率和精度都很高时才能得到较高的 <span class="math">\\( F_1 \\)</span> 分数。</p>

<p>在 Scikit-Learn 中，可以通过 <var type="module" class="code-font">metrics</var> 模块提供的工具计算 <span class="math">\\( F_1 \\)</span> 分数。</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>metrics <span token="keyword">import</span> f1_score</div><div>f1_score<span token="symbol">(</span>y_true<span token="symbol">,</span> model<span token="symbol">.</span>predict<span token="symbol">(</span>X<span token="symbol">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.4</div>
</div>

<p>计算得到模型的 <span class="math">\\( F_1 \\)</span> 分数只有 0.4 ，说明对正类的分类效果完全不像整体的准确率一样还算不错。</p>

<p>有时可能需要模型必须保证找到的正类都是对的，而允许模型存在一定的漏检（例如在登录时的用户面部识别，如果将错误的样本划归为正类会招致严重的损失）；有时可能需要确保模型没有漏检，而允许模型找到的正类不必都是对的（例如查找嫌疑人时的面部识别，如果遗漏一个正类会导致严重的后果）。这时可能会更关心精确率和召回率的其中一个，除了上文中见到的准确率计算，该模块也包含精确率和召回率的计算函数，可以组合它们拼凑一个需要的指标。</p>

<h3>评估曲线</h3>

<p>以上的准确率、精确度、<span class="math">\\( F_1 \\)</span> 值等都只是一个单一的数值指标，如果想观察分类算法在不同的参数下的表现情况，就可以使用一条曲线描述。</p>

<p>ROC(Receiver Operating Characteristic, 受试者工作特征)曲线是一种用于评估二元分类器性能的工具。它的横纵坐标都是来自混淆矩阵的组合指标：</p>

<ul>
    <li>横坐标为<strong>假正例率</strong>(False Positive Rate, FPR)，表示在所有真反例中，分类器错误识别为正例的比例 <span class="math">\\( \text{FPR} = \dfrac{\text{FP}}{\text{FP}+\text{TN}} \\)</span></li>
    <li>纵坐标为<strong>真正例率</strong>(True Positive Rate, TPR)，表示在所有真正例中，分类器正确识别为正例的比例 <span class="math">\\( \text{TPR} = \dfrac{\text{TP}}{\text{TP}+\text{FN}} \\)</span> ，就是刚才介绍的召回率</li>
</ul>

<p>ROC 曲线的特点是，它能够展示分类器在不同阈值下的性能表现。这里的阈值指的是分类器判断一个样本为正例的概率的截断值。一般情况下，当阈值设定为 0.5 时，分类器将所有概率大于 0.5 的样本判断为正例，而将所有概率小于等于 0.5 的样本判断为反例。</p>

<p>提高阈值会使预测为正类的样本数量减少，但预测的样本是正类的可能性都很高，因此可以提高模型的精确率。同样地，降低阈值会让模型将一些不太可能是正类的样本预测为正类，但也可能找出更多实际是正类的样本，因此可以提高模型的召回率。</p>

<p>ROC 曲线呈现了不同阈值下的假正例率和真正例率，如下图所示：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-ROC-curve-concept.png" alt="" width="320">
</figure>

<p>一个良好的模型应该拥有高真正例率(TPR)和低假正例率(FRP)，即尽可能找出属于该组的，但也要排除不属于该组的。一个完美的模型希望假警报率接近 0 ，命中率接近 1 ，即左上角顶点。一般的模型不可能达到该值，只能尽可能接近它，反应在图形上就是 ROC 曲线最接近左上角的一点，为模型的最优情况。</p>

<p>在 <span class="code-font">sklearn</span> 中，绝大多数分类器都有 <code>.predict_proba()</code> 方法，可以得到该模型判断样本为每个分类的概率：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>model<span token="symbol">.</span>predict_proba<span token="symbol">(</span>X<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[0.0925382 , 0.9074618 ],
       [0.24097764, 0.75902236],
       [0.05459936, 0.94540064],
       ...,
       [0.20851233, 0.79148767]])</div>
</div>

<p>对于二分类模型，判断样本为正例或反例的概率加起来应该等于 1.0 。</p>

<p>有了这些概率数据，就可以通过设置不同阈值来观察假正例率和真正例率的变化。<span class="code-font">sklearn</span> 提供了如下工具来计算 <span class="math">\\( \text{TPR} \\)</span> 和 <span class="math">\\( \text{FPR} \\)</span> 在不同阈值下的表现情况：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>metrics <span token="keyword">import</span> roc_curve</div><div>FPR<span token="symbol">,</span> TPR<span token="symbol">,</span> thres <span style="color: #7c4dff;">=</span> roc_curve<span token="symbol">(</span>y_true<span token="symbol">,</span> </div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; model<span token="symbol">.</span>predict_proba<span token="symbol">(</span>X<span token="symbol">)[:,</span> <span token="number">1</span><span token="symbol">])</span></div></div>
</div>

<p>这里采用类别 1 作为正类。计算得到的结果是排序后的，可以直接调用 <span class="code-font">matplotlib</span> 绘制曲线，得到的结果可能是这样的：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-ROC-curve-demo.png" alt="">
</figure>

<p>在数值上通常使用 <strong>AUC</strong>(Area Under the ROC Curve, ROC 曲线下面积)作为衡量分类器性能的指标，AUC 取值范围为 <span class="math">\\( (0.5,1) \\)</span> ，越接近 1 表示分类器的性能越好。通常达到 0.75 表示可以接受，0.85 表示非常不错。</p>

<p>如果不是为了可视化，一般可以使用以下工具直接计算 AUC 值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>metrics <span token="keyword">import</span> roc_auc_score</div><div>roc_auc_score<span token="symbol">(</span>y_true<span token="symbol">,</span> model<span token="symbol">.</span>predict_proba<span token="symbol">(</span>X<span token="symbol">)[:,</span> <span token="number">1</span><span token="symbol">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.8382</div>
</div>

<p>进一步地，通过绘制 K-S 曲线可以分析模型随阈值变化的特性。K-S(Kolmogorov-Smirnov)检验用于测量两个累积分布是否一致。在二分类问题中，K-S 检验用于度量正分布和负分布之间的分离程度。</p>

<p>随着阈值的上升，真正例率(TPR)可以理解为累积正样本率，假正例率(FPR)可以理解为累积负样本率，因此可以使用这两个指标绘制 <strong>K-S 曲线</strong>。绘制时一般将阈值作为横坐标，真正例率(TPR)和假正例率(FPR)之差作为纵坐标，如下图所示：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-KS-curve-explain.png" alt="" width="410">
</figure>

<p>K-S 曲线有助于调整模型的决策阈值。K-S 值是两个两个累积分布曲线的最大垂直距离。在二分类问题中，它是曲线的纵坐标最大值。K-S 值的取值范围为 0~1 ，较高的值表示正类和负类之间的分离更好，即模型的分类效果更好。不过应该注意的是，K-S 检验假设数据是独立同分布的，在实践中可能未必如此。</p>

<h2>参数选择方法</h2>

<p>在了解了如何评价一个模型以及阈值对模型的影响后，接下来的问题是如何才能得到最优的模型，这就涉及到为模型选择合适的参数。</p>

<h3>鸢尾花数据集</h3>

<p>接下来介绍著名的鸢尾花数据集，它是一个经典的多分类数据，经常用于检验新模型的分类效果。它是 <span class="code-font">sklearn</span> 内置的数据集之一，可以通过以下方法加载它：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>datasets <span token="keyword">import</span> load_iris</div><div>iris <span style="color: #7c4dff;">=</span> load_iris<span token="symbol">()</span></div></div>
</div>

<p>得到的是一个类似字典的对象，它有以下键：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>iris<span token="symbol">.</span>keys<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">dict_keys(['data', 'target', 'frame', 'target_names', 'DESCR', 'feature_names', 'filename', 'data_module'])</div>
</div>

<p>主要用到的键对应的值的含义为：</p>

<ul>
    <li><code>feature_names</code> ：特征名称</li>
    <li><code>data</code> ：特征数据，是一个二维数组对象</li>
    <li><code>target</code> ：目标数据</li>
    <li><code>target_names</code></li>
</ul>

<p>这些数据大致分布如下：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-iris-data.png" alt="" width="700">
</figure>

<p><code>iris['data']</code> 和 <code>iris['target']</code> 符合模型对特征矩阵 <code>X</code> 和目标数据 <code>y</code> 的要求，因此可以直接用于训练模型。</p>

<h3>网格搜索</h3>

<p>如果不确定某个参数要如何选择，需要多次调整参数并观察模型指标的变化，以此选择参数的最优值。而如果有多个参数需要选择，那么也需要调整参数的组合，并从中选择最优的结果。</p>

<p><strong>网格搜索</strong>是一种通过穷举搜索来选择最优参数组合的手段，它将使用所有候选参数的组合来循环建立模型，并选取表现最好的参数作为最终结果。</p>

<p>网格搜索的思路很简单，就是暴力穷举参数组合并观察效果。Scikit-Learn 提供了 <code>GridSearchCV</code> 工具来实现此过程的自动化。如果现在已经有了一个模型和一些候选参数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>clf_tree <span style="color: #7c4dff;">=</span> DecisionTreeClassifier<span token="symbol">()</span></div><div>params_tree <span style="color: #7c4dff;">=</span> <span token="symbol">{</span></div><div>&#160; &#160; <span token="string">'min_samples_split'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="number">2</span><span token="symbol">,</span> <span token="number">4</span><span token="symbol">,</span> <span token="number">6</span><span token="symbol">,</span> <span token="number">10</span><span token="symbol">],</span></div><div>&#160; &#160; <span token="string">'min_samples_leaf'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="number">1</span><span token="symbol">,</span> <span token="number">3</span><span token="symbol">,</span> <span token="number">6</span><span token="symbol">,</span> <span token="number">10</span><span token="symbol">]</span></div><div><span token="symbol">}</span></div></div>
</div>

<p>那么首先需要创建一个网格搜索器：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>grid_search <span style="color: #7c4dff;">=</span> GridSearchCV<span token="symbol">(</span>clf_tree, params_tree, </div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span style="color: #e53935;">scoring</span><span style="color: #7c4dff;">=</span><span token="string">'f1_weighted'</span><span token="symbol">,</span> <span style="color: #e53935;">cv</span><span style="color: #7c4dff;">=</span><span token="number">5</span><span token="symbol">)</span></div></div>
</div>

<p>这样，<code>GridSearchCV</code> 会使用 5 轮交叉验证评估每个参数组合的效果，防止过拟合的影响。这里的评估标准 <code>"f1_weighted"</code> 指的是加权 F1 分数(Weighted F1-Score)，加权 F1 分数是对每个类别的 F1 分数进行加权平均，权重为各类别的样本数量占总样本数量的比例。关于 <span class="code-font">sklearn</span> 提供的更多检验标准，可以参考<a href="https://scikit-learn.org/stable/modules/model_evaluation.html#common-cases-predefined-values" class="link-external">官方文档</a>。</p>

<p>有了评估器以后，就可以使用 <code>.fit()</code> 方法，表示<em>应用到数据</em>：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>grid_search.fit<span token="symbol">(</span>iris<span token="symbol">[</span><span token="string">'data'</span><span token="symbol">]</span>, iris<span token="symbol">[</span><span token="string">'target'</span><span token="symbol">])</span></div></div>
</div>

<p>应用数据之后，就可以获取最优的参数组合，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="number">print</span>(grid_search.best_params_, grid_search.best_score_)</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">{'min_samples_leaf': 1, 'min_samples_split': 6} 0.9664818612187034</div>
</div>

<p>如果只是想检查参数组合对模型分数的影响，也可以通过 <code>.cv_results_</code> 属性获取。它是一个很详细的数据，同时还记录了训练时间、验证时间等信息。</p>

<p><code>GridSearchCV</code> 的 <code><em>refit</em></code> 参数默认被设为 <code>True</code> ，这代表找到了最优的参数组合后，它将立刻被应用于训练模型，并且所有的数据都将作为训练集，这个完善的模型可以通过 <code>.best_estimator_</code> 获取，并直接参与 <code>.predict()</code> 的决策中。</p>

<p>最后要注意的是，如果这个模型是使用 <code>make_pipeline()</code> 与预处理结合得到的多个步骤，那么每个步骤的参数要用两个下划线区分，整个字典看起来类似这样：</p>

<div class="vscode-block"><div>params <span style="color: #7c4dff;">=</span> <span token="symbol">{</span></div><div>&#160; &#160; <span token="string">'logisticregression__penalty'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="string">'l1'</span><span token="symbol">,</span> <span token="string">'l2'</span><span token="symbol">,</span> <span token="string">'none'</span><span token="symbol">],</span></div><div>&#160; &#160; <span token="string">'logisticregression__C'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="number">0.2</span><span token="symbol">,</span> <span token="number">1.0</span><span token="symbol">,</span> <span token="number">4.0</span><span token="symbol">],</span> </div><div>&#160; &#160; <span token="string">'polynomialfeatures__degree'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="number">3</span><span token="symbol">,</span> <span token="number">4</span><span token="symbol">,</span> <span token="number">5</span><span token="symbol">]</span></div><div><span token="symbol">}</span></div></div>

<h3>随机搜索</h3>

<p>网格搜索的缺点是如果参数列表很多，那么搜索范围会变得很大，再加上交叉验证会严重拖慢搜索进度。此时可以使用随机搜索 <code>RandomizedSearchCV</code> ，它只会挑选部分而不是全部的参数组合，再从这部分随机组合中挑选最优结果。这个类的用法与 <code>GridSearchCV</code> 大致相同。</p>

<p>随机搜索不仅速度更快，而且对是连续值的参数效果更好，因为随机搜索可以很方便地抽取大量参数用于检验，每个参数可能差别很小，完整训练的代价太大。</p>
<p><a rel="nofollow" href="/archives/1081">机器学习-参数选择与模型验证</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1081/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python面向对象编程04-类与实例的方法</title>
		<link>/archives/1059</link>
					<comments>/archives/1059#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 27 Mar 2023 01:08:07 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=1059</guid>

					<description><![CDATA[<p>类方法和静态方法 实例方法 在第一节中，便已经介绍过&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1059">Python面向对象编程04-类与实例的方法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>类方法和静态方法</h2>

<h3>实例方法</h3>

<p>在<a href="/archives/442" class="link-internal">第一节</a>中，便已经介绍过实例方法。实例方法需要有一个实例才能调用，而这个实例是通过第一个通常名为 <code>self</code> 的参数表示的，因此借助该参数可以在定义方法时就去操作一个抽象的实例对象。例如，假设有一个这样的类和实例的定义：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>:</div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">method</span>(self, arg):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">self</span>, arg)</div><br><div><span style="color: #268bd2;">c</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">C</span>()</div></div>

<p>那么可以使用这样的方式通过实例调用该方法，实例对象将会自动作为第一个位置参数传入：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">c</span>.<span style="color: #268bd2;">method</span>(arg<span style="color: #859900;">=</span><span style="color: #cb4b16;">...</span>)</div></div>

<p>许多编程语言在方法内部，对实例的引用是通过 <code>this</code> 关键字完成的；而 Python 则与之不同，实例的引用是通过显式的参数传递的。这样做的好处在于，一是通过显式定义来强调默认定义的方法是实例方法，二是也可以把方法当做第一个参数是实例的函数一样调用：</p>

<div class="vscode-block"><div><span style="color: #cb4b16;">C</span>.<span style="color: #268bd2;">method</span>(<span style="color: #268bd2;">c</span>, arg<span style="color: #859900;">=</span><span style="color: #cb4b16;">...</span>)</div></div>

<p>例如，多个字符串连接默认是通过字符串的 <code>.join()</code> 方法实现，这里调用该方法的字符串实例将被插入被连接的字符串之间：</p>

<div class="vscode-block"><div><span style="color: #2aa198;">'||'</span>.<span style="color: #268bd2;">join</span>([<span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'c'</span>])</div><div><span style="color: #a8a8a8;"># 'a||b||c'</span></div></div>

<p>如果觉得用被插入的字符串去调用该方法比较奇怪，也可以通过 <code>str</code> 类调用该方法，并将被插入的字符串作为第一个位置参数主动传入：</p>

<div class="vscode-block"><div><span style="color: #cb4b16;">str</span>.<span style="color: #268bd2;">join</span>(<span style="color: #2aa198;">'||'</span>, [<span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'c'</span>])</div></div>

<!-- <div class="vscode-block"><div><span style="color: #cb4b16;">str</span>.<span style="color: #268bd2;">replace</span>(<span style="color: #2aa198;">'%time</span><span style="color: #cb4b16;">%-%</span><span style="color: #2aa198;">name%.jpg'</span>, <span style="color: #2aa198;">'%time%'</span>, <span style="color: #268bd2;">ctime</span>())</div></div> -->

<p>因此，实例方法的实质就是一个函数，只不过它的主要用途是处理实例。Python 允许实例方法可以直接由实例调用，使得调用的表示更加简洁。</p>

<h3>类方法</h3>

<p>与实例方法相对应的是<strong>类方法</strong>。类方法是类本身具有的方法，它可以在不需要实例的情况下使用类本身来调用。</p>

<p>Python 中类方法和实例方法相似，但是它需要传入一个名为 <code>cls</code> 的参数，用来代表这个类本身（同样，这个名字不必是 <code>cls</code> ，可以是 <code>typ</code> 或 <code>Lei</code> 等）。但是为了与实例方法区分，类方法在定义时需要使用 <code>@classmethod</code> 装饰器。</p>

<p>因此，一个完整的类方法的定义为：</p>

<div class="codeblock code-template">
    @classmethod<br>
    <strong>def</strong> <em>method_name</em>(cls, ...):<br>
    &nbsp; &nbsp; ...
</div>

<p>类方法有几种比较常见的应用场景。首先是构造前交互，有些时候需要在实例化前做一些准备，例如一个代表数据库的类，可以通过类方法读取配置文件并连接到数据库中，这样随后对实例的操作可以实时反映到对数据库的更新中。由于读取配置文件这种操作需要在得到任意一个实例之前完成，因此可以借助类方法实现。</p>

<p>类方法还可以用于以别的方式构建实例。例如，<code>datetime</code> 是一个用于处理日期与时间的标准库，其中 <code>date</code> 是一个用于表示日期的类。如果要通过该类生成一个具体的日期，在初始化时需要传入代表年、月、日的参数：</p>

<div class="codeblock code-console">>>> from datetime import date
>>> date(2023, 3, 19)
datetime.date(2023, 3, 19)</div>

<p>但有些时候，拿到的信息可能未必包含年月日，它可能是具有特定格式的表示时间的字符串，还有可能是浮点型的时间戳。此时，可以使用 <code>date</code> 类提供的类方法使用这几种信息构造一个日期实例：</p>

<div class="codeblock code-console">>>> date.fromisoformat('2023-03-19')  # python3.7+
datetime.date(2023, 3, 19)
>>> date.fromtimestamp(time.time())
datetime.date(2023, 3, 19)</div>

<p>仿照这种思路，可以为之前自定义的 <code>Point</code> 类编写一个类方法来通过格式字符串构造实例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, x, y):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> x, y</div><div>&#160; &#160; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">classmethod</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">from_format</span>(cls, format):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">format</span>[<span style="color: #d33682;">1</span>:<span style="color: #859900;">-</span><span style="color: #d33682;">1</span>].split(<span style="color: #2aa198;">','</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">cls</span>(<span style="color: #cb4b16;">int</span>(<span style="color: #268bd2;">x</span>), <span style="color: #cb4b16;">int</span>(<span style="color: #268bd2;">y</span>)) &#160;<span style="color: #a8a8a8;"># same as Point(...)</span></div></div>

<p>注意，这里的参数 <code>cls</code> 在调用时会替换为 <code>Point</code> ，因此调用 <code>cls(...)</code> 等价于类的实例化 <code>Point(...)</code></p>

<p>使用这个类方法可以返回一个实例，就像正常方式得到的实例一样可以调用各种方法：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">p</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">from_format</span>(<span style="color: #2aa198;">'(10,40)'</span>)</div><div><span style="color: #268bd2;">p</span>.<span style="color: #268bd2;">distance_to_origin</span>() &#160;<span style="color: #a8a8a8;"># returns 41.23</span></div></div>

<p>从技术上说，也可以用一个普通函数来构造实例。但使用类方法的好处在于，一是使用者容易明白构造出的实例是属于哪个类的，二是当类被重命名后类方法无需跟着修改，降低了因为疏忽导致错误的可能性。</p>

<p>这里顺便说一下，既然实例可以调用类属性，那么实例也可以调用类方法，这等价于用它的类调用类方法。不过一般不推荐利用实例调用类方法，因为这样做可能有些奇怪。</p>

<h3>静态方法</h3>

<p>除了类方法和实例方法外，还有一个特殊的方法称为<strong>静态方法</strong>。静态方法不是类或实例所特有的，它可以被任意的类或实例调用。静态方法不涉及对类和实例的操作，因此被称为静态方法。</p>

<p>静态方法需要使用 <code>@staticmethod</code> 装饰器，并且不需要添加像 <code>self</code> 或 <code>cls</code> 这种特殊的参数，因此不参与对任意属性的修改。</p>

<p>一个静态方法的定义为：</p>

<div class="codeblock code-template">
    @staticmethod<br>
    <strong>def</strong> <em>method_name</em>(...):<br>
    &nbsp; &nbsp; ...
</div>

<p>不难看出，静态方法脱离了类和实例，表现得更像一个普通的函数。</p>

<hr>

<p>实际上，Python 中的方法和函数除了是否位于类的定义中外，并没有本质的区别。Python 中的类可以看作一个独立的<em>命名空间</em>。在 <code>class</code> 关键字引导的代码块中，可以包含各种语句，例如常见的 <code>for</code> 循环和 <code>with</code> 语句：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Type</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">s</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">i</span> <span style="color: #859900;font-weight: bold;">in</span> <span style="color: #cb4b16;">range</span>(<span style="color: #d33682;">10</span>):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">s</span> <span style="color: #859900;">+=</span> <span style="color: #268bd2;">i</span> <span style="color: #859900;">**</span> <span style="color: #d33682;">2</span></div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">with</span> <span style="color: #268bd2;">open</span>(<span style="color: #2aa198;">'settings.txt'</span>, <span style="color: #2aa198;">'r'</span>) <span style="color: #859900;font-weight: bold;">as</span> <span style="color: #268bd2;">f</span>:</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">settings</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">dict</span>([</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">kv</span>.<span style="color: #268bd2;">split</span>(<span style="color: #2aa198;">'='</span>) <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">kv</span> <span style="color: #859900;font-weight: bold;">in</span> <span style="color: #268bd2;">f</span>.<span style="color: #268bd2;">read</span>().<span style="color: #268bd2;">split</span>(<span style="color: #2aa198;">'</span><span style="color: #cb4b16;">\n</span><span style="color: #2aa198;">'</span>)</div><div>&#160; &#160; &#160; &#160; ])</div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">settings</span>.<span style="color: #268bd2;">get</span>(<span style="color: #2aa198;">'value'</span>):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">property</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">value</span>(self):</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">settings</span>[<span style="color: #2aa198;">'value'</span>]</div></div>

<p>注意，这里使用 <code>if</code> 语句动态地定义了一个方法，这是完全可以的。除此之外，在类内定义另一个类也是很常见的情况，这个嵌套类一般用于提供基本的元信息。</p>

<p>在类之中这个独立的命名空间内，可以直接访问其中定义的变量（或者说属性）。而在类外部，访问这些变量需要通过类名来标识其所位于的命名空间：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">Type</span>.<span style="color: #268bd2;">s</span>) &#160;<span style="color: #a8a8a8;"># 285</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">Type</span>().<span style="color: #268bd2;">value</span>) &#160;<span style="color: #a8a8a8;"># 1</span></div></div>

<p>从这个角度上说，类和模块并没有太大的差别。实际上，当模块导入后，它就是一个普通的 Python 对象，只不过是 <code>&lt;class 'module'></code> 类型的对象。所以在 Python 中使用方法时，实际上就是使用一个函数，Python 解释器只是额外提供了一个语法糖，将调用方法的实例自动填写到函数的 <code>self</code> 参数上，仅此而已。</p>

<h2>特殊方法</h2>

<p>在<a href="" class="link-internal">第一节</a>介绍过实例方法时，同时介绍了一个特殊的实例方法 <code>.__init()__</code> ，它会在类初始化时自动调用，以此完成一些初始化工作。之前介绍时同时提及了类还有很多类似的特殊方法，它们都以双下划线开头结尾，有时也被称为双下方法。</p>

<p>Python 的特点是一切皆对象，任何 Python 的变量都是一个对象。而 Python 对这些变量的操作，例如构造、初始化、删除、获取属性，甚至比较、索引、和迭代，都是通过调用一些特殊的方法实现的，这些方法称为 Python 的<strong>特殊方法</strong>(special method)或<strong>魔法方法</strong>(magic method)，它们的名称以双下划线开始，以双下划线结束，代表着对象的一种特殊的操作。一般情况下，使用类方法或实例方法就可以完成类的功能；但在必要时，可以使用或者重写这些特殊方法，来为自己的类提供更加规范的接口。</p>

<p>在后续篇章中，对 Python 面向对象的介绍几乎都围绕这些特殊方法。通过对这些特殊方法的介绍，可以从根本上了解 Python 的运行机制，从而编写出更加优雅、更 Pythonic 的代码。</p>

<p>本节先介绍类的三个特殊方法：<code>.__init__()</code> 、<code>.__new__()</code> 和 <code>.__del__()</code> ，它们参与着实例的生命周期。</p>

<h3>初始化方法</h3>

<p>初始化方法 <code>.__init()__</code> 是第一个介绍的特殊方法，可能也是最常用的特殊方法。每当生成一个实例后，它便会调用该方法，以此完成一些初始化工作。</p>

<p>需要注意的是，<code>.__init__()</code> 方法不能有任何非 <code>None</code> 的返回值，否则就会引起 <code class="error">TypeError</code> ，错误内容将提示该方法应该返回 <code>None</code> 。</p>

<h3>构造方法</h3>

<p><code>.__new__()</code> 被称为构造方法，因为它负责创建一个新的实例。而 <code>.__init__()</code> 负责创建后的初始化，从中也可以明白它们的用途以及调用的先后顺序。</p>

<p><code>.__new__()</code> 负责创建类的实例，它的第一个位置通常名为 <code>cls</code> ，代表生成实例的类，其余参数应该是 <code>.__init__()</code> 方法的其余参数。虽然看起来很像一个类方法，但它却是一个静态方法，并且无需使用 <code>@staticmethod</code> 装饰器。这也是特殊方法和普通方法的根本区别：Python 解释器已经规定了如何使用特殊方法，因此没必要额外声明其它东西。</p>

<p>它的返回值是新的对象实例（通常是 <code>cls</code> 的实例）。例如以下类 <code>Card</code> ，它使用 <code>.__new__()</code> 方法，在每次生成一个实例时，便给予它唯一的一个 <code>.id_</code> 属性：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Card</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">id_</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__new__</span>(cls, <span style="color: #859900;">*</span>args, <span style="color: #859900;">**</span>kwargs):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__new__</span>(<span style="color: #268bd2;">cls</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">id_</span> <span style="color: #859900;">+=</span> <span style="color: #d33682;">1</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">instance</span>.<span style="color: #268bd2;">id_</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">id_</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">instance</span></div><br><div><span style="color: #268bd2;">c01</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c02</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c03</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c03</span>.<span style="color: #268bd2;">id_</span> &#160;<span style="color: #a8a8a8;"># 3</span></div></div>

<p>注意，虽然它表现得很像一个类方法，但不能像之前介绍的类方法一样通过 <code>cls(...)</code> 来创建实例，因为这样做实质上就是在调用该方法，会陷入无限递归。一般来说对象的创建是底层 C 语言的任务，而 Python 中只需要使用 CPython 提供的接口即可，例如使用 <code>super().__new__(cls, ...)</code> 调用 <code>object</code> 类提供的基本 <code>.__new__()</code> 方法，然后在返回之前根据需要修改新创建的实例即可。</p>

<p>由于涉及到对类属性的修改，因此使用 <code>.__init__()</code> 方法不太好实现（当然不是不能实现，在后续会介绍）。同时使用 <code>.__new__()</code> 方法也方便了继承，子类可以正常编写 <code>.__init__()</code> 方法而不影响 <code>.id_</code> 的分配。</p>

<p>通过之前的介绍可以明白构造方法和初始化方法的执行顺序：<code>.__new__()</code> 方法会优先 <code>.__init__()</code> 初始化方法在生成实例前调用。执行了 <code>.__new__()</code> 并不一定会进入 <code>.__init__()</code> ；只有 <code>.__new__()</code> 返回了当前类的实例（即便是父类的实例也不行），才会进入 <code>.__init__()</code> 并为该实例做一定初始化，否则没有东西可以用于初始化。</p>

<p>利用这种特性，可以在 Python 中创建单例。单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。单例提供了创建与访问其唯一对象的方式。使用 <code>.__new__()</code> 方法可以自由控制创建的对象，从而比较方便地实现单例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Singleton</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">_has_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">False</span></div><div>&#160; &#160; <span style="color: #268bd2;">__single_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">None</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__new__</span>(cls, <span style="color: #859900;">*</span>args, <span style="color: #859900;">**</span>kwargs):</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #859900;">not</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">_has_instance</span>:</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">_has_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">True</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">__single_instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__new__</span>(<span style="color: #268bd2;">cls</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">__single_instance</span></div><div>&#160; &#160; </div><div><span style="color: #268bd2;">one_task</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Singleton</span>()</div><div><span style="color: #268bd2;">another_task</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Singleton</span>(<span style="color: #d33682;">123</span>, name<span style="color: #859900;">=</span><span style="color: #2aa198;">'another'</span>)</div><div><span style="color: #268bd2;">one_task</span> <span style="color: #859900;">is</span> <span style="color: #268bd2;">another_task</span> <span style="color: #859900;">is</span> <span style="color: #cb4b16;">Singleton</span>(<span style="color: #2aa198;">'abs'</span>) &#160;<span style="color: #a8a8a8;"># True</span></div></div>

<p>可以看到，不管该类被实例化多少次，如何实例化，得到的都是唯一的实例。单例提供了一种共享数据的方式，并且方便使用 <code><strong>is</strong></code> 判断。但考虑到 Python 能使用全局变量完成相同的工作，因此一般来说在 Python 中没必要使用单例。</p>

<h3>析构方法</h3>

<p>与构造方法相反，析构方法 <code>.__del__()</code> 用于在销毁一个类实例时调用，它对应的是 Python 中的 <code>del</code> 语句。</p>

<p>当一个对象即将被销毁时，它便会调用 <code>.__del__()</code> 方法，通常该方法用于释放实例用到的一些额外的资源（如关闭已经打开的文件）。</p>

<p><code>.__del__()</code> 是实例相关的方法，因此第一个参数应该为 <code>self</code> 。注意区别于 <code>property</code> 的 <code>@.deleter</code> 装饰器，它装饰的方法在删除某个属性时调用，而不是整个实例。由于垃圾回收是后台处理的，且 <code>del</code> 是一个语句，因此 <code>.__del__()</code> 的返回值并没有任何意义。并且在该方法内引发任何异常也是没有作用的，它既不能被所处的 <code>try</code> 块捕获，也不会中断程序的运行。</p>

<p>注意，<code>del</code> 语句在调用时，并没有直接调用实例的 <code>.__del__()</code> 方法，这是因为如果变量仅仅是对实例的一个引用，那么 <code>del</code> 语句只会销毁这个引用的对象。只有当所有的引用都被销毁了，那么 <code>del</code> 语句才会调用 <code>.__del__()</code> 方法来清除这个实例。因此，通过在 <code>.__del__()</code> 中为对象添加一个引用可以暂时推迟对象的删除，但这是很不建议的做法。</p>

<p>通过 <code>.__del__()</code> 方法，可以研究 Python 的垃圾回收机制。例如，以下是在命令行中的一个小测试：</p>

<div class="codeblock code-console">>>> GCTest()
&lt;__main__.GCTest object at 0x00000282CE8907B8>
>>> t = GCTest()
>>> del t
object deleted
>>> 'now delete "_"'
object deleted
'now delete "_"'
</div>

<p>第一个实例被自动保存在 <code>_</code> 变量中，只有这个引用改变了，它才会被删除。</p>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization">https://docs.python.org/3/reference/datamodel.html#basic-customization</a><br>
    Python3 语言参考——数据模型部分，该部分介绍了绝大多数常用的特殊方法、特殊属性与 Python 的运行机制，是深入理解 Python 最好的文档。
</p>
<p><a rel="nofollow" href="/archives/1059">Python面向对象编程04-类与实例的方法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1059/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-pandas04:索引与缺失值</title>
		<link>/archives/1054</link>
					<comments>/archives/1054#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 17 Mar 2023 09:55:47 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[pandas]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1054</guid>

					<description><![CDATA[<p>上一节介绍了 pandas 中的索引，本节补充关于索&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1054">Python数据分析-pandas04:索引与缺失值</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p><a class="link-internal">上一节</a>介绍了 pandas 中的索引，本节补充关于索引对齐的更多内容。</p>

<p>在 <var type="module">numpy</var> 中对两个数组做运算，如果它们形状既不完全一致，也不满足广播规则，那么会产生错误：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a01 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div>a02 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>linspace<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div><span style="color: #39adb5;font-weight: bold;">try</span><span style="color: #39adb5;">:</span></div><div>&#160; &#160; a01 <span style="color: #7c4dff;">+</span> a02</div><div><span style="color: #39adb5;font-weight: bold;">except</span> <span style="color: #8796b0;">ValueError</span> <span style="color: #39adb5;font-weight: bold;">as</span> e<span style="color: #39adb5;">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span>e<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">operands could not be broadcast together with shapes (4,) (5,) </div>
</div>

<p>但是对两个类似的 <code>Series</code> 对象做运算时，就不会产生这种错误：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">))</span></div><div>s02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>linspace<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">))</span></div><div>s01 <span style="color: #7c4dff;">+</span> s02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    2.0
1    4.0
2    6.0
3    8.0
4    NaN
dtype: float64</div>
</div>

<p>虽然不会产生错误，但是注意到得到的 <code>Series</code> 包含 5 个元素，并且最后一个元素似乎不是数值数据。同时结果的类型由整数变为了浮点数。</p>

<p>这两个现象就包含了本节的内容。接下来逐一介绍。</p>

<h2>索引对齐</h2>

<p>当在两个 <code>Series</code> 或 <code>DataFrame</code> 对象上做计算时，<var type="module">pandas</var> 会按照索引值配对计算元素，而不是按位置配对：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>divide<span style="color: #39adb5;">(</span>pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">ABCD</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)),</span></div><div>&#160; &#160; &#160; &#160; &#160; pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">ACBD</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">A    1.000000
B    0.666667
C    1.500000
D    1.000000
dtype: float64</div>
</div>

<p>这实际上是由于 <var type="module">pandas</var> 会在计算过程中对齐两个对象的索引。索引对齐确保计算可以得到合理的结果，并且当处理不完整的数据时也更方便。</p>

<p>例如，以下根据现有的地区面积和人口数据，计算人口密度：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>territory <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">D0</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">1708</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D1</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">9403</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">3640</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D3</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">3360</span><span style="color: #39adb5;">},</span></div><div>&#160; &#160; <span style="color: #e53935;">name</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">territory</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>population <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">D0</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">14300</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">13900</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D3</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">33280</span><span style="color: #39adb5;">},</span></div><div>&#160; &#160; <span style="color: #e53935;">name</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">population</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>population <span style="color: #7c4dff;">/</span> territory</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">D0    8.372365
D1         NaN
D2    3.818681
D3    9.904762
dtype: float64</div>
</div>

<p>结果数组的索引是两个输入数组索引的并集，并用索引相同的元素做运算。这样一来不需要使两个 <code>Series</code> 都是完整且顺序一致的，也能根据索引完成配对元素的计算。</p>

<p>在计算两个 <code>DataFrame</code> 时，类似的索引对齐规则也同样会出现在列索引中：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;">(</span>pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">6</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">AB</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">))</span> <span style="color: #7c4dff;">+</span> </div><div>&#160;pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">9</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">BAC</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>A</th><th>B</th><th>C</th>
        </tr>
        <tr>
            <td>0</td><td>1</td><td>1</td><td>NaN</td>
        </tr>
        <tr>
            <td>1</td><td>6</td><td>6</td><td>NaN</td>
        </tr>
        <tr>
            <td>2</td><td>11</td><td>11</td><td>NaN</td>
        </tr>
    </table></div>
</div>

<p>因此，索引对齐就是在计算时根据配对的索引完成元素的运算。如果有一个运算对象缺少该索引，该位置的数据会用 <code>NaN</code> 填充。这是 <var type="module">pandas</var> 表示缺失值的方法，接下来会介绍缺失值的处理方法。</p>

<h2>处理缺失值</h2>

<h3>认识缺失值</h3>

<p>在 Python 中，空值一般用 <code>None</code> 对象表示。它是一个特殊的 Python <code>object</code> 对象 ，由 Python 解释器提供并处理。</p>

<p><code>None</code> 作为一个 Python 对象，并不能兼容任何 <var type="module">numpy</var> 的原生类型。如果在创建数组时包含 <code>None</code> ，那么数组的类型会被强制提升为 <code>object</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">None</span><span style="color: #39adb5;">])</span></div><div>a1</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 1, 3, None], dtype=object)</div>
</div>

<p>然而，使用 <code>object</code> 作为数组类型会严重拖慢计算速度，因为它在底层不但占用更多空间，并且无法通过向量化加速运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">10000</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>np<span style="color: #39adb5;">.</span>int32<span style="color: #39adb5;">)</span></div><div>a3 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">10000</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">object</span><span style="color: #39adb5;">)</span></div><div><span style="color: #7c4dff;">%</span>timeit a2 <span style="color: #7c4dff;">/</span> <span style="color: #f76d47;">2</span></div><div><span style="color: #7c4dff;">%</span>timeit a3 <span style="color: #7c4dff;">/</span> <span style="color: #f76d47;">2</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">9.99 µs ± 51.7 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)
199 µs ± 1.35 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)</div>
</div>

<p>可以看到即便对于简单的除法运算，两者都有 20 倍的速度差异。除此之外，数组中一旦包含 <code>None</code> 值，那么它就无法参与各种运算，因为 Python 并没有实现 <code>None</code> 和其它类型的运算方法。</p>

<p>不过好在 <var type="module">numpy</var> 提供了另一种缺失值：<code>NaN</code> 。它全称 Not a Number ，即非数字，是一种按照 IEEE 754 标准设计的特殊<em>浮点数</em>：（有关 <code>NaN</code> 与浮点数的更多底层设计可以参见<a href="https://en.wikipedia.org/wiki/NaN">维基百科</a>）</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 1., nan,  2.,  3.])</div>
</div>

<p><code>NaN</code> 作为一种浮点数，在大多数编程语言中都可以被处理。浮点类型使得含 <code>NaN</code> 的数组可以使用向量化计算，获得很快的运算速度。</p>

<p><code>NaN</code> 的一个特性是：它与任何数字的运算结果都是它本身。也就是说无论 <code>NaN</code> 参与何种运算，最终结果都是 <code>NaN</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>nan <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">nan</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>nan <span style="color: #7c4dff;">/</span> np<span style="color: #39adb5;">.</span>nan <span style="color: #7c4dff;">*</span> <span style="color: #f76d47;">0</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">nan</div>
</div>

<p>这种特性使得在对含有 <code>NaN</code> 的数组做聚合处理时，虽然不会引起异常，但结果不一定有效：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a5 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div><div>a5<span style="color: #39adb5;">.</span>sum<span style="color: #39adb5;">(),</span> a5<span style="color: #39adb5;">.</span>max<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(nan, nan)</div>
</div>

<p>为此，<var type="module">numpy</var> 提供了一些以 <var>nan</var> 开头的特殊累计函数，它们可以忽略数组中的缺失值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>nansum<span style="color: #39adb5;">(</span>a5<span style="color: #39adb5;">),</span> np<span style="color: #39adb5;">.</span>nanmax<span style="color: #39adb5;">(</span>a5<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(6.0, 3.0)</div>
</div>

<h3>处理缺失值</h3>

<p><code>NaN</code> 虽然不像 <code>None</code> 的问题那么明显，但也容易出现奇怪的问题。接下来看看 <var type="module">pandas</var> 中对 <code>NaN</code> 的处理方式。</p>

<p>考虑到空值 <code>None</code> 的副作用太过明显，<var type="module">pandas</var> 会将空值自动转换为 <code>NaN</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">None</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">])</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
1    NaN
2    NaN
3    1.0
dtype: float64</div>
</div>

<p><code>Series</code> 和 <code>DataFrame</code> 均可以使用 <code>.isnull()</code> 和 <code>.notnull()</code> 方法来发现缺失值，它们像通用函数一样返回布尔数组，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">.</span>isnull<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    False
1     True
2     True
3    False
dtype: bool</div>
</div>

<p>这种布尔数组可以配合数组索引直接修改缺失值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">[</span>s03<span style="color: #39adb5;">.</span>isnull<span style="color: #39adb5;">()]</span> <span style="color: #7c4dff;">=</span> <span style="color: #f76d47;">2</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
1    2.0
2    2.0
3    1.0
dtype: float64</div>
</div>

<p><var type="module">pandas</var> 还提供了两种很好用的缺失值处理方式，分别是 <code>.dropna()</code> 和 <code>.fillna()</code> 方法，分别用于剔除缺失值和填充缺失值。在 <code>Series</code> 上使用这些方法比较易懂：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">.</span>dropna<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
3    1.0
dtype: float64</div>
</div>

<p>更复杂的情况涉及对 <code>DataFrame</code> 的缺失值处理，因为 <code>DataFrame</code> 增删的最小单元是一行或一列。默认情况下，<code>DataFrame.dropna()</code> 会剔除任何包含缺失值的整行数据。可以设置按不同的坐标轴剔除缺失值，比如 <code>axis=1</code>（或 <code>axis='columns'</code> ）会剔除任何包含缺失值的整列数据：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">([[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span>np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">]])</span></div><div>df01<span style="color: #39adb5;">.</span>dropna<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th><th>1</th><th>2</th>
        </tr>
        <tr>
            <td>1</td><td>2.0</td><td>3.0</td><td>5</td>
        </tr>
    </table></div>
</div>

<p>这种做法会把非缺失值一并剔除。有时候可能只需要剔除缺失值较多的行或列，这种需求可以通过以下两个参数来满足：</p>

<ul>
    <li><code><em>how</em></code> 参数的默认值是 <code>'any'</code> ，表示只要有缺失值就剔除整行或整列。还可以传入 <code>'all'</code> ，从而剔除全部是缺失值的行或列</li>
    <li><code><em>thresh</em></code> 参数用于设置需要保留的行或列中非缺失值的最小数量</li>
</ul>

<p>剔除缺失值时只关注特定的列也是一种常见的需求，因为有时 <code>DataFrame</code> 只有部分列会参与运算，而其它列无论是否包含缺失值都想保留下了。这时可以通过向 <code><em>subset</em></code> 参数传入包含列名的列表来指定剔除缺失值时只关注表的哪些部分。</p>

<p>除此之外，<code><em>inplace</em></code> 当然也是 <code>.dropna()</code> 方法具有的参数，说明该方法默认情况下也不修改原有表，而是得到一个剔除缺失值后的副本。</p>

<p><code>.fillna()</code> 方法用于填充缺失值。对于 <code>Series</code> 而言，该方法就是一个简单的替换：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">.</span>fillna<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
1    3.0
2    3.0
3    1.0
dtype: float64</div>
</div>

<p>对于 <code>DataFrame</code> 而言，除了用单个值填充所有的缺失位置外，还可以使用字典为不同列指定不同的填充值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span style="color: #39adb5;">.</span>fillna<span style="color: #39adb5;">({</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">20</span><span style="color: #39adb5;">})</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th><th>1</th><th>2</th>
        </tr>
        <tr>
            <td>0</td><td>1.0</td><td>20.0</td><td>2</td>
        </tr>
        <tr>
            <td>1</td><td>2.0</td><td>3.0</td><td>5</td>
        </tr>
        <tr>
            <td>2</td><td>10.0</td><td>4.0</td><td>6</td>
        </tr>
    </table></div>
</div>

<p><code>.fillna()</code> 方法还有以下两个常用参数：</p>

<ul>
    <li><code><em>method</em></code> ：参数指定填充的方法，例如 <code>"pad"</code> 或 <code>"ffill"</code> 用缺失值前或上面的有效值填充；<code>"bfill"</code> 或 <code>"backfill"</code> 用缺失值后或下面的有效值填充。默认用自定义行为填充</li>
    <li><code><em>limit</em></code> ：填充的最大数量</li>
</ul>

<!-- 可以用适当的对象方法代替运算符，并使用参数 <code><em>fill_value</em></code> 填充缺失的数据后再参与运算。 -->

<h3>可空类型</h3>

<p>最后要说明的是，尽管 <var type="module">pandas</var> 为处理 <code>NaN</code> 提供了很多便利的工具，但是尽可能不要向表中引入 <code>NaN</code> 。因为一旦表中出现一个 <code>NaN</code> ，会使得一列的数据类型都变成浮点数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">int32</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>df02<span style="color: #39adb5;">.</span>iloc<span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>nan</div><div>df02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th><th>1</th><th>2</th><th>3</th>
        </tr>
        <tr>
            <td>0</td><td>0</td><td>1.0</td><td>2</td><td>3</td>
        </tr>
        <tr>
            <td>1</td><td>4</td><td>5.0</td><td>6</td><td>7</td>
        </tr>
        <tr>
            <td>2</td><td>8</td><td>NaN</td><td>10</td><td>11</td>
        </tr>
    </table></div>
</div>

<p>浮点数可能使得表在处理时出现问题。例如，如果一个整型或布尔数组出现了一个浮点数，那么它便无法用于索引。</p>

<p>为此，<var type="module">pandas</var> 提供了一类特别的可空类型，向可空类型中引入空值并不会使 <code>Series</code> 变为浮点数。目前 <var type="module">pandas</var> 具有的可空类型包括各种长度的 <code>Int</code> 和 <code>Float</code> 类型（注意首字母大写）、<code>string</code> 类型和 <code>boolean</code> 类型。</p>

<p>如果在创建 <code>Series</code> 时使用 <code><em>dtype</em></code> 参数指定类型为以上这些可空类型，那么其中的缺失值便会使用特别的缺失值指示器 <code>pd.NA</code> 代替：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s04 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">None</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> pd<span style="color: #39adb5;">.</span>NA<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">],</span> </div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">Int32</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>s04</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0       0
1    &lt;NA&gt;
2    &lt;NA&gt;
3    &lt;NA&gt;
4       1
dtype: Int32</div>
</div>

<p><code>pd.NA</code> 不代表任何实际的值，因此可以用在任何数组中而不会改变其原有类型。例如，如果创建一个类型为 <code>boolean</code> 的可空布尔数组，那么它便可用于索引，并且其中的 <code>pd.NA</code> 会被当做 <code>False</code> 用于索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">s05 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> pd</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">Series</span><span style="color: #39adb5;">([</span><span style="color: #f76d47;">True</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">None</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">nan</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">False</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">boolean</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">[</span>s05<span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    1
dtype: int32</div>
</div>

<p>但截至 pandas 1.5 ，该功能似乎仍然处于实验阶段。</p>
<p><a rel="nofollow" href="/archives/1054">Python数据分析-pandas04:索引与缺失值</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1054/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-pandas03:深入认识索引</title>
		<link>/archives/1048</link>
					<comments>/archives/1048#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 06 Mar 2023 09:35:45 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[pandas]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1048</guid>

					<description><![CDATA[<p>Pandas索引机制 pandas 相比 numpy&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1048">Python数据分析-pandas03:深入认识索引</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>Pandas索引机制</h2>

<p><var type="module">pandas</var> 相比 <var type="module">numpy</var> ，一个很重要的特点就在于它引入了显式的索引机制。显式的索引在方便数据获取的同时，也可能造成学习上的困惑。接下来首先详细介绍 <var type="module">pandas</var> 的索引机制。</p>

<h3>Series与索引</h3>

<p>之前说过，<code>Series</code> 对象可以看作一种字典，它提供了索引与值对的映射，因此可以使用字典一样的方式获取值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">4</span><span token="symbol">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">c</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">])</span></div><div>s01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1</div>
</div>

<p><code>Series</code> 的许多操作都和 Python 字典很像，例如可以通过 item assignment 增加新的索引-值对，这等价于向 <code>Series</code> 添加新的一项：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">e</span><span token="symbol">'</span><span token="symbol">]</span> <span style="color: #7c4dff;">=</span> <span token="number">10</span></div></div>
</div>

<p>这种自定义的索引是显式的，它是真实存在的，因此可以向字典一样获取所有的索引-值对：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #8796b0;">list</span><span token="symbol">(</span>s01<span token="symbol">.</span>items<span token="symbol">())</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 10)]</div>
</div>

<p><code>Series</code> 不仅有着和字典一样的索引操作，还具备和 <var type="module">numpy</var> 数组一样的数组数据选择功能，例如数组索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
d    3
dtype: int32</div>
</div>

<p>这么看来，<code>Series</code> 的索引除了允许自定义外，和 <code>ndarray</code> 的索引好像没什么区别。不过注意，<code>Series</code> 的索引是允许重复的，这可能会导致一次性获取到多个值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s02 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">5</span><span token="symbol">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">])</span></div><div>s02<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
b    2
b    4
dtype: int32</div>
</div>

<p>此外，这种索引在用作切片时，得到的结果将包含后端的值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">:</span><span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
c    2
d    3
dtype: int32</div>
</div>

<p>这样做的好处是不用明白它后一项的索引是什么。但如果索引有重复的话，将不能用于切片操作：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s02<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">:</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">Exception</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span><span style="color: #8796b0;">type</span><span token="symbol">(</span>e<span token="symbol">),</span> e<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'KeyError'> "Cannot get right slice bound for non-unique label: 'b'"</div>
</div>

<p>这种索引机制可能会导致数据获取的不便。但实际上，<code>Series</code> 依然保留了 <var type="module">numpy</var> 数组从零开始、切片时前闭后开的隐式索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="number">1</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="number">1</span><span token="symbol">:</span><span token="number">3</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
c    2
dtype: int32</div>
</div>

<p>这两种索引方式很容易造成混淆，尤其是使用自定义整数作索引时，它可能会覆盖隐式索引，使得某些操作失效：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">4</span><span token="symbol">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">1</span><span token="symbol">,</span> <span token="number">5</span><span token="symbol">))</span></div><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s03<span token="symbol">[</span>s03<span token="symbol">.</span>argmin<span token="symbol">()]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">Exception</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span><span style="color: #8796b0;">type</span><span token="symbol">(</span>e<span token="symbol">),</span> e<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'KeyError'> 0</div>
</div>

<p>因此 <var type="module">pandas</var> 提供了一些<strong>索引器</strong>作为取值的方法，它们是 <code>Series</code> 对象暴露取值与切片接口的属性。</p>

<p>第一种索引器是 <code>.loc</code> 属性，表示用的是自定义、可重复、类型不限、切片时包含两端的显式索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">.</span>loc<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">:</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">a    0
b    1
dtype: int32</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s01<span token="symbol">.</span>loc<span token="symbol">[</span><span token="number">1</span><span token="symbol">]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">KeyError</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span>e<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1</div>
</div>

<p>第二种索引器是 <code>.iloc</code> 属性，表示用的是从 0 开始、切片前闭后开的整数隐式(<span style="font-weight: bold;">i</span>mplicit)索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>iloc<span token="symbol">[</span>s03<span token="symbol">.</span>argmin<span token="symbol">()]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0</div>
</div>

<p>这两种索引器独立工作，不能混用，因此可以各自用于需要的场景中。</p>

<h3>DataFrame与索引</h3>

<p>之前说过 <code>DataFrame</code> 也可以看作一种字典，它提供了列索引与 <code>Series</code> 对的映射，因此可以使用字典一样的方式由列索引获取一个 <code>Series</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>DataFrame<span token="symbol">(</span></div><div>&#160; &#160; <span token="symbol">{</span><span token="symbol">'</span><span style="color: #91b859;">units</span><span token="symbol">'</span><span token="symbol">:</span> <span token="symbol">{</span><span token="symbol">'</span><span style="color: #91b859;">pencil</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">95</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">binder</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">30</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">paperclip</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">81</span><span token="symbol">},</span></div><div>&#160; &#160; &#160;<span token="symbol">'</span><span style="color: #91b859;">unitcost</span><span token="symbol">'</span><span token="symbol">:</span> <span token="symbol">{</span><span token="symbol">'</span><span style="color: #91b859;">pencil</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">1.99</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">binder</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">19.99</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">paperclip</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">4.99</span><span token="symbol">}})</span></div><div>df01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td>
        </tr>
        <tr>
            <td>binder</td><td>30</td><td>19.99</td>
        </tr>
        <tr>
            <td>paperclip</td><td>81</td><td>4.99</td>
        </tr>
    </table></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">unitcost</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">pencil        1.99
binder       19.99
paperclip     4.99
Name: unitcost, dtype: float64</div>
</div>

<p>和前面介绍的 <code>Series</code> 对象一样，也可以用 item assignment 增加一列：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">total</span><span token="symbol">'</span><span token="symbol">]</span> <span style="color: #7c4dff;">=</span> df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">units</span><span token="symbol">'</span><span token="symbol">]</span> <span style="color: #7c4dff;">*</span> df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">unitcost</span><span token="symbol">'</span><span token="symbol">]</span></div><div>df01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th><th>total</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td><td>189.05</td>
        </tr>
        <tr>
            <td>binder</td><td>30</td><td>19.99</td><td>599.70</td>
        </tr>
        <tr>
            <td>paperclip</td><td>81</td><td>4.99</td><td>404.19</td>
        </tr>
    </table></div>
</div>

<p>因此对列索引而言，它和 <code>Series</code> 的索引机制比较像。但是由于 <code>DataFrame</code> 行列都有索引，因此单级的显式索引只能作用于列，否则操作很容易引起歧义。</p>

<p>除此之外，直接对行或列应用隐式索引会引起错误。从概念上来说，对行和列的隐式索引容易存在误解：如果将 <code>DataFrame</code> 看作结构数组，那么一列就代表一个结构成员，列与列之间并没有严格的先后关系，直接取第几列这种操作无法让人明白其意图。而行虽然没有这种误解，但是会产生一个更关键的问题：直接取某一行使得行索引不再被用到而丢弃，返回一个 <code>Series</code> ，但是 <code>Series</code> 要求所有元素的类型一致，而一个结构各成员间往往有着各自各样的类型，强行统一它们的类型会造成类型提升，为后续操作带来更多问题。</p>

<p>一种特殊的情况是切片。切片将会保留行索引，得到的仍然是一个 <code>DataFrame</code> 。如果切片涉及的范围只有一行，那么就基本等价于获取 <code>DataFrame</code> 的某一行（虽然得到的仍然是一个二维数组）：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">[</span><span token="number">0</span><span token="symbol">:</span><span token="number">1</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th><th>total</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td><td>189.05</td>
        </tr>
    </table></div>
</div>

<p>因此，除了对列应用显式索引外，其它形式的索引不仅应该使用索引器，而且应该使用 <var type="module">numpy</var> 高维数组的索引方式。</p>

<p>例如，以下使用隐式索引器获取 <code>DataFrame</code> 的元素。这里在代表取值的方括号内传入了一个元组，第一个元素指代行的隐式索引，第二个元素指代列的隐式索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">.</span>iloc<span token="symbol">[</span><span token="number">2</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">4.99</div>
</div>

<p>根据隐式索引的规则，获取的应该是第 3 行第 2 列位置的元素。</p>

<p>再如，以下使用显式索引器得到指定几行的元素。这里对行应用数组索引，对列使用单个冒号 <code>:</code> 表示全部切片：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">.</span>loc<span token="symbol">[[</span><span token="symbol">'</span><span style="color: #91b859;">pencil</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">paperclip</span><span token="symbol">'</span><span token="symbol">],</span> <span token="symbol">:]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th><th>total</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td><td>189.05</td>
        </tr>
        <tr>
            <td>paperclip</td><td>81</td><td>4.99</td><td>404.19</td>
        </tr>
    </table></div>
</div>

<p>最后，下图总结了 <code>DataFrame</code> 的索引：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/03/09-dataframe-indexes.png" alt="" width="520">
</figure>

<h2>层级索引</h2>

<h3>层级索引的概念</h3>

通过之前的介绍可以认识到，<code>DataFrame</code> 是一种二维的结构。但有些时候，处理的数据可能不止两个维度。例如，在操作 Excel 时，经常可以看到这样的表格：

<table>
    <tr>
        <th></th><th></th>
        <th colspan="2">2021</th><th colspan="2">2022</th>
    </tr>
    <tr>
        <th></th><th></th>
        <th>mid term</th><th>end of term</th>
        <th>mid term</th><th>end of term</th>
    </tr>
    <tr>
        <td rowspan="3">grade 1</td>
        <td>class 1</td>
        <td>86</td><td>88</td>
        <td>89</td><td>90</td>
    </tr>
    <tr>
        <td>class 2</td>
        <td>88</td><td>87</td>
        <td>91</td><td>89</td>
    </tr>
    <tr>
        <td>class 3</td>
        <td>84</td><td>86</td>
        <td>86</td><td>85</td>
    </tr>
    <tr>
        <td rowspan="3">grade 2</td>
        <td>class 1</td>
        <td>86</td><td>94</td>
        <td>90</td><td>91</td>
    </tr>
    <tr>
        <td>class 2</td>
        <td>85</td><td>84</td>
        <td>87</td><td>91</td>
    </tr>
    <tr>
        <td>class 3</td>
        <td>87</td><td>91</td>
        <td>90</td><td>90</td>
    </tr>
</table>

<p>这种数据可以从四个维度聚合：对列来说，可以得出每个年度的得分平均值，也可以得出历年期中和期末的得分平均值；对行也是同理。只凭借二维数据无法实现这样的关系，这时就需要使用层级索引。层级索引可以从多个角度来描述数据的分组。</p>

<p><var type="module">pandas</var> 中的索引类型不仅限于数值和字符串，甚至还能使用元组，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01 <span style="color: #7c4dff;">=</span> <span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">3</span><span token="symbol">),</span></div><div>&#160; &#160; &#160; &#160;<span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">3</span><span token="symbol">)]</span></div><div>s03 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">([</span><span token="number">1341</span><span token="symbol">,</span> <span token="number">1412</span><span token="symbol">,</span> <span token="number">1263</span><span token="symbol">,</span> <span token="number">643</span><span token="symbol">,</span> <span token="number">632</span><span token="symbol">,</span> <span token="number">685</span><span token="symbol">],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>i01<span token="symbol">)</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(A, 1)    1341
(A, 2)    1412
(A, 3)    1263
(B, 1)     643
(B, 2)     632
(B, 3)     685
dtype: int64</div>
</div>

<p>元组表示存储了多个值，是多级索引的基础。<var type="module">pandas</var> 的 <code>MultiIndex</code> 类提供了更丰富的操作方法。可以用它的类方法从元组创建一个多级索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i02 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_tuples<span token="symbol">(</span>i01<span token="symbol">,</span> <span style="color: #e53935;">names</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">class</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">group</span><span token="symbol">'</span><span token="symbol">])</span></div></div>
</div>

<p>通过 <code><em>names</em></code> 参数可以为这两个层级指定名称，方面区分各索引层。层级名称会保存到索引对象的 <code>.names</code> 属性中。</p>

<p>如果将前面创建的 <code>Series</code> 对象使用 <code>.reindex()</code> 方法将它的索引重置为 <code>MultiIndex</code> 对象，就会看到一个层级索引结构：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> s03<span token="symbol">.</span>reindex<span token="symbol">(</span><span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>i02<span token="symbol">)</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">class  group
A      1        1341
       2        1412
       3        1263
B      1         643
       2         632
       3         685
dtype: int64</div>
</div>

<p>关于层级索引，需要记住的是：层级索引可以看作一个元素对应多个索引，或者说一个索引元组。如果检查层级索引的 <code>.values</code> 属性，会发现每个索引都使用多个值来描述：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>index<span token="symbol">.</span>values</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([('A', 1), ('A', 2), ('A', 3), ('B', 1), ('B', 2), ('B', 3)],
      dtype=object)</div>
</div>

<p>因此在获取元素的时候，也需要通过多个值，或者说一个元组来获取：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1412</div>
</div>

<p>多个值或一个元组构成的索引也可以用于切片。除了索引由一个值变成一个元组外，均遵循一维 <code>Series</code> 的切片规则，例如可以使用显式索引器 <code>.loc</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">):(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">class  group
A      2        1412
       3        1263
B      1         643
dtype: int64</div>
</div>

<p>显式索引器使切片包含两端的元素。返回检查层级索引的 <code>.values</code> 属性可以发现，包含两端的元素确实是 3 个。</p>

<p>这里需要注意，如果层级索引不是有序的，那么大多数切片操作都会失败。以下演示一种会导致错误的操作：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>rand <span style="color: #7c4dff;">=</span> np<span token="symbol">.</span>random<span token="symbol">.</span>RandomState<span token="symbol">(</span><span token="number">3</span><span token="symbol">)</span></div><div>s04 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>rand<span token="symbol">.</span>rand<span token="symbol">(</span><span token="number">6</span><span token="symbol">),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_product<span token="symbol">([[</span><span token="symbol">'</span><span style="color: #91b859;">C</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="symbol">[</span><span token="number">1</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">]]))</span></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s04<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">C</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">):(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">)]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">Exception</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span><span style="color: #8796b0;">type</span><span token="symbol">(</span>e<span token="symbol">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'pandas.errors.UnsortedIndexError'></div>
</div>

<p>问题出在切片和许多其它相似的操作都要求 <code>MultiIndex</code> 的各级索引是有序的。为此，<var type="module">pandas</var> 提供了一些操作可以实现对索引的排序，最简单的方法是 <code>.sort_index()</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s04<span token="symbol">.</span>sort_index<span token="symbol">(</span><span style="color: #e53935;">inplace</span><span style="color: #7c4dff;">=</span><span token="number">True</span><span token="symbol">)</span></div><div>s04<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">):(</span><span token="symbol">'</span><span style="color: #91b859;">C</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">B  2    0.510828
C  1    0.550798
   2    0.708148
dtype: float64</div>
</div>

<p>经过索引排序后的切片结果就正常了。这里再次使用 <code><em>inplace</em></code> 参数来提醒默认情况下排序后得到的是一个新的对象，而不是在原有对象的基础上做修改。</p>

<p>层级索引相比普通的索引，索引类型由一个值变为多个值（或者说一个元组）。这看似多此一举，但是它允许从不同层面来处理一维的数据。如果访问层级索引的 <code>.level</code> 属性，可以得到：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>index<span token="symbol">.</span>levels</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">FrozenList([['A', 'B'], [1, 2, 3]])</div>
</div>

<p>这说明该层级索引有两层：从索引的角度看，第一层有 2 种不同的索引，第二层有 3 种不同的索引；从数据的角度看，根据第一层索引可以将数据分为 2 类，根据第二层可以将数据分为 3 类。因此数据在聚合、变换时，可以根据不同的索引层级，从不同的<em>角度</em>处理。例如，对于以上具有层级索引的 <code>Series</code> ，可以统计每个 <code>"class"</code> 的数值平均值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>sum<span token="symbol">(</span><span style="color: #e53935;">level</span><span style="color: #7c4dff;">=</span><span token="symbol">'</span><span style="color: #91b859;">class</span><span token="symbol">'</span><span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">class
A    4016
B    1960
dtype: int64</div>
</div>

<p>新版本的 <var type="module">pandas</var> 可能已经弃用了这种使用方式，或者抛出 <code>FutureWarning</code> ，提示说应该使用对表作分组计算后再合并，这就是以后介绍的内容了。</p>

<p>具有层级索引的 <code>Series</code> 很像一个 <code>DataFrame</code> 。事实上，使用对象的 <code>.unstack()</code> 方法可以将一个多级索引的 <code>Series</code> 转化为普通索引的 <code>DataFrame</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>unstack<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>group</th><th>1</th><th>2</th><th>3</th>
        </tr>
        <tr>
            <td>class</td><td></td><td></td><td></td>
        </tr>
        <tr>
            <td>A</td><td>1341</td><td>1412</td><td>1263</td>
        </tr>
        <tr>
            <td>B</td><td>643</td><td>632</td><td>685</td>
        </tr>
    </table></div>
</div>

<p>或者使用 <code>.stack()</code> 方法实现相反的效果，将一个 <code>DataFrame</code> 变成具有多级索引的 <code>Series</code> 。 既然可以用含多级索引的一维 <code>Series</code> 数据表示二维数据，那么就可以用 <code>Series</code> 或 <code>DataFrame</code> 表示三维甚至更高维度的数据。借助多级索引，可以使三维及以上的数据以一种较为易读的形式表示出来。层级索引每增加一层，就表示数据增加一维，使得 <code>DataFrame</code> 可以表示任意维度的数据。因此 <var type="module">pandas</var> 并没有提供三维及以上的数量类型。</p>

<h3>DataFrame与层级索引</h3>

<p>在 <code>DataFrame</code> 使用层级索引和在 <code>Series</code> 上使用层级索引是一致的，只不过列索引和行索引都可以设置为层级索引。</p>

<p>以下创建一个较为复杂的、行列都具有两级索引的 <code>DataFrame</code> 用于演示：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>DataFrame<span token="symbol">(</span>rand<span token="symbol">.</span>randint<span token="symbol">(</span><span token="number">50</span><span token="symbol">,</span> <span token="number">95</span><span token="symbol">,</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span token="symbol">(</span><span token="number">4</span><span token="symbol">,</span> <span token="number">6</span><span token="symbol">)),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_product<span token="symbol">([[</span><span token="number">2020</span><span token="symbol">,</span> <span token="number">2021</span><span token="symbol">],</span> <span token="symbol">[</span><span token="number">1</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">]],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span style="color: #e53935;">names</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">year</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">term</span><span token="symbol">'</span><span token="symbol">]),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span>pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_product<span token="symbol">([[</span><span token="symbol">'</span><span style="color: #91b859;">Tim</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">Mary</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">John</span><span token="symbol">'</span><span token="symbol">],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">physics</span><span token="symbol">'</span><span token="symbol">]],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span style="color: #e53935;">names</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">name</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">subject</span><span token="symbol">'</span><span token="symbol">])</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="symbol">)</span></div><div>df03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>name</th><th colspan="2">Tim</th><th colspan="2">Mary</th><th colspan="2">John</th>
        </tr>
        <tr>
            <th></th><th>subject</th><th>math</th><th>physics</th><th>math</th><th>physics</th><th>math</th><th>physics</th>
        </tr>
        <tr>
            <th>year</th><th>term</th><td></td><td></td><td></td><td></td><td></td><td></td>
        </tr>
        <tr>
            <td rowspan="2">2020</td><td>1</td><td>92</td><td>74</td><td>53</td><td>58</td><td>50</td><td>71</td>
        </tr>
        <tr>
            <td>2</td><td>69</td><td>60</td><td>93</td><td>91</td><td>60</td><td>71</td>
        </tr>
        <tr>
            <td rowspan="2">2021</td><td>1</td><td>88</td><td>82</td><td>70</td><td>94</td><td>79</td><td>89</td>
        </tr>
        <tr>
            <td>2</td><td>64</td><td>76</td><td>67</td><td>76</td><td>72</td><td>52</td>
        </tr>
    </table></div>
</div>

<p>对 <code>DataFrame</code> 索引和 <code>Series</code> 基本一致，需要通过元组形式的索引来获取一个 <code>Series</code> ，并会保留行的层级索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">John</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">year  term
2020  1       50
      2       60
2021  1       79
      2       72
Name: (John, math), dtype: int32</div>
</div>

<p>索引器和切片的用法都是一致的：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="number">2020</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">):(</span><span token="number">2020</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">),</span> <span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">John</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">Mary</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">)]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>name</th><th>John</th><th>Mary</th>
        </tr>
        <tr>
            <th>subject</th><th>math</th><th>math</th>
        </tr>
        <tr>
            <th>year</th><th>term</th><th></th><td></td>
        </tr>
        <tr>
            <td>2020</td><td>1</td><td>50</td><td>53</td><td></td>
        </tr>
        <tr>
            <td></td><td>2</td><td>60</td><td>93</td>
        </tr>
    </table></div>
</div>

<p>不过这种索引元组的用法不是很方便，因为这个 <code>DataFrame</code> 实际上可以看作四维数据，但是只能在两个维度上切片。如果想获取所有人在第 1 学期的数学成绩，那么可能需要这样的索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03<span token="symbol">.</span>loc<span token="symbol">[(:,</span> <span token="number">1</span><span token="symbol">),</span> <span token="symbol">(:,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">  Cell In [35], line 1
        df03.loc[(:, 1), (:, 'math')]
                  ^
<span style="color: red;">SyntaxError</span>: invalid syntax</div>
</div>

<p>这是错误的用法，它会直接导致解释出错。为此，<var type="module">pandas</var> 提供了 <code>IndexSlice</code> 对象，专门用来解决高维 <code>DataFrame</code> 的切片问题，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>Idx <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>IndexSlice</div><div>df03<span token="symbol">.</span>loc<span token="symbol">[</span>Idx<span token="symbol">[:,</span> <span token="number">1</span><span token="symbol">],</span> Idx<span token="symbol">[:,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>name</th><th>Tim</th><th>Mary</th><th>John</th>
        </tr>
        <tr>
            <th></th><th>subject</th><th>math</th><th>math</th><th>math</th>
        </tr>
        <tr>
            <td>year</td><td>term</td><td></td><td></td><td></td>
        </tr>
        <tr>
            <td>2020</td><td>1</td><td>92</td><td>53</td><td>50</td>
        </tr>
        <tr>
            <td>2021</td><td>1</td><td>88</td><td>70</td><td>79</td>
        </tr>
    </table></div>
</div>

<p>下图总结了 <code>DataFrame</code> 的层级索引：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/03/09-dataframe-multi-indexes.png" alt="" width="720">
</figure>
<p><a rel="nofollow" href="/archives/1048">Python数据分析-pandas03:深入认识索引</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1048/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-pandas01:基本数据类型</title>
		<link>/archives/1041</link>
					<comments>/archives/1041#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 27 Feb 2023 07:03:43 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[pandas]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1041</guid>

					<description><![CDATA[<p>Pandas简介 之前详细介绍了 NumPy 和它的&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1041">Python数据分析-pandas01:基本数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>Pandas简介</h2>

<p><a href="/all/data-science">之前</a>详细介绍了 <var type="module">NumPy</var> 和它的 <code>ndarray</code> 多维数组对象，为 Python 多维数组提供了高效的存储和处理方法。</p>

<p>本章基于前面的知识，继续学习 <a href="https://pandas.pydata.org/">Pandas</a> 库提供的数据操作方法。<code>Pandas</code> 是在 <code>NumPy</code> 基础上建立的另一个第三方库，提供了一种高效的 <code>DataFrame</code> 数据结构。<code>DataFrame</code> 本质上是一种带行标签和列标签、支持相同类型数据和缺失值的多维数组。<code>Pandas</code> 不仅为带各种标签的数据提供了便利的存储与展示接口，还实现了许多强大的计算、查找和分类等操作。</p>

<p><var type="module">pandas</var> 在底层存储时使用的是 <var type="module">numpy</var> 的数组，因此在安装 <var type="module">pandas</var> 之前，需要确保已经安装了 <var type="module">numpy</var> 。</p>

<p>在安装完成 <code>pandas</code> 之后，可以导入它检查一下版本号：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">import</span> pandas</div><div>pandas.__version__</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">'1.3.1'</div>
</div>

<p>和之前导入 <var type="module">numpy</var> 并使用别名 <code>np</code> 一样，之后将导入 <var type="module">pandas</var> 并使用别名 <code>pd</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">import</span> pandas <span style="color: #f76d47;">as</span> pd</div></div>
</div>

<h2>Pandas的数据对象</h2>

<h3>Series对象</h3>

<p><var type="module">pandas</var> 最简单的数据类型是 <code>Series</code> 。<code>Series</code> 对象是一个带索引数据构成的一维数组。可以用一个数组创建 <code>Series</code> 对象，如下所示：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">])</span></div><div>s01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    1
1    2
2    3
3    4
dtype: int64</div>
</div>

<p><code>Series</code> 对象将一组数据和一组索引绑定在一起，可以通过 <code>.values</code> 属性获取数据，通过 <code>.index</code> 属性获取索引。<code>.values</code> 属性返回的结果就是底层的 <var type="module">numpy</var> 数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">.</span>values</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([1, 2, 3, 4], dtype=int64)</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #6182b8;">isinstance</span><span style="color: #39adb5;">(</span>s01<span style="color: #39adb5;">.</span>values<span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>ndarray<span style="color: #39adb5;">)</span></div></div>    
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">True</div>
</div>

<p><code>.index</code> 属性返回的结果是一个类型为 <code>Index</code> 的索引对象。索引是 <var type="module">pandas</var> 的特点之一，将在后面的内容里详细介绍它。</p>

<p>和 <var type="module">numpy</var> 数组一样，可以通过中括号实现索引或切片：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">3</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1    2
2    3
3    4
dtype: int64</div>
</div>

<p>这么看来，<var type="module">pandas</var> 的 <code>Series</code> 与 <var type="module">numpy</var> 的一维数组很类似。但 <code>Series</code> 为数组提供了一种更加强大的索引系统：<var type="module">numpy</var> 数组通过隐式定义的整数索引获取数值，而 <var type="module">pandas</var> 的 <code>Series</code> 对象用可以手动指定索引与数值关联。</p>

<p>显式索引的定义让 <code>Series</code> 拥有了更好的可读性。例如，索引不再仅仅是整数，还可以是任意想要的类型。如果需要，完全可以用字符串定义索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0.25</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">0.5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">0.75</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1.0</span><span style="color: #39adb5;">],</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">b</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">c</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">d</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">])</span></div><div>s02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">a    0.25
b    0.50
c    0.75
d    1.00
dtype: float64</div>
</div>

<p>在使用索引访问元素时，可以通过之前定义的字符索引获取数值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">b</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.5</div>
</div>

<p>这种数值的访问形式很像 Python 字典，可以将每个索引作为键映射到一个值。因此可以直接使用 Python 的字典创建一个 <code>Series</code> 对象，让两者的类比更加清晰：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">({</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">key1</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">key2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">keyi</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">keyn</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">10</span></div><div><span style="color: #39adb5;">})</span></div></div>
</div>

<p>由于 Python3.6+ 的字典是有序的，因此创建的 <code>Series</code> 对象索引也默认按照顺序排列。</p>

<p>除了可以使用像字典一样按键获取数值外，<code>Series</code> 的索引还可以用于切片操作：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">key2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">keyn</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">key2     2
keyi     5
keyn    10
dtype: int64</div>
</div>

<p>这种切片是包括终点位置的元素的，这和普通的索引形式不同。后续会详细介绍这种索引规则。</p>

<h3>DataFrame对象</h3>

<p><var type="module">pandas</var> 的另一个基础数据结构是 <code>DataFrame</code> 。<code>DataFrame</code> 可以看作是一种二维数组，但它既有行索引，又有列索引，因此它经常被当做一个表格使用。注意，<code>DataFrame</code> 是 <var type="module">pandas</var> 的非常重要的一个数据类型，因为它可以很好地表达日常生活中处理的各种表格结构。<code>DataFrame</code> 与 Excel 中表格或 SQL 中表的概念非常相似，可以实现大多数 Excel 或 SQL 的表操作。</p>

<p><code>DataFrame</code> 有许多创建方式，每种创建方式都代表着对它的理解。例如，和 <code>Series</code> 对象一样，<code>DataFrame</code> 可以看作一个更灵活的 <var type="module">numpy</var> 二维数组。因此可以直接使用二维数据创建 <code>DataFrame</code> ，只要手动指定符合形状的行列索引即可：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">)),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">A</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">B</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">C</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">])</span></div><div>df01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>A</th><th>B</th><th>C</th><th>D</th>
        </tr>
        <tr>
            <td>1</td><td>0</td><td>1</td><td>2</td><td>3</td>
        </tr>
        <tr>
            <td>2</td><td>4</td><td>5</td><td>6</td><td>7</td>
        </tr>
        <tr>
            <td>3</td><td>8</td><td>9</td><td>10</td><td>11</td>
        </tr>
    </table></div>
</div>

<p>也可以把 <code>DataFrame</code> 看成是一种结构数组，每行表示一个结构元素，行索引表示每个结构元素的索引，列索引则表示的是结构的字段名。因此，当然可以使用 <var type="module">numpy</var> 的结构数组来创建 <code>DataFrame</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">A</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">i8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">),</span> <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">B</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">f8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)]))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>A</th><th>B</th>
        </tr>
        <tr>
            <td>0</td><td>0</td><td>0.0</td>
        </tr>
        <tr>
            <td>1</td><td>0</td><td>0.0</td>
        </tr>
        <tr>
            <td>2</td><td>0</td><td>0.0</td>
        </tr>
    </table></div>
</div>

<p>结构数组的表述便于理解，但实际上可能会带来一些误解。例如，<code>DataFrame</code> 的索引和 <var type="module">numpy</var> 的二维数组索引不太一样：在 <var type="module">numpy</var> 的二维数组里，<code>arr[0]</code> 被认为是一个嵌套数组返回包含的第一个子数组；而在 <var type="module">pandas</var> 中，第一层索引得到的结果是一个列的数据：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">A</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1    0
2    4
3    8
Name: A, dtype: int32</div>
</div>

<p>对 <code>DataFrame</code> 一种更好的理解方式是看作一个数组字典，每一个索引都可以看作是字典的一个键，对应一个列的数据；这些数据是一系列同种类型的数值，或者说一个 <code>Series</code> 。也就是说，<code>DataFrame</code> 是具有共同索引的若干 <code>Series</code> 对象组合。</p>

<p>因此，使用单个 <code>Series</code> 创建的是一个单列的 <code>DataFrame</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">bread</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">279</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">biscuit</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">78</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">strawberry</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">26</span><span style="color: #39adb5;">}))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th>
        </tr>
        <tr>
            <td>bread</td><td>279</td>
        </tr>
        <tr>
            <td>biscuit</td><td>78</td>
        </tr>
        <tr>
            <td>strawberry</td><td>26</td>
        </tr>
    </table></div>
</div>

<p>如果能接受这种 <code>DataFrame</code> 的理解方式，不仅容易记住它的创建方式，也有助于明白对它的操作会得到什么样的结果。</p>

<p>创建 <code>DataFrame</code> 的方式非常丰富，只要能表达出这种二维的 <span class="code-font">{column: series}</span> 的映射关系基本都可以用于创建它。例如，可以使用一组具有<em>相同索引</em>的 <code>Series</code> 对象创建它；由于 <code>Series</code> 可以被看作特殊的字典，因此也可以使用一个二维字典来创建一个 <code>DataFrame</code> 对象：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>price <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">cake</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">23</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">cookie</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">bread</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">}</span></div><div>sales <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">cake</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">cookie</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">14</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">bread</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">23</span><span style="color: #39adb5;">}</span></div><div>df02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">({</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">price</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> price<span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">sales</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> sales<span style="color: #39adb5;">})</span></div><div>df02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>price</th><th>sales</th>
        </tr>
        <tr>
            <td>cake</td><td>23</td><td>5</td>
        </tr>
        <tr>
            <td>cookie</td><td>6</td><td>14</td>
        </tr>
        <tr>
            <td>bread</td><td>10</td><td>23</td>
        </tr>
    </table></div>
</div>

<p>如果明白“<code>DataFrame</code> 是一组具有<em>相同索引</em>的 <code>Series</code> 对象组合”，就会知道字典的嵌套与被嵌套的关系：内层的字典应该要具有相同的键。</p>

<p>如果能理解这种嵌套关系，那么就可以很自然地明白数据获取方式：第一次索引将以列索引值为键，得到一个列作为字典；第二次索引将以行索引值为键，从得到字典中获取相应的元素：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">price</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">cookie</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">6</div>
</div>

<p>和 Python 字典一样，<code>Series</code> 和 <code>DataFrame</code> 还支持 item assignment ，对 <code>Series</code> 的操作结果是更新项或添加项，对 <code>DataFrame</code> 的操作结果是更新列或添加列：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">sum</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">price</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">*</span> df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">sales</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div><div>df02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>price</th><th>sales</th><th>sum</th>
        </tr>
        <tr>
            <td>cake</td><td>23</td><td>5</td><td>115</td>
        </tr>
        <tr>
            <td>cookie</td><td>6</td><td>14</td><td>84</td>
        </tr>
        <tr>
            <td>bread</td><td>10</td><td>23</td><td>230</td>
        </tr>
    </table></div>
</div>

<h3>Index对象</h3>

<p><var type="module">pandas</var> 的 <code>Index</code> 对象是构成 <code>Series</code> 和 <code>DataFrame</code> 显式索引的基础。</p>

<p><code>Series</code> 是一维的数据，因此需要一个 <code>Index</code> 对象用于获取数据，这个对象被保存在它的 <code>.index</code> 属性中。而二维的 <code>DataFrame</code> 需要两个 <code>Index</code> 对象来定位数据，它们分别是代表行的 <code>.index</code> 属性和代表列的 <code>.columns</code> 属性：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">.</span>index</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Index(['cake', 'cookie', 'bread'], dtype='object')</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">.</span>columns</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Index(['price', 'sales'], dtype='object')</div>
</div>

<p><code>Index</code> 对象可以看作是一个不可变数组，因此可以像创建数组一样创建 <code>Index</code> 对象：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Index<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">])</span></div><div>i01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 3, 5, 6, 7], dtype='int64')</div>
</div>

<p>除了没有那么丰富的创建方法外，<code>Index</code> 对象的许多属性与操作都像数组，例如索引与切片：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01<span style="color: #39adb5;">[[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">]]</span> &#160;<span style="color: #a8a8a8;"># array indexing</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 3, 5], dtype='int64')</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01<span style="color: #39adb5;">[:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 5], dtype='int64')</div>
</div>

<p>两者之间的不同在于 <code>Index</code> 对象是不可变的，这种特征使得多个 <code>DataFrame</code> 等类型之间共享索引时更加安全，可以避免修改索引而破坏表的结构。</p>

<p>一种对 <code>Index</code> 更精确的描述是<em>有序集合</em>。<var type="module">pandas</var> 对象被设计用于实现许多操作，如合并数据集，这就要求相同列之间需要合并。<code>Index</code> 对象遵循 Python 标准库的集合 <code>set</code> 数据结构的许多习惯用法，包括并集、交集、差集等：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Index<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">9</span><span style="color: #39adb5;">])</span></div><div>i03 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Index<span style="color: #39adb5;">([</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">11</span><span style="color: #39adb5;">])</span></div><div>i02 <span style="color: #7c4dff;">&amp;</span> i03 &#160;<span style="color: #a8a8a8;"># intersection</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([3, 5, 7], dtype='int64')</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i02<span style="color: #39adb5;">.</span>union<span style="color: #39adb5;">(</span>i03<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 2, 3, 5, 7, 9, 11], dtype='int64')</div>
</div>

<p>高版本的 <var type="module">pandas</var> 可能已经弃用了运算符重载的形式，或对其抛出警告，因此一般更推荐直接调用对象的方法实现这些运算。</p>
<p><a rel="nofollow" href="/archives/1041">Python数据分析-pandas01:基本数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1041/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Jupyter Notebook 入门指南</title>
		<link>/archives/823</link>
					<comments>/archives/823#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sun, 23 Oct 2022 09:45:16 +0000</pubDate>
				<category><![CDATA[数据科学]]></category>
		<category><![CDATA[IPython]]></category>
		<category><![CDATA[Jupyter]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=823</guid>

					<description><![CDATA[<p>使用IPython IPython简介 有时候仅需要&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/823">Jupyter Notebook 入门指南</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>使用IPython</h2>

<h3>IPython简介</h3>

<p>有时候仅需要通过几行 Python 代码来执行一些简单的功能，或测试某个库的基本使用方式。此时专门再编写一个脚本运行不免有些麻烦。好在 Python 提供了一个命令行的交互式控制台，可以立即执行输入的每一条语句并暂时保存变量。例如；</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/python-console-demo.png" alt="" width="530">
</figure>

<p>交互式控制台的特点在于其的交互功能，它可以直接查看变量的值，这样就避免了在简单的脚本中大量使用 <code>print()</code> 。</p>

<p>然而，Python 自带的交互式控制台功能过于薄弱。它没有语法高亮，没有自动补全，并且对缩进的处理也不够自然。如果代码较多，那么不但编写容易出错，而且难以阅读。</p>

<p>因此许多项目都尝试增强原有交互式控制台的功能。<a href="https://www.bpython-interpreter.org/">bpython</a> 就是其中之一，bpython 在原有控制台的功能的基础上，提供了代码高亮、自动补全、括号匹配、缩进处理等功能，大大优化了交互体验。以下是 bpython 的简单交互效果：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/bpython-demo.jpg" alt="" width="500">
</figure>

<p>bpython 可以通过命令行快速安装，但它目前只支持 Linux 系统。</p>

<p><a href="https://ipython.org/">IPython</a> 则是一个更加强大的改进版交互式控制台，它不但支持代码高亮、自动补全等功能，还实现了跨平台以及更加丰富的扩展功能。以下是 IPython 的效果演示：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/ipython-demo.jpg" alt="" width="380">
</figure>

<p>从截图中可以看到，IPython 还具有以下功能：</p>

<p>IPython 使用一个个单元格(cell)来对输入及输出编号，相比原先 Python 的提示符更加清晰。</p>

<p>单元格及其编号也为获取历史记录提供了一些便利。在 Python 的交互式控制台中都有一个特殊变量单下划线 <code>_</code> ，它保存着上次访问的对象信息，而 IPython 则具有更多这样的特殊变量，例如：</p>

<ul>
    <li><code>_i4</code> 用于获取 <var>In[4]</var> 单元的代码</li>
</ul>

<div class="codeblock code-console"><span class="ipython-in">In [6]:</span> _i4
<span class="ipython-out">Out[6]</span>: 'for i in range(2, 8):\n    d.append(log(i))\n    '
</div>

<ul>
    <li>两个下划线 <code>__</code> 用于获取上上次访问的对象信息：</li>
</ul>

<div class="codeblock code-console"><span class="ipython-in">In [7]:</span> __
<span class="ipython-in">Out[7]:</span>
[0.6931471805599453,
 1.0986122886681098,
 1.3862943611198906,
 1.6094379124341003,
 1.791759469228055,
 1.9459101490553132]
</div>

<p>这样的特殊变量还有很多。并且从返回的结果来看，IPython 还提供了更加美观的打印效果：列表、字典等会换行对齐展示，更易于阅读。IPython 也对其它常见的输出做了一定优化，使其更便于展示。</p>

<p>在 2 号单元格内，执行了以下命令：</p>

<div class="codeblock code-console"><span class="ipython-in">In [2]:</span> log?
</div>

<p>这不是标准的 Python 语法，而是 IPython 的扩展语法，在某个函数或类后面添加一个问号可以显示其文档字符串。IPython 提供了更丰富的扩展语法，使得某些基础的功能可以通过简单的命令实现。再如，IPython 将一些简单的命令行功能整合进了扩展语法中：</p>

<div class="codeblock code-console"><span class="ipython-in">In [1]:</span> cd project/
E:\workspace\ai\project
</div>

<p>IPython 通过 <code>pip</code> 就可以安装。接下来介绍 IPython 更多类似这样的扩展语法。</p>

<h3>IPython的高级功能</h3>

<h4>提示与帮助</h4>

<p>前文介绍了 IPython 可以在函数或类后面加上一个问号获取它的文档帮助。实际上，对于任意的对象都可以用此方法查看它的基本信息：</p>

<div class="codeblock code-console"><span class="ipython-in">In [2]:</span> l?
Type:        list
String form: [1, 2, 3]
Length:      3
Docstring:   ...
</div>

<p>除此之外，还可以通过两个问号 <code>??</code> 来获取函数的源代码：</p>

<div class="codeblock code-console"><span class="ipython-in">In [3]:</span> average??
Signature: average(a)
Source:
def average(a):
    """Returns the average of some numbers"""
    return sum(a) / len(a)
File:      e:\workspace\ai\project\&lt;ipython-input-5-96774c320447>
Type:      function
</div>

<p>当然，如果源代码不是使用 Python 编写的，那么就只能获取到一些基本信息了。</p>

<p>单个问号还可以配合通配符检查命名空间中所有匹配的成员：</p>

<div class="codeblock code-console">In [16]: os.*dir?
os.chdir
os.curdir
os.listdir
... 
</div>

<p>IPython 还提供了强大的自动补全功能。在访问模块或类的成员时，可以通过 <kbd>TAB</kbd> 键获取其包含的成员提示：</p>

<div class="codeblock code-console"><span class="ipython-in">In [4]:</span> import urllib.r
                       <span class="ipython-hint"> request     </span>
                       <span class="ipython-hint"> response    </span>
                       <span class="ipython-hint"> robotparser </span>  
</div>

<h4>shell交互</h4>

<p>IPython 还可以直接与命令行交互，使用 <code>!</code> 符号作为前缀可以执行命令行命令：</p>

<div class="codeblock code-console"><span class="ipython-in">In [5]:</span> !echo ${PATH}
/usr/local/sbin:...
</div>

<p>注意，在 Windows 系统上默认调用的是 DOS 而不是 PowerShell 命令，即使 IPython 是通过 PowerShell 启动的。</p>

<p>该命令甚至还能作为一个值赋给变量：</p>

<div class="codeblock code-console"><span class="ipython-in">In [6]:</span> files = !ls

<span class="ipython-in">In [7]:</span> files
<span class="ipython-out">Out[7]:</span> ['user123', 'user01', 'user3', 'image']
</div>

<p>这个结果有点类似列表，但它实际上是 IPython 提供的一种增强版列表，它提供了更多操作方法，例如使用函数或正则字符串筛选合适元素：</p>

<div class="codeblock code-console"><span class="ipython-in">In [7]:</span> files.grep(r'user\d+')
<span class="ipython-out">Out[7]:</span> ['user123', 'user01', 'user3']
</div>

<p>也可以实现相反方向的交互，通过 <code>{<em>var</em>}</code> 将 Python 变量传入 shell ：</p>

<div class="codeblock code-console"><span class="ipython-in">In [8]:</span> for i in range(1, 5):
  ....:     !mkdir group{i}
</div>

<h4>魔法命令</h4>

<p>IPython 中的一个更强大的功能是魔法命令(magic command)，魔法命令可以用一种简洁的形式解决各种常见问题。</p>

<p>魔法命令以 <code>%</code> 符号作为前缀，如果要让魔法命令作用于整个单元，那么以两个 <code>%%</code> 作为前缀。魔法命令是一个很复杂的系统，接下来只介绍各种常用的魔法命令。</p>

<p><code>%run <em>file</em></code> 是一个很常用的魔法命令，它可以执行某一个 Python 脚本，在执行完后由 IPython 接管环境。这在 Debug 的时候很好用，当抛出异常时可以自动切换到 IPython 环境，此时可以使用 IPython 检查异常位置一些变量的值，或者查看异常的回溯栈等，在非图形界面下也可以很好地调试。</p>

<p><code>%timeit</code> 也是一个很常用的魔法命令，用于分析一条或一块语句执行时长，这在科学计算或分析性能瓶颈的时候非常有用：</p>

<div class="codeblock code-console"><span class="ipython-in">In [9]:</span> a = np.arange(1, 1000)

<span class="ipython-in">In [10]:</span>  %%timeit
    ...: b = np.empty_like(a)
    ...: for i, v in enumerate(a):
    ...:     b[i] = math.log(v)
    ...:
517 µs ± 4.4 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)

<span class="ipython-in">In [11]:</span> %timeit np.log(a)
9.63 µs ± 1.53 µs per loop (mean ± std. dev. of 7 runs, 100,000 loops each)
</div>

<p>直接从 Python 命令行控制台中复制的代码会带上提示符，如果要使用它还必须去除提示符。使用 <code>%paste</code> 命令可以从剪贴板中获取并执行代码，同时消除提示符的影响：</p>

<div class="codeblock code-console"><span class="ipython-in">In [12]:</span> %paste
>>> from typing import NamedTuple
>>> class User(NamedTuple):
...     id_: int
...     name: str

## -- End pasted text --

<span class="ipython-in">In [13]:</span> u = User(id_=1, name='hello')
</div>

<p>配合特殊变量 <code>In</code> 可以获取去除提示符的实际执行的代码：</p>

<div class="codeblock code-console"><span class="ipython-in">In [14]:</span> print(In[13])
from typing import NamedTuple
class User(NamedTuple):
    id_: int
    name: str
</div>

<p>这里对魔法命令暂时就介绍这么多。可以通过 <code>%magic</code> 打开魔法命令的帮助文档，所有魔法命令可以通过 <code>%lsmagic</code> 获取，通过使用 <code>?</code> 符号就可以了解每个魔法命令的使用。</p>

<h2>使用Jupyter Notebook</h2>

<h3>简介与安装</h3>

<p>IPython 的功能非常丰富，甚至超越了原生 Python 的功能。然而 IPython 毕竟只是个命令行的控制台，进一步提升的空间被限制了。</p>

<p>基于此，IPython 发展出了一种更强大的编辑器模式：<a href="https://jupyter.org/">Jupyter Notebook</a> 。Notebook 具有可视化的编辑界面，并使用文件来编辑与保存单元格的内容。</p>

<p>以下是 Jupyter Notebook 的使用截图：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-page-demo.png" alt="" width="540">
</figure>

<p>Jupyter 在保留 IPython 特点的同时，功能与交互性都更加强大。</p>

<p>Jupyter 的安装十分简单，只需要通过 <code>pip</code> 安装即可：</p>

<div class="codeblock code-console">$ pip install jupyter
</div>

<blockquote>
    <p>注：目前主流的 Jupyter 安装和管理都是通过 Anaconda 完成的，这里使用命令行仅仅是为了简化使用与配置。关于 Anaconda 的使用网络上已经有较多文章，这里不再重复。</p>
</blockquote>

<p>然后在命令行中就可以启动 Notebook ：</p>

<div class="codeblock code-console">$ jupyter notebook
</div>

<p>这会在浏览器中打开一个新的页面，稍等片刻后便会进入 Notebook 的初始界面：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-page-initial.png" alt="" width="760">
</figure>

<h3>认识Notebook</h3>

<p>Jupyter Notebook 也是基于文件执行的，其文件后缀为 <code>.ipynb</code> ，它实质上是一个 Json 文件，只有使用 Jupyter 等支持的编辑器打开才能正常被渲染。在 Jupyter 提供的浏览器页面中，可以像别的编辑器一样新建、修改和保存这种文件，还可以将其导出为 Python 代码、Markdown 文本、PDF 文档等。</p>

<p>进入 Jupyter 后，它提供了 3 个选项卡：</p>

<ol>
    <li>Files 页用于管理工作路径下的文件</li>
    <li>Running 页显示当前正在运行的终端和 Notebooks</li>
    <li>Clusters 页用于处理计算群集</li>
</ol>

<p>新建或打开一个 Notebook 文件后，即可像 IPython 一样在各个单元格内编写、执行代码：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-page-write.png" alt="" width="480">
</figure>

<p>但与 IPython 不同的是，Notebook 单元格的代码可以修改后重新执行，这会使得虽然上面某个单元格的代码修改了，但是下面单元格的输出结果还没更新，并且原始的数据也会被覆盖。注意单元格左侧 In 中的编号才表示真正的执行顺序。</p>

<p>Jupyter 提供的菜单中有各种功能，例如新建或保存文件、合并或移动单元格、控制显示内容等，它们使用较为简单，这里就不展开介绍了。</p>

<p>Notebook 中的单元格除了可以编写代码，还可以使用其余类型的单元格，例如通过 Markdown 单元格编写简单文档并嵌入 LaTeX 公式，或者使用 Raw 单元格显示纯文本。一些 Notebook 的扩展还允许它编写 bash 脚本、执行 R 语言甚至 SQL 命令等。</p>

<p>Notebook 的单元格在编写代码时，具有以下两种模式：</p>

<ul>
    <li>编辑模式：此时单元格外围的边框颜色为绿色，可以直接在该单元格中输入代码或文本</li>
    <li>命令模式：此时单元格外围的边框颜色为蓝色，键盘操作将作为命令执行</li>
</ul>

<p>点击单元格代码外区域或使用快捷键 <kbd>Esc</kbd> 即可进入命令模式，此时可以使用以下常用的命令对单元格做调整：</p>

<table>
    <tr>
        <th>命令</th>
        <th>功能</th>
        <th>命令</th>
        <th>功能</th>
    </tr>
    <tr>
        <td><kbd>L</kbd></td>
        <td>在单元格中显示或取消显示代码行号</td>
        <td><kbd>X</kbd></td>
        <td>剪切选中的单元格</td>
    </tr>
    <tr>
        <td><kbd>M</kbd></td>
        <td>将该单元格变为 Markdown 类型</td>
        <td><kbd>C</kbd></td>
        <td>复制选中的单元格</td>
    </tr>
    <tr>
        <td><kbd>Y</kbd></td>
        <td>将该单元格变为 Code 类型</td>
        <td><kbd>V</kbd></td>
        <td>将单元格粘贴到当前单元格下方</td>
    </tr>
    <tr>
        <td><kbd>A</kbd></td>
        <td>在当前单元格上方插入一个 Code 单元格</td>
        <td><kbd>Shift+↑</kbd> 或 <kbd>Shift+↓</kbd></td>
        <td>向上或向下连续选择多个单元格</td>
    </tr>
</table>

<p>返回编辑模式可以点击代码区域或使用快捷键 <kbd>Enter</kbd> 。运行代码可以使用如下快捷键，它们在任意模式下都可以直接使用：</p>

<ul>
    <li><kbd>Ctrl+Enter</kbd> ：运行选中单元格</li>
    <li><kbd>Shift+Enter</kbd> ：运行选中的单元格，并选中下一个单元格</li>
    <li><kbd>Alt+Enter</kbd> ：运行选中的单元格，并在下方插入一个新的单元格</li>
</ul>

<h3>配置Jupyter</h3>

<p>Jupyter 的某些配置可以修改以满足使用要求。</p>

<p>在启动时可以通过命令行参数临时修改配置。例如 Jupyter 运行的默认端口号是 8888 ，可以通过如下参数修改端口号：</p>

<div class="codeblock code-console">$ jupyter notebook --NotebookApp.port=8088
</div>

<p>如果需要永久更改某个配置，那么就需要使用配置文件。初次使用需要通过如下命令生成配置文件：</p>

<div class="codeblock code-console">$ jupyter notebook --generate-config
</div>

<p>然后可以根据提示信息找到配置文件的位置。该文件是一个纯 Python 文件，使用变量保存所有的配置信息，并且默认情况下配置都被注释了。</p>

<p>如果要启用某项配置只需要取消注释即可，这些配置的说明都在注释中写的很明白了。例如，假设要更改 Jupyter 打开后的根目录，那么可以修改以下配置：</p>

<div class="vscode-block"><div><span style="color: #a8a8a8;">## The directory to use for notebooks and kernels.</span></div><div><span style="color: #a8a8a8;"># &#160;Default: ''</span></div><div><span style="color: #405c79;">c.NotebookApp.notebook_dir = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">E\workspace</span><span style="color: #405c79;">'</span></div></div>

<h3>管理内核</h3>

<p>Notebook 在浏览器前端编写代码后，由内核(kernel)负责执行并返回结果。内核保存着单元格中的所有变量，因此一个 Notebook 所有的代码都在一个内核中执行。</p>

<p>在编辑界面中，可以在 kernel 菜单中终止或重启内核。但需要注意的是：内核一旦中断，所有的变量都会丢失，只有重新执行才可以访问这些变量。</p>

<p>在使用 Python 的过程中，免不了要管理各种虚拟环境，此时就需要管理 Jupyter 的各种内核。内核管理需要借助 <code>ipykernel</code> 第三方库实现，不过它应该在安装 Jupyter 时已经作为一个依赖被一并安装了。</p>

<p>使用以下命令即可查看当前 Jupyter 具有的全部内核：</p>

<div class="codeblock code-console">$ jupyter kernelspec list
</div>

<p>每个内核都是一个目录，它主要包含以下文件：</p>

<div class="codeblock code-template">
    kernel.json<br>
    logo-32x32.png<br>
    logo-64x64.png<br>
    logo-svg.svg
</div>

<p>通过在 <var>kernels</var> 目录中创建多个类似这样的目录并修改 <var>kernel.json</var> 文件的内容，即可创建多个使用不同解释器的内核。<var>kernel.json</var> 文件中的内容为：</p>

<div class="vscode-block" style="color: #90a4ae;"><div><span style="color: #39adb5;">{</span></div><div><span>&#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #7c4dff;">argv</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">:</span><span> </span><span style="color: #39adb5;">[</span></div><div><span>&#160; &#160; &#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #91b859;">E:</span><span style="color: #39adb5;">\\</span><span style="color: #91b859;">workspace</span><span style="color: #39adb5;">\\</span><span style="color: #91b859;">ai</span><span style="color: #39adb5;">\\</span><span style="color: #91b859;">env</span><span style="color: #39adb5;">\\</span><span style="color: #91b859;">sci</span><span style="color: #39adb5;">\\</span><span style="color: #91b859;">Scripts</span><span style="color: #39adb5;">\\</span><span style="color: #91b859;">python.exe</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">,</span></div><div><span>&#160; &#160; &#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #91b859;">-m</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">,</span></div><div><span>&#160; &#160; &#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #91b859;">ipykernel_launcher</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">,</span></div><div><span>&#160; &#160; &#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #91b859;">-f</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">,</span></div><div><span>&#160; &#160; &#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #91b859;">{connection_file}</span><span style="color: #39adb5;">"</span></div><div><span>&#160; &#160; </span><span style="color: #39adb5;">],</span></div><div><span>&#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #7c4dff;">display_name</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">:</span><span> </span><span style="color: #39adb5;">"</span><span style="color: #91b859;">Python 3 (sci)</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">,</span></div><div><span>&#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #7c4dff;">language</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">:</span><span> </span><span style="color: #39adb5;">"</span><span style="color: #91b859;">python</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">,</span></div><div><span>&#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #7c4dff;">metadata</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">:</span><span> </span><span style="color: #39adb5;">{</span></div><div><span>&#160; &#160; &#160; &#160; </span><span style="color: #39adb5;">"</span><span style="color: #ffb62c;">debugger</span><span style="color: #39adb5;">"</span><span style="color: #39adb5;">:</span><span> </span><span style="color: #f76d47;">true</span></div><div><span>&#160; &#160; </span><span style="color: #39adb5;">}</span></div><div><span style="color: #39adb5;">}</span></div></div>

<p>这里主要修改 <code>"argv"[0]</code> 决定的解释器路径和 <code>"display_name"</code> 决定的内核名，启动 Jupyter 后就能在 Kernel 菜单中更换内核并使用不同的虚拟环境了：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-manage-kernels.png" alt="" width="340">
</figure>

<h3>高级交互效果</h3>

<p>借助浏览器的前端技术，Jupyter 可以使用在命令行甚至一般的编辑器中无法实现的交互效果。</p>

<p>在之前介绍 Jupyter 时就展示了在单元格内显示，借助 <code>IPython.display</code> 模块的各种显示类，可以在浏览器中显示各种格式的文本、数学公式乃至多媒体文件等：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-display.jpg" alt="" width="630">
</figure>

<p>还可以使用控件(widget)实现更强大的交互效果。控件的实现由第三方库 <code>ipywidgets</code> 提供，它应该在安装 Jupyter 时就被一并安装了，如果没有的话也可以使用 <code>pip</code> 安装它。</p>

<p>先来看一个最简单的示例，在输出中显示一个滑块：</p>

<div class="vscode-block"><div><span style="color: #405c79;">w = ipywidgets.IntSlider()</span></div><div><span style="color: #405c79;">w</span></div></div>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-widgets-demo-1.png" alt="" width="360">
</figure>

<p>交互最主要的就是处理各种事件，这可以通过向 <code>.observe()</code> 方法提供回调函数实现。每次发生交互时，事件的相关信息将以字典的形式由回调函数处理：</p>

<div class="vscode-block"><div><span style="color: #405c79;">w = ipywidgets.IntSlider()</span></div><div><span style="color: #405c79;">w.observe(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">e</span><span style="color: #405c79;">: </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(e[</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">new</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]), </span><span style="color: #bf8b56;">names</span><span style="color: #405c79;">=[</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">value</span><span style="color: #405c79;">'</span><span style="color: #405c79;">])</span></div><div><span style="color: #405c79;">w</span></div></div>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-widget-demo-2.gif" alt="" width="440">
</figure>

<p>由于许多动作都会导致事件的发生，因此这里通过 <code>names</code> 参数限制处理的事件，即只有选定的值发生变化时才处理该事件。滑块在滑动过程中会不断触发事件，在复杂操作时可能引起卡顿。如果想让滑块在最终释放时才执行动作，那么可以在初始化时将 <code>continuous_update</code> 参数设置为 <code>False</code> 。</p>

<p>按钮之类的特殊控件没有那么多交互逻辑，可以使用其它方法简化处理，例如：</p>

<div class="vscode-block"><div><span style="color: #405c79;">w = ipywidgets.Button(</span><span style="color: #bf8b56;">description</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">click me</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div><div><span style="color: #405c79;">w.on_click(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">w</span><span style="color: #405c79;">: </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'clicked </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">w</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;">))</span></div><div><span style="color: #405c79;">w</span></div></div>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-widgets-demo-3.png" alt="" width="480">
</figure>

<p>给多个控件建立联系也是很常见的做法，这点可以通过 <code>link()</code> 函数实现。例如，以下在一个滑块和进度条之间建立联系，使滑块的位置被同步反映到进度条上：</p>

<div class="vscode-block"><div><span style="color: #405c79;">w1 = ipywidgets.FloatSlider()</span></div><div><span style="color: #405c79;">w2 = ipywidgets.FloatProgress()</span></div><div><span style="color: #405c79;">ipywidgets.link((w1, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">value</span><span style="color: #405c79;">'</span><span style="color: #405c79;">), (w2, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">value</span><span style="color: #405c79;">'</span><span style="color: #405c79;">))</span></div><br><div><span style="color: #405c79;">display.display(w1, w2)</span></div></div>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-widgets-demo-4.png" alt="" width="300">
</figure>

<p>如果要建立单向联系，可以使用 <code>dlink()</code> 。这种联系的后台交互由内核实现，因此内核断开后就无法继续使用。如果要使用纯前端方法实现的联系，可以使用 <code>jslink()</code> 和 <code>jsdlink()</code> 。</p>

<p>一种更为强大的交互效果由 <code>interact()</code> 函数实现。该函数可以根据初始值自动选择合适的控件展示，以下简单展示了几个示例：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyter-widgets-demo-5.png" alt="" width="500">
</figure>

<p><var>ipywidgets</var> 的内容非常复杂，它不仅包含了大量常用的输入框、按钮、框架盒系列的控件，还允许对控件的样式做详细的定制，这里就不展开说明了。要了解更多有关它的内容，可以参考<a href="https://ipywidgets.readthedocs.io/en/latest/">官方文档</a>。</p>

<h3>JupyterLab：更强大的Notebook IDE</h3>

<p>Jupyter 作为 Notebook 的开发环境，只提供了基本的界面及一些简单的单元格编辑与处理功能。JupyterLab 则是一个更高级的浏览器 Notebook 开发环境，它提供了更加丰富的功能，其使用截图如下：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/jupyterlab-demo.png" alt="" width="840">
</figure>

<p>用过 VS Code 等编辑器的话应该会对该界面比较熟悉，JupyterLab 提供了更实用的文件管理、预览、分屏、状态显示等功能，并且还可以通过安装扩展进一步丰富其功能。</p>

<p>JupyterLab 可以通过 <code>pip</code> 快速安装：</p>

<div class="codeblock code-console">$ pip install jupyterlab
</div>

<p>然后就可以在命令行中运行：</p>

<div class="codeblock code-console">$ jupyter lab
</div>

<p>Jupyter 及 Notebook 的发展远没有结束，除了以上介绍的技术外，Jupyter Hub 可以用于多人协同开发，而各个常用 Python IDE（如 Pycharm 和 VS Code ）也推出了内置的 Notebook 开发环境，使 Notebook 可以使用它们提供的代码补全、语法检查、调试、环境管理等更多功能。</p>
<p><a rel="nofollow" href="/archives/823">Jupyter Notebook 入门指南</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/823/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy06:高级数据类型</title>
		<link>/archives/816</link>
					<comments>/archives/816#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 17 Oct 2022 11:45:52 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=816</guid>

					<description><![CDATA[<p>复合数据类型 结构化数组 前面介绍过，在创建数组时使&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/816">Python数据分析-numpy06:高级数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>复合数据类型</h2>

<h3>结构化数组</h3>

<p>前面介绍过，在创建数组时使用 <code>dtype</code> 参数可以指定数组元素的类型：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>np<span style="color: #39adb5;">.</span>complex128<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j])</div>
</div>

<p><var type="module">numpy</var> 提供了许多数据类型，可以满足各种场景的使用。但是这种方式创建的数组只能容纳同种类型的元素。</p>

<p>通过在列表内安排多个数据类型，可以指定复合数据类型，构造一个结构化数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>empty<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[</span></div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>unicode_<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">16</span><span style="color: #39adb5;">),</span> </div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>int16<span style="color: #39adb5;">),</span></div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>float_<span style="color: #39adb5;">)</span></div><div><span style="color: #39adb5;">])</span></div><div>students<span style="color: #39adb5;">.</span>dtype</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">dtype([('name', '&lt;U16'), ('age', '&lt;i2'), ('score', '&lt;f8')])</div>
</div>

<p>这种复合数据类型可以通过字段名来区分各个数据成员，就像命名元组一样。</p>

<p>当检查该数组的类型时，可以看到复合数据类型由多个简单数据类型组合而成。这里基本数据类型以简写形式表达，<code>U16</code> 表示“长度不超过 16 的 Unicode 字符串”，<code>i2</code> 表示“ 2 字节（16 位）整型”，f8 表示“ 8 字节（64 位）浮点型”。最前方的小于号 <code>&lt;</code> 表示以低字节序(little endian)存储。</p>

<p>更多字符对应的 numpy 的数据类型如下表所示：</p>

<table>
    <tr>
        <th>数据类型符号</th><th>描述</th>
        <th>数据类型符号</th><th>描述</th>
    </tr>
    <tr>
        <td class="code">'b'</span></td><td>字节型</td>
        <td class="code">'c'</span></td><td>浮点型复数</td>
    </tr>
    <tr>
        <td class="code">'i'</span></td><td>有符号整型</td>
        <td class="code">'S', 'a'</span></td><td>字符串</td>
    </tr>
    <tr>
        <td class="code">'u'</span></td><td>无符号整型</td>
        <td class="code">'U'</span></td><td>Unicode 字符串</td>
    </tr>
    <tr>
        <td class="code">'f'</span></td><td>浮点型</td>
        <td class="code">'V'</span></td><td>原生数据</td>
    </tr>
</table>

<p>除了元组列表外，还可以通过字典的形式表达复合数据类型：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">{</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">names</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">),</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">formats</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">&lt;U16</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">&lt;i2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">&lt;f8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div><span style="color: #39adb5;">})</span></div></div>
</div>

<p>还可以忽略字段名称，仅用一个逗号分隔的字符串来指定复合类型：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>dtype<span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">S16,i2,f8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">dtype([('f0', 'S16'), ('f1', '&lt;i2'), ('f2', '&lt;f8')])</div>
</div>

<p>这种通过 <code>dtype</code> 类构造的类型也可以直接用作传参。</p>

<p>现在生成了一个空的数组容器，可以将列表数据放入数组中：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">Alice</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Tim</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Duff</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div><div>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">25</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">19</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">31</span><span style="color: #39adb5;">]</span></div><div>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">75.0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">61.3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">57.9</span><span style="color: #39adb5;">]</span></div><div>students</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([('Alice', 25, 75. ), ('Tim', 19, 61.3), ('Duff', 31, 57.9)],
       dtype=[('name', '&lt;U16'), ('age', '&lt;i2'), ('score', '&lt;f8')])</div>
</div>

<p>结构化数组所有的数据被安排在一个内存块中，因此它的存储和运算效率都优于元组列表。</p>

<p>可以通过索引或名称查看相应的值。例如，以下获取结构数组所有 <code>name</code> 字段的内容：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> &#160;<span style="color: #a8a8a8;"># name field</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array(['Alice', 'Tim', 'Duff'], dtype='&lt;U16')</div>
</div>

<p>以下获取数据的第一个结构：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span> &#160;<span style="color: #a8a8a8;"># first struct</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">('Alice', 25, 75.)</div>
</div>

<p>以下获取最后一个结构的 <code>name</code> 字段：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">'Duff'</div>
</div>

<p>利用布尔数组数据，还可以做一些更复杂的操作，如按照分数筛选结构，再提取结构字段：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">&gt;</span> <span style="color: #f76d47;">60</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array(['Alice', 'Tim'], dtype='&lt;U16')</div>
</div>

<h3>更高级的复合类型</h3>

<p><var type="module">numpy</var> 中也可以定义更高级的复合数据类型，其中每个字段又是一个复合数据类型。</p>

<p>例如，可以创建一种结构，其中每个元素都包含一个数组或矩阵：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>im3_3 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>dtype<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">[(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">id</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">i8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">),</span> <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">matrix</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">f8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">))]</span></div><div><span style="color: #39adb5;">)</span></div></div>

    <div class="juputer-separator"></div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>c1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>im3_3<span style="color: #39adb5;">)</span></div><div>c1<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(0, [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])</div>
</div>

<p>使用第三个参数可以确定数组的形状。</p>

<p>使用这种规则还可以创建嵌套结构类型，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>classroom <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>dtype<span style="color: #39adb5;">([</span></div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">teacher</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>dtype<span style="color: #39adb5;">([</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>unicode_<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">16</span><span style="color: #39adb5;">),</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>int16<span style="color: #39adb5;">)</span></div><div>&#160; &#160; <span style="color: #39adb5;">])),</span></div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">students</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> student<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div><div><span style="color: #39adb5;">])</span></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>grade_7 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>empty<span style="color: #39adb5;">(</span><span style="color: #f76d47;">8</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>classroom<span style="color: #39adb5;">)</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">teacher</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Mr.C</span><span style="color: #39adb5;">'</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">teacher</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #f76d47;">32</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">students</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">Alice</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Tim</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Duff</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">students</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">25</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">19</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">31</span><span style="color: #39adb5;">]</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">students</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">75.0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">61.3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">57.9</span><span style="color: #39adb5;">]</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(('Mr.C', 32), [('Alice', 25, 75. ), ('Tim', 19, 61.3), ('Duff', 31, 57.9)])</div>
</div>

<p>它的使用方法和普通的数组并没有太大差异。</p>

<p><var type="module">numpy</var> 还提供了 <code>recarray</code> 类。它和前面介绍的结构化数组几乎相同，但是它有一个独特的特征：字段可以像属性一样获取，而不是像字典的键那样获取。</p>

<p>例如，以下使用 <code>.view()</code> 方法，将一个数组通过视图表现为 <code>recarray</code> 类。这种类型的转换不修改底层数据，只改变数据的处理方式：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>graderec_7 <span style="color: #7c4dff;">=</span> grade_7<span style="color: #39adb5;">.</span>view<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>recarray<span style="color: #39adb5;">)</span></div><div>graderec_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">].</span>students<span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">].</span>name</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">'Tim'</div>
</div>

<h2>NumPy与I/O</h2>

<p>在处理大量数据时，将结果暂时保存到磁盘上是有必要的。<var type="module">numpy</var> 提供了一系列 I/O 操作，可以与磁盘交互。</p>

<p>最基本的 <code>save(<em>file</em>, <em>arr</em>, <em>allow_pickle</em>=True, <em>fix_imports</em>=True)</code> 函数将数组保存到扩展名为 <code>.npy</code> 的文件中。<code><em>allow_pickle</em></code> 参数使用序列化形式保存数组对象。<code><em>fix_imports</em></code> 参数则是为了处理 Python2 与 Python3 的版本差异：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>save<span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">grade7</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> grade_7<span style="color: #39adb5;">)</span></div></div>
</div>

<p>然后同级目录下就会得到一个 <code>grade7.npy</code> 的文件。由于对其做了序列化操作，因此该文件是二进制形式的，不能通过一般的文本编辑器打开。</p>

<p>读取则使用 <code>load()</code> 函数。如果不想使用二进制的形式保存数据，可以调用 <code>savetxt()</code> 以简单的文本形式存储数据，对应的使用 <code>loadtxt()</code> 函数读取文本数据。不过文本形式无法保存复杂的结构化数组数据，因此不建议使用。</p>
<p><a rel="nofollow" href="/archives/816">Python数据分析-numpy06:高级数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/816/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy05:数组统计与排序</title>
		<link>/archives/807</link>
					<comments>/archives/807#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 13 Oct 2022 09:32:07 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=807</guid>

					<description><![CDATA[<p>数组的统计 有时要获取数组的某些统计值，例如最值、总&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/807">Python数据分析-numpy05:数组统计与排序</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>数组的统计</h2>

<p>有时要获取数组的某些统计值，例如最值、总和、方差等。这种统计值可以使用 <var type="module">numpy</var> 相关的函数来获取：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>rand <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>RandomState<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div>a1 <span style="color: #7c4dff;">=</span> rand<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>mean<span style="color: #39adb5;">(</span>a1<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">4.3</div>
</div>

<p>相比 Python 内置的相同作用的函数，<var type="module">numpy</var> 对数组操作做了一些底层的优化，计算会更快一些：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>big_array <span style="color: #7c4dff;">=</span> rand<span style="color: #39adb5;">.</span>rand<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1000000</span><span style="color: #39adb5;">)</span></div><div><span style="color: #7c4dff;">%</span>timeit <span style="color: #6182b8;">sum</span><span style="color: #39adb5;">(</span>big_array<span style="color: #39adb5;">)</span></div><div><span style="color: #7c4dff;">%</span>timeit np<span style="color: #39adb5;">.</span>sum<span style="color: #39adb5;">(</span>big_array<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">113 ms ± 1.16 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
1.5 ms ± 32.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</div>
</div>

<p>下表列出了 <var type="module">numpy</var> 提供的统计函数：</p>

<table>
    <tr>
        <th>函数名称</th><th>描述</th>
        <th>函数名称</th><th>描述</th>
    </tr>
    <tr>
        <td class="code">sum()</td><td>计算元素的和</td>
        <td class="code">min()</td><td>得到最小值</td>
    </tr>
    <tr>
        <td class="code">prod()</td><td>计算元素的积</td>
        <td class="code">max()</td><td>得到最大值</td>
    </tr>
    <tr>
        <td class="code">mean()</td><td>计算元素的平均值</td>
        <td class="code">argmin()</td><td>得到最小值的索引</td>
    </tr>
    <tr>
        <td class="code">average()</td><td>计算元素的加权平均值</td>
        <td class="code">argmax()</td><td>得到最大值的索引</td>
    </tr>
    <tr>
        <td class="code">median()</td><td>计算元素的中位数</td>
        <td class="code">ptp()</td><td>计算元素的最值之差</td>
    </tr>
    <tr>
        <td class="code">std()</td><td>计算元素的标准差</td>
        <td class="code">percentile()</td><td>计算元素的百分比位数</td>
        
    </tr>
    <tr>
        <td class="code">var()</td><td>计算元素的方差</td>
        <td class="code">any()</td><td>验证是否存在元素为真</td>
    </tr>
    <tr>
        <td class="code"></td><td></td>
        <td class="code">all()</td><td>验证所有元素是否都为真</td>
    </tr>
</table>

<p>除了 <code>any()</code> 和 <code>all()</code> 外，这些函数都有一个以 nan 开头、对 NaN 值的安全处理版本，在计算时忽略所有的缺失值。</p>

<p>对于这些聚合函数，一种更简洁的形式是对数组对象直接调用对应的方法：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a1<span style="color: #39adb5;">.</span>std<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">3.257299494980466</div>
</div>

<p><code>any()</code> 和 <code>all()</code> 是比较特殊的聚合函数，因为它们只针对布尔数组。配合<a href="/archives/800">上一节</a>介绍的通用函数，可以快速检查数组是否符合某一条件。例如，可以使用以下代码来检查数组中是否有值为 10 的元素：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>any<span style="color: #39adb5;">(</span>a1 <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">False</div>
</div>

<p><var type="module">numpy</var> 提供的统计函数还允许操作多维数组时，沿着某一个维度聚合。例如，对于一个二维数组，可以对某一行或某一列聚合：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">))</span></div><div>a2<span style="color: #39adb5;">.</span>sum<span style="color: #39adb5;">(</span><span style="color: #e53935;">axis</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 6, 22, 38])</div>
</div>

<p>下图展示了数组“在 <code>axis=1</code> 上聚合”的原理：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/05-array-aggregate.png" alt="" width="200">
</figure>

<p>注意，聚合得到的结果比原数组低 1 个维度。</p>

<h2>数组的排序</h2>

<p><var type="module">numpy</var> 的 <code>sort()</code> 函数可以实现数组的高效排序。<code>sort()</code> 函数返回的是原始数组的副本：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a3 <span style="color: #7c4dff;">=</span> rand<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">8</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>sort<span style="color: #39adb5;">(</span>a3<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([2, 7, 7, 8, 8, 8, 9, 9])</div>
</div>

<p>如果希望用排序好的数组替代原始数组，可以使用数组的 <code>.sort()</code> 方法。</p>

<p>另一个相关的函数是 <code>argsort()</code> ，该函数返回的是原始数组排序完成的索引值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>argsort<span style="color: #39adb5;">(</span>a3<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([3, 1, 5, 0, 2, 6, 4, 7], dtype=int32)</div>
</div>

<p>这些索引值可以用作索引数组，来得到这个数组有序的视图：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a3<span style="color: #39adb5;">[</span>np<span style="color: #39adb5;">.</span>argsort<span style="color: #39adb5;">(</span>a3<span style="color: #39adb5;">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 7,  8,  9,  9, 12, 17, 18, 18])</div>
</div>

<p>使用 <var type="module">numpy</var> 的排序函数可以通过 <code>axis</code> 参数，沿着某个维度排序。例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a4 <span style="color: #7c4dff;">=</span> rand<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">))</span></div><div>np<span style="color: #39adb5;">.</span>sort<span style="color: #39adb5;">(</span>a4<span style="color: #39adb5;">,</span> <span style="color: #e53935;">axis</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[0, 1, 7, 9],
       [0, 1, 4, 7],
       [0, 3, 6, 8]])</div>
</div>

<p>对单一数组排序可能会遇到几个相同的值。可以综合多个数组使用 <code>lexsort()</code> 函数排序，该排序得到的结果也是索引数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div><div>x2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">8</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">])</span></div><div>x3 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div><div><span style="color: #a8a8a8;"># sort by x3, then sort by x1, then sort by x2</span></div><div>np<span style="color: #39adb5;">.</span>lexsort<span style="color: #39adb5;">((</span>x2<span style="color: #39adb5;">,</span> x1<span style="color: #39adb5;">,</span> x3<span style="color: #39adb5;">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([2, 0, 5, 1, 3, 4], dtype=int32)</div>
</div>

<p><code>partition()</code> 函数可以用于找到数组中 K 个最小值。该函数得到的结果是一个新数组，最左边是 K 个最小值，往右是任意顺序的其他值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>partition<span style="color: #39adb5;">(</span>a1<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 0, 0, 3, 6, 8, 4, 7, 6, 9])</div>
</div>

<p>类似的也有一个 <code>argpartition()</code> 函数，不过返回的结果是索引。</p>
<p><a rel="nofollow" href="/archives/807">Python数据分析-numpy05:数组统计与排序</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/807/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy04:通用函数与广播规则</title>
		<link>/archives/800</link>
					<comments>/archives/800#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sun, 09 Oct 2022 08:51:39 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=800</guid>

					<description><![CDATA[<p>通用函数 通用函数的概念 numpy 的数组在底层使&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/800">Python数据分析-numpy04:通用函数与广播规则</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>通用函数</h2>

<h3>通用函数的概念</h3>

<p><var type="module">numpy</var> 的数组在底层使用了C语言构造存储效率更高，如果对 <var type="module">numpy</var> 的数组使用 Python 的遍历方式，那么效率很低。例如，以下是一个 Python 函数，用于计算数组内每个元素的倒数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #7c4dff;font-weight: bold;">def</span> <span style="color: #6182b8;">reciprocal</span><span style="color: #39adb5;">(</span><span style="color: #e53935;">values</span><span style="color: #39adb5;">):</span></div><div>&#160; &#160; output <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>empty<span style="color: #39adb5;">(</span><span style="color: #6182b8;">len</span><span style="color: #39adb5;">(</span>values<span style="color: #39adb5;">))</span></div><div>&#160; &#160; <span style="color: #39adb5;font-weight: bold;">for</span> i <span style="color: #7c4dff;">in</span> <span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #6182b8;">len</span><span style="color: #39adb5;">(</span>values<span style="color: #39adb5;">)):</span></div><div>&#160; &#160; &#160; &#160; output<span style="color: #39adb5;">[</span>i<span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #f76d47;">1.0</span> <span style="color: #7c4dff;">/</span> values<span style="color: #39adb5;">[</span>i<span style="color: #39adb5;">]</span></div><div>&#160; &#160; <span style="color: #39adb5;font-weight: bold;">return</span> output</div></div>
</div>

<p>如果对 <var type="module">numpy</var> 的数组调用该函数，计算的速度比较慢：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>big_array <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">100</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">1000000</span><span style="color: #39adb5;">)</span></div><div><span style="color: #7c4dff;">%</span>timeit reciprocal<span style="color: #39adb5;">(</span>big_array<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">2.25 s ± 18.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</div>
</div>

<p>纯 Python 执行的效率偏低，不过好在 <var type="module">numpy</var> 为数组的各种操作提供了非常方便且高效的接口，这种接口称为通用函数(universal function, ufunc)，也称为向量操作。</p>

<p>通用函数使得对数组的简单操作，将会作用于数组的每一个元素。例如，以上倒数的计算可以以运算符“ <code>/</code> ”直接操作数组对象和一个整数，而实际的运算将会发生在数组的每一个元素之间：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>small_array <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span>reciprocal<span style="color: #39adb5;">(</span>small_array<span style="color: #39adb5;">))</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1.0</span> <span style="color: #7c4dff;">/</span> <span style="color: #39adb5;">(</span>small_array<span style="color: #39adb5;">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[0.14285714 0.11111111 0.125      0.11111111 0.16666667]
[0.14285714 0.11111111 0.125      0.11111111 0.16666667]</div>
</div>

<p>通用函数的实际计算由 numpy 底层执行，可以做到 CPU 级别的优化，这样会取得非常快的执行效率：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #7c4dff;">%</span>timeit <span style="color: #39adb5;">(</span><span style="color: #f76d47;">1.0</span> <span style="color: #7c4dff;">/</span> big_array<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">2.82 ms ± 106 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</div>
</div>

<p>计算大型数组时，使用通用函数的效率高得多。</p>

<h3>使用通用函数</h3>

<p>通用函数有一元通用函数和二元通用函数，可以操作一个数组、一个数组和一个数值，甚至两个数组。</p>

<p><var type="module">numpy</var> 的通用函数重载了 Python 的运算符，因此可以像对一个数值的运算一样对数组内的每个元素做运算。以下是一些示例：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a1 + 5 &#160;=</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a1 <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a1 // 2 =</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a1 <span style="color: #7c4dff;">//</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a1 ** 2 =</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a1 <span style="color: #7c4dff;">**</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">-a1 &#160; &#160; =</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #7c4dff;">-</span>a1<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">a2 + 5  = [5 6 7 8 9]
a2 // 2 = [0 0 1 1 2]
a2 ** 2 = [ 0  1  4  9 16]
-a2     = [ 0 -1 -2 -3 -4]</div>
</div>

<p>还可以将这些运算符任意组合使用，并且组合使用也遵循运算符的优先级：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #7c4dff;">-</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">0.5</span> <span style="color: #7c4dff;">*</span> a1 <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span> <span style="color: #7c4dff;">**</span> <span style="color: #f76d47;">2</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([-1.  , -2.25, -4.  , -6.25, -9.  ])</div>
</div>

<p>所有的运算符都是 <var type="module">numpy</var> 内置函数的简单封装器。例如，运算符“ <code>+</code> ”就是一个 <code>add()</code> 函数的封装：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>add<span style="color: #39adb5;">(</span>a1<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([5, 6, 7, 8, 9])</div>
</div>

<p>下表列出了 <var type="module">numpy</var> 重载的运算符与其对应的函数：</p>

<table>
    <tr>
        <th>运算符</th><th>对应的通用函数</th><th>描述</th>
    </tr>
    <tr>
        <td class="code">+</td><td class="code">add()</td><td>加法运算</td>
    </tr>
    <tr>
        <td class="code">-</td><td class="code">subtract()</td><td>减法运算</td>
    </tr>
    <tr>
        <td class="code">-</td><td class="code">negative()</td><td>负数运算</td>
    </tr>
    <tr>
        <td class="code">*</td><td class="code">multiply()</td><td>乘法运算</td>
    </tr>
    <tr>
        <td class="code">/</td><td class="code">divide()</td><td>除法运算，得到的结果是小数</td>
    </tr>
    <tr>
        <td class="code">//</td><td class="code">floor_divide()</td><td>整数除法运算，得到的结果是向下截断的整数</td>
    </tr>
    <tr>
        <td class="code">**</td><td class="code">power()</td><td>指数运算</td>
    </tr>
    <tr>
        <td class="code">%</td><td class="code">mod()</td><td>模运算（余数运算）</td>
    </tr>
</table>

<p>除了运算符外，<var type="module">numpy</var> 还重载了 Python 内置的运算函数，使这些函数可以应用于数组。</p>

<p>例如，可以使用 <code>abs()</code> 函数取绝对值。当该函数作用于复数数组时，绝对值返回的是该复数在复平面上对应向量的模长：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">3</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">4</span><span style="color: #7c4dff;font-weight: bold;">j</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">3</span><span style="color: #7c4dff;font-weight: bold;">j</span><span style="color: #39adb5;">,</span> <span style="color: #7c4dff;">-</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #7c4dff;">-</span><span style="color: #f76d47;">5</span><span style="color: #7c4dff;font-weight: bold;">j</span><span style="color: #39adb5;">])</span></div><div>np<span style="color: #39adb5;">.</span>abs<span style="color: #39adb5;">(</span>a2<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([5., 5., 2., 5.])</div>
</div>

<p>该重载方法对应的 <var type="module">numpy</var> 通用函数是 <code>absolute()</code> ，并且在 <var type="module">numpy</var> 内还有一个别名也为 <code>abs()</code> 。</p>

<p><var type="module">numpy</var> 还提供了计算三角函数的通用函数，包括正弦、余弦、正切以及它们对应的反三角函数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>theta <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>linspace<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>pi<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">theta &#160; &#160; &#160;:</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> theta<span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">sin(theta) :</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>sin<span style="color: #39adb5;">(</span>theta<span style="color: #39adb5;">))</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">tan(theta) :</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>tan<span style="color: #39adb5;">(</span>theta<span style="color: #39adb5;">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">theta      : [0.         1.57079633 3.14159265]
sin(theta) : [0.0000000e+00 1.0000000e+00 1.2246468e-16]
tan(theta) : [ 0.00000000e+00  1.63312394e+16 -1.22464680e-16]</div>
</div>

<p>另一类常用的通用函数是指数运算，包括以 e 为底数的指数函数 <code>exp()</code> 、以 2 为底数的指数函数 <code>exp2()</code> 、任意数为底数的指数函数 <code>pow()</code> 。不是特殊的指数运算也可以直接使用指数运算符“ <code>**</code> ”计算，该运算符对应的通用函数是 <code>power()</code> 。</p>

<p>指数运算的逆运算，即对数运算也是很有用的。最基本的 <code>log()</code> 给出的是以 e 为底数的对数，还有包括以 2 为底数的对数函数 <code>log2()</code> 、以 10 为底数的对数函数 <code>log10()</code> 。</p>

<p>还有一些特殊的函数例如 <code>expm1()</code> 用于计算 e<sup>x</sup> - 1 ，以及 <code>log1p()</code> 用于计算 ln(x + 1) ，它们在底层做了一定优化，对于非常小的输入值可以保持很好的精度，比间接计算再组合更精确。</p>

<p>通用函数非常灵活，甚至可以对两个数组进行运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span> <span style="color: #7c4dff;">/</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0.        , 0.5       , 0.66666667, 0.75      , 0.8       ])</div>
</div>

<p>不仅限于一维函数，也可以用于多维数组的计算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a6 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">6</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">))</span></div><div><span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">**</span> a6</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 1,  2,  4],
       [ 8, 16, 32]], dtype=int32)</div>
</div>

<h3>通用函数与布尔运算</h3>

<p>通用函数除了计算外，还有一种实用的用法是布尔运算。这些比较运算符和其对应的通用函数如下表所示：</p>

<table>
    <tr>
        <th>运算符</th><th>对应的通用函数</th>
    </tr>
    <tr>
        <td class="code">==</td><td class="code">equal()</td>
    </tr>
    <tr>
        <td class="code">!=</td><td class="code">not_equal()</td>
    </tr>
    <tr>
        <td class="code">&lt;</td><td class="code">less()</td>
    </tr>
    <tr>
        <td class="code">&lt;=</td><td class="code">less_equal()</td>
    </tr>
    <tr>
        <td class="code">&gt;</td><td class="code">greater()</td>
    </tr>
    <tr>
        <td class="code">&gt;=</td><td class="code">greater_equal()</td>
    </tr>
</table>

<p>对一个数组对象的布尔运算将对每个元素做布尔运算，并得到一个新的布尔数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a1 <span style="color: #7c4dff;">%</span> <span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([False,  True, False,  True, False])</div>
</div>

<p>如果需要对两个布尔结果做布尔逻辑运算，可以通过 Python 的逐位逻辑运算符“ & ”、“ | ”、“ ^ ”和“ ~ ”来实现。当作用与布尔数组时，可以表示布尔逻辑运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;">(</span>a1 <span style="color: #7c4dff;">&gt;</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span> <span style="color: #7c4dff;">&amp;</span> <span style="color: #39adb5;">(</span>a1 <span style="color: #7c4dff;">%</span> <span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([False, False, False,  True, False])</div>
</div>

<p>下表总结了逐位的布尔运算符和其对应的通用函数：</p>

<table>
    <tr>
        <th>运算符</th><th>对应通用函数</th><th>逻辑含义</th>
    </tr>
    <tr>
        <td class="code">&amp;</td><td class="code">bitwise_and()</td><td>与</td>
    </tr>
    <tr>
        <td class="code">|</td><td class="code">bitwise_or()</td><td>或</td>
    </tr>
    <tr>
        <td class="code">^</td><td class="code">bitwise_xor()</td><td>异或</td>
    </tr>
    <tr>
        <td class="code">~</td><td class="code">bitwise_not()</td><td>非</td>
    </tr>
</table>

<p>这种布尔数组实用之处在于，可以将其作为数组索引，从而快速选出在 <code>True</code> 位置的所有元素。例如，以下操作可以选择数组中的所有偶数元素：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a9 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>RandomState<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">).</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">9</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span><span style="color: #39adb5;">,))</span></div><div>a9<span style="color: #39adb5;">[</span>a9 <span style="color: #7c4dff;">%</span> <span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([8, 0, 0, 6, 2, 4])</div>
</div>

<p>注意：这种情况下 <code>a % 2</code> 和 <code>a % 2 != 0</code> 表示的不是一个意思。前者得到的是一个数值数组，将其作为索引时每个元素表示的意思是索引值位置的元素；后者得到的是一个布尔数组，将其作为索引时每个元素表示的意思是是否取用当前位置的元素。</p>

<p>可以使用 <code>where()</code> 函数将后一种布尔数组转为等价的索引数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>where<span style="color: #39adb5;">(</span>a9 <span style="color: #7c4dff;">%</span> <span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">0</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(array([1, 3, 4, 7, 8, 9], dtype=int32),)</div>
</div>

<p><code>where()</code> 函数一般用在高维的索引查询中，每个数组相应位置元素组合的结果就是元素在高维数组的索引。</p>

<h3>通用函数高级特性</h3>

<p>通用函数有两种表现形式：函数对象和运算符。显式使用通用函数代替运算符的好处在于，可以使用通用函数提供的一些参数。</p>

<p>例如，有时需要指定一个用于存放这些运算结果的数组。所有的通用函数都可以通过设置 <code>out</code> 参数的值来指定计算结果的存放位置：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a7 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>empty<span style="color: #39adb5;">(</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>multiply<span style="color: #39adb5;">(</span>a4<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">out</span><span style="color: #7c4dff;">=</span>a7<span style="color: #39adb5;">)</span></div><div>a7</div></div>
</div>

<p>这个特性也可用于向数组视图内输出数据。例如可以将计算结果写入指定数组间隔的位置：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a8 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>ones<span style="color: #39adb5;">(</span><span style="color: #f76d47;">8</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>add<span style="color: #39adb5;">(</span>a7<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">out</span><span style="color: #7c4dff;">=</span>a8<span style="color: #39adb5;">[::</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div><div>a8</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 5.,  1.,  7.,  1., 11.,  1., 23.,  1.])</div>
</div>

<p>对于较大的数组，使用 <code>out</code> 参数可以有效节约内存。</p>

<hr>

<p>通用函数对象还提供了一些方法，可以完成更高级的运算需求。例如，调用通用函数对象的 <code>.reduce()</code> 方法会对给定的元素连续执行操作，直到得到单个的结果，类似 <code>functools</code> 库的 <code>reduce()</code> 函数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>multiply<span style="color: #39adb5;">.</span>reduce<span style="color: #39adb5;">(</span>a8<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">8855.0</div>
</div>

<p>类似于 <code>itertools</code> 库的 <code>accumulate()</code> 函数，可以使用通用函数对象的 <code>.accumulate()</code> 方法来存储每次计算的中间结果：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>add<span style="color: #39adb5;">.</span>accumulate<span style="color: #39adb5;">(</span>a9<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 5, 13, 18, 18, 18, 19, 26, 32, 34, 38], dtype=int32)</div>
</div>

<p>任何通用函数对象都可以使用 <code>.outer()</code> 方法获得两个不同输入数组的所有元素对的运算结果。例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>multiply<span style="color: #39adb5;">.</span>outer<span style="color: #39adb5;">(</span>a2<span style="color: #39adb5;">,</span> a7<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[  6.  -8.j,  12. -16.j,  24. -32.j,  60. -80.j],
       [  8.  -6.j,  16. -12.j,  32. -24.j,  80. -60.j],
       [ -4.  +0.j,  -8.  +0.j, -16.  +0.j, -40.  +0.j],
       [  0. -10.j,   0. -20.j,   0. -40.j,   0.-100.j]])</div>
</div>

<p>上一节提过：当使用数组索引修改值时，如果索引数组包含多个相同的索引元素，那么只有最后一次对索引位置的操作才有效。如果想要每次使用索引时立即执行给定的操作，可以使用通用函数的 <code>.at()</code> 方法：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a_cnt <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div>a_rnd <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>RandomState<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">).</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10000</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>add<span style="color: #39adb5;">.</span>at<span style="color: #39adb5;">(</span>a_cnt<span style="color: #39adb5;">,</span> a_rnd<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div><div>a_cnt</div></div>
</div>

<h2>广播规则</h2>

<h3>广播规则简介</h3>

<p>如果二元通用函数作用于两个数组，那么将对相应元素逐个计算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div><div>x2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">])</span></div><div>x1 <span style="color: #7c4dff;">+</span> x2</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([6, 6, 8])</div>
</div>

<p>这种操作很容易理解。但是二元操作也可以用于不同大小的数组，例如可以简单地将一个标量（可以认为是零维的数组）和一个数组相加：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x2 <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">4</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([9, 8, 9])</div>
</div>

<p><strong>广播规则</strong>(broadcasting rule)允许二元操作用于不同大小的数组。例如，甚至可以将一个一维数组与二维数组做运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>y1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>full<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">),</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)</span></div><div>x1 <span style="color: #7c4dff;">+</span> y1</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[3, 4, 5],
       [3, 4, 5],
       [3, 4, 5]])</div>
</div>

<p>广播规则并没有特别规定这两个数组的运算次序，其实质上是扩展了数组的形状，使两个数组形状匹配再做运算：当一维数组与标量运算时，标量将复制若干份形成一个形状匹配的一维数组；当一维数组与二维数组运算时，一维数组将自身复制若干份向着另一个维度扩展，从而匹配二维数组的形状。</p>

<p>以下是 <var type="module">numpy</var> 官网提供的一个很好的图解，来表示广播时的形状扩展：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/04-broadcasting-2.png" alt="">
</figure>

<p>更复杂的情况涉及到对两个数组的同时广播。例如对一个行向量和一个列向量做运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x3 <span style="color: #7c4dff;">=</span> x1<span style="color: #39adb5;">[:,</span> np<span style="color: #39adb5;">.</span>newaxis<span style="color: #39adb5;">]</span></div><div>x1 <span style="color: #7c4dff;">+</span> x3</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[2, 3, 4],
       [3, 4, 5],
       [4, 5, 6]])</div>
</div>

<p><code>x1</code> 必须复制自身以扩展到二维，但 <code>x3</code> 也需要在第二个维度扩展以匹配出一个公共的形状。</p>

<h3>广播规则的原理</h3>

<p><var type="module">numpy</var> 的广播遵循一套严格的规则，这套规则是为了决定两个数组间的操作：</p>

<ul>
    <li>规则 1 ：如果两个数组的维度不相同，那么更小维度的数组首先需要将自身提高一个维度（形状在左边补 1 ）；</li>
    <li>规则 2 ：如果两个数组的形状还是不匹配，那么数组将会沿着只有一个元素（形状值为 1 ）的维度将这个元素复制若干份，以扩展并匹配另外一个数组的形状；</li>
    <li>规则 3 ：如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度只有一个元素，那么会引发异常。</li>
</ul>

<p>接下来看几个广播的示例。对于以下两个相加的数组：</p>

<table>
    <tr>
        <td class="code">l.shape == (2, 3)</td>
        <td class="code">r.shape == (3,)</td>
    </tr>
</table>

<p>根据规则 1 ，数组 <code>r</code> 的维度更小，因此需要提升一个维度（在其左边补 1 ）：</p>

<table>
    <tr>
        <td class="code">l.shape == (2, 3)</td>
        <td class="code">r.shape => (1, 3)</td>
    </tr>
</table>

<p>根据规则 2 ，第一个维度不匹配，因此扩展该维度以匹配数组：</p>

<table>
    <tr>
        <td class="code">l.shape == (2, 3)</td>
        <td class="code">r.shape => (2, 3)</td>
    </tr>
</table>

<p>现在两个数组形状匹配了，最终结果也就是该形状。</p>

<p>再来看一个示例，对于一个行向量和一个列向量：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 1)</td>
        <td class="code">r.shape == (3,)</td>
    </tr>
</table>

<p>根据规则 1 ，在数组 <code>r</code> 的左边补 1 ：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 1)</td>
        <td class="code">r.shape => (1, 3)</td>
    </tr>
</table>

<p>根据规则 2 ，扩展其值为 1 的维度匹配数组 <code>l</code> ：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 1)</td>
        <td class="code">r.shape => (3, 3)</td>
    </tr>
</table>

<p>这个时候两个数组的形状仍然不匹配。不过数组 <code>l</code> 还有元素个数为 1 的维度，因此根据规则 2 ，继续扩展其值为 1 的维度匹配数组 <code>r</code> ：</p>

<table>
    <tr>
        <td class="code">l.shape => (3, 3)</td>
        <td class="code">r.shape == (3, 3)</td>
    </tr>
</table>

<p>现在两个数组形状匹配了，并且得到一个公共的形状。</p>

<p>最后看一个类似的相加：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 2)</td>
        <td class="code">r.shape == (3,)</td>
    </tr>
</table>

<p>根据规则 1 ，同样在数组 <code>r</code> 的左边补 1 ：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 2)</td>
        <td class="code">r.shape => (1, 3)</td>
    </tr>
</table>

<p>根据规则 2 ，在数组 <code>r</code> 的第一个维度进行扩展，以匹配数组l的维度：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 2)</td>
        <td class="code">r.shape => (3, 3)</td>
    </tr>
</table>

<p>现在根据规则 3 ，最终的形状还是不匹配，但是也没有任何一个数组的维度值为 1 ，因此这样的两个数组相加会产生错误：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x4<span style="color: #39adb5;">,</span> y4 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>ones<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)),</span> np<span style="color: #39adb5;">.</span>ones<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,))</span></div><div><span style="color: #39adb5;font-weight: bold;">try</span><span style="color: #39adb5;">:</span></div><div>&#160; &#160; x4 <span style="color: #7c4dff;">+</span> y4</div><div><span style="color: #39adb5;font-weight: bold;">except</span> <span style="color: #8796b0;">Exception</span> <span style="color: #39adb5;font-weight: bold;">as</span> e<span style="color: #39adb5;">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span>e<span style="color: #39adb5;">.</span>__class__<span style="color: #39adb5;">,</span> e<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'ValueError'> operands could not be broadcast together with shapes (3,2) (3,) </div>
</div>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://numpy.org/doc/stable/user/basics.ufuncs.html">https://numpy.org/doc/stable/user/basics.ufuncs.html</a>
</p>

<p>
    <a href="https://numpy.org/doc/stable/user/basics.broadcasting.html">https://numpy.org/doc/stable/user/basics.broadcasting.html</a>
</p>
<p><a rel="nofollow" href="/archives/800">Python数据分析-numpy04:通用函数与广播规则</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/800/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy03:数组索引与切片</title>
		<link>/archives/795</link>
					<comments>/archives/795#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 05 Oct 2022 03:00:55 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=795</guid>

					<description><![CDATA[<p>数组的索引与切片 数组的索引 类似 Python 的&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/795">Python数据分析-numpy03:数组索引与切片</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>数组的索引与切片</h2>

<h3>数组的索引</h3>

<p>类似 Python 的列表，<var type="module">numpy</var> 中的数组也可以用中括号指定获取索引值位置的元素。索引值同样从零开始计数，且可以使用负数索引获取末尾元素：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">arange</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> a1</span><span style="color: #39adb5;">[</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0 4 8</div>
</div>

<p>不同与 Python 的嵌套列表，可以用逗号分隔的索引元组获取多维数组的某一元素，而不需要多次索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">arange</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span><span style="color: #90a4ae;">reshape</span><span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">))</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> a2</span><span style="color: #39adb5;">[</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
0 9 3</div>
</div>

<p>索引元组是多次切片的一个便捷替代，因此前面的值代表的是外层数组的索引。</p>

<p>可以用以上的索引方式为数组内某个位置的元素分配一个新值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">23</span></div><div><span style="color: #90a4ae;">a2</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8, 23, 10, 11]])</div>
</div>

<p>注意，<var type="module">numpy</var> 的数组是固定类型的，当将一个不同类型的元素插入数组时，它会被隐式地截短转换：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">10.55</span></div><div><span style="color: #90a4ae;">a1</span></div></div>

    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([10,  0,  3,  3,  7,  9])</div>
</div>

<h3>数组的切片</h3>

<p><var type="module">numpy</var> 的数组也支持切片语法，语法和 Python 对序列的切片一致。如果 <code>arr</code> 是一个数组，可以用以下语法对 <code>arr</code> 切片：</p>

<div class="code-template">
    arr[<em>start</em>:<em>stop</em>:<em>step</em>]
</div>

<p>对一维数组的切片很简单，与 Python 切片语法一致。例如以下几个简单示例：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">7</span><span style="color: #39adb5;">])</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[:</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">])</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">6</span><span style="color: #39adb5;">::</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[4 5 6]
[9 8 7 6]
[6 4 2 0]</div>
</div>

<p>多维数组的切片也采用类似索引的方法处理：可以用逗号分隔的切片对象来逐维切片，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[:</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> &nbsp;</span><span style="color: #a8a8a8;"># slice to line, slice to col</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[32,  5,  2],
       [ 7,  6,  8]])</div>
</div>

<p>该切片的意思是先在第二个维度（列方向）取前 2 项元素，再在第一个维度（行方向）取前三项元素。下面再给出一个更复杂的示例：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">::</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 4,  6],
       [ 8, 10]])</div>
</div>

<p>一种常见的需求是获取多维数组的特定行和列。这种情况下，可以用索引与切片组合起来实现该功能，用单个冒号“ <code>:</code> ”表示空切片（即不做切片，获取该维度的所有元素）：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[:,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 4, 8])</div>
</div>

<p>意思是不对第二个维度做切片（保留所有行），然后获取每行的首个元素。再如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:]</span><span style="color: #90a4ae;"> &nbsp;</span><span style="color: #a8a8a8;"># equals to a2[0]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 1, 2, 3])</div>
</div>

<p>在更高维的数组切片中，还可以使用省略号来表示多个连续的空切片，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a3 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">arange</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">*</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">*</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">).</span><span style="color: #90a4ae;">reshape</span><span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">))</span></div><div><span style="color: #90a4ae;">a3</span><span style="color: #39adb5;">[</span><span style="color: #90a4ae;">...</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> &nbsp;</span><span style="color: #a8a8a8;"># equals to a3[:, :, -1]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 4,  9, 14, 19],
       [24, 29, 34, 39],
       [44, 49, 54, 59]])</div>
</div>

<p>为了不发生歧义，一个切片中最多只能使用一个省略号。</p>

<p>最后关于数组切片需要注意的是，切片返回的也是数组的视图，因此在切片中修改元素也会影响原数组。如果确实需要得到一个副本子数组的话，可以对切片对象使用 <code>.copy()</code> 方法得到副本。</p>

<h3>切片与数组升维</h3>

<p>切片还可用于给数组增加维度。一种常见的需求是将一个数组变成二维数组的行或列，此时可以在数组切片中使用 <code>np.newaxis</code> 变量给数组添加新维度，具体操作为：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[:,</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">newaxis</span><span style="color: #39adb5;">][:</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[10],
       [ 1],
       [ 2]])</div>
</div>

<p>以上操作在 <code>np.newaxis</code> 对应的位置加上了一个维度，使数组的形状变成了 <code>(-1, 1)</code> ，形成二维数组（列向量）。</p>

<p>可以结合以下升维再切片降维的过程理解，两个切片互为逆过程：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #90a4ae;">np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">newaxis</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:,</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">newaxis</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">newaxis</span><span style="color: #39adb5;">][</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([10,  1,  2,  3,  4,  5,  6,  7,  8,  9])</div>
</div>

<p><code>np.newaxis</code> 实际上是 <code>None</code> 的别名。该过程虽然是升维，但得到的也是数组的视图。</p>

<h2>高级索引机制</h2>

<h3>数组索引</h3>

<p>接下来简单介绍另外一种索引方式<strong>数组索引</strong>，也称作花哨的索引(fancy indexing)。花哨的索引和前面那些简单的索引非常类似，但是传递的是索引数组，而不是单个标量。这种强大的索引能够快速获得并修改复杂的数组值的子数据集。</p>

<p>如果在索引中传递单个列表或数组，它包括的元素会被当做索引值，可以获取若干元素构成的数组（视图）：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">8</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([10,  1,  2,  4,  8,  9])</div>
</div>

<p>数组索引得到的数组形状与索引的形状一致，而不是与原数组的形状一致：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">ind1 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">array</span><span style="color: #39adb5;">([[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">8</span><span style="color: #39adb5;">]])</span></div><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #90a4ae;">ind1</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[10,  1],
       [ 5,  8]])</div>
</div>

<p>这种索引方式也适用于多维数组，不过多维数组下的数组索引是这样工作的：如果向索引内传入多个数组，那么每个数组分别确定每个维度的索引。例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 4, 23, 11])</div>
</div>

<p>以上两个数组结合确定了三个位置：[1, 0] [2, 1] 和 [2, 3] 。</p>

<p>可以将普通索引、切片和数组索引组合使用，使数组在某些维度做普通索引，某些维度做切片，某些维度用数组索引。例如，索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([4, 5, 6])</div>
</div>

<p>取第二行的数组中除最后一个元素外的所有元素，但不改变数组间的嵌套关系。再如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 4,  7],
       [ 8, 11]])</div>
</div>

<p>取第一行及往后的第一个和最后一个元素，但不改变数组间的嵌套关系。</p>

<h3>用数组索引修改值</h3>

<p>切片和数组索引可以用于获取部分元素，并且返回的是数组视图。如果对视图内的元素赋值，可以批量修改数组的一部分数据，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">20</span></div><div><span style="color: #90a4ae;">a1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([20, 20, 20, 20, 20,  5,  6,  7,  8,  9])</div>
</div>

<p>可以做任意的赋值操作，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">//=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span></div><div><span style="color: #90a4ae;">a1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([5, 5, 5, 5, 5, 5, 6, 7, 8, 9])</div>
</div>

<p>数组索引有一种特殊情况，那就是对同一个位置做了多次索引，导致重复获取该位置的值。如果对一个位置做重复的赋值，会导致前面的赋值被覆盖：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[[</span><span style="color: #f76d47;">9</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">13</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 5,  5,  5,  5,  5,  5,  6,  7,  8, 13])</div>
</div>

<p>因为该操作对最后一个位置的元素赋值了两次。覆盖的本质是只有最后一次对元素的操作才有效，因此对同一个元素的多次复合运算赋值不会累计起效：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">10</span></div><div><span style="color: #90a4ae;">a1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([-5,  5,  5,  5,  5,  5,  6,  7,  8, 13])</div>
</div>

<p>本节对数组的索引机制暂时到这边结束。下一节将介绍通用函数和数组的广播机制，可以结合数组索引做一些更复杂的操作。</p>
<p><a rel="nofollow" href="/archives/795">Python数据分析-numpy03:数组索引与切片</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/795/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
