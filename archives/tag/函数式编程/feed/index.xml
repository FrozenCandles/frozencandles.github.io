<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>函数式编程归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/feed?simply_static_page=3761" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Mon, 12 Dec 2022 12:20:13 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>函数式编程归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Python函数式编程10 functools模块：高阶函数工具</title>
		<link>/archives/296</link>
					<comments>/archives/296#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Tue, 07 Jun 2022 05:53:18 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Python标准库]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=296</guid>

					<description><![CDATA[<p>functools 库包含许多实用的函数操作工具，并&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/296">Python函数式编程10 functools模块：高阶函数工具</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p><code>functools</code> 库包含许多实用的函数操作工具，并且它们都是高阶函数。</p>
<h2>常用函数</h2>
<h3>lru_cache：缓存结果</h3>
<p><code>@lru_cache(maxsize)</code> 装饰器能保存已有计算结果，从而加快函数运行，其中 LRU 指最近使用的(least recent used) 。该装饰器会将最近得到的计算结果保留在缓存中，并在必要时清除不常用的计算结果。</p>
<p>例如，以下是使用缓存改进后的递归形式的斐波那契数列函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">lru_cache</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">maxsize</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">1024</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">fibonacci_cached</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> n &lt; </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> n</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> fibonacci_cached(n - </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">) + fibonacci_cached(n - </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">)</span></div>
</div>
<p>接下来在 IPython 环境中对有无缓存的情况测试执行效率，结果为：</p>
<div class="codeblock code-console"><span class="codetoken ipython-in">In [1]:</span> def fibonacci_without_cache():<br />
...:     return fibonacci(34)<br />
...: def fibonacci_with_cache():<br />
...:     fibonacci_cached.cache_clear()<br />
...:     return fibonacci_cached(34)<br />
<span class="codetoken ipython-in">In [2]:</span> %timeit fibonacci_without_cache<br />
2.12 s ± 7.21 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)<br />
<span class="codetoken ipython-in">In [3]:</span> %timeit fibonacci_with_cache<br />
12.6 µs ± 67.8 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</div>
<p>注意，不能直接使用 <code>%timeit</code> 命令测试函数，因为它会多次执行取平均时间，而第一次执行后由于缓存的存在使后续结果直接从缓存中获取，干扰测试效果。因此，每次测试后都通过装饰器的 <code>.cache_clear()</code> 方法清空缓存。</p>
<p>从测试结果中可以看出，缓存的存在极大提升了递归函数的执行效率。</p>
<h3>partial：冻结参数</h3>
<p><code>partial(<em>func</em>, /, *<em>args</em>, **<em>kwargs</em>)</code> 可以将函数的部分参数固定，得到一个新的函数。</p>
<p>例如，如果想要设置打开一个文件时，永远是以 UTF-8 编码的形式打开，那么可以使用 <code>partial</code> 将 <code>open()</code> 函数的 <code><em>encoding</em></code> 参数固定，形成一个新的函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">uopen = partial(</span><span style="color: #8b56bf;">open</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">encoding</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">utf8</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
</div>
<p>这样每次确保都是以 UTF-8 编码对文件操作的：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> uopen(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">demo.txt</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">w</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> f:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; f.write(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f641.png" alt="🙁" class="wp-smiley" style="height: 1em; max-height: 1em;" />✯<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/26c8.png" alt="⛈" class="wp-smiley" style="height: 1em; max-height: 1em;" />⚝<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2602.png" alt="☂" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2601.png" alt="☁" class="wp-smiley" style="height: 1em; max-height: 1em;" />︎<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f636.png" alt="😶" class="wp-smiley" style="height: 1em; max-height: 1em;" /></span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
</div>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/10-unicode-txt.jpg" alt="" width="150"></figure>
<p><code>partial()</code> 非常适用于冻结高阶函数的函数参数，这种情况下，可以提前写好一个函数，从而让一个比较泛化的高阶函数具有更具体的功能，例如：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> operator </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> add, mul</span></div>
<div><span style="color: #8b56bf;">sum</span><span style="color: #405c79;"> = partial(reduce, add) </span></div>
<div><span style="color: #405c79;">prod = partial(reduce, mul) </span></div>
</div>
<p>该装饰器的本质就是给一部分参数提前赋值，也可以使用匿名函数实现类似的效果。</p>
<h3>singledispatch：单分派</h3>
<p><code>@singledispatch</code> 装饰器可以根据参数的类型指定不同的函数，可以在一定程度上使用泛型。</p>
<p>例如，假设要实现一个函数 <code>scale(<em>data</em>, <em>scalar</em>)</code> ，将数据缩放。但是传入的数据可能是一个数值，也可能是一个数组。那么就需要在函数内判断传入数据的类型。</p>
<p><code>@singledispatch</code> 装饰器则可以简化判断的流程，它可以根据参数类型的不同，指定调用不同的函数。为了实现这一点，需要先将目标函数装饰起来：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">singledispatch</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
</div>
<p>然后调用目标函数的 <code>@.register(<em>type</em>)</code> 方法作为装饰器，将不同类型的参数导向不同的函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">float</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">_scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">float</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> data * scalar</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">list</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">_scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x * scalar, data))</span></div>
</div>
<p>此时，如果传入的参数类型不同，那么就会被不同的函数调用了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; scale(0.7, 2)<br />
1.4<br />
&gt;&gt;&gt; scale(list(range(10)), 0.3)<br />
[0.0, 0.3, 0.6, 0.8999999999999999, 1.2, 1.5, 1.7999999999999998, 2.1, 2.4, 2.6999999999999997]</div>
<p>如果对一个分派函数同时使用多个装饰器，那么这些类型的参数都会汇合到这个函数中：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">tuple</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">list</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">_scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
</div>
<p>Python3.7 对该函数做了一些改进，如果已经提供了类型注解，那么可以直接使用方法对象作为装饰器，即 <code>@scale.register</code> 这种不调用的形式。</p>
<p>这种单分派函数可以在一定程度上实现函数签名效果，但可惜的是它只支持一个参数。</p>
<p>除此之外，functools 还包含一系列其它的高阶函数，例如<a href="/archives/239">第 4 节</a>中介绍到的 <code>reduce()</code> 函数、在介绍面向对象编程时装饰类的 <code>@total_ordering</code> 装饰器、Python3.9 新增的 <code>@cache</code> 装饰器，以及以上提到的装饰器都有用于方法的改版。更多标准库的介绍可以参阅 Python 标准库官方文档。</p>
<h2>参考资料</h2>
<p><a href="https://docs.python.org/3/library/functools.html">https://docs.python.org/3/library/functools.html</a></p>
<p>Python3 标准库 <code>functools</code> 官方文档</p>
<p><!-- finished(all):2022-06-02 --></p>
<p><a rel="nofollow" href="/archives/296">Python函数式编程10 functools模块：高阶函数工具</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/296/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程09 闭包和装饰器</title>
		<link>/archives/276</link>
					<comments>/archives/276#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 03 Jun 2022 03:07:51 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=276</guid>

					<description><![CDATA[<p>闭包 闭包的概念 在第 3 节中，介绍了高阶函数的概&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/276">Python函数式编程09 闭包和装饰器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>闭包</h2>
<h3>闭包的概念</h3>
<p>在<a href="/archives/246">第 3 节</a>中，介绍了高阶函数的概念，一个高阶函数可以返回另一个函数。但实际上，Python 的函数定义还有另一个有意思的地方：一个函数的定义可以嵌套在另一个函数之内，也就是说，如下所示的定义：</p>
<div class="codeblock code-template">
    <strong>def</strong> func(...):<br />
&nbsp; &nbsp; ...<br />
&nbsp; &nbsp; <strong>def</strong> inner_func(...):<br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; ...</div>
<p>是完全可以的。这种情况下，内部定义的函数会视为在函数内创建了一个类型为函数的局部对象。</p>
<p>嵌套定义的函数有一个特别的地方在于，嵌套函数可以使用函数内定义的局部变量；并且如果嵌套函数被当做结果返回时，如果调用这个返回结果，它可以访问到内部定义的局部变量。</p>
<p>以下展示了一个这样的情形，注意到在调用函数后，就将这个函数给删除了：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">func</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; n = </span><span style="color: #bf8b56;">10</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_n</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> n</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_n</span></div>
<div><span style="color: #405c79;">inner_func = func()</span></div>
<div><span style="color: #bf568b;font-weight: bold;">del</span><span style="color: #405c79;"> func</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(inner_func())</span></div>
</div>
<p>结果为：</p>
<div class="codeblock code-console">python -u demo.py<br />
10</div>
<p>可以看到，即便函数被删除后，内部函数依旧记录着函数提供的局部变量的信息。这种返回的函数包含外部函数绑定的变量，称为<strong>闭包</strong>(closure)。</p>
<p>闭包能够让内部函数记录局部变量的信息，本质上通过在内部函数中使用 <code>__closure__</code> 属性保存这些数据。</p>
<p>闭包的一个用途就是通过函数批量生成所需的参数。例如，以下函数利用闭包的特性，可以批量生成多项式函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> itertools </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> starmap</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">polinomial</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">coeffs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(starmap(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">i</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">coeff</span><span style="color: #405c79;">: coeff * x ** i,</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #8b56bf;">enumerate</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">reversed</span><span style="color: #405c79;">(coeffs)))</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner</span></div>
</div>
<p>这样可以通过控制几个参数得到不同的函数：</p>
<div class="codeblock code-console">&gt;&gt;&gt; regr = polinomial(2, 1)<br />
&gt;&gt;&gt; regr(3)<br />
7<br />
&gt;&gt;&gt; polinomial(4, 3, 7, 2)<br />
&lt;function polinomial.&lt;locals&gt;.inner at 0x0000023B89B85A60&gt;</div>
<h3>闭包和nonlocal声明</h3>
<p>函数内可能会处理全局变量，同理嵌套在其他函数中的函数也可能需要处理不在全局作用域中的外部变量：如果在嵌套函数内对不在全局作用域中的外部变量重新赋值，那么影响范围只会局限于嵌套函数中。</p>
<p>一般的函数使用 <code>global</code> 关键字来在函数内将一个变量声明为全局变量；Python3 引入了关键字 <code>nonlocal</code> ，它的作用效果类似：<code>nonlocal</code> 关键字可以声明一个变量为一个不在全局作用域中的外部变量声明，使得对该变量的重新赋值或修改的影响范围不局限于嵌套函数体内部。</p>
<h2>装饰器</h2>
<h3>装饰器的基本概念</h3>
<p><strong>装饰器</strong>(decorator)是 Python 的语法糖，其作用是增强函数的功能。在编写大型项目时，需要给很多函数加上某个相似功能，或是一些函数的某个基本功能需要重复使用，又或者需要将函数内某部分内容独立出来便于维护和更新，这些便可以使用函数的装饰器来实现。</p>
<p>装饰器可以在不改变函数原有的结构下，增强函数的功能。装饰器适用于以下两个场景：</p>
<ol>
<li>增强被装饰函数的功能</li>
<li>代码复用</li>
</ol>
<p>装饰器的思路可以从高阶函数开始。假设有函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">demo01</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">hello</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">demo02</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">hello</span><span style="color: #405c79;">'</span></div>
</div>
<p>在某个比较大的项目内，可能不知道这两个函数是在哪里执行的。现在需要增加这两个函数的功能，能让函数在调用时，显示函数名、调用时间、保存的局部变量等信息，但又希望不要逐个修改函数结构，否则这样会让工程量大大增加，而且容易出现疏忽。</p>
<p>这个时候，很自然地就会想到利用高阶函数。即新定义一个函数，它能够利用传入的函数对象输出其基本信息，然后再执行该函数。也就是说，对于这个高阶函数的需求有：</p>
<ul>
<li>它需要接受一个函数作为参数，这样在函数体内输出该函数的函数名</li>
<li>考虑到函数是要被调用的，所以高阶函数不能影响函数正常的调用功能，这就要求高阶函数返回结果必须要是传入的函数</li>
</ul>
<p>那么关于该提供调试信息的高阶函数便可以是这样：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">log</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; result = func()</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'[</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">strftime(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">%H:%M:%S</span><span style="color: #405c79;">"</span><span style="color: #405c79;">, localtime())</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">]'</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">' </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> returns </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">result</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
</div>
<p>测试运行的效果为：</p>
<div class="codeblock code-console">&gt;&gt;&gt; log(demo01)<br />
hello<br />
[21:31:49] demo01 returns None<br />
&gt;&gt;&gt; type(log(demo02))<br />
[21:31:50] demo02 returns hello<br />
&lt;class 'str'&gt;</div>
<p>该函数基本实现了要求的功能，即不修改原函数的定义、不影响原函数的调用，同时又可以输出原函数名。</p>
<p>不过以上定义的高阶函数存在一定问题，例如对于以下这些函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">double = polinomial(</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">triple = polinomial(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">)</span></div>
</div>
<p>这些函数是含有参数的，如果使用原先的高阶函数，则会因为高阶函数传入的参数不再是一个函数名了，而是一个返回值而出错。因此，这样一来对高阶函数的需求又增加了：高阶函数应该能支持函数的传入参数功能。</p>
<p>这就可以使用之前介绍闭包时提到过的批量生产函数的用法：可以让函数在生产时不改变其用法，只输出基本信息，也就是说在高阶函数内部定义一个嵌套函数，让高阶函数传入的参数来供嵌套函数使用，再由返回的嵌套函数来执行需要的传参功能。因此，该高阶函数便可以是：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">log</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; result = func()</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'[</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">strftime(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">%H:%M:%S</span><span style="color: #405c79;">"</span><span style="color: #405c79;">, localtime())</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">]'</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">' </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> returns </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">result</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_func</span></div>
</div>
<p>注意到定义装饰器函数时，其传参是依靠内层函数来完成的，因此嵌套函数的参数应该与装饰器函数的内层函数的参数数量相一致。这里使用可变参数 <code>*args</code> 和 <code>**kwargs</code> 组合，就可以表示任意的传参情况。接下来的一个技巧就是使用覆盖原有的函数定义，使用添加功能后的同名函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">double = log(double)</span></div>
<div><span style="color: #405c79;">triple = log(triple)</span></div>
</div>
<p>这样不但可以正常地进行传参功能，还可以利用生产得到的具有更多功能的函数替换原有函数，来执行更高级的效果：</p>
<div class="codeblock code-console">&gt;&gt;&gt; triple(3) * 8<br />
[21:41:34] inner returns 9<br />
72</div>
<p>如果不需要这些功能了，就把生成与覆盖的过程去掉即可。</p>
<p>这就是装饰器的基本思路，使用嵌套函数实现的生产函数效果来替换原有函数，实现更丰富的功能。不过这种使用高阶函数的方式略显复杂，而且还需要定义很多新函数来执行传入参数功能。实际上，Python 中可以使用装饰器来很好地实现以上操作。相对于赋值创建一个新函数的方法去改变原有函数的功能，可以在函数定义的前一行，通过 <code>@</code> 符号加上高阶函数名，来作为一个函数的装饰器。例如，以上修改后的高阶函数便可以作为一个装饰器来装饰函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">log</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">four_times</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> x * </span><span style="color: #bf8b56;">4</span></div>
</div>
<p>是 Python 提供的一种更简洁的写法。也就是说，函数的装饰器使用下列形式来装饰一个函数：</p>
<div class="codeblock code-template">
    @decorator<br />
<strong>def</strong> function():<br />
&nbsp; &nbsp; ...</div>
<p>等价于下面这种普通形式：</p>
<div class="codeblock code-template">
    <strong>def</strong> function():<br />
&nbsp; &nbsp; ...<br />
function = decorator(function)</div>
<p>装饰器实际上就是一个函数，它将一个函数装饰成一个它修改之后的新的函数。需要注意的是，装饰器的函数是一个高阶函数，且必须要有一个位置参数。</p>
<p>可以看出，<mark>装饰器可以在不影响函数结果的同时，为函数增加一些新的功能</mark>，也就是“装饰”的字面意义。</p>
<p>下图表达了这种装饰的思路，可以看到装饰器就像一张图片的花边，让图片内容变得更丰富，但又不改变图片原有的含义：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/06/09-decorator-concept.jpg" alt="" width="330"><figcaption>图片素材来源于网络</figcaption></figure>
<p>例如，以下实现了一个装饰器 <code>@timer</code> ，可以在调用函数时同时检查函数运行的时间，从而统计出是哪一个函数拖慢了程序的运行：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">timer</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">wrapper</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">args</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">kwargs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; start = perf_counter()</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; result = func(*args, **kwargs)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> execs </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">perf_counter() - start</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> second(s)'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> wrapper</span></div>
</div>
<p>一个函数的定义可以使用多个装饰器，结果与装饰器的位置顺序有关。例如：</p>
<div class="codeblock code-template">
    @outer_decor<br />
@inner_decor<br />
<strong>def</strong> func(..):<br />
&nbsp; &nbsp; ...</div>
<p>它等价于：</p>
<div class="codeblock code-template">
    <strong>def</strong> func(...):<br />
&nbsp; &nbsp; ...<br />
func = outer_decor(inner_decor(func))</div>
<p>每一次添加装饰器，函数的功能就又丰富了一层。</p>
<h3>带参数的装饰器</h3>
<p>由于装饰器的本质就是高阶函数，当然可以在装饰函数时就加上参数。让装饰器加上参数可以进一步丰富装饰器的功能。</p>
<p>前文说过，装饰器</p>
<div class="codeblock code-template">
    @decorator<br />
<strong>def</strong> function():<br />
&nbsp; &nbsp; ...</div>
<p>等价于下面这种普通形式：</p>
<div class="codeblock code-template">
    <strong>def</strong> function():<br />
&nbsp; &nbsp; ...<br />
function = decorator(function)</div>
<p>如果此时让装饰器加上一个参数，例如 <code>@decorator(<em>arg</em>)</code> 。那么此时，真正作为高阶函数的表达式应该是 <code>@decorator(<em>arg</em>)</code> ，这个表达式可以接收一个函数作为参数，并且生成一个新的函数。也就是说，这个高阶函数再次嵌套了一个函数。</p>
<p>例如，以下修改之前定义的 <code>log</code> 函数，使它能够在装饰函数时可以通过参数自由控制显示的内容。这样，该函数便可以再嵌套一次，以完成二次传参作用：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">log</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">time</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">check_arg</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">False</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">outer_wrapper</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_wrapper</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">args</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">kwargs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = func(*args, **kwargs)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> time:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'[</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">strftime(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">%H:%M:%S</span><span style="color: #405c79;">"</span><span style="color: #405c79;">, localtime())</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">]'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">end</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"> </span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">end</span><span style="color: #405c79;">=</span><span style="color: #405c79;">''</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> check_arg:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">(</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, *args, *[</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">k</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">=</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">v</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> k, v in kwargs.items()], </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">)</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">end</span><span style="color: #405c79;">=</span><span style="color: #405c79;">''</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">' returns </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">result</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_wrapper</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> outer_wrapper</span></div>
</div>
<p>先分析一下该函数，当该函数作为装饰器装饰 <code>function</code> 函数时，等价于这种形式：</p>
<div class="codeblock code-template">
    function = log(<em>time</em>, <em>check_arg</em>)(function)</div>
<p>该函数自左向右执行，首先将 <code>log(<em>time</em>, <em>check_arg</em>)</code> 返回 <code>outer_wrapper</code> ，变成 <code>outer_wrapper(function)</code> ，进一步执行返回 <code>inner_wrapper</code> ，赋值给变量 <code>function</code> ，因此传参和执行都由 <code>inner_wrapper</code> 来完成，该函数在执行时，会调用 <code>log(<em>time</em>, <em>check_arg</em>)</code> 接收的参数，并给函数增加更为复杂的功能。</p>
<p>以下编写了两个函数：<code>isprime()</code> 用于判断一个数是否为质数；<code>prime_factorization()</code> 则根据结果将一个大数分解为它的质因数。如果给第一个函数加上 <code>@log</code> 装饰器，那么在调用函数时就可以很清楚地看到程序执行的过程：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">log</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">check_arg</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">isprime</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">number</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">int</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, number // </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> number % i == </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">False</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">True</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">prime_factorization</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">number</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">int</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; factors = []</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">while</span><span style="color: #405c79;"> not isprime(number):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, number // </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> number % i == </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; factors.append(i)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; number //= i</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">break</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; factors.append(number)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> factors</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(prime_factorization(</span><span style="color: #bf8b56;">6108984</span><span style="color: #405c79;">))</span></div>
</div>
<p>通过结果可以观察到质因数的分解过程：</p>
<div class="codeblock code-console">python -u demo.py<br />
[11:05:32] isprime( 6108984 ) returns False<br />
[11:05:32] isprime( 3054492 ) returns False<br />
[11:05:32] isprime( 1527246 ) returns False<br />
[11:05:32] isprime( 763623 ) returns False<br />
[11:05:32] isprime( 254541 ) returns False<br />
[11:05:32] isprime( 84847 ) returns False<br />
[11:05:32] isprime( 12121 ) returns False<br />
[11:05:32] isprime( 713 ) returns False<br />
[11:05:32] isprime( 31 ) returns True<br />
[2, 2, 2, 3, 3, 7, 17, 23, 31]</div>
<p>当然，以上编写的程序运行效率还有许多优化空间，不过对于较小的数字还算够用。</p>
<h3>完善装饰器</h3>
<p>装饰器的基本结构已经大致完成，但是仍然有一些小缺陷。例如，以下装饰器可以将任意函数的返回值包装成 HTML 标签：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">tag</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">attrs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">outer_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">contain</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr = </span><span style="color: #405c79;">''</span><span style="color: #405c79;">.join([</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">' </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">k</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">="</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">v</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">"'</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> k, v in attrs.items()])</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">&lt;</span><span style="color: #bf8b56;">{0}{1}</span><span style="color: #56bf8b;">&gt;</span><span style="color: #bf8b56;">{2}</span><span style="color: #56bf8b;">&lt;/</span><span style="color: #bf8b56;">{0}</span><span style="color: #56bf8b;">&gt;</span><span style="color: #405c79;">'</span><span style="color: #405c79;">.format(tag, attr, func(contain))</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_func</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> outer_func</span></div>
</div>
<p>这个装饰器本身没有任何问题，以下是一个装饰示例：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">p</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">a</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">href</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">javascript: upload(this);</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">legalize</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #405c79;">"""</span><span style="color: #56bf8b;">Make the string a valid filename</span><span style="color: #405c79;">"""</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> sub(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #bf8b56;">[</span><span style="color: #568bbf;">\\\/</span><span style="color: #bf8b56;">:*?"&lt;&gt;|]</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"> </span><span style="color: #405c79;">'</span><span style="color: #405c79;">, string)</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(legalize(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">&lt;User&gt;: name</span><span style="color: #405c79;">'</span><span style="color: #405c79;">))</span></div>
</div>
<p>这里为函数提供了帮助文档。运行结果为：</p>
<div class="codeblock code-console">python -u demo.py<br />
&lt;p&gt;&lt;a href="javascript: upload(this);"&gt; User   name&lt;/a&gt;&lt;/p&gt;</div>
<p>但是如果查看它的帮助文档，结果就变得奇怪了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; help(legalize)<br />
Help on function inner_func in module __main__:</p>
<p>inner_func(contain: str)</p>
</div>
<p>这个帮助文档看起来根本不是之前编写的函数。这是因为，当装饰器装饰函数后，被装饰函数被当做一个参数传递给了装饰器，然后就被同名变量取代了，实际上执行的是装饰器提供的 <code>inner_func()</code> 函数，因此获取的是这个函数的帮助文档。</p>
<p>要想完善该问题，可以在装饰器函数内部返回 inner_func 前进行一些改动，手动将原有函数的属性拷贝给返回的函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">tag</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">attrs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">outer_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">contain</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; inner_func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #405c79;"> = func.</span><span style="color: #8b56bf;">__name__</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; inner_func.</span><span style="color: #8b56bf;">__doc__</span><span style="color: #405c79;"> = func.</span><span style="color: #8b56bf;">__doc__</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># too many attributes need to update</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_func</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> outer_func</span></div>
</div>
<p>这样的做法稍显复杂，因为函数的属性实际上是非常多的（例如，<code>__dict__</code> 包含了各种额外属性，如果不更新会导致这些属性丢失）。实际上，Python 提供了一种方法，可以快速拷贝函数对象的所有属性给另一个函数，通过使用 <code>functools</code> 模块的 <code>@wraps()</code> 装饰器来完成该操作：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> functools </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> wraps</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">tag</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">attrs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">outer_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; @</span><span style="color: #8b56bf;">wraps</span><span style="color: #405c79;">(func)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">contain</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_func</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> outer_func</span></div>
</div>
<p>这样再次检查帮助文档的结果就正确了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; help(legalize)<br />
Help on function legalize in module __main__:</p>
<p>legalize(string)<br />
Make the string a valid filename</p>
</div>
<p>至此，装饰器便已经非常完善了。装饰器作为在不修改函数本义的情况下，可以增加函数的功能，有效增加了代码的复用性，并使写出的代码结构更清晰。在一些大型框架中，通过编写强大的装饰器，只需要非常简短的函数就可以装饰出非常丰富的功能，大大降低了编程的复杂程度。</p>
<p>例如，以下是第三方框架 Flask 的一个非常简单的示例：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> flask </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> Flask, render_template</span></div>
<div><span style="color: #405c79;">app = Flask(</span><span style="color: #8b56bf;">__name__</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">app</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">route</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">/</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">methods</span><span style="color: #405c79;">=[</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">GET</span><span style="color: #405c79;">'</span><span style="color: #405c79;">])</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">main</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> render_template(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">index.html</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">__name__</span><span style="color: #405c79;"> == </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">__main__</span><span style="color: #405c79;">'</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; app.run(</span><span style="color: #bf8b56;">debug</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">)</span></div>
</div>
<p>只需要一个装饰器，便可以将一个只有两行的函数变成一个网络应用，当在浏览器中访问本地端口时就会将 <code>index.html</code> 中的内容显示在浏览器上，但在代码中几乎完全不用涉及这方面的内容，这就是装饰器的强大之处。</p>
<p><!-- finished(all):2022-06-01 --></p>
<p><a rel="nofollow" href="/archives/276">Python函数式编程09 闭包和装饰器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/276/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程08 itertools模块：更多迭代器</title>
		<link>/archives/270</link>
					<comments>/archives/270#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 01 Jun 2022 04:46:00 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Python标准库]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=270</guid>

					<description><![CDATA[<p>itertools 模块中包含大量迭代器函数，是处理&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/270">Python函数式编程08 itertools模块：更多迭代器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p><code>itertools</code> 模块中包含大量迭代器函数，是处理数据的非常好用的工具。</p>
<blockquote><p>生成器是迭代器的一个部分，迭代器和生成器的用途是一致的，只是迭代器并不都是使用 <code>yield</code> 这种关键字的方式定义。可以用生成器的概念来理解它。</p></blockquote>
<h2>无限迭代器</h2>
<p>以下迭代器如果在迭代时不使用 <code>break</code> 终止或遇到错误，那么它会一直执行下去。</p>
<h3>count：计数迭代器</h3>
<p>内置的 <code>range()</code> 函数需要定义范围的上界，而下限和步长值可选。count(start=0, step=1) 函数与之相反，需要给出可选的起始值和步长，无须定义上界。在停止之前，该生成器会一直执行下去。</p>
<p><code>count()</code> 函数的参数可以是浮点数，但是由于进制带来的舍入误差会随着程序的运行逐渐累积，因此尽量在较大的计数过程中慎用浮点数计数，或者使用整型计数再转换为浮点数的方式。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">count(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 10 11 12 13 14 ...</span></div>
<div><span style="color: #405c79;">count(</span><span style="color: #bf8b56;">2.5</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0.5</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 2.5 3.0 3.5 ...</span></div>
</div>
<h3>cycle：循环迭代器</h3>
<p><code>cycle()</code> 函数重复循环一组值，可用它循环数据集标识符对数据集进行分组。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">cycle(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; A B C A B C A B C ...</span></div>
</div>
<h3>repeat：重复迭代器</h3>
<p><code>repeat(<em>elem</em>, <em>n</em>=None)</code> 用于重复单个值，不过也可以通过第二个参数将其限制为有限的迭代器。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">repeat(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 10 10 10</span></div>
</div>
<h2>有限迭代器</h2>
<p>有限迭代器更多，也更常用。它们具体的长度一般取决于给定序列的长度或特征。</p>
<h3>accumulate：归约迭代器</h3>
<p><code>accumulate()</code> 函数基于给定的函数返回一个可迭代对象，将一系列归约值汇总在一起，遍历迭代器得出当前汇总值。以下给出了一个这样的示例：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">accumulate([</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 1 3 6 10 15</span></div>
</div>
<p><code>accumulate()</code> 函数的第二个参数 <code>func</code> 的默认行为是加法，也可以改成其它的归约函数。</p>
<h3>chain：组合迭代器</h3>
<p><code>chain()</code> 函数将多个迭代器组合为单个迭代器，可以用于一次处理多个集合。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">chain(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">), </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">20</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">)) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 0 1 2 3 4 10 12 14 16 18</span></div>
</div>
<p>如果多个迭代器被放在一个可迭代对象内，那么还可以使用 chain.from_iterable() 类方法取代以上这种可变参数的形式。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">chain.from_iterable([</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">DEF</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; A B C D E F</span></div>
</div>
<h3>groupby：分组迭代器</h3>
<p><code>groupby(<em>iterable</em>, <em>key</em>=None)</code> 通过对每个元素应用 <code><em>key</em></code> 函数求值，并根据求值结果将一个迭代器切分为多个小迭代器，具体的规则为：如果后一个元素的 key 返回值等于前一个元素的 key 返回值，会将这两个元素放在同一个分组中；如果与前一个元素的 key 值不同，则当前分组结束，将当前元素放到新的分组中。</p>
<p>该生成器每一次迭代的结果都是一个 <code>(key, group)</code> 形式的元组，其中第二个元素是生成器。</p>
<p>以下是一个简单的示例，将一个排序好的列表按十位分组：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> random </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> randint</span></div>
<div><span style="color: #405c79;">target = </span><span style="color: #8b56bf;">filter</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">_</span><span style="color: #405c79;">: randint(</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">), </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">50</span><span style="color: #405c79;">))</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in groupby(target, </span><span style="color: #bf8b56;">key</span><span style="color: #405c79;">=</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x // </span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(i[</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">], </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">(i[</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]))</span></div>
</div>
<p>结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
0 [2, 4, 6]<br />
1 [10, 11, 13, 16, 19]<br />
2 [23, 26, 27, 29]<br />
3 [30, 31, 32, 35, 37, 38]<br />
4 [40, 41, 46, 47, 48]</div>
<p>因此，<code>groupby()</code> 函数的输入列表必须是排序好的，以确保分在一组中的元素是相邻的。</p>
<h3>compress：选择迭代器</h3>
<p>内置的 <code>filter()</code> 根据函数求值结果为真或假决定是否保留元素，而 <code>compress(<em>data</em>, <em>selectors</em>)</code> 则根据 <code><em>selectors</em></code> 可迭代对象给出的布尔值决定是否保留同一位置处的元素。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">compress(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCDEF</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; A C E</span></div>
</div>
<h3>islice：切片迭代器</h3>
<p><code>islice(<em>iterable</em>, <em>start</em>=0, <em>stop</em>, <em>step</em>=1)</code> 函数可以对迭代器实现切片操作，就像 <code>slice</code> 类对序列实现切片操作一样。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">islice(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCDEFG</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># =&gt; C D E F G</span></div>
<div><span style="color: #405c79;">islice(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCDEFG</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">None</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; B D F</span></div>
</div>
<h3>dropwhile和takewhile：过滤状态迭代器</h3>
<p><code>dropwhile(<em>predicate</em>, <em>iterable</em>)</code> 和 <code>takewhile(<em>predicate</em>, <em>iterable</em>)</code> 都是过滤函数，其用法是：从 <code><em>predicate</em></code> 函数给定的一种布尔模式开始，当布尔状态变换后，则函数的过滤规则也发生变化。<code>dropwhile()</code> 函数开始采用拒绝模式，当谓词函数变为 <code>False</code> 时切换并一直保持为通过模式。<code>takewhile()</code> 则从通过模式开始，当谓词函数变为 <code>False</code> 时切换并一直保持为拒绝模式。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">dropwhile(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x &lt; </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 6 4 1</span></div>
<div><span style="color: #405c79;">takewhile(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x &lt; </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 1 4</span></div>
</div>
<p>这两个函数的一种常见用法是过滤掉文件的头部和尾部的一些无用信息。例如，假设有如下附加了额外头部信息的 CSV 文件：</p>
<div class="vscode-block">
<div><span style="color: #24292e;">Author: Hello</span></div>
<div><span style="color: #24292e;">Date: 2022-05-31</span></div>
<div><span style="color: #24292e;">sepal_length,</span><span style="color: #d73a49;">sepal_width,</span><span style="color: #6f42c1;">petal_length,</span><span style="color: #a8a8a8;">petal_width,</span><span style="color: #032f62;">species</span></div>
<div><span style="color: #24292e;">5.1,</span><span style="color: #d73a49;">3.5,</span><span style="color: #6f42c1;">1.4,</span><span style="color: #a8a8a8;">0.2,</span><span style="color: #032f62;">Iris-setosa</span></div>
<div><span style="color: #24292e;">4.9,</span><span style="color: #d73a49;">3.0,</span><span style="color: #6f42c1;">1.4,</span><span style="color: #a8a8a8;">0.2,</span><span style="color: #032f62;">Iris-setosa</span></div>
<div><span style="color: #24292e;">6.4,</span><span style="color: #d73a49;">3.2,</span><span style="color: #6f42c1;">4.5,</span><span style="color: #a8a8a8;">1.5,</span><span style="color: #032f62;">Iris-versicolor</span></div>
<div><span style="color: #24292e;">6.9,</span><span style="color: #d73a49;">3.1,</span><span style="color: #6f42c1;">4.9,</span><span style="color: #a8a8a8;">1.5,</span><span style="color: #032f62;">Iris-versicolor</span></div>
</div>
<p>那么可以使用如下方式处理它：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">open</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">header.csv</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">r</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> f:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; data = dropwhile(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">row</span><span style="color: #405c79;">: </span><span style="color: #bf568b;font-weight: bold;">not</span><span style="color: #405c79;"> row[</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">].isdigit(), f)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">row</span><span style="color: #405c79;">: row.replace(</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\n</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">''</span><span style="color: #405c79;">).split(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">,</span><span style="color: #405c79;">'</span><span style="color: #405c79;">), data):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(i)</span></div>
</div>
<p>该程序检查 CSV 文件的每一行（注意文件对象也是可迭代对象，每次迭代结果为文件中的一行），判断每一行的首字符是不是数字，并将头部非数字开头的行丢弃。其结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
['5.1', '3.5', '1.4', '0.2', 'Iris-setosa']<br />
['4.9', '3.0', '1.4', '0.2', 'Iris-setosa']<br />
['6.4', '3.2', '4.5', '1.5', 'Iris-versicolor']<br />
['6.9', '3.1', '4.9', '1.5', 'Iris-versicolor']</div>
<h2>改进的迭代器</h2>
<p>以下迭代器是对内置迭代器的补充或改进。</p>
<h3>zip_longest：不截短的zip</h3>
<p>在<a href="/archives/239">第 4 节</a>介绍了 <code>zip()</code> 迭代器，它接收多个序列，返回结果的长度是其中最短序列的长度。而 <code>zip_longest(*<em>iterables</em>, <em>fillvalue</em>=None)</code> 则为较短的序列填充 <code><em>fillvalue</em></code> 参数提供的默认值，直到遍历完最长的序列。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">zip_longest(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCD</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">xy</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">fillvalue</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">*</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; Ax By C* D*</span></div>
</div>
<h3>filterfalse：filter的反相过滤</h3>
<p>内置的 <code>filter()</code> 迭代器会保留所有求值结果为 <code>True</code> 的数据；而 <code>filterfalse()</code> 则与之相反，它会保留所有求值结果为 <code>False</code> 的数据。</p>
<div class="vscode-block">
<div><span style="color: #8b56bf;">filter</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x % </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">)) &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># =&gt; 1 3 5 7 9</span></div>
<div><span style="color: #405c79;">filterfalse(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x % </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">)) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 0 2 4 6 8</span></div>
</div>
<p>通过组合这两个迭代器，可以方便地将输入数据分为“保留”和“舍弃”两组。</p>
<h3>starmap：平铺的map</h3>
<p>内置的 <code>map()</code> 迭代器可以接收多个可迭代对象，它将每一个可迭代对象中的元素组合为所需的参数；而 <code>starmap()</code> 迭代器只接收一个可迭代对象，它将其中元素展开后变成所需的参数。以下给出了一个这样的示例：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">starmap(</span><span style="color: #8b56bf;">pow</span><span style="color: #405c79;">, [(</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">,</span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">), (</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">,</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">), (</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">,</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">)]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 32 9 1000</span></div>
</div>
<p>因此，使用 <code>zip()</code> 迭代器可以非常简单地将 <code>map()</code> 变成 <code>starmap()</code> ：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">starmap</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">function</span><span style="color: #405c79;">, *</span><span style="color: #bf8b56;">iterables</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(function, </span><span style="color: #8b56bf;">zip</span><span style="color: #405c79;">(iterables))</span></div>
</div>
<h3>tee：克隆迭代器</h3>
<p><code>tee(<em>iterable</em>, <em>n</em>=2)</code> 函数可以突破<mark>迭代器只能使用一次</mark>的限制，将可迭代对象拷贝 <code><em>n</em></code> 份，并将拷贝结果以元组的形式返回。</p>
<p>不过该函数在使用时有一些限制：它的实现实际上有将迭代器转化为序列的过程，因此在处理大型数据集且拷贝次数较少时的效果往往不佳。</p>
<h2>组合迭代器</h2>
<p>接下来的迭代器与排列组合有关，因此它们往往需要输入多个序列。</p>
<h3>product：笛卡儿积</h3>
<p><code>product(*<em>iterables</em>, <em>repeat</em>=1)</code> 用于得到笛卡儿积，即基于一组集合生成所有可能的元素组合。<code><em>repeat</em></code> 参数可以将提供的集合重复若干次参与组合。例如：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">product(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">), </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">)) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 00 01 02 10 11 12 20 21 22</span></div>
<div><span style="color: #405c79;">product(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">AB</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">repeat</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AA AB BA BB</span></div>
</div>
<p>该函数的作用结果类似嵌套的 <code>for</code> 循环。以下再次给出了一个示例：</p>
<div class="codeblock code-console">&gt;&gt;&gt; from random import choice<br />
&gt;&gt;&gt; cards = list(product(range(1, 14), '<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" />'))<br />
&gt;&gt;&gt; choice(cards)<br />
(2, '<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />')<br />
&gt;&gt;&gt; choice(cards)<br />
(9, '<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />')</div>
<h3>排列组合相关迭代器</h3>
<p><code>permutations(<em>iterable</em>, <em>r</em>=None)</code> 函数会排列集合中所有元素；如果给出参数 <code><em>r</em></code> ，则它会限制参与排列元素的个数，例如：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">permutations(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">)) &nbsp; </span><span style="color: #a8a8a8;"># =&gt; 012 021 102 120 201 210</span></div>
<div><span style="color: #405c79;">permutations(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCD</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AB AC AD BA BC BD CA CB CD DA DB DC</span></div>
</div>
<p>由于 <span class="math">\\( n \\)</span> 个元素的排列结果有 <span class="math">\\( P_n^r = \frac{n!}{(n-r)!} \\)</span> 个，因此随着元素个数的上升，排列结果的长度急剧上升。</p>
<p>与之类似的函数是 <code>combinations(<em>iterable</em>, <em>r</em>)</code> ，它会以忽略顺序的形式组合集合中所有元素。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">combinations(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCD</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AB AC AD BC BD CD</span></div>
<div><span style="color: #405c79;">combinations(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">), </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 012 013 023 123</span></div>
</div>
<p>还有一个类似的迭代器 <code>combinations_with_replacement(<em>iterable</em>, <em>r</em>)</code> ，其区别是该迭代器在组合时允许元素重复：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">combinations(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># =&gt; AB AC BC</span></div>
<div><span style="color: #405c79;">combinations_with_replacement(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AA AB AC BB BC CC</span></div>
</div>
<p>这些迭代器通常用于处理排列组合相关的数学问题中。</p>
<p>使用这些迭代器可以代替许多算法中出现的简单循环，并使执行过程更高效。<code>itertools</code> 模块中还给出了更多范例，将基本的迭代器组合成更高级、有用的迭代器，可以高效地处理复杂的数据，参见 <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes">https://docs.python.org/3/library/itertools.html#itertools-recipes</a> 。</p>
<h2>参考资料</h2>
<p><a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a></p>
<p><code>itertools</code> 模块的官方文档。本文中的许多示例代码都来自该文档中。</p>
<p>文章中使用到的 CSV 数据来自 kaggle 。</p>
<p><!-- finished(all):2022-05-31 --></p>
<p><a rel="nofollow" href="/archives/270">Python函数式编程08 itertools模块：更多迭代器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/270/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程07 生成器</title>
		<link>/archives/262</link>
					<comments>/archives/262#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sun, 29 May 2022 04:55:09 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=262</guid>

					<description><![CDATA[<p>生成器的概念 为什么需要生成器 在 Python 中&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/262">Python函数式编程07 生成器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>生成器的概念</h2>
<h3>为什么需要生成器</h3>
<p>在 Python 中，如果一个函数不使用 <code>return</code> 关键字返回数据，而是使用 <code>yield</code> 关键字得到数据，那么该函数就称为<strong>生成器函数</strong>。也就是说，生成器函数的特征为：</p>
<div class="codeblock code-template">
    <strong>def</strong> function(...):<br />
&nbsp; &nbsp; ...  # statements<br />
&nbsp; &nbsp; <strong>yield</strong> expression</div>
<p>既然可以使用返回值，为什么需要生成器这种奇怪的语法？下面通过一个示例来说明函数存在的不足。</p>
<p>重新回到之前编写的生成斐波那契数列的函数，该函数的代码如下：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">fibonacci</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; result = []</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; a, b = </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">while</span><span style="color: #405c79;"> a &lt; n:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; result.append(a)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; a, b = b, a + b</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
</div>
<p>既然编写了这个函数，那么它肯定就会有用得到的地方。例如，假设要从斐波那契数列中找到是否存在一个完全平方数，那么可以再编写一个函数 <code>issquare()</code> ，然后使用以下代码判断：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in fibonacci(</span><span style="color: #bf8b56;">1000</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> issqare(i):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># do something</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">break</span></div>
</div>
<p>这种形式有一个明显的不足，注意在程序中，调用了两次循环：一次用于挨个生成斐波那契数列的元素，另一次用于从得到的斐波那契数列中挨个判断是否满足条件，这就会造成有一半的时间都会浪费在重复地将一个无用的元素塞入列表，然后再取出上。</p>
<p>除此之外，这个函数还返回了一个列表，这是另一个问题：如果要判断的数据量很多，那么这个列表也势必很大，但是真正要用到的值只有一个，那么这个列表又浪费了太多无用的空间。而且必须得等到列表生成完毕以后，再去列表中取值；但问题是在生成列表时，还不知道结果是多少，那么也不知道生成的列表到底要多大，这样要么得到的列表长度不足，其中不包含结果；要么得到的列表结果过大，其中包含了许多压根不会用上的元素。</p>
<p>这样的缺点不仅降低了效率，还可能招致严重的问题。</p>
<p>如果是在命令式编程，那么只需要在同一个循环内，在生成元素的时候顺便判断一下结果是否满足就行了。当然也可以把它封装成一个函数，但是如果判断斐波那契数列中是否存在平方数这种宏观的问题都需要用一个函数处理的话，那么判断斐波那契数列中素数的个数是否大于 10 个是否也要编写一个函数？这种问题塞到一个函数显然不够合适，因为它处理的问题太过细致了，这种函数显然不会用很多次，如果程序中都是这样不太能复用的函数，那么肯定不够合适。</p>
<p>生成器就是为了解决以上问题的。接下来先介绍生成器的特征，这样可以更好地明白使用生成器解决上述问题的优点所在。</p>
<h3>什么是生成器</h3>
<p>首先看看 <code>yield</code> 关键字会得到什么样的结果，以下编写了一个最基本的生成器函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">func</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">3</span></div>
</div>
<p>然后检查一下函数对象：</p>
<div class="codeblock code-console">&gt;&gt;&gt; func<br />
&lt;function func at 0x0000013CD9737C10&gt;</div>
<p>结果表明函数依旧是函数，这点没有发生改变。那么再试着调用一下函数：</p>
<div class="codeblock code-console">&gt;&gt;&gt; func()<br />
&lt;generator object func at 0x0000013CD934F890&gt;</div>
<p>调用函数的结果显示，该函数返回了一个生成器对象。</p>
<p><strong>生成器</strong>(generator)是一种特殊的数据类型，生成器只在需要的时候，才会产生具体的值，这就避免了时间上的浪费；生成器在产生一个值时，会将上一次产生的值抛弃，这就避免了空间上的浪费。生成器是 Python 的一大特性，使用生成器可以让代码变得更加简洁、优雅。</p>
<p>以上说法可能只能让人似懂非懂，下面结合一个具体的示例说明。以下将上面的斐波那契函数改成生成器函数的形式，如下所示：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">fibonacci</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; a, b = </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">while</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> a</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; a, b = b, a + b</span></div>
</div>
<p>一个生成器最基本、最实用的用法就是使用 <code>for</code> 循环对生成器迭代，每一次迭代过程中，如果遇到 <code>yield</code> 语句，那么<mark>后面的表达式就会被作为<em>本次迭代</em>的结果返回</mark>给中间变量如 <code>i</code> 后续利用。</p>
<p>这也揭示出了生成器函数与普通函数的区别：</p>
<ul>
<li>普通函数在执行到 <code>return</code> 语句后就终止，后面的所有语句都会被忽略；生成器函数执行到 <code>yield</code> 语句后，只是暂时将结果返回，下一次遍历时，又会从暂停的位置继续执行下去</li>
<li>因此，一个生成器函数在执行时，可以遇到多个<code>yield</code> 语句；普通函数虽然可以串列多个 <code>return</code> 语句，但是遇到第一个语句后就会终止</li>
<li>也正是因为这个特点，生成器会在迭代过程中一直保存其中的局部变量，直到迭代结束</li>
</ul>
<p>以下示例展示了生成器的用法：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in fibonacci():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(i, </span><span style="color: #bf8b56;">end</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"> </span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> i &gt; </span><span style="color: #bf8b56;">30</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">break</span></div>
</div>
<p>以上代码的执行结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
0 1 1 2 3 5 8 13 21 34</div>
<p>这里简单分析一下程序的执行过程，首先生成器函数执行到 <code>yield</code> 语句时，变量 <code>a</code> 的值是 0 ，因此 0 被作为生成结果传递给迭代的中间变量 <code>i</code> ；第二次进入迭代时函数从 yield 语句后继续运行，变量的值发生改变，<code>a</code> 变成了 1 ，再次作为生成结果传递给迭代的中间变量；以此类推，第三次执行到 <code>yield</code> 时返回的结果是 1 ，第四次是 2 ……。</p>
<blockquote><p>使用集成开发环境的读者可以使用 debug 功能，对程序下断点，进一步观察每一步代码是如何执行、变量的值是如何变化的。</p></blockquote>
<p>下图表示了这一过程：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/07-generator-procedure.jpg" alt="" width="330"></figure>
<p>最后，在外部使用 <code>break</code> 语句强行终止了这一过程。如果不手动终止的话，迭代会一直发生下去，生成器可以一直生成新的值出来，因此这类的生成器也称为<strong>无限生成器</strong>。这又是生成器相对普通函数的优点：普通函数不可能返回一个具有无穷长度的列表，但是生成器可以一直源源不断地计算新的结果。</p>
<p>可以从这个角度理解：函数返回的是结果，而生成器返回的是<em>过程</em>。</p>
<p>实际上，在第四节中介绍的内置函数 <code>map()</code> 、<code>enumerate()</code> 等，得到的结果就是一个类似生成器的对象。</p>
<h3>生成器与生成器函数</h3>
<p>前面介绍了生成器的概念，并通过示例展示了生成器的用法。但是注意，生成器在使用时有一些注意事项。</p>
<p>以上提到了一个基本的事实：生成器函数在调用时，才会返回一个生成器。但是注意，在介绍生成器时，还提到了：<mark>生成器在产生一个值时，会将上一次产生的值抛弃</mark> 。这种性质虽然节约了空间的开销，但也使得一个生成器只能被迭代一次，一旦调用完成后该值便不再保存在内存当中，因此生成器中生成的值只能访问一次。</p>
<p>为了理解这句话，给定以下生成器：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">odd</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; i = </span><span style="color: #bf8b56;">0</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">while</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> i * </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;"> + </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; i += </span><span style="color: #bf8b56;">1</span></div>
</div>
<p>第一次对生成器迭代的结果很正常：</p>
<div class="codeblock code-console">&gt;&gt;&gt; for i in g1:<br />
...     print(i, end=' ')<br />
...     if i &gt; 15:<br />
...         break<br />
...<br />
0 2 4 6 8 10 12 14 16</div>
<p>但是第二次生成的结果就有些变化了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; for i in g1:<br />
...     print(i, end=' ')<br />
...     if i &gt; 30:<br />
...         break<br />
...<br />
18 20 22 24 26 28 30 32</div>
<p>这一次，生成器是顺着上一次的结果继续执行了下去，这说明前面的值都被抛弃了，再也访问不到了。或者也可以从生成器的执行过程分析：生成器还没执行完成，只是这一过程暂停了。</p>
<p>因此，以下两种使用生成器的方式：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;"># 1</span></div>
<div><span style="color: #405c79;">g2 = odd()</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in g2:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in g2:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #a8a8a8;"># 2</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in odd():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in odd():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
</div>
<p>得到的是完全不同的结果，因为第一次只创建了一个生成器，第二次创建了两个生成器。</p>
<p>这种特性是生成器的优点，但它有时也会带来问题。因为生成器的迭代可能是显式的，也有可能是隐式的，有些时候生成器在生成值时难以被察觉。考虑以下简单的函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">average</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">l</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(l) / </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">tuple</span><span style="color: #405c79;">(l))</span></div>
</div>
<p>该函数用于求一个序列或可迭代对象的平均值，为了弥补 <code>len()</code> 函数不可作用于可迭代对象的缺点，它在内部将其转换为元组。但是真正使用的结果可能出乎意料：</p>
<div class="codeblock code-console">&gt;&gt;&gt; average(map(lambda x: x ** 2, range(10)))<br />
Traceback (most recent call last):<br />
File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br />
File "&lt;stdin&gt;", line 2, in average<br />
ZeroDivisionError: division by zero</div>
<p>这段代码直接产生了错误。不过定义的函数不长，稍微分析就能发现问题所在：序列的长度变成 0 了，因此发生了错误。</p>
<p>这就是对同一个生成器两次迭代带来的后果，在第一次使用 <code>sum()</code> 函数时，它就会隐式迭代生成器，迭代完成后，生成器就变空了，因此第二次得到的是一个空序列，自然就会出错。</p>
<h2>生成器的高级用法</h2>
<h3>生成器与递归调用</h3>
<p>普通的函数允许递归，通过在函数中调用自身是实现循环的一种方式。而生成器函数有时为了实现类似迭代生成的功能，也会需要类似递归的用法。</p>
<p>考虑以下生成器，该生成器用于将一个任意嵌套的列表碾平成一维列表：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">ls = [</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">1</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">a</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, [[</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">hello</span><span style="color: #405c79;">'</span><span style="color: #405c79;">], </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">w</span><span style="color: #405c79;">'</span><span style="color: #405c79;">], </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">], [[[</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">o</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]], </span><span style="color: #bf8b56;">7</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">9</span><span style="color: #405c79;">], </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">d</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">flatten</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">nest</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in nest:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> not </span><span style="color: #8b56bf;">isinstance</span><span style="color: #405c79;">(i, </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> i</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
</div>
<p>首先看看生成器该如何处理这种问题：首先生成器遍历列表的每一个元素，如果已经是一个基本的元素，那就将其生成出来。如果是一个嵌套的列表的话，那么应该将该列表内的元素生成出来，再次嵌套的列表继续作类似处理。</p>
<p>上下级之间以相同的逻辑处理，这就很符合递归的一些特性。但是注意，如果按照普通函数递归的思路，可能有些人的第一印象是写作</p>
<div class="vscode-block">
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> flatten(i)</span></div>
</div>
<p>这是完全错误的写法，因为仔细分析该语句的目的是生成出了一个生成器对象作为本次迭代的结果。回想一下，函数递归的特点是函数在函数体调用时，又在内部调用自身，是 <code>return func()</code> 这种嵌套调用的形式而不是 <code>return func</code> 直接把函数对象返回。</p>
<p>类比这种特点，那么生成器在递归时，也应该是生成器函数在生成值时，包含了一个自身的生成器，并将自身生成的结果作为生成的结果。</p>
<p>这种说法可能有点绕，下面借用代码说明。以下是函数递归的特性，函数在调用时，又在内部调用自身：</p>
<div class="codeblock code-template">
    func(...)&nbsp; <span class="codetoken comment"># function call</span><br />
<strong>=&gt;</strong> func(...)&nbsp; <span class="codetoken comment"># nested function call</span></div>
<p>那么，生成器函数的递归思路也是如此。生成器函数在迭代时，又在内部迭代自身：</p>
<div class="codeblock code-template">
    <strong>for</strong> i in gener(...):<br />
&nbsp; &nbsp; ...&nbsp; &nbsp; <span class="codetoken comment"># generator iterate</span><br />
<strong>=&gt;</strong> <strong>for</strong> i in gener():<br />
<strong>=&gt;</strong> &nbsp; &nbsp; &nbsp; ...&nbsp; <span class="codetoken comment"># nested generator iterate</span></div>
<p>这样，上述生成器递归部分的代码为：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> k in flatten(i):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> k</span></div>
</div>
<p>生成器在迭代自身时，自身的迭代过程又迭代了自身，这就是递归的过程。</p>
<p>以上代码的检验结果为：</p>
<div class="codeblock code-console">&gt;&gt;&gt; list(flatten(ls))<br />
['1', 2, 'a', 'hello', 'w', 6, 'o', 7, 9, 'd']</div>
<p>可以看到它很好地完成了工作。并且这种情况下生成器比函数的递归调用方便，因为这种混乱嵌套的列表，很难将其拆解成上下级的递推关系。</p>
<p>实际上，Python 中还新增了组合关键字 <code>yield from</code> ，用于生成器的递归调用。也就是说，以上递归部分可以简单地改成：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield from</span><span style="color: #405c79;"> flatten(i)</span></div>
</div>
<p>这样的表述非常清晰，每次遇到一个 <code>yield from</code> ，就转从另一个生成器里面生成结果，这样就实现了生成器的递归。</p>
<p>以下再次给出了一个生成器函数示例，该生成器函数从一个给定的文件夹中找出文件，如果遇到嵌套的文件夹，它便递归地从嵌套的文件夹中找出包含的文件：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> os</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">get_files</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">dir</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> f in os.listdir(</span><span style="color: #8b56bf;">dir</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; path = os.path.join(</span><span style="color: #8b56bf;">dir</span><span style="color: #405c79;">, f)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> os.path.isfile(path):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> path</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield from</span><span style="color: #405c79;"> get_files(path)</span></div>
</div>
<p>这样就可以实现文件的搜索功能。</p>
<h3>生成器表达式</h3>
<p>除了使用函数和 <code>yield</code> 关键字创建生成器外，简短的生成器还有另一种创建方式：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">g = (i ** </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">1000</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> isprime(i))</span></div>
</div>
<p>熟悉列表解析语法的读者应该可以很容易理解它的语法。列表解析的介绍可以参见 <a href="javascript: alert('还没发布呢')">这篇文章</a> 。</p>
<div class="codeblock code-console">&gt;&gt;&gt; g<br />
&lt;generator object &lt;genexpr&gt; at 0x0000013CD934F890&gt;<br />
&gt;&gt;&gt; type(g)<br />
&lt;class 'generator'&gt;</div>
<p>这种最外层使用圆括号的语法不是什么元组解析，而是生成器表达式，它本质就是一个生成器。这种短小的生成器表达式一般用于简单的应用场景中。</p>
<p><!-- finished(all):2022-05-27 --></p>
<p><a rel="nofollow" href="/archives/262">Python函数式编程07 生成器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/262/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程05 函数的递归</title>
		<link>/archives/257</link>
					<comments>/archives/257#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 27 May 2022 03:49:20 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=257</guid>

					<description><![CDATA[<p>什么是递归 如果一个函数在执行时，调用了它自身，那么&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/257">Python函数式编程05 函数的递归</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>什么是递归</h2>
<p>如果一个函数在执行时，调用了它自身，那么这个函数就会执行自身，然后执行自身时又执行了自身。这种一层一层地向下执行下去的过程称为<strong>递归</strong>(recursion)。</p>
<p>也就是说，递归的特征为：</p>
<div class="codeblock code-template">
    <strong>def</strong> func(...):<br />
&nbsp; &nbsp; ...<br />
&nbsp; &nbsp; func(...)&nbsp; <span class="codetoken command"># call itself</span><br />
&nbsp; &nbsp; ...</div>
<p>既然递归会一直执行下去，那么必须要在合适的时候让它停止。结束递归是使用递归的难点，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。要终止一个循环只需要使用 <code>break</code> 语句；而要终止一个递归也很简单，只需要让函数不再调用自身即可。</p>
<p>既然在递归时，有时候允许继续递归，有时候需要终止递归，那么肯定要在函数调用前给它一个信号。这个信号一般是用过参数的传递来作用的，因此在递归调用时，需要注意如何给调用的函数设计传入的参数，以及如何根据传入的参数中断递归。</p>
<p>下面根据一个具体的示例来介绍递归的原理：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">up_and_down</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">floor</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, n) &nbsp;</span><span style="color: #a8a8a8;"># 1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> n &lt; </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; up_and_down(n + </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">)</span><span style="color: #f7f9fb;">;</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">floor</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, n) &nbsp;</span><span style="color: #a8a8a8;"># 2</span></div>
<div><span style="color: #405c79;">up_and_down(</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">)</span></div>
</div>
<p>以上调用一个可以发生递归的函数，结果为：</p>
<div class="codeblock code-console">python -u demo.py<br />
floor 1<br />
floor 2<br />
floor 3<br />
floor 3<br />
floor 2<br />
floor 1</div>
<p>在代码中调用了 <code>up_and_down()</code> 函数，这次调用称为“第 1 级递归”。然后 <code>up_and_down()</code> 调用自身，这次调用称为“第 2 级递归”。接着第 2 级递归调用第 3 级递归，以此类推。该示例程序共有 3 级递归。程序通过显示变量 n 的值，演示了执行的语句及变量的值。</p>
<p>首先，程序调用了带参数 1 的 <code>up_and_down()</code> 函数，该函数先在 #1 处打印 floor 1 。然后，由于 n 小于 3 ，该函数调用实际参数为 n + 1（即 2 ）的 <code>up_and_down()</code> 函数，再在 #1 处打印 floor 2 。与此类似，接下来打印的是 floor 3 。当执行到第 3 级时，n 的值是 3 ，所以 <code>if</code> 测试条件为假。<code>up_and_down()</code> 函数不再调用自己。第 3 级调用接着执行打印语句 #2 ，即打印 floor 3 。此时，第 3 级调用结束，控制被传回它的主调函数，即第 2 级调用，接着执行 <code>if</code> 语句后，即 #2 处打印 floor 2 ，然后第 2 级调用结束，控制被传回第 1 级调用，以此类推。下图展示了这一过程：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/05-recursion.jpg" alt="" width="670"></figure>
<p>注意，每级递归的变量 n 都属于本级递归私有，这点从程序输出的变量值可以看出。因此每次调用函数时的局部变量都是互不相关的。虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。</p>
<p>递归调用尤其要注意语句执行的顺序。递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。因此，以上程序在 #1 处按顺序打印 1 2 3 。递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。因此，以上程序在 #2 处打印 3 2 1 。</p>
<p>递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。稍后将介绍一个这样的例子。</p>
<p>除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。递归比循环更直观、容易理解，但是编写出一个合适的递归语句则比较难。除此之外，递归会产生空间上的额外开销，这点放到后面详细介绍。</p>
<h2>递归的用法</h2>
<h3>编写合适的递归函数</h3>
<p>要编写合适的递归语句，也需要像编写循环一样，考虑以下两个问题：</p>
<ul>
<li>递归过程中，上一级函数与下一级函数的关系</li>
<li>什么时候退出递归</li>
</ul>
<p>例如，如果使用递归的方式计算阶乘，那么根据阶乘的定义：</p>
<div class="math">
\\[<br />
n! = n (n-1) \cdots 3 \cdot 2 \cdot 1<br />
\\]</div>
<p>而 <span class="math">\\( (n-1)! \\)</span> 则表示为 <span class="math">\\( (n-1)! = (n-1) \cdots 3 \cdot 2 \cdot 1 \\)</span> ，那么由此可得上一级函数与下一级函数的关系为：<span class="math">\\( (n)! = n \times (n-1)! \\)</span></p>
<p>还需要注意的是阶乘的终止条件，根据阶乘的定义，阶乘的终止条件就是乘到 1 后，有 <span class="math">\\( 1!=1 \\)</span> 。因此，阶乘也可以定义为：</p>
<div class="math">
\\[<br />
factorial(n) =<br />
\begin{cases}<br />
1,  &amp; \text{if} n = 1 \\[2ex]<br />
n \times factorial(n-1), &amp; \text{otherwise}<br />
\end{cases}<br />
\\]</div>
<p>以下将其翻译成了代码语句：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">factorial</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> n == </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> n</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> n * factorial(n-</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">)</span></div>
</div>
<p>以上是一个很简单的示例，接下来再看一个更复杂的示例：使用递归实现二分查找法。</p>
<blockquote><p>二分查找法是一种在有序序列中查找某一特定元素的查找算法，其过程如下：首先检查序列的中间元素，如果中间元素正好是待查找的元素，则<em>结束查找</em>；如果待查找的元素大于或者小于中间元素，则在序列大于或小于中间元素的那一半中<em>使用相同方式</em>查找。除此之外，找到最后发现剩下的一半序列为空，则说明待查找的元素<em>不存在</em>。</p>
<p>二分查找法每一次递归都使查找范围缩小一半，因此特别适合在很大的序列中查找一个元素。不过二分查找法有一个前提就是序列必须是有序的。</p></blockquote>
<p>以上递归的要点都已经在背景资料里着重标出。根据递归的原理，相应的二分查找函数如下：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">binary_search</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">seq</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">left</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">right</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">value</span><span style="color: #405c79;">): </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> right &gt;= left:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; mid = </span><span style="color: #bf568b;">int</span><span style="color: #405c79;">(left + (right - left) / </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> seq[mid] &lt; value: </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> binary_search(seq, mid + </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, right, value) </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">elif</span><span style="color: #405c79;"> seq[mid] &gt; value: </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> binary_search(seq, left, mid - </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, value) </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">: </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> mid </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">: </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> -</span><span style="color: #bf8b56;">1</span></div>
</div>
<p>具体的细节就不再重复介绍。可以自行比对背景介绍了解每一条语句的由来。</p>
<h3>递归和倒序计算</h3>
<p>递归在处理倒序时非常方便。在解决这类问题中，递归比循环简单，因为循环还需要对结果做反序操作。</p>
<p>以下使用递归来将十进制数转换为二进制数。在给出函数前，先介绍该转换算法的原理。</p>
<blockquote><p>在二进制中，对于数字 <span class="math">\\( n \\)</span> ，其二进制的最后一位是 <span class="math">\\( n \text{mod} 2 \\)</span> 。因此，计算的第一位数字实际上是待输出二进制数的最后一位。</p>
<p>要获得下一位数字，必须把原数除以 2 。这种计算方法相当于在十进制下把小数点左移一位，然后再计算新的 <span class="math">\\( n \text{mod} 2 \\)</span> ，这样得到的就是待输出二进制数的倒数第二位。通过重复这个过程，便可以得到十进制数等价的二进制。</p>
<p>程序停止计算的依据是当与 2 相除的结果小于 2 ，因为只要结果大于或等于 2 ，就说明还有二进制位。每次除以 2 就相当于去掉一位二进制，直到计算出最后一位为止。</p></blockquote>
<p>以下程序演示了上述算法：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">tobinary</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> n &lt; </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">(n)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> tobinary(n // </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) + </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">(n % </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">)</span></div>
</div>
<p>检查一下编写的函数是否正确：</p>
<div class="codeblock code-console">&gt;&gt;&gt; tobinary(3508)<br />
'110110110100'</div>
<p>使用系统自带的计算器验算，可以看到结果完全正确：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/05-dec-to-bin.jpg" alt="" width="290"></figure>
<p>如果不用递归，由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的位数都储存起来。</p>
<h3>递归的缺点</h3>
<p>递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归函数不方便维护。</p>
<p>以下函数用递归计算斐波那契数列的值，它接受正整数 n ，返回该项对应的数值。根据斐波那契数列的定义，如果 n 是 1 或 2 ，<code>fibonacci(n)</code> 应返回 1 ；对于其他数值，则应返回 <code>fibonacci(n-1) + fibonacci(n-2)</code> 。它很符合递归的条件，因此，函数可以是：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">fibonacci</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> n &gt; </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> fibonacci(n-</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">) + fibonacci(n-</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">)</span><span style="color: #f7f9fb;">;</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">1</span><span style="color: #f7f9fb;">;</span></div>
</div>
<p>该函数使用了双递归，即函数每一级递归都要调用本身两次。这产生了一个问题：假设 n 足够大，在第 1 级递归调用，将创建一个变量 <code>n</code> ，然后在该函数中要调用自身两次；在第 2 级递归中要分别创建 2 个变量 n ，这 2 次调用中的每次调用又会进行 2 次调用，因而在第 3 级递归中要创建 4 个名为 n 的变量。此时总共创建了 7 个变量。由于每级递归创建的变量都是上一级递归的 2 倍，所以变量的数量呈指数增长，这很快就会产生非常大的内存，消耗掉计算机的大量内存，很可能导致程序崩溃。</p>
<h3>尾递归</h3>
<p>如果把递归调用置于函数的末尾，即正好在 <code>return</code> 语句之前，这种形式的递归被称为<strong>尾递归</strong>(tail recursion)。以上编写的很多递归函数都是尾递归，尽管递归语句可能并不放在函数的最后一行。</p>
<p>尾递归是最简单的递归形式，因为它在某种程度上可以表达为循环。除此之外，尾递归一个很大的特点是它<em>可以</em>被优化。</p>
<p>递归的另一个问题在于每一次调用函数，都需要存储局部变量和参数，这会产生一定的内存开销。但是在递归发生时，函数调用并没有结束，因而这一部分内存并没有被释放，还在内存中存在，因此很深的递归会导致大量内存被占用。</p>
<blockquote><p>熟悉别的编程语言的读者可能会明白函数是使用栈传递参数的，Python 也不例外，不过这里不具体展开说明。</p></blockquote>
<p>尾递归的特殊性在于发生递归调用时，函数已经执行到最后了，因此局部变量和参数已经不再需要，这部分内容占据的空间完全可以忽略。</p>
<p>例如，以上的阶乘函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">factorial</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> n == </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> n</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> n * factorial(n-</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">)</span></div>
</div>
<p>注意，尽管很像，但是该递归并不是尾递归，因为在发送递归时，局部变量 <code>n</code> 的值还没有被利用。如果把 <code>factorial(5)</code> 递归展开，那么它会变成如下形式：</p>
<div class="codeblock code-template">
    factorial(5) <strong>=&gt;</strong><br />
(5 * factorial(4)) <strong>=&gt;</strong><br />
(5 * (4 * factorial(3)))) <strong>=&gt;</strong><br />
... <strong>=&gt;</strong><br />
(5 * (4 * (3 * (2 * (1 * 1))))))</div>
<p>由此可见，递归过程中产生的中间变量只有在递归结束后才会被一起利用，这就产生了大量的空间上的浪费。</p>
<p>如果把以上阶乘函数改成尾递归形式，变成：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">factorial</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">t</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> (n == </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">): </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> t</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> factorial(n - </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, t * n)</span></div>
</div>
<p>这就是真正的尾递归，它的调用会变成：</p>
<div class="codeblock code-template">
    factorial(5, 1) <strong>=&gt;</strong><br />
factorial(4, 5) <strong>=&gt;</strong><br />
factorial(3, 20) <strong>=&gt;</strong><br />
factorial(2, 60) <strong>=&gt;</strong><br />
factorial(1, 120) <strong>=&gt;</strong><br />
120</div>
<p>这一过程中，每次的调用不再需要用到上一次调用的变量了，因此这部分中间变量完全可以抛弃。在一些语言中，尾递归会在编译阶段被编译器通过优化转换成循环语句。</p>
<p>但是很遗憾，Python 并没有优化递归的功能，并且 Python 对嵌套递归的深度也有限制，递归深度上限默认为 1000 ，或者可以通过 <code>sys.setrecursionlimit()</code> 函数修改这个值。不过尾递归在编写代码时，完全可以使用循环代替，这就是手动形式的优化了。</p>
<p>总的来说，递归不仅占用内存更多，并且由于每次函数调用要花费一定的时间，递归的执行速度也更慢，因此简单的递归应该使用循环代替。但递归较循环语句更简洁，而且在某些情况下，不能用简单的循环代替递归。</p>
<h2>参考资料</h2>
<p>本文的许多思路都来自于对《C Primer Plus》相关章节的读书笔记。</p>
<p><!-- finished(all):2022-05-26 --></p>
<p><a rel="nofollow" href="/archives/257">Python函数式编程05 函数的递归</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/257/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程06 元组与命名元组</title>
		<link>/archives/253</link>
					<comments>/archives/253#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 25 May 2022 15:15:06 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=253</guid>

					<description><![CDATA[<p>元组的基本概念 元组的基本操作 在 Python 中&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/253">Python函数式编程06 元组与命名元组</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p><!-- 为了跟书中的内容同步，特地加的这一章。 --></p>
<h2>元组的基本概念</h2>
<h3>元组的基本操作</h3>
<p>在 Python 中，使用圆括号括起逗号分隔的不同的数据项</p>
<div class="codeblock code-template">
    (elem1, elem2, ..., elemn)</div>
<p>会被视为一个元组字面量。在不引起歧义的情况下，最外层的括号可以省略，例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; t1 = (1, 3, 4, 6)<br />
&gt;&gt;&gt; type(t1)<br />
&lt;class 'tuple'&gt;<br />
&gt;&gt;&gt; t2 = 2, ['1', 'a']<br />
&gt;&gt;&gt; type(t2)<br />
&lt;class 'tuple'&gt;</div>
<p>因此，要注意有些时候，一个元素后面不小心多加了一个逗号，它会被当做只有一个元素的元组处理，可能会导致类型错误等问题。</p>
<p>也可以使用 <code>tuple</code> 类从一个可迭代对象中构造元组。</p>
<p>给定一个元组，可以使用赋值语句将其中包含的元素分配给一系列变量，例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; x1, x2, x3, x4 = t1<br />
&gt;&gt;&gt; x1<br />
1<br />
&gt;&gt;&gt; x3<br />
4</div>
<p>这种操作称为元组的<strong>解包</strong>(unpack)。在解包时，变量的个数要和元组的元素个数一致，否则会导致错误。</p>
<p>如果解包时，只需要前面的几个元素，那么可以在最后一个变量前加上星号 <code>*</code> ，将解包后剩下的值塞进该变量中：</p>
<div class="codeblock code-console">&gt;&gt;&gt; x1, x2, *y = t1<br />
&gt;&gt;&gt; x1<br />
1<br />
&gt;&gt;&gt; y<br />
[4, 6]</div>
<p>元组是一种不可变类型，任何尝试对元组元素的修改都会发生错误。元组仅支持 <code>.count()</code> 和 <code>.index()</code> 方法，分别用于统计某个元素出现的次数以及查找某个元素的位置。</p>
<p>实际上以上元组的特性，列表也能做到。看起来元组就是一个不能修改的列表，那为何 Python 要引入这种类型呢？</p>
<p>元组最大的特性也就是其不可变，而有些时候（例如在函数式编程中）并不需要改变元素的值，此时为了防止元素意外变动，就需要使用元组。例如在某些大型工程中函数众多，可能会有某个排序函数意外改变原有序列，如果使用元组就能提前发现问题所在。</p>
<p>元组这种不可变的特点使得它可以作为字典的键：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">{(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">8</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">): </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">hello</span><span style="color: #405c79;">'</span><span style="color: #405c79;">}</span></div>
</div>
<p>而列表则不行。</p>
<p>在使用使用中，常用元组来表达某一个结构形式的数据，例如以下是一个列表元组，列表中的每一个元组在同一索引值处，表达的都是同一含义的数据：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">[(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">a</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">), (</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">c</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">False</span><span style="color: #405c79;">), (</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">k</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">)]</span></div>
</div>
<h3>使用命名元组</h3>
<p>以上使用元组来表达结构形式的数据，但这种结构只能通过索引来访问其元素。如果元组中的元素较多，不仅操作起来很麻烦，而且比较容易出错。</p>
<p>命名元组是一种特殊的元组，命名元组的元素既可以使用名称访问，也可以使用索引值访问，大大增加了元组的可读性。</p>
<p>命名元组并不是内置的数据类型，而是标准库的一部分，因此首先需要导入命名元组：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> collections </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> namedtuple</span></div>
</div>
<p>使用 <code>namedtuple</code> 的构造函数可以定义一个子类命名元组，其构造函数的完整形式为：</p>
<div class="codeblock code-template">
    namedtuple(<em>typename</em>, <em>field_names</em>, *, <em>rename</em>=False, <em>defaults</em>=None, <em>module</em>=None)</div>
<p>其中各参数的含义为：</p>
<ul>
<li><code>typename</code> 是返回的命名元组子类的类名，创建命名元组相当于创建了一个新类</li>
<li><code>field_names</code> 是命名元组各元素的名称，是一个由字符串组成的列表，其中的字符串必须为合法的标识符；或者 <code>field_names</code> 也可以是一个字符串，各元素名称使用逗号或空格隔开</li>
<li>当 <code>rename</code> 设置为 <code>True</code> 时，如果 <code>field_names</code> 中包含保留关键字或重复的变量名，则会自动重命名为 <code>_1</code> 、<code>_2</code> 等</li>
<li>如果给定 <code>defaults</code> 值，则它应该是一个由默认值组成的可迭代对象。由于具有默认值的参数必须位于没有默认值的任何参数之后，如果默认值少于命名元组的元素个数，默认值将应用于最右边的元素。如果默认值多于命名元组的元素个数，将引起错误</li>
<li>如果设置了 <code>module</code> 参数，那么该类将位于该模块下，因此该自定义类的 <code>__module__</code> 属性将被设置为该参数值</li>
</ul>
<p>以下是一个简单的示例，构造了一个类型的命名元组，并由该类型的命名元组生成具体的元组对象：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">Point = namedtuple(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Point</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, [</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">x</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">y</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">z</span><span style="color: #405c79;">'</span><span style="color: #405c79;">])</span></div>
<div><span style="color: #405c79;">p01 = Point(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">8</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(p01)</span></div>
</div>
<p>命名元组对象可以通过访问元素的字段名称来访问其属性，这更加准确、方便：</p>
<div class="codeblock code-console">&gt;&gt;&gt;p01[0]<br />
3<br />
&gt;&gt;&gt; p01.y<br />
4</div>
<p>命名元组创建的类继承于元组，并且包含以下额外属性和方法：</p>
<p><code>._fields</code> 类属性返回其所有字段名称，以下给出了一个示例，并注意 <code><em>rename</em></code> 参数的作用效果：</p>
<div class="codeblock code-console">&gt;&gt;&gt; SomeStruct = namedtuple('OneTuple', ['abc', 'def', 'ghi', 'abc'], defaults=['1', '2', '3'], rename=True)<br />
&gt;&gt;&gt; SomeStruct._fields<br />
('abc', '_1', 'ghi', '_3')</div>
<p>如果没有设置 <code><em>rename</em></code> 参数，则会直接发生错误。</p>
<p><code>._field_defaults</code> 属性返回所有有默认值的字段及其默认值组成的字典。如果没有默认值，那么返回空字典。</p>
<p><code>._make(<em>iterable</em>)</code> 用于从指定可迭代对象构建命名元组对象。这里需要注意的是，得到的命名元组参数和字段名是对应的，可以使用关键字参数的形式生成命名元组：</p>
<div class="codeblock code-console">&gt;&gt;&gt; Point(1, 2, z=3)<br />
Point(x=1, y=2, z=3)</div>
<p>因此，调用该方法相当于在可迭代对象前加上星号将其变为一系列参数。</p>
<p><code>_replace(**<em>kwargs</em>)</code> 方法可以用于从另一个命名元组得到其部分值被替换后的副本：</p>
<div class="codeblock code-console">&gt;&gt;&gt; p02 = p01._replace(x=10, z=12)<br />
&gt;&gt;&gt; p02<br />
Point(x=10, y=4, z=12)</div>
<p>最后，<code>._asdict()</code> 方法用于把命名元组对象转换为 OrderedDict ，即一种字典对象。</p>
<h2>改进的命名元组</h2>
<p>Python 中可以使用另一种方式得到命名元组，这种方式得到的命名元组更简洁，并且可以保存类型信息。</p>
<blockquote><p>如果对以下涉及的 Python 语法有疑问，也可以暂时忽略。</p></blockquote>
<p>这种类型的命名元组通过继承创建，并且使用类属性表示各个字段，代码为：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> typing </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> NamedTuple</span></div>
<div><span style="color: #bf568b;font-weight: bold;">class</span><span style="color: #405c79;"> </span><span style="color: #568bbf;">Student</span><span style="color: #405c79;">(</span><span style="color: #56bf8b;">NamedTuple</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; name: </span><span style="color: #bf568b;">str</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; age: </span><span style="color: #bf568b;">int</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; score: </span><span style="color: #bf568b;">float</span></div>
</div>
<p>类型注解是必须的，否则无法通过语法检查。Python 中的类型注解都不会实际检查类型是否匹配，不过它会为编写和阅读代码提供一定方便。</p>
<p>它的使用方法也和前一种命名元组一致：</p>
<div class="codeblock code-console">&gt;&gt;&gt; s = Student('Peter', 21, 62.0)<br />
&gt;&gt;&gt; s<br />
Student(name='Peter', age=21, score=62.0)</div>
<p>这种命名元组也具有以上所使用的一些特别的属性和方法。在实际使用时可以任意选取一种命名元组。个人比较推荐这一种，因为它的定义比较简洁易懂。</p>
<p><a rel="nofollow" href="/archives/253">Python函数式编程06 元组与命名元组</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/253/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程03 高阶函数与匿名函数</title>
		<link>/archives/246</link>
					<comments>/archives/246#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 23 May 2022 13:58:18 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=246</guid>

					<description><![CDATA[<p>函数式编程的概念 编程有多种范式，每种范式都代表了使&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/246">Python函数式编程03 高阶函数与匿名函数</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>函数式编程的概念</h2>
<p>编程有多种范式，每种范式都代表了使用程序处理问题的思维方式。</p>
<p>命令式编程是一种常见的编程范式，在命令式编程中，每一条语句通过一定方式改变变量的值，推进处理过程逐渐到预期结果。</p>
<p><strong>函数式编程</strong>(functional programming)也是一种编程范式，它与命令式编程最重要的特征区别是<strong>状态</strong>。函数式编程并不需要修改变量，而是通过每一次调用函数创造出一个或多个新的结果，然后再用得到的结果参与新的运算，最终得到合适的结果。纯粹的函数式编程避免了由于使用变量赋值导致程序显式维护计算状态而带来的复杂性。</p>
<p>函数式编程会基于一些基本的、功能清晰的简单函数，将其组合形成功能更抽象、符合业务需要的高级函数。相比由基础指令组成的复杂流程，函数式编程更容易理解其执行的过程。</p>
<p>大部分编程语言都提供了函数，不过不是每一种编程语言都支持使用函数式编程。Python 不是纯粹的函数式语言，不过 Python 语言的特性使得它可以使用函数式编程的方式去编写程序。</p>
<p>接下来将会根据函数式编程的特点，介绍 Python 中函数的高级特性。后续几节的内容，都围绕以下概念展开：</p>
<ol>
<li>函数式编程中，函数可以用作其他函数的参数或者返回值。要做到这一点，函数必须是运行时环境中的<strong>头等对象</strong></li>
<li>一个函数在运行时不能影响到别的函数的结果，所以需要构建复杂的<strong>不可变数据结构</strong></li>
<li>函数式编程会将计算推迟到需要的时候进行，即<strong>非严格求值</strong>（惰性求值）</li>
<li>一个函数可能在执行时调用自身，这称为<strong>递归</strong>。函数式编程可以通过递归代替循环语句，这样可以不用产生跟踪循环状态的开销</li>
</ol>
<h2>头等函数</h2>
<h3>高阶函数</h3>
<p>在 Python 中，函数通常是通过 <code>def</code> 语句创建的对象，它与其它对象例如数值、列表甚至模块都没有本质上的区别。在创建一个函数后，可以检查其类型：</p>
<div class="codeblock code-console">&gt;&gt;&gt; def func(a, b, c=3, *d):<br />
...     pass<br />
...<br />
&gt;&gt;&gt; type(func)<br />
&lt;class 'function'&gt;</div>
<p>结果表明，<code>func</code> 的类型是“函数”。</p>
<p>可以通过检查其属性来分析函数对象的一些特点：</p>
<div class="codeblock code-console">&gt;&gt;&gt; func.__name__<br />
'func'<br />
&gt;&gt;&gt; func.__defaults__<br />
(3,)<br />
&gt;&gt;&gt; func.__code__.co_varnames<br />
('a', 'b', 'c', 'd')</div>
<p>甚至可以为函数对象添加上自定义的属性：</p>
<div class="codeblock code-console">&gt;&gt;&gt; func.level = 1<br />
&gt;&gt;&gt; func.self = func</div>
<p>一些大型框架通过函数的自定义属性来获取函数的元属性，除此之外一般情况下很少用到。不过通过以上的介绍，可以明白 Python 中函数与其它对象并没有本质区别。完全可以将函数对象赋值给一个变量，再通过调用变量获取结果：</p>
<div class="codeblock code-console">&gt;&gt;&gt; my_sum = sum<br />
&gt;&gt;&gt; my_sum([1, 4, 5, 8, 9])<br />
27</div>
<p>因此，一个函数完全可以用作参数传入另一个函数中，还可以作为返回值从另一个参数返回。反之，如果一个函数接受一个或多个函数作为输入，或者输出一个函数作为返回值，则称该函数为<strong>高阶函数</strong>。</p>
<p>以下就是一个简单的高阶函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">call</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">f</span><span style="color: #405c79;">, *</span><span style="color: #bf8b56;">args</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">kwargs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> f(*args, **kwargs)</span></div>
</div>
<p>可以将一个函数对象作为参数传递给它，例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; call(pow, 2, 3, 4)<br />
0</div>
<p>高阶函数在函数式编程中用途广泛。接下来先介绍匿名函数，后续再研究高阶函数的使用方法。</p>
<h3>匿名函数</h3>
<p>所谓匿名函数，是指不用 <code>def</code> 语句来创建的函数。匿名函数短小简洁，不需要专门定义，适合许多一次性使用的场景。</p>
<p>Python 中使用关键字 <code>lambda</code> 来创建一个匿名函数，它的语法为：</p>
<div class="codeblock code-template">
    <strong>lambda</strong> <em>param1</em>, <em>param2</em>, ... : <em>expression</em></div>
<p>其中函数的返回值即为冒号后表达式 <code><em>expression</em></code> 的值。以下是一个示例：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">y</span><span style="color: #405c79;"> : x + y ** </span><span style="color: #bf8b56;">2</span></div>
</div>
<p>一个 <code>lambda</code> 表达式，相当与隐式定义了如下的函数：</p>
<div class="codeblock code-template">
    <strong>def</strong> <strong>lambda</strong>(<em>param1</em>, <em>param2</em>, ...):<br />
&nbsp; &nbsp; <strong>return</strong> <em>expression</em></div>
<p>尽管这个等价形式从语法上来说是错误的。不过，<code>lambda</code> 也可以使用普通函数具有的各种特性，例如可变参数、默认参数等。</p>
<p>一个 <code>lambda</code> 表达式即是一个函数对象，可以把一个 <code>lambda</code> 表达式赋值给一个变量，通过变量调用匿名函数，例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; power = lambda a, n: a ** n<br />
&gt;&gt;&gt; power(3, 4)<br />
81</div>
<p>利用 <code>lambda</code> 函数也可以非常方便地调用一个高阶函数，只需要在调用函数时传入一个 <code>lambda</code> 函数作为参数即可，例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; call(lambda x, y, z: x / y - z, 10, 2, 4)<br />
1.0</div>
<p>或者也可以直接利用 <code>lambda</code> 函数作为一个函数的返回值，例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; def add_n(n):<br />
...     return lambda x : n + x<br />
...<br />
&gt;&gt;&gt; add_30 = add_n(30)<br />
&gt;&gt;&gt; add_30(-10)<br />
20</div>
<p>注意第一次调用高阶函数，返回了另一个函数，需要再次调用返回的结果。</p>
<p>既然一个 <code>lambda</code> 表达式就是一个函数对象，完全可以在定义完之后马上就调用：</p>
<div class="codeblock code-console">&gt;&gt;&gt; (lambda seq, n, p: seq[n] ** p)([1, 2, 3], 1, 5)<br />
32</div>
<p>注意为了防止歧义，需要将整个 <code>lambda</code> 表达式使用括号表示为一个整体。</p>
<p>这种定义完马上执行就抛弃的自执行函数看似多此一举，实际上它也是有用途的。例如在异步编程时，为了防止函数引用的一个全局变量被意外修改，就可以使用自执行函数将其变成一个参数，函数马上执行使得它变成了一个被“冻结”的局部变量。</p>
<h3>纯函数</h3>
<p>为了达到纯粹，函数式编程要求避免函数改变可变对象的状态。变量不会在全局范围内发生变化，这就要求在函数内不能使用 <code>global</code> 语句。除此之外，引用外部的可变对象也应该小心，因为可能在不经意间修改了可变对象。</p>
<p>没有副作用的函数符合在数学中函数的纯粹定义，也称为<strong>纯函数</strong>。</p>
<p><!-- finished(all):2022-05-21 --></p>
<p><a rel="nofollow" href="/archives/246">Python函数式编程03 高阶函数与匿名函数</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/246/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程04 常用内置函数</title>
		<link>/archives/239</link>
					<comments>/archives/239#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 23 May 2022 02:13:40 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=239</guid>

					<description><![CDATA[<p>Python 中的函数大体可分为以下两类： 标量函数&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/239">Python函数式编程04 常用内置函数</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p>Python 中的函数大体可分为以下两类：</p>
<ul>
<li>标量函数：作用于单个值，并返回单个值，例如 <code>abs()</code>、<code>pow()</code> 、<code>divmod()</code> 以及整个 <code>math</code> 模块中的函数都是标量函数。</li>
<li>集合函数：作用于一个集合或序列</li>
</ul>
<p>标量函数比较简单，这里就不再做额外的介绍。集合函数根据作用的效果，又可以细分为以下三类。</p>
<ol>
<li>映射：函数将运算作用于集合的每个元素，作为结果返回的集合与输入集合长度相同</li>
<li>过滤：函数将判断作用于集合的每个元素，以此舍弃一部分元素，返回的集合是输入集合的子集</li>
<li>归约：函数将集合内元素汇聚在一起，生成单个值作为结果，也称为累积</li>
</ol>
<p>这三种类型的函数在 Python 中都有典型的代表，下面先介绍这几个典型代表。</p>
<h2>典型高阶函数：map、filter和reduce</h2>
<h3>map：映射</h3>
<p>标量函数将数值从定义域映射到值域。例如 <code>math.sqrt()</code> 函数做的标量映射就为将一个浮点数 x 映射为另一个浮点数 y ，它们满足映射关系 <span class="math">\\( y \Leftarrow \sqrt{x} \\)</span> 。</p>
<p><code>map()</code> 是一个 Python 内置的集合映射函数，它接收一个函数和若干个列表（或者其他能够用 for 循环遍历的对象），并通过函数依次作用在列表的每个元素上，得到一个新的列表并返回。例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; map(abs, [-1, 2, -3, 4, -5])<br />
&lt;map object at 0x00000252852182B0&gt;</div>
<p>不过该函数的返回结果比较让人疑惑，它提醒得到了一个“map对象”，却不告诉具体包含了哪一些值。</p>
<p>这是因为 <code>map()</code> 得到的结果是一个可迭代对象。关于可迭代对象，这里暂时不做介绍，只需要知道它不是序列，因此直接打印它不会像序列一样可以直接观察其包含的每一个元素。</p>
<blockquote><p>在以后介绍到 Python 的面向对象编程时，将会详细介绍可迭代对象的概念和实质。</p></blockquote>
<p>后续会介绍 Python 中的生成器，从生成器的角度就可以明白可迭代对象的作用了。不过目前只需要明白以下两点就可以了：</p>
<ol>
<li>可迭代对象可以使用 <code>list()</code> 等转化为一个序列</li>
<li>可迭代对象可以使用 <code>for</code> 循环依次取出其包含的每一个值</li>
</ol>
<p>因此，可迭代对象有序列的特征。将其转换为列表，就可以很清楚地观察到结果了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; list(map(abs, [-1, 2, -3, 4, -5]))<br />
[1, 2, 3, 4, 5]</div>
<p><code>map()</code> 的作用原理，可以用下图很清晰地表示出来：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/04-function-map.jpg" alt="" width="340"></figure>
<p><code>map()</code> 将函数作用于序列中的每一个元素，并得到作用后的结果，因此表示一种映射关系。map 在英文中也有映射的意思。</p>
<p><code>lambda</code> 匿名函数特别适合作为 <code>map()</code> 所需要的函数，因为它只需要在传参的过程中用一下，然后就丢弃了。</p>
<p>例如，以下实现了这样一个集合映射：将集合中每一个为偶数的元素的值变为其一半，非偶数的元素的值变为其平方：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">seq = [</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">7</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">8</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">9</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #405c79;">result = </span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">elem</span><span style="color: #405c79;">: elem / </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> elem % </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;"> == </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;"> elem ** </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, seq)</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">list</span><span style="color: #405c79;">(result))</span></div>
</div>
<p>结果为：</p>
<div class="codeblock code-console">python -u demo.py<br />
[1.0, 9, 25, 49, 4.0, 81, 5.0]</div>
<p><code>map()</code> 函数也可以作用于多个可迭代对象，这种情况下其传入的函数会依次接收每一个可迭代对象中的元素作为参数，由多个参数得到一个结果。</p>
<p>以下示例，使用一个列表中的元素作为底数，另一个列表中的元素作为指数，使用映射关系得到每一组元素的幂：</p>
<div class="codeblock code-console">&gt;&gt;&gt; map(pow, range(3, 7), range(6, 2, -1))<br />
&lt;map object at 0x00000252852061D0&gt;<br />
&gt;&gt;&gt; list(_)<br />
[729, 1024, 625, 216]</div>
<p>如果不同序列长度不一样，那么结果的长度会被截断，只执行到可以映射一部分：</p>
<div class="codeblock code-console">&gt;&gt;&gt; list(map(lambda x, y: x + y, range(5), range(10)))<br />
[0, 2, 4, 6, 8]</div>
<h3>filter：过滤</h3>
<p><code>filter()</code> 函数的作用是把一个测试函数应用于集合中的每个值。如果测试结果为真，则保留该值，否则将其舍弃，最终根据结果得到一个子集。</p>
<p>以下给出了一个简单的示例，将一个整数列表中所有奇数剔除：</p>
<div class="codeblock code-console">&gt;&gt;&gt; filter(lambda n: n % 2 == 0, [1, 9, 4, 6, 25, 6])<br />
&lt;filter object at 0x0000025285218278&gt;<br />
&gt;&gt;&gt; list(_)<br />
[4, 6, 6]</div>
<p>注意 <code>filter()</code> 函数得到的结果也是一个可迭代对象，需要将其转换为列表才能观察包含的内容。</p>
<p>下图表示了 <code>filter()</code> 函数的作用原理：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/04-function-filter.jpg" alt="" width="390"></figure>
<p><code>filter()</code> 函数就像一个闸门，测试函数是闸门的控制杆，它决定了每个元素是否可以通过测试。</p>
<h3>reduce：归约</h3>
<p>相比前两个函数，<code>reduce()</code> 的作用可能稍微难理解。该函数不是 Python 内置函数，它存在于标准库中，需要提前将其导入进来：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> functools </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> reduce</span></div>
</div>
<p><code>reduce()</code> 传入的函数必须接收两个参数，<code>reduce()</code> 对可迭代对象中的每两个相邻元素反复调用传入的函数并得到一个结果，并返回最终生成的结果值。</p>
<p>下图表示了 <code>reduce()</code> 函数的作用原理：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/04-function-reduce.jpg" alt="" width="300"></figure>
<p>注意，<code>reduce()</code> 函数是返回一个具体的值，而不是可迭代对象。可以看出 <span class="math">\\( reduce(f, [x_1, x_2, x_3, x_4, \dots ]) \\)</span> 等价于 <span class="math">\\( f( \dots (f(f(x_1, x_2), x_3), x_4) \dots ) \\)</span> 这种形式。</p>
<p>下面通过两个具体的示例来介绍该函数的用法。更高级的用法在介绍了 <code>functools</code> 的其余实用函数后再介绍。</p>
<p>从一个高维列表中找出某一个元素，则需要若干次取值操作，每次取值都取出一个高维列表中的某一个子列表，从而将维度降低一级，若干次降维之后即可得到零维的元素。如果将以上行为翻译成<code>reduce()</code> 操作，则可以表示为对一个列表执行取值操作，再对得到子列表再次重复这一操作直至结束。相应的代码可以表示为：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> numpy </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> np</span></div>
<div><span style="color: #405c79;">space = np.arange(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;"> ** </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">).reshape((</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">))</span></div>
<div><span style="color: #405c79;">coordinate = [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">7</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #405c79;">elem = reduce(np.ndarray.</span><span style="color: #8b56bf;">__getitem__</span><span style="color: #405c79;">, [space] + coordinate)</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(elem)</span></div>
</div>
<p>如果不熟悉第三方库 NumPy 也不要紧，只需要知道它将 10<sup>0</sup> 到 10<sup>4</sup>-1 的所有数值按顺序重新排列成了一个 4 维的数组，每个维度的数组都具有 10 个元素。如果对传入的函数不太理解，可以改写成 <code>lambda arr, n: arr[n]</code> 这种直接的取值形式。以上函数的执行结果为：</p>
<div class="codeblock code-console">python -u demo.py<br />
1572</div>
<p>这与直接逐个取值的结果是一样的：</p>
<div class="codeblock code-console">&gt;&gt;&gt; space[1][5][7][2]<br />
1572</div>
<p>如果要对一个列表内的元素逐个相乘，并得到累积结果，这一过程可以表示为：对列表内每两个相邻元素相乘，将得到的结果再与下一个元素相乘。那么，用代码就可以表示为：</p>
<div class="codeblock code-console">&gt;&gt;&gt; reduce(lambda x, y: x * y, [6, 2, 9, 7, 3])<br />
2268</div>
<h2>其它常用内置函数</h2>
<p>接下来介绍一些常用的内置函数。由于它们已经被细分好了用途，因此它们并不都是高阶函数。同时，这些函数按照特点，都可以使用 <code>map()</code> 、<code>filter()</code> 和 <code>reduce()</code> 表示。</p>
<h3>映射函数</h3>
<h4>reverse：反序映射</h4>
<p>反转序列是一种比较常用到的操作。使用 <code>reversed()</code> 函数可以快速反转序列。</p>
<p>以下给出了一个简单的示例：</p>
<div class="codeblock code-console">&gt;&gt;&gt; reversed((1, 2, 3, 4, 5))<br />
&lt;reversed object at 0x00000252852181D0&gt;<br />
&gt;&gt;&gt; list(_)<br />
[5, 4, 3, 2, 1]</div>
<p>从结果中可以看到 <code>reversed()</code> 就像 <code>map()</code> 和 <code>filter()</code> 一样，不会立即得到结果，需要显式将结果转化为序列。</p>
<p><code>reversed()</code> 函数不能用于可迭代对象，只能用于序列。也就是说，<code>map()</code> 和 <code>filter()</code> 等函数的返回结果不能使用该函数反转值的顺序。</p>
<p>也可以使用切片 <code>[::-1]</code> 实现反序，但是切片会立即得到结果，有时候无法满足要求。</p>
<h4>enumerate：包含索引值映射</h4>
<p><code>enumerate()</code> 函数将输入序列的每一个元素扩展为一个二元组，其中第一个元素是索引值，另一个是原始输入元素。使用该函数可以为序列或者可迭代对象添加索引值信息。</p>
<p>以下给出了一个简单的示例：</p>
<div class="codeblock code-console">&gt;&gt;&gt; enumerate(['a', 'b', 'hello', 600])<br />
&lt;enumerate object at 0x0000025285216AB0&gt;<br />
&gt;&gt;&gt; list(_)<br />
[(0, 'a'), (1, 'b'), (2, 'hello'), (3, 600)]</div>
<p><code>enumerate()</code> 函数有一个非常常用的情景就是既需要用到一个序列的元素，又需要用到一个元素的索引值，此时就完全可以用它来取代</p>
<div class="codeblock code-template">
    <strong>for</strong> i <strong>in</strong> range(len(<em>sequence</em>)):<br />
&nbsp; &nbsp; i, sequence[i]<br />
&nbsp; &nbsp; ...</div>
<p>这种别扭的形式。因此，<code>enumerate()</code> 函数常用在循环中，写作：</p>
<div class="codeblock code-template">
    <strong>for</strong> i, elem <strong>in</strong> enumerate(<em>sequence</em>):<br />
&nbsp; &nbsp; ...</div>
<p>以下给出了这样一个示例函数，用于从一个序列中寻找一个元素：如果找到，它返回元素的索引值；否则，返回空值 <code>None</code> ：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">find_element</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">seq</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">target</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i, elem in </span><span style="color: #8b56bf;">enumerate</span><span style="color: #405c79;">(seq):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> elem == target:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> i</span></div>
</div>
<h3>归约函数</h3>
<h4>all和any：布尔规约</h4>
<p><code>all()</code> 函数用于判断一个集合内的所有元素是否<strong>都</strong>为真：如果都为真，它也返回真 <code>True</code> ；如果有一个不为真，它就返回假 <code>False</code> 。</p>
<p>它等价于以下函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">all</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">iterable</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> element in iterable:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> not element:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">False</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">True</span></div>
</div>
<p><code>any()</code> 函数用于判断一个集合内的所有元素是否<strong>存在</strong>真值：只要有一个真，它就返回真 <code>True</code> ；如果没有真值，它就返回假 <code>False</code> 。</p>
<p>它等价于以下函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">any</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">iterable</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> element in iterable:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> element:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">True</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">False</span></div>
</div>
<p>从它们的描述上可以看到，它们都是归约函数，将一个集合的元素归约成单个布尔值 <code>True</code> 或 <code>False</code> 。<code>all()</code> 函数对集合中的所有元素使用 and 归约，相当于在各个值之间加上 <code>and</code> 运算符。any() 函数使用 or 归约，相当于加上 or 运算符。</p>
<p>这两个函数与数理逻辑密切相关，<code>all()</code> 等效于全称量词 <span class="math">\\( \forall \\)</span> ，其运算可以表现为如下公式：</p>
<div class="math">
\\[<br />
(\forall _{x \in s })\, x \equiv \text{True}<br />
\\]</div>
<p>由数理逻辑上的概念，可以研究一个有趣的命题：对一个空序列调用以上函数，即 <code>all([])</code> 的结果如何？该命题可以把对空集的归约和对非空集的归约放在一起做交集来解决。</p>
<p>首先研究对空集和非空集的归约做逻辑与运算：</p>
<div class="math">
\\[<br />
(\forall _{x \in \emptyset })\, x \equiv \text{True} \land (\forall _{x \in s })\, x \equiv \text{True}<br />
\\]</div>
<p>使用集合的分配律，可以将两个结果的与运算符改为两个集合做并集运算的形式：</p>
<div class="math">
\\[<br />
(\forall _{x \in \emptyset \cup s })\, x \equiv \text{True}<br />
\\]</div>
<p>注意到 <span class="math">\\( \emptyset \cup s \\)</span> 就等价于 <span class="math">\\( \emptyset \cup s \\)</span> ，也就是说对空集和非空集的归约做逻辑与运算的结果和空集无关，由此可以得出结论：对空集的 all 归约为布尔值真 <code>True</code>（真和另一值的与运算都取决于另一值）。</p>
<p>同理，<code>any()</code> 等效于存在量词 <span class="math">\\( \exists \\)</span> ，研究方法与以上类似，不过要对空集和非空集的归约做逻辑或运算，这样才满足集合的分配律，可以让两个归约取并集。得到的逻辑或运算的结果仍然和空集无关，对空集的 any 归约为布尔值真 <code>False</code>（假和另一值的或运算都取决于另一值）。</p>
<p>可以验证 Python 的行为满足以上规则：</p>
<div class="codeblock code-console">&gt;&gt;&gt; all([])<br />
True<br />
&gt;&gt;&gt; any(())<br />
False</div>
<p>这是 <code>all()</code> 和 <code>any()</code> 函数初看可能比较违反直觉的一点。不过仔细查看两者的等价函数，可以发现其实现实际上是满足该规则的。</p>
<h4>len和sum：汇聚归约</h4>
<p><code>len()</code> 函数用于计算序列中所有值的个数，即序列的长度。<code>sum()</code> 函数用于计算所有值的总数，即对序列的所有元素求和。</p>
<p>这两个函数在数学上意义相近：<code>len()</code> 函数把序列中每个元素看作 1（取 0 次方），然后返回所有元素的和；sum() 函数则把序列中每个元素看作实际值（取 1 次方），然后返回所有元素的和。</p>
<p>但在 Python 中的实现方法却有很大差别：<code>sum()</code> 函数可用于任何可迭代对象，<code>len()</code> 函数不能用于可迭代对象，只能用于序列。</p>
<p>这种实现方法上的不对等可能会导致在某些情况下遇到类型错误，因此注意在编写相关代码时为了扩展使用场景，需要在用到 <code>len()</code> 之前将参数转换为序列对象，例如：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">average</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">iterable</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; seq = </span><span style="color: #bf568b;">tuple</span><span style="color: #405c79;">(iterable)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(seq) / </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(seq)</span></div>
</div>
<h4>zip：结构化和平铺序列</h4>
<p><code>zip()</code> 函数将来自多个集合的数据交叉组合在一起，将 n 个带有元素的集合转换为 n 元组。例如：</p>
<p class="hidden">注：原文表述有误，不知道是不是翻译的锅</p>
<div class="codeblock code-console">&gt;&gt;&gt; ls01 = [1, 2, 3, 4]<br />
&gt;&gt;&gt; ls02 = [0.5, 1, 2, 4]<br />
&gt;&gt;&gt; zip(ls01, ls02)<br />
&lt;zip object at 0x0000025284CB3CC8&gt;<br />
&gt;&gt;&gt; list(_)<br />
[(1, 0.5), (2, 1), (3, 2), (4, 4)]</div>
<p>以上示例用 <code>zip()</code> 函数将两个集合的数据组合在一起，生成了一个二元组序列。并且可以看到 <code>zip()</code> 同样不会立即得到结果，需要显式将结果转化为序列。</p>
<p>如果只给 <code>zip()</code> 函数传入一个集合，那么得到的结果是只有一个元素的元组，这也符合逻辑。</p>
<p>对于归约函数，都需要知道归约空序列（即传入一个空序列作为参数）的结果，即归约时的<strong>单位元</strong>是什么。例如对于上文提到的几个函数，<code>any()</code> 的单位元是布尔值 <code>False</code> ，sum() 的单位元是数值 <code>0</code> 。可以通过代码检查 <code>zip()</code> 的单位元：</p>
<div class="codeblock code-console">&gt;&gt;&gt; list(zip([]))<br />
[]</div>
<p>结果表明 <code>zip()</code> 的单位元是无数据，并且可以被转换为一个空序列。</p>
<p><code>zip()</code> 有几个很常见的应用场景，例如，从两个序列构造成一个字典，此时就可以使用 <code>zip()</code> 将一个键值对合在一起：</p>
<div class="codeblock code-console">&gt;&gt;&gt; keys = [1, 2, 3, 'a']<br />
&gt;&gt;&gt; values = ['a', 'b', ['hello'], 123]<br />
&gt;&gt;&gt; dict(zip(keys, values))<br />
{1: 'a', 2: 'b', 3: ['hello'], 'a': 123}</div>
<p>zip 在英文中也表示拉链，可以认为该函数像拉链一样将两个序列并排缝合在了一起。</p>
<p>可以将其推广到更一般的应用场景。假设有许多个序列，它们在相同位置处表达的是同一个结构在同一维度上的信息，例如：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">names = [</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">John</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Tim</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Marry</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #405c79;">ages = [</span><span style="color: #bf8b56;">14</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">12</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">13</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #405c79;">scores = [</span><span style="color: #bf8b56;">74</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">79</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">86</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;">]</span></div>
</div>
<p>如果要处理各个结构的信息，那么一种朴素的方法就是使用 <code>for</code> 循环依次按索引值来处理每个元素：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(names)):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; names[i], ages[i], scores[i]</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
</div>
<p>使用 <code>zip()</code> 函数，可以将不同维度的信息按索引值组成一个整体，然后在遍历时可以按整体代替索引值，这样处理逻辑更清晰：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> name, age, score in </span><span style="color: #8b56bf;">zip</span><span style="color: #405c79;">(names, ages, scores):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
</div>
<p>不过，<code>zip()</code> 函数使用时有一点需要注意：如果不同序列长度不一样，那么它们会被截断以保证长度相同：</p>
<div class="codeblock code-console">&gt;&gt;&gt; ls2 = [2, 2]<br />
&gt;&gt;&gt; ls3 = [3, 3, 3]<br />
&gt;&gt;&gt; ls4 = [4, 4, 4, 4]<br />
&gt;&gt;&gt; list(zip(ls2, ls3, ls4))<br />
[(2, 3, 4), (2, 3, 4)]</div>
<p>这个特性有时也会造成一定的困扰。不过 Python 的标准库提供了一种替代的解决方案，这点留到后续介绍。</p>
<h3>高阶函数</h3>
<h4>max与min：寻找最值</h4>
<p><code>max()</code> 函数和 <code>min()</code> 函数就像表明上的含义一样，用来寻找最大值或最小值的。这两个函数可以接收可变个输入参数，找出其中的最值；也可以接收一个集合，寻找其中的最值。例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; max(1, 7, 4, 6)<br />
7<br />
&gt;&gt;&gt; min([1, 7, 4, 6])<br />
1</div>
<p>注意，这两个函数默认情况下没有单位元，因为传入空序列是会发生错误的。不过它们都有一个关键字形式的默认参数 <code>default</code> ，用于表示当传入空序列时默认返回的值：</p>
<div class="codeblock code-console">&gt;&gt;&gt; max([], default=10)<br />
10</div>
<p>当 <code>max()</code> 函数和 <code>min()</code> 函数接收一个集合时，它们可以用作高阶函数，它的关键字参数 <code>key</code> 可以传入一个函数，该函数指定如何从集合中的每一个对象获取需要比较的值。</p>
<p>例如，给定以下包含元组的序列：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">students = [(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">John</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">14</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">74</span><span style="color: #405c79;">, ), (</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Tim</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">12</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">79</span><span style="color: #405c79;">), </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Marry</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">13</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">86</span><span style="color: #405c79;">), (</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Hans</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">13</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">81</span><span style="color: #405c79;">)]</span></div>
</div>
<p>每个元组中，最后一个元素代表分数。如果要找出列表中分数的最大值，可以这样设计 <code>key</code> 的函数：</p>
<div class="codeblock code-console">&gt;&gt;&gt; max(students, key=lambda x: x[-1])<br />
('Marry', 13, 86)</div>
<p><code>key</code> 代表的函数需要是标量函数（作用于一个值，返回一个值）。</p>
<p>以下再给出一个示例，可以获取一个序列中绝对值最大的元素：</p>
<div class="codeblock code-console">&gt;&gt;&gt; max([1, 4, -5, 3, -7], key=abs)<br />
-7</div>
<h4>sorted：数据排序</h4>
<p><code>sorted()</code> 函数用于将数据排序。以下给出了一个简单示例：</p>
<div class="codeblock code-console">&gt;&gt;&gt; sorted([6, 2, 9, 7, 3])<br />
[2, 3, 6, 7, 9]</div>
<p>该函数不同于以上介绍的其它函数，它会直接返回列表对象。也可以使用列表对象的 <code>.sort()</code> 方法将列表排序，但是使用 <code>sorted()</code> 函数的优点在于它不会改动原有列表，而是返回一个新列表，因此该函数是无副作用的。</p>
<p>该函数可以将任意可迭代对象排序，返回的结果都是列表。它和 <code>max()</code> 函数一样都有参数 <code>key</code> ，与列表的 <code>.sort()</code> 方法一样都有参数 <code>reversed</code> 用于指定是否降序排列。</p>
<h2>参考资料</h2>
<p><a href="https://docs.python.org/3/library/functions.html">https://docs.python.org/3/library/functions.html</a></p>
<p>Python3 官方文档关于内置函数的介绍</p>
<p><a rel="nofollow" href="/archives/239">Python函数式编程04 常用内置函数</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/239/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程02 函数参数设计与处理</title>
		<link>/archives/230</link>
					<comments>/archives/230#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 20 May 2022 15:31:46 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=230</guid>

					<description><![CDATA[<p>在上一节中，介绍了参数的概念，并用以下图片来表示传参&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/230">Python函数式编程02 函数参数设计与处理</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p>在<a href="/archives/210">上一节</a>中，介绍了参数的概念，并用以下图片来表示传参的过程：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/01-function-return.jpg" alt="" width="490"></figure>
<p>但是实际上，Python 的参数传递方式有很多，下面逐一介绍。</p>
<h2>函数的多种参数</h2>
<h3>位置参数和关键字参数</h3>
<p>一个函数可能有多个参数，在定义时需要将这些参数逐个声明在圆括号内：</p>
<div class="codeblock code-template">
    <strong>def</strong> function_name(<em>param1</em>, <em>param2</em>, ...):<br />
&nbsp; &nbsp; ...</div>
<p>在传入参数时，必须按照定义时的顺序将实际参数填入函数调用时的括号内，绝对不能过多或过少，否则就会引发错误。传入实际参数的顺序要和定义形式参数的顺序一致，不然形式参数就会接收到错误的值，可能会导致严重的后果。</p>
<p>考虑以下用于计算等差数列前 n 项和的函数，这里没有使用公式计算，而是使用了最原始的累加方式：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">series_sum</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">first</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">inc</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; total = </span><span style="color: #bf8b56;">0</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> _ in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(n):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; total += first</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; first += inc</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> total</span></div>
</div>
<p>该函数定义了三个参数：首项 <code>first</code> 、公差 <code>inc</code> 、项数 <code>n</code> 。如果传入的参数过少，不能满足求和的条件，那么自然会导致错误；如果传入的参数过多，没有变量能够接纳它，也会导致错误；如果传入的参数顺序错误，那么它们被解释为错误的含义，计算得到的结果自然也会出问题。</p>
<p>这种直接按照顺序接收括号内填入的实际参数，必须和定义函数时的位置一一对应，就像最开始的那张图片展示的一样，称为<strong>位置参数</strong>。以下调用函数就使用位置参数的形式传参：</p>
<div class="codeblock code-console">&gt;&gt;&gt; series_sum(1, 2, 5)<br />
25</div>
<p>除此之外，还有一种称为<strong>关键字参数</strong>的传参方式。在使用关键字参数的形式传入参数的时候，形式参数使用等号被赋予实际参数的值，就像普通的变量赋值方式一样，如下：</p>
<div class="codeblock code-template">
    function_name(<em>param1</em>=arg1, <em>param2</em>=arg2, ...)</div>
<p>以下是使用关键字参数向之前的函数传参：</p>
<div class="codeblock code-console">&gt;&gt;&gt; series_sum(first=2, inc=3, n=4)<br />
26</div>
<p>使用关键字参数传递实际参数的优点在于，哪个参数接收哪个值在传参的时候便表现地一目了然，只需要关注参数的含义，不需要知道按什么顺序填入。因此这种方式可以不受参数位置的影响，在传参的时候可以任意调换参数的位置：</p>
<div class="codeblock code-console">&gt;&gt;&gt; series_sum(n=4, first=2, inc=3)<br />
26</div>
<p>位置参数和关键字参数可以在调用时混用，但是必须要确保关键字参数在位置参数的后面，否则 Python 解释器无法确定位置参数表示哪个位置。</p>
<hr>
<p>由于关键字参数比较好用，Python 中可以在定义一个函数时，使用星号 <code>*</code> 占据一个参数的位置，表示在此之后的参数都只接受关键字参数的传参形式，即按照如下形式定义参数：</p>
<div class="codeblock code-template">
    <strong>def</strong> function_name(<em>param1</em>, ..., *, <em>paramn</em>, ...):<br />
&nbsp; &nbsp; ...</div>
<p>那么 <code><em>paramn</em></code> 及其之后的参数都只接受 <code><em>paramn</em>=argn</code> 形式的传参方式。如果不按照此规则传入参数，那么会发生错误。在此之前的参数则可以按任意形式传参。</p>
<p>Python3.8 新增了一种语法，可以使用斜杠 <code>/</code> 占据一个参数的位置，表示在此之前的参数都只接受位置参数的传参形式。</p>
<p>例如，对以下函数声明：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">a</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">b</span><span style="color: #405c79;">, /, </span><span style="color: #bf8b56;">c</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">d</span><span style="color: #405c79;">, *, </span><span style="color: #bf8b56;">e</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">f</span><span style="color: #405c79;">): </span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">pass</span></div>
</div>
<p>那么参数 <code>a</code> 和 <code>b</code> 都只能以位置参数的形式传入，参数 <code>e</code> 和 <code>f</code> 都只能以关键字参数的形式传入，而 <code>c</code> 和 <code>d</code> 则不受限制，可以按任意形式传入参数。因此，调用该函数时，前两个参数必定代表 <code>a</code> 和 <code>b</code> ，并且必定存在 <code>e=...</code> 和 <code>f=...</code> 的关键字参数。</p>
<p>如果查阅 Python 内置函数 <code>divmod()</code> 的帮助，可以看到：</p>
<div class="codeblock code-console">&gt;&gt;&gt; help(divmod)<br />
Help on built-in function divmod in module builtins:</p>
<p>divmod(x, y, /)<br />
Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.</p>
</div>
<p>这表明 <code>divmod()</code> 的两个参数都只支持按位置形式传参的方法。</p>
<h3>可变参数</h3>
<p>在 Python 中，通常使用 <code>print</code> 函数来打印变量。该函数可以一次性打印多个变量，多个变量的打印结果以空格隔开：</p>
<div class="codeblock code-console">&gt;&gt;&gt; v1 = 'hello'<br />
&gt;&gt;&gt; v2 = 0.75<br />
&gt;&gt;&gt; v3 = [1, 2]<br />
&gt;&gt;&gt; v4 = sum<br />
&gt;&gt;&gt; print(v1, v2, v3, v4)<br />
a 0.7 [1, 2] &lt;built-in function sum&gt;</div>
<p>仔细观察传参的过程，可以发现向 <code>print</code> 函数中传入了许多个位置参数。但是传入的参数个数是不确定的，可能为 4 个，也可能为 5 个、10 个 或 146 个。但函数在定义参数时，无法确定到底要定义几个参数，因为不管是位置参数还是关键字参数，都必须使定义的参数个数等于传入的参数个数。</p>
<p>如果需要让函数接收可变个数的参数，可以使用<strong>可变参数</strong>。可变参数在定义时，需要在参数名前面加上星号 <code>*</code> ，如下所示：</p>
<div class="codeblock code-template">
    <strong>def</strong> function_name(*<em>args</em>):<br />
&nbsp; &nbsp; ...</div>
<p>当然，参数也可以写作 <code>*data</code> 、<code>*hello</code> 等任意星号后接一个变量名的形式，这种情况下该变量代表的参数会被解释为可变参数。</p>
<p>接下来通过以下函数观察可变参数的实质：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">func_with_args</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">args</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(args, </span><span style="color: #bf568b;">type</span><span style="color: #405c79;">(args))</span></div>
</div>
<p>可以这样调用该函数，给它传入任意数量的参数：</p>
<div class="codeblock code-console">&gt;&gt;&gt; func_with_args('str', 0.12, [6, False])<br />
('str', 0.12, [6, False]) &lt;class 'tuple'&gt;</div>
<p>根据结果可以看到，可变参数实际上就是将许多参数封装成了一个元组，以元组的形式传入函数内部处理。</p>
<p>明白了这个道理以后，就可以编写类似以下的函数来处理可变参数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">average</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(data) / </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(data)</span></div>
</div>
<p>注意到 <code>data</code> 就是元组以后，就可以调用 <code>sum()</code> 和 <code>len()</code> 这两个能接收元组作为参数的函数了。当然也可以使用 <code>for</code> 循环直接遍历它。</p>
<p>以上可变参数在传递参数时都是使用位置参数的形式，除此之外还有一种关键字形式的可变参数。关键字形式的可变参数在定义时，需要在参数名前面加上两个星号 <code>**</code> ，如下所示：</p>
<div class="codeblock code-template">
    <strong>def</strong> function_name(**<em>kwargs</em>):<br />
&nbsp; &nbsp; ...</div>
<p>同理参数也可以写作 <code>**kw</code> 、<code>**options</code> 等形式，总之这种情况下该变量代表的参数会被解释为关键字形式的可变参数。</p>
<p>类似地可以通过以下函数观察关键字可变参数的实质：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">func_with_kwargs</span><span style="color: #405c79;">(**</span><span style="color: #bf8b56;">kwargs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(kwargs, </span><span style="color: #bf568b;">type</span><span style="color: #405c79;">(kwargs))</span></div>
</div>
<p>可以给它传入任意数量的关键字参数，注意参数名可以是任意的：</p>
<div class="codeblock code-console">&gt;&gt;&gt; MALE=0<br />
&gt;&gt;&gt; func_with_kwargs(name='John', age=12, gender=MALE)<br />
{'name': 'John', 'age': 12, 'gender': 0} &lt;class 'dict'&gt;</div>
<p>原来，关键字形式的可变参数实际上是被封装成了一个字典，键是形式参数名，值是实际参数值，传入函数内部处理。</p>
<p>有一点需要注意的是，在定义函数时，参数的定义顺序必须满足以下规则：</p>
<ul>
<li>一个函数定义时，最多只能有一个位置形式的可变参数，也最多只能有一个关键字形式的可变参数</li>
<li>位置形式的可变参数后面可以定义普通形式的参数，并且如果后面有普通形式的参数，它必须以关键字形式的方式传递实际参数</li>
<li>关键字形式的可变参数必须是最后一个定义的参数</li>
</ul>
<p>也就是说，在传递实际参数时，首先要让位置参数根据位置一一对应，多余的位置参数被位置形式的可变参数接收；然后要让关键字参数根据关键字一一对应，多余的关键字参数被关键字形式的可变参数接收。</p>
<p>使用默认参数，可以让函数在传入不同参数时，得到不同的结果。例如以下计算三角形的函数，如果传入两个参数，就将它们当做三角形的底和高；如果传入三个参数，就将它们当做三角形的三个边：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">triangle_aera</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">args</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(args) == </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; b, h = args[</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">], args[</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> b * h / </span><span style="color: #bf8b56;">2</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">elif</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(args) == </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; a, b, c = args[</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">], args[</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">], args[</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; s = (a + b + c) / </span><span style="color: #bf8b56;">2</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> (s * (s - a ) * (s - b) * (s - c)) ** </span><span style="color: #bf8b56;">0.5</span></div>
</div>
<p>Python 内置类 <code>range</code> 的构造函数也使用了类似的方式：当传入一个参数时，它被当做范围的结束值，此时起始值默认为 0 ；当传入两个参数时，它们分别被当做范围的起始和结束值；当传入三个参数时，最后一个参数被当做步长。</p>
<hr>
<p>Python 中还存在以下语法：在一个序列前加上星号 <code>*</code> ，它会被展开为一系列参数供函数调用，例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; ls = [1, 4, 6, 9]<br />
&gt;&gt;&gt; print(*ls)<br />
1 4 6 9<br />
&gt;&gt;&gt; func_with_args(*ls)<br />
(1, 4, 6, 9) &lt;class 'tuple'&gt;</div>
<p>这种参数传递的方式，等价于使用 <code>for</code> 循环依次从序列中取值，然后逐一填入函数调用的括号中。</p>
<p>有位置形式的参数处理就有关键字形式的参数处理，在一个字典前加上两个星号 <code>**</code> ，它会被展开为一系列键值对映射的关键字参数供函数调用，例如：</p>
<div class="codeblock code-console">&gt;&gt;&gt; from time import localtime<br />
&gt;&gt;&gt; info = {'type': 'text', 'length': 592523, 'create-at': localtime()}<br />
&gt;&gt;&gt; func_with_kwargs(**info)<br />
{'type': 'text', 'length': 592523, 'create-at': time.struct_time(tm_year=2022, tm_mon=5, tm_mday=20, tm_hour=12, tm_min=27, tm_sec=40, tm_wday=4, tm_yday=140, tm_isdst=0)} &lt;class 'dict'&gt;</div>
<p>对比可变参数的定义，就可以很好地明白它们的关系：调用函数时在实际参数前置星号可以将序列或字典展开成一系列参数，定义函数时在形式参数前置星号可以将一系列参数收集成序列或字典。</p>
<p>可变参数还有一个非常好用的功能，<code>*args</code> 和 <code>**kwargs</code> 组合在一起可以接收任意形式的参数。例如，以下实现了一个 <code>print_any()</code> 函数，如果检查满足 <code>print()</code> 需要的参数，就将接收的所有参数传递给它；否则，传递给自定义的 <code>log</code> 函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">log</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">values</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">options</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'[</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">options.get(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">level</span><span style="color: #405c79;">"</span><span style="color: #405c79;">)</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">]'</span><span style="color: #405c79;">, *values)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">print_any</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">args</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">kwargs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> not </span><span style="color: #bf568b;">set</span><span style="color: #405c79;">(kwargs.keys()) - {</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">sep</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">end</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">file</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">flush</span><span style="color: #405c79;">'</span><span style="color: #405c79;">}:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(*args, **kwargs)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; log(*args, **kwargs)</span></div>
</div>
<p>例如，以下尝试调用该函数：</p>
<div class="codeblock code-console">&gt;&gt;&gt; print_any(1, 2, ['a', 'b'])<br />
1 2 ['a', 'b']<br />
&gt;&gt;&gt; print_any(1, 2, ['a', 'b'], sep='--')<br />
1--2--['a', 'b']<br />
&gt;&gt;&gt; print_any(1, 2, ['a', 'b'], level='DEBUG')<br />
[DEBUG] 1 2 ['a', 'b']</div>
<p>这时通过将一个函数的可变参数传给另一个函数，只需修改最终调用函数时传入的参数，而无需修改定义时的参数。</p>
<h3>默认参数</h3>
<p>如果在调用函数时不向某些参数传递值，那么 Python 解释器就不知道参数的具体值，由此发送错误。</p>
<p>不过 Python 提供了一种语法，可以在定义函数时带上一个可选的参数，使得它在调用函数时可以不进行传参数操作。若未传入参数，它取得默认值；若传入参数，它取得传入的参数。这种形式的参数，称为<strong>默认参数</strong>。</p>
<p>定义默认参数只需要在定义普通参数时用等号给它一个默认值即可：</p>
<div class="codeblock code-template">
    <strong>def</strong> function_name(<em>arg1</em>, ..., <em>argn</em>=<em>default</em>):<br />
&nbsp; &nbsp; ...</div>
<p>任何非可变参数都可以当做默认参数使用，只有一个限制：默认参数的定义必须要在非默认参数之后，否则在调用时无法判断该参数是被忽略了还是使用默认值。</p>
<p>在定义函数时，经常会添加一些额外的参数让函数处理更多功能。但是有时候部分参数又用不上，只希望它保持一个常用的值即可，这个时候就可以使用默认参数。</p>
<p>例如，以下使用了这样一个求加权平均值的函数。但是在一般情况下求平均值时，其权重全部相等且为 1 。此时，就可以使用默认参数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">weighted_average</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">weight</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">None</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> weight is </span><span style="color: #bf8b56;">None</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(data) / </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(data)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; total = </span><span style="color: #bf8b56;">0</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(data)):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total += data[i] * weight[i]</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> total / </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(data)</span></div>
</div>
<p>如果参数的默认值较多，使用关键字形式的可变参数也可以代替默认参数。例如，在某些编写桌面应用的库中，生成一个组件具有很多选项，那么此时就可以先使用关键字形式的可变参数，到了函数内部再进一步判断有没有给定相应的选项。不过，一般情况下不建议滥用这种行为，因为关键字形式的可变参数仅凭函数定义的基本信息无法很快明白到底该传入什么样的参数。</p>
<p>默认参数在使用时，有一个非常容易遇到的陷阱，在介绍时不能不提。考虑以下函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">make_staggered</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">seq1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">seq2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">init</span><span style="color: #405c79;">=[]):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(seq1)):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(seq2) &lt; i + </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">break</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; init.append(seq1[i])</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; init.append(seq2[i])</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> init</span></div>
</div>
<p>该函数可以将两个序列中的值交错排列在同一个列表中并返回。可以给函数一个默认值让交错结果添加到默认列表后，不然就添加到一个空列表后。尝试调用该函数，可以看到结果是正常的：</p>
<div class="codeblock code-console">&gt;&gt;&gt; ls_1 = [1, 3, 5, 7, 9]<br />
&gt;&gt;&gt; ls_2 = [2, 4, 6, 8, 10]<br />
&gt;&gt;&gt; make_staggered(ls_1, ls_2)<br />
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div>
<p>如果自行提供一个列表，让结果补充在它后面，也是可以的：</p>
<div class="codeblock code-console">&gt;&gt;&gt; make_staggered(ls_1, ls_2, ls_1)<br />
[1, 3, 5, 7, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</div>
<p>不过，再次忽略默认参数的结果可能出乎意料：</p>
<div class="codeblock code-console">&gt;&gt;&gt; ls_3 = [1] * 4<br />
&gt;&gt;&gt; ls_4 = [-1] * 4<br />
&gt;&gt;&gt; make_staggered(ls_3, ls_4)<br />
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, -1, 1, -1, 1, -1, 1, -1]</div>
<p>明明在调用时让默认值取空列表，但此时前面明显多了一部分没有涉及到的元素。仔细观察，这部分元素是在第一次调用时该函数得到的结果。</p>
<p>出现这部分结果的原因在于，函数在被 Python 解释器处理后，参数的默认值也会随即生成。如果自行指定一个其它值，那么生成的默认值就会被放在一旁；如果空缺出这个参数，那么默认值就会被用上。</p>
<p>默认值和函数一起，不管调用多少次，自始至终只生成一次。而上一节介绍了列表是可变对象，在调用函数是会改变它的内在结构。因此，这个改变在函数调用完毕后，就被保留了下来，并在下一次调用时影响结果。</p>
<p>因此，函数的默认参数应该避免为可变对象，否则被改变的可变对象就会干扰函数的默认值。如果真的要让默认参数是一个可变对象，也不能直接将可变对象放在参数列表中，应该做如下处理：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">make_staggered</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">seq1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">seq2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">init</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">None</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> init is </span><span style="color: #bf8b56;">None</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; init = []</span></div>
</div>
<p>这样，如果空缺默认参数，它就会在函数运行时创建一个空列表。</p>
<p>不过，这种特性有时候也有用。在深拷贝一个对象时，为了避免直接或间接对自身的引用导致循环拷贝，在默认参数中使用一个字典保留在当前复制过程中已复制的对象。</p>
<h2>为函数提供注释</h2>
<h3>函数的文档</h3>
<p>当定义完成函数后，需要为其编写一份简短的说明，介绍函数的用途、参数和返回值的含义，帮助使用函数的人更快明白其用法。</p>
<p>Python 的 docstring 提供了一种原生的对函数文档的支持。在每一个函数的开头，在函数体前，都可以直接放置一个字符串，这个字符串也需要和下面的代码一样有缩进，它就代表对这个函数的说明。</p>
<p>以下给出了一个示例：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">fibonacci</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #405c79;">"""</span><span style="color: #56bf8b;">Return a list containing the Fibonacci series up to n.</span><span style="color: #405c79;">"""</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; result = []</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; a, b = </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">while</span><span style="color: #405c79;"> a &lt; n:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; result.append(a)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; a, b = b, a+b</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
</div>
<p>在使用内置函数 <code>help()</code> 查看一个函数的说明时，docstring 就会被打印出来协助说明函数的用途：</p>
<div class="codeblock code-console">&gt;&gt;&gt; help(fibonacci)<br />
Help on function fibonacci in module __main__:</p>
<p>fibonacci(n)<br />
Return a list containing the Fibonacci series up to n.</p>
</div>
<p>在使用编辑器或 IDE 编写代码时，一些专业的编辑器或 IDE 就会在调用函数时显示其文档，帮助使用者更好地明白如何应用该函数。</p>
<p>以下是在 Visual Studio Code 中的提示效果：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/02-docstring-vscode.jpg" alt="" width="430"><figcaption>敲出括号后，VSCode就会出现此提示</figcaption></figure>
<p>以下是在 Jetbrains Pycharm 中的提示效果：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/02-docstring-pycharm.jpg" alt="" width="380"><figcaption>将鼠标移动到函数名上，Pycharm就会出现此提示</figcaption></figure>
<p>当遇到一个不认识的函数时，可以通过检查其文档了解使用方法。以下是第三方库 <code>sklearn</code> 的帮助文档，可以看到它不仅提供了详尽的注释，还提供了使用示例：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/02-docstring-sklearn.jpg" alt="" width="580"></figure>
<h3>类型注解</h3>
<p>类型注解是 Python3 提供的一个实验性语法，用来表示一个参数的参数应该是什么类型的，以及它应该会返回什么类型的值。注意这里的表述“应该”，这里只是一种辅助性说明，Python 解释器并不会真正确定类型是否匹配。</p>
<p>类型注解在变量名后使用冒号 <code>:</code> 后面跟随一个具体的类型表明参数的类型，在参数列表的括号后、冒号前使用组合箭头符号 <code>-&gt;</code> 表示返回值的类型，如下：</p>
<div class="codeblock code-template">
    <strong>def</strong> function_name(<em>param1</em>: type1, <em>param2</em>: type2, ...) -&gt; rettype:<br />
&nbsp; &nbsp; ...</div>
<p>以下是一个使用示例：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> typing </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> List</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">vector</span><span style="color: #405c79;">: List[</span><span style="color: #bf568b;">float</span><span style="color: #405c79;">], </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">float</span><span style="color: #405c79;"> = </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">) -&gt; List[</span><span style="color: #bf568b;">float</span><span style="color: #405c79;">]:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; result = []</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in vector:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; result.append(i * scalar)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
</div>
<p>类型注解有以下几个常用功能：</p>
<ol>
<li>在 <code>help()</code> 提供的帮助文档中，让使用者了解应该传入的参数类型</li>
<li>许多编辑器或 IDE 也会在使用时显示这些信息</li>
<li>一些第三方静态检查工具例如 mypy 可以根据类型注解对 Python 代码做静态类型检查</li>
</ol>
<p>由于静态类型比动态类型的代码更易使用、更好维护，因此 Python 社区对引入静态类型的呼吁较高，许多 Python 项目都引入了类似的静态类型注解与检查功能。这里仅对类型注解做最基本的介绍，如果想了解更多有关于静态注解的资料，可以参考官方文档 <a href="https://docs.python.org/3/library/typing.html">https://docs.python.org/3/library/typing.html</a> 。</p>
<p><a rel="nofollow" href="/archives/230">Python函数式编程02 函数参数设计与处理</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/230/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程01 函数的基本概念</title>
		<link>/archives/210</link>
					<comments>/archives/210#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 18 May 2022 11:48:15 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=210</guid>

					<description><![CDATA[<p>什么是函数 函数(function)是可以重复使用的&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/210">Python函数式编程01 函数的基本概念</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>什么是函数</h2>
<p><strong>函数</strong>(function)是可以重复使用的代码片段。在不同的编程语言里，它可能有不同的称呼，例如子程序、方法、过程等。但它们的本质都是类似的。</p>
<p>当经常性地遇到一种或一类的问题时，需要多次使用相同或类似的代码。这个时候，就可以将这一段代码编写成函数，利用函数来执行一种或一类功能，从而更加简洁、逻辑清晰。</p>
<p>例如，考虑有以下列表：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">ls = [</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">7</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">]</span></div>
</div>
<p>假设需要计算列表内所有元素的和，这个时候，一般来说可以编写以下代码：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">total = </span><span style="color: #bf8b56;">0</span></div>
<div><span style="color: #bf568b; font-weight: bold;">for</span><span style="color: #405c79;"> i in ls:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; total += i</span></div>
</div>
<p>这当然没有问题。但是，如果每次遇到计算元素的和，都需要编写这样一段代码，不仅比较麻烦，而且还容易发生疏忽，编写完的程序看上去都是一些简单的命令，无法很快明白其具体用途。</p>
<p>这个时候，一个更好的思路是将其抽象为一个过程，每次只需要表示需要处理一段类似的过程即可，至于具体的处理细节可以预先定义好。</p>
<p>函数是具有一定功能的一些代码组成的一个抽象整体，在编写程序时往往只需要关注整体将实现哪些功能，而不需要明白具体的实现步骤如何。编程语言上的函数实质上很类似于数学上的函数。</p>
<p>如果使用 Python 的内置函数(built-in functions)，以上代码可以代替为：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">total = </span><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(ls)</span></div>
</div>
<p><code>sum()</code> 函数将一个处理逻辑抽象为了求和过程，无论是编程程序还是阅读程序，都可以很好地明白该代码的工作内容和结果。</p>
<p>函数将代码分割成不同的区域，每个区域只需实现一个或一类特定的功能，让代码更模块化，在阅读代码时，如果遇到一个函数，很容易就可以明白它的功能。至于具体的实现方法，只需找到函数的位置就可以明白。因此即便有些时候，一个功能只需使用一次，也可以编写一个函数来处理这个功能。</p>
<h2>Python中的函数</h2>
<h3>函数与参数</h3>
<p>首先来看看如何定义函数。函数的定义函数的定义需要使用关键字 <code>def</code> ，空格后紧跟一个函数名，函数名后面有一对圆括号，接着以一个冒号收尾：</p>
<div class="codeblock code-template"><strong>def</strong> function_name():<br />
... &nbsp;<span class="codetoken comment"># function body</span></div>
<p>这样就完成了一个函数的定义了。在需要的时候，便可以使用函数，来执行函数体内的代码。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/05/01-function-definition.jpg" alt="" width="300"></figure>
<p>关于定义函数，需要注意以下几点：</p>
<ul>
<li>函数使用关键字 <code>def</code> 声明，函数名为有效的标识符，Python 的一项提议建议函数名统一采取小写的蛇形命名法，用下划线连接不同单词</li>
<li><code>def</code> 关键字引导的是复合语句，冒号后面的函数体内部需要采取缩进的形式表示这些语句属于该函数的部分</li>
<li>一个函数创建后，它不会立即执行，只有需要时才会执行。函数名用于标识一个函数对象，可以通过一个函数名执行函数内包含的代码</li>
<li>正因如此，一般在编写程序时，都会将函数的定义置于主体程序的上方，统一管理</li>
</ul>
<hr>
<p>为了能让函数处理过程相似、但被处理对象完全不同的逻辑，一个函数需要获取外部的变量，并根据获取的变量决定需要得到什么样的结果。考虑以上对列表求和的代码片段，如果要对不同的列表求和，往往会得到不同的结果。</p>
<p>一个函数可以具有一个、多个或没有<strong>参数</strong>(argument)，参数用于接收外部数据，并根据数据的不同执行不同的处理方式。</p>
<p>为了向函数传递参数，函数在设计时就必须具有容纳并处理参数的功能。具体方式是在函数定义的小括号内，使用一个或多个标识符来表示这里有参数：</p>
<div class="codeblock code-template"><strong>def</strong> function_name(<em>param1</em>, <em>param2</em>, ..., <em>param3</em>):<br />
... &nbsp;<span class="codetoken comment"># function body</span></div>
<p>由于函数在定义时，还不知道具体传入的是哪个参数，因此这里先用一个标识符代表具体的参数，在函数体内处理这个标识符，就好像处理实际传入的值一样，因此函数定义中表示参数的标识符也称为<strong>形式参数</strong>，即虽然它不是一个外界传入的具体值，但在函数体内还是将其作为一个外界传入的具体值对待。</p>
<p>例如，以下函数定义：</p>
<div class="vscode-block">
<div><span style="color: #bf568b; font-weight: bold;">def</span> <span style="color: #8b56bf;">average</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">seq</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; total = length = </span><span style="color: #bf8b56;">0</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">for</span><span style="color: #405c79;"> i in seq:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; total += i</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; length += </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">average: </span><span style="color: #405c79;">'</span><span style="color: #405c79;">, total / length)</span></div>
</div>
<p>将标识符 <code>seq</code> 作为外界传入的参数对待，并对它调用 <code>for</code> 循环。在调用时，实际得到的参数就会替代 <code>seq</code> ，作为真正被 <code>for</code> 循环遍历的对象。</p>
<h3>函数的调用与返回值</h3>
<p>知道了如何创建函数，接下来是关于函数的调用。前面说过在使用 <code>def</code> 关键字创建函数后，其函数名就是一个变量，它绑定了函数体。因此，调用函数的方式为在函数名后面跟上一对圆括号，即可完成对函数的调用：</p>
<div class="codeblock code-template">function_name()</div>
<p>这样，程序运行到该处，就会执行函数体内对应的语句。</p>
<p>如果函数有参数，那么在调用时，需要将参数依次填入括号中，如下：</p>
<div class="codeblock code-template">function_name(<em>arg1</em>, <em>arg2</em>, ..., <em>arg3</em>)</div>
<p>注意参数的位置需要和定义时一致。下图展示了函数调用时，参数是如何传入与起作用的：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/05/01-function-call.jpg" alt="" width="490"></figure>
<p>在调用时传入的参数也称为<strong>实际参数</strong>。形式参数说明参数是如何参与运算的，实际参数用于计算运算的最终结果。</p>
<hr>
<p>既然外界可以通过参数向函数传递信息，那么函数在完成计算后，应该也可以将结果返回给外界。否则外界便无法利用其计算结果。Python 中，一个函数具有<strong>返回值</strong>，返回值用于将一个结果传递给外界，让外界收集并利用函数计算的结果。</p>
<p>返回语句使用关键字 <code>return</code> 开头，后面跟随一个表达式。函数执行到 <code>return</code> 语句后，会立即退出函数的执行流畅，并将后面的表达式作为函数的运算结果：</p>
<div class="codeblock code-template"><strong>def</strong> function_name(<em>param1</em>, <em>param2</em>, ..., <em>param3</em>):<br />
... &nbsp;<span class="codetoken comment"># function body</span><br />
<strong>return</strong> <em>expression</em></div>
<p>下面实现了这样一个 <code>get_max()</code> 函数，用于计算一个序列中元素的最大值。当遍历完序列，得到最大值后，它并没有将结果打印出来，而是作为返回值传递给外界：</p>
<div class="vscode-block">
<div><span style="color: #bf568b; font-weight: bold;">def</span> <span style="color: #8b56bf;">get_max</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">seq</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">if</span><span style="color: #405c79;"> not seq:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">return</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; max_value = seq[</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">for</span><span style="color: #405c79;"> i in seq:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">if</span><span style="color: #405c79;"> i &gt; max_value:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_value = i</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">return</span><span style="color: #405c79;"> max_value</span></div>
</div>
<p>如果一个函数不带 <code>return</code> 语句或 <code>return</code> 语句后面不带表达式，它会返回空值 <code>None</code> 。以上函数在判断传入的序列不可循环后，使用空的 <code>return</code> 语句强制退出函数。</p>
<p>可以使用赋值语句将结果保存到一个变量内：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">result = get_max([</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">7</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">])</span></div>
</div>
<p>因此，可以认为一个函数的调用就是将一个函数替换为返回的表达式，下图表达了这种思想：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/05/01-function-return.jpg" alt="" width="350"></figure>
<p>在明白了函数、参数和返回值后，可以完全将其类比到数学概念上的函数内。假设有以下函数：</p>
<div class="math">\\[<br />
f(x, y) = e^y + \log _2 (x) \dot \sin (x)<br />
\\]</div>
<p>那么它的函数名为 <span class="math">\\( f \\)</span> ，具有两个参数 <span class="math">\\( x \\)</span> 和 <span class="math">\\( y \\)</span> ，尽管它们都不是具体的值，但是从函数的结构上，还是可以推断出该函数的定义域、值域等内容。</p>
<p>一旦给定了自变量的具体值，就可以计算出函数的具体结果。例如，给定参数的具体值 <span class="math">\\( f(\frac \pi 2, 1) \\)</span> ，该函数的计算结果为 <span class="math">\\( \log _2 \pi + e -1 \\)</span> ，得到的就是函数的返回值。</p>
<h3>变量的作用域</h3>
<p>在介绍返回值前，或许有人会想过可以直接将结果保存在变量内，然后在函数外部引用保存的变量来获取返回结果，例如以下代码：</p>
<div class="vscode-block">
<div><span style="color: #bf568b; font-weight: bold;">def</span> <span style="color: #8b56bf;">length</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">seq</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; n = </span><span style="color: #bf8b56;">0</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">for</span><span style="color: #405c79;"> i in seq:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; n += </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(n)</span></div>
</div>
<p>但是，这样是错误的做法，尝试运行的结果会发生错误，错误原因是变量未被定义：</p>
<div class="codeblock code-console">&gt;&gt;&gt; def length(seq):<br />
... n = 0<br />
... for i in seq:<br />
... n += 1<br />
...<br />
&gt;&gt;&gt; print(n)<br />
Traceback (most recent call last):<br />
File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br />
NameError: name 'n' is not defined</div>
<p>虽然函数在调用时，函数体内的代码会被执行，就像将其放在函数调用的位置一样，但是在函数体内定义的变量，有一个变量的<strong>作用域</strong>的概念。简单地说，在函数内定义的变量，在函数执行完成后，会销毁所有定义的变量，释放这部分被占用的内存。</p>
<p>因此，以上函数实际上的执行过程类似：</p>
<div class="vscode-block">
<div><span style="color: #bf568b; font-weight: bold;">def</span> <span style="color: #8b56bf;">length</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">seq</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; n = </span><span style="color: #bf8b56;">0</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">for</span><span style="color: #405c79;"> i in seq:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; n += </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">del</span><span style="color: #405c79;"> n</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">return</span></div>
</div>
<p>在函数内重新定义的变量，也被称为<strong>局部变量</strong>，因为它们只在函数体内有效，函数体外无法访问，对函数体外的同名变量不产生任何影响。</p>
<p>实际上，函数的参数也可以看作是一个局部变量，它在参数传递的时候被创建并赋予对应的值，并在函数调用完成后被销毁。</p>
<p>以下给出了这样一个示例：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">n = </span><span style="color: #bf8b56;">3</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(n) &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># n 为定义的值</span></div>
<div><span style="color: #bf568b; font-weight: bold;">def</span> <span style="color: #8b56bf;">test01</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">) :</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(n) &nbsp;</span><span style="color: #a8a8a8;"># n 为使用的参数</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; n = </span><span style="color: #bf8b56;">10</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(n) &nbsp;</span><span style="color: #a8a8a8;"># n 为重新定义的值</span></div>
<div><span style="color: #405c79;">test01(</span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(n) &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># n 仍为函数体外定义的值</span></div>
</div>
<p>该函数的运行结果如下，注意观察变量的值是如何反映同名变量的创建与销毁的：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
3<br />
5<br />
10<br />
3</div>
<p>调用完函数后，外部变量的值仍然是 <code>3</code> ，说明局部变量值的修改不会影响全局变量。</p>
<p>不过还存在一种情况，考虑以下冒泡排序函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b; font-weight: bold;">def</span> <span style="color: #8b56bf;">bubble_sort</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">seq</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(seq)):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">for</span><span style="color: #405c79;"> j in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(seq)-i):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">if</span><span style="color: #405c79;"> seq[j] &gt; seq[j+</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq[j], seq[j + </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">] = seq[j + </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">], seq[j]</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">return</span><span style="color: #405c79;"> seq</span></div>
</div>
<p>这是一个很简单的函数，但是如果尝试调用它，看看会发生什么：</p>
<div class="codeblock code-console">&gt;&gt;&gt; data = [5, 1, 4, 3, 10, 4, 2, 7, 7, 9]<br />
&gt;&gt;&gt; bubble_sort(data)<br />
[1, 2, 3, 4, 4, 5, 7, 7, 9, 10]<br />
&gt;&gt;&gt; data<br />
[1, 2, 3, 4, 4, 5, 7, 7, 9, 10]</div>
<p>调用函数之后，再次检查列表 <code>data</code> 的值，可以发现该列表的值发生了变化。但是，在函数体内，自始至终只涉及到对参数的修改。</p>
<p>要解答这个问题，必须先了解 Python 中的可变对象与不可变对象的概念。</p>
<h3>可变对象与不可变对象</h3>
<p>Python 中的对象可以分为可变(mutable)对象与不可变(immutable)对象。不可变对象不能修改，只能重新赋值，这个过程实际上是新生成了一个对象，再让变量指向它，而旧对象被丢弃。而对可变对象的修改，则是将其中的一部分值更改，变量本身并没有修改。</p>
<p>注意以上的说法：对可变对象的修改，那么之前的排序函数哪里有对可变对象的修改呢？答案就在这条语句：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">seq[j], seq[j + </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">] = seq[j + </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">], seq[j]</span></div>
</div>
<p>这条语句中，将列表的某个元素与其后一个元素交换位置，这一操作就发生了对列表的修改，但是列表作为一个整体还是之前的列表，并没有变成另一个新列表。</p>
<p>在 Python 中，数值、字符串和元组是不可更改的对象，对它们调用任何方法都只能得到一个新的数值、字符串和元组；而列表、集合和字典则是可以修改的对象，它们随时可以增加、改变或删除包含的某些元素。</p>
<p>在 Python 中，可以通过 <code>id(<em>obj</em>)</code> 函数来查看某一变量的唯一身份标识。它接收一个变量作为参数，返回的结果是一个数值，不同对象得到的数值不同。</p>
<p>以下测试函数用于检查修改可更改对象修改前后的 id 值：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">m = [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">id</span><span style="color: #405c79;">(m))</span></div>
<div><span style="color: #bf568b; font-weight: bold;">def</span> <span style="color: #8b56bf;">modify_m</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">m</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">id</span><span style="color: #405c79;">(m))</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; m.append(</span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">id</span><span style="color: #405c79;">(m))</span></div>
<div><span style="color: #405c79;">modify_m(m)</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">id</span><span style="color: #405c79;">(m))</span></div>
</div>
<p>结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
1980965310984<br />
1980965310984<br />
1980965310984<br />
1980965310984</div>
<p>结果表明，在函数体内外、修改变量前后，四个 id 值都相同，指向的是同一个对象。</p>
<h3>global语句</h3>
<p>修改可变对象是一种在函数内部影响函数外部变量的一种方式。在函数体内，对变量重新赋值会使变量指向另一个对象，要使函数体内修改一个变量，让其指向别的对象，并且作用于函数体外，需要将其标示为全局变量。</p>
<p>可以使用 <code>global</code> 语句将一个或一些变量标示为全局变量：</p>
<div class="codeblock code-template"><strong>def</strong> function_name(<em>param</em>, ...):<br />
<strong>global</strong> <em>var1</em>, <em>var2</em>, ...</div>
<p><code>global</code> 关键字会将跟随的变量表示为全局变量，使得影响范围不局限于函数体内部，对其任意修改、赋值均会对函数内外的变量值造成改变。</p>
<p><code>global</code> 关键字可以位于函数的任意位置，只有一个条件：其声明为全局的变量不能在函数体的前面被赋值。否则，编译器无法判断是否需要让前面的赋值作用到全局范围内。由于函数的形式参数会在函数调用时被赋值为实际参数的值，因此不能对形式参数使用 <code>global</code> 声明。</p>
<p>以下示例检查一个 <code>global</code> 声明前后、函数内外变量的 id 值：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">im = </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">id</span><span style="color: #405c79;">(im))</span></div>
<div><span style="color: #bf568b; font-weight: bold;">def</span> <span style="color: #8b56bf;">modify_im</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b; font-weight: bold;">global</span><span style="color: #405c79;"> im &nbsp; &nbsp;</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">id</span><span style="color: #405c79;">(im))</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; im = </span><span style="color: #bf8b56;">5</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">id</span><span style="color: #405c79;">(im))</span></div>
<div><span style="color: #405c79;">modify_im()</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">id</span><span style="color: #405c79;">(im))</span></div>
</div>
<p>结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
1474521856<br />
1474521856<br />
1474521984<br />
1474521984</div>
<p>可以看到，在对 <code>global</code> 声明的变量赋值后，全局变量指向的对象也改变了，这说明函数体内修改的是全局变量而不是局部变量。</p>
<p><a rel="nofollow" href="/archives/210">Python函数式编程01 函数的基本概念</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/210/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
