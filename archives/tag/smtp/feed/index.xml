<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>SMTP归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/smtp/feed?simply_static_page=3748" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Thu, 14 Jul 2022 15:15:47 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>SMTP归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>计算机网络02-应用层概览与SMTP电子邮件发送</title>
		<link>/archives/403</link>
					<comments>/archives/403#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sat, 25 Jun 2022 15:35:56 +0000</pubDate>
				<category><![CDATA[计算机网络]]></category>
		<category><![CDATA[SMTP]]></category>
		<guid isPermaLink="false">/?p=403</guid>

					<description><![CDATA[<p>应用层协议原理 应用程序体系结构 应用层是计算机网络&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/403">计算机网络02-应用层概览与SMTP电子邮件发送</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>应用层协议原理</h2>

<h3>应用程序体系结构</h3>

<p>应用层是计算机网络结构体系的最顶层，也是计算机网络最终的发展目的。计算机网络的其余体系结构主要都是为应用层提供正常运作所需的服务而建立的。</p>

<p>应用层主要通过应用程序的交互来实现网络应用，其核心是编写能够运行在不同的端系统和通过网络彼此通信的程序。因此这一章内容基本只涉及软件方面的应用。</p>

<p>应用程序体系结构由研发者规定如何在各种端系统上组织来自多方的应用程序。目前来说有两种主要的体系结构：</p>

<p><strong>客户-服务器体系结构</strong>(client-server architecture)中总是打开的主机称为<strong>服务器</strong>，它处理许多<strong>客户</strong>的请求。该体系结构中客户端之间不直接通信。例如，大型游戏需要有游戏服务器来记录玩家数据；视频网站需要有资源服务器来向用户提供视频。</p>

<p><strong>P2P体系结构</strong>(Peer-to-Peer architecture)中，应用程序在间断连接的<strong>对等方</strong>主机对之间使用直接通信，这种对等方通信不需要通过专门的服务器。例如，一些小型游戏可以直接在两台主机间连接，而无需服务器的存在。</p>

<p>下图展示了这两种应用程序体系结构的区别：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/06/02-program-architecture.jpg" alt="" width="840">
    <figcaption>客户-服务器体系结构与P2P体系结构</figcaption>
</figure>

<p>在客户-服务器体系结构中，一台服务器往往要同时接收并处理多个客户的请求，为了避免单台服务器性能不足的问题，大型互联网服务往往使用计算机集群构建一个强大的虚拟服务器。而 P2P 体系结构则不存在该问题，服务随着规模的扩大，对等方中服务的提供者也会随之增加。</p>

<h3>进程通信</h3>

<p>在应用层中，进行通信的实际上是<strong>进程</strong>(process)，多个进程运行在相同的端系统上时，它们使用操作系统规定的进程进程通信机制相互通信。</p>

<blockquote>
    <p>进程是程序的载体。程序在执行时，操作系统会为它提供一些内存、输入设备（如键盘、鼠标）接口、权限等额外内容，由此产生的真正运行的任务称为进程。</p>

    <p>由于应用层依赖操作系统提供的底层服务，因此应用层通信的真正主体是进程。</p>
</blockquote>

<p>在两个不同端系统上的进程通过跨越计算机网络交换<strong>报文</strong>(message)。报文是一种特殊格式的数据，不同应用程序体系交换的报文格式也可能不同。发送进程被创建并向网络中发送报文；接收进程接收这些报文并可能通过回复报文响应发送方。</p>

<p>在一对进程之间的通信会话场景中，发起通信的进程被标识为<strong>客户端</strong>(client)，在会话开始时等待联系的进程是<strong>服务端</strong>(server)。</p>

<p>进程通过<strong>套接字</strong>(socket)软件接口向网络发送和接收报文。套接字是同一台主机内应用层与运输层之间的接口，也称为<strong>应用程序编程接口</strong>(Application Programming Interface, API)。应用程序可以控制套接字在应用层端的功能。下图展示了套接字与进程在计算机网络中所处的位置（这里只关心应用层与运输层之间的部分）：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/06/02-socket-process.png" alt="" width="380">
    <figcaption>进程、套接字与计算机网络其余部分的图示</figcaption>
</figure>

<p>为了向特定目的主机的进程发送分组，接收进程通过其<strong>IP 地址</strong>(IP address)标识，目前只需要知道它是一个 32 比特能够唯一标识主机的虚拟地址。目的地的<strong>端口号</strong>(port number)用于指定接收主机上的接收进程，它是一个无符号 16 位整数，用于区分一台主机上多个同时运行的套接字应用程序。总体来说，IP 地址和端口号结合，可以在互联网中找到一台主机上的特定进程。</p>

<p>在运输层中，会更详细地介绍端口号存在的意义；在网络层中，会更详细地介绍 IP 地址的作用。</p>

<h3>运输服务</h3>

<p>运输层是应用层之下的部分，运输层的作用就是提供<strong>可靠数据传输</strong>(reliable data transfer)，确保一个端系统发送的数据能够正确、完全地交付给另一个端系统的应用程序。</p>

<p>当一个运输层协议不提供可靠数据传输时，<strong>容忍丢失的应用</strong>(lost-tolerant application)可以接受部分无法到达接收进程的数据。</p>

<p>可用吞吐量指两个进程通信时，发送进程向接收进程发送比特的速率。运输层协议应保证可用吞吐量不低于应用程序要求的吞吐量。具有吞吐量要求的应用被称为<strong>带宽敏感的应用</strong>(bandwidth-sensitive application)，而<strong>弹性应用</strong>(elastic application)能根据当时可用的吞吐量调整传输速率并尽可能利用当前的吞吐量。例如，互联网电话、视频直播就属于带宽敏感的应用，在吞吐量不足时会造成卡顿、信息丢失等情况；而文件传输、电子邮件则属于弹性应用，此时发送方在一定程度上允许延后接收来适应缓慢的传输速率。</p>

<p>运输层协议也需要提供交互式实时应用程序的定时保证，发送方传递给套接字的每个比特到达接收方的套接字不能有太大间隔。较长的时延会使一些实时应用发生不自然的停顿等问题。</p>

<p>最后，运输协议也可能需要为应用程序提供若干安全性服务，以防止传输的数据被窃取或篡改。</p>

<hr>

<p>互联网为应用程序提供了两个运输层协议：TCP 协议和 UDP 协议。这里仅对此做简要介绍，在运输层中才会真正涉及这两个协议的细节。</p>

<ul>
    <li><strong>TCP 服务</strong></li>
</ul>

<p>TCP 服务模型包括面向连接服务和可靠数据传输服务。</p>

<p>在应用层数据报文传输之前，TCP 服务会先在客户和服务器之间握手，交互运输层控制信息，握手之后会在两个进程的套接字之间建立一个 TCP 连接，连接双方的进程可以在此连接上同时收发报文，并当应用程序结束报文发送后会拆除该连接。</p>

<p>使用 TCP 服务，可以按正确顺序接收所有数据，不会有字节的丢失、乱序等差错。</p>

<ul>
    <li><strong>UDP 服务</strong></li>
</ul>

<p>UDP 是一种不提供不必要服务的轻量级运输服务，仅提供最小服务，因此它是无连接的，两个进程通信前没有握手过程。</p>

<p>除此之外，UDP 也不能保证报文到达接收进程，也不能保证接收的顺序正确。但是 UDP 传输更快，基于 UDP 的扩展性也更强。</p>

<h3>实验：套接字编程</h3>

<h4>UDP 套接字编程</h4>

<p>UDP 编程相对比比较简单，因此接下来先研究 UDP 编程。</p>

<p>当套接字使用 UDP 通信时，在发送进程能够将数据分组从应用层推到运输层之前，需要先将目的地址填入分组里，这样互联网可以正确连接到接收方的套接字。</p>

<p>一台主机可以运行多个网络进程，因此当生成一个套接字时，会为它分配一个端口号。发送进程除了为分组附加上目的地址，还要带上目的端口号。为了能接收到目的主机的响应信息，操作系统还会为发送方的分组附带源主机的 IP 地址和套接字端口号。</p>

<p>当分组到达接收套接字时，接收进程通过套接字取回分组，然后检查分组内容并采取适当动作。</p>

<p>下图描述了这一通信的过程：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/06/02-usp-socket.jpg" alt="" width="330">
    <figcaption>UDP 套接字的通信过程</figcaption>
</figure>

<ul>
    <li><strong>UDP 服务端套接字程序</strong></li>
</ul>

<p>服务器为了能够接收并回答该客户的报文，它必须提前运行套接字进程并等待接收。因此这里首先研究服务端的套接字程序。</p>

<p>操作系统提供了套接字的接口，为了使用套接字，首先需要导入相应的模块：</p>

<div class="vscode-block"><div><span style="color: #a8a8a8;"># server.py</span></div><div><span style="color: #d73a49;font-weight: bold;">import</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span></div></div>

<p><code>socket</code> 模块是 Python 对操作系统提供的套接字接口的封装，是网络通信的基础，通过该模块可以在程序中创建套接字。</p>

<p>对于每个生成的套接字，都需要为其分配一个端口号。例如，这里确定待分配的端口号为 12000 ：</p>

<div class="vscode-block"><div><span style="color: #24292e;">server_port</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #005cc5;">12000</span></div></div>

<p>接下来，通过 <code>socket</code> 类创建一个套接字：</p>

<div class="vscode-block"><div><span style="color: #24292e;">server</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">(</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">AF_INET</span><span style="color: #24292e;">, </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">SOCK_DGRAM</span><span style="color: #24292e;">)</span></div></div>

<p>第一个参数指示了所使用的地址族，这里 <code>socket.AF_INET</code> 表示使用的是一般的 IP 地址，不同类型的网络使用的地址族也不同，其它类型的地址留待网络层讨论。第二个参数指示该套接字是 <code>socket.SOCK_DGRAM</code> 类型，即一个 UDP 套接字。</p>

<p>接下来，需要将端口号 12000 与该服务器的套接字绑定，即让套接字运行在端口 12000 上：</p>

<div class="vscode-block"><div><span style="color: #24292e;">server</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">bind</span><span style="color: #24292e;">((</span><span style="color: #032f62;">''</span><span style="color: #24292e;">, </span><span style="color: #24292e;">server_port</span><span style="color: #24292e;">))</span></div></div>

<p>这样，任何人向位于该服务器的 IP 地址的端口 12000 发送一个分组时，操作系统将该分组将导向该套接字。</p>

<p>服务端的套接字进程需要持续运行，以在任何时候接收到客户端发送的信息，因此需要使用 <code>while True</code> 无限循环：</p>

<div class="vscode-block"><div><span style="color: #d73a49;font-weight: bold;">while</span><span style="color: #24292e;"> </span><span style="color: #005cc5;">True</span><span style="color: #24292e;">:</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #24292e;">received_message</span><span style="color: #24292e;">, </span><span style="color: #24292e;">client_address</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #24292e;">server</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">recvfrom</span><span style="color: #24292e;">(</span><span style="color: #005cc5;">2048</span><span style="color: #24292e;">)</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #24292e;">message</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #24292e;">received_message</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">decode</span><span style="color: #24292e;">()</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #24292e;">server</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">sendto</span><span style="color: #24292e;">(</span><span style="color: #d73a49;font-weight: bold;">f</span><span style="color: #032f62;">'</span><span style="color: #005cc5;">{</span><span style="color: #24292e;">message</span><span style="color: #005cc5;">}</span><span style="color: #032f62;"> (</span><span style="color: #005cc5;">{</span><span style="color: #6f42c1;">len</span><span style="color: #24292e;">(</span><span style="color: #24292e;">message</span><span style="color: #24292e;">)</span><span style="color: #005cc5;">}</span><span style="color: #032f62;">)'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">(), </span><span style="color: #24292e;">client_address</span><span style="color: #24292e;">)</span></div></div>

<p>套接字对象的 <code>.recvform(<em>bufsize</em>)</code> 方法将会返回一个有两个元素的元组，第一个元素是返回的数据字符串，第二个元素是数据的来源地址。<code>.sendto(<em>data</em>, <em>address</em>)</code> 方法则向特定远程地址发送数据。</p>

<p>报文需要以字节的形式发送，因此发送的字符串需要提前调用 <code>.encode()</code> 方法将其变为字节形式，接收的字节也需要通过 <code>.decode()</code> 将其解码为一般形式的字符串。</p>

<ul>
    <li><strong>UDP 客户端套接字程序</strong></li>
</ul>

<p>为了找到服务端对应的套接字，客户端的 UDP 套接字程序还需要提供服务端的 IP 地址或主机名：</p>

<div class="vscode-block"><div><span style="color: #a8a8a8;"># client.py</span></div><div><span style="color: #d73a49;font-weight: bold;">import</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span></div><br><div><span style="color: #24292e;">server_name</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #032f62;">'localhost'</span></div><div><span style="color: #24292e;">server_port</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #005cc5;">12000</span></div></div>

<p>然后，创建一个用户端的 UDP 套接字对象：</p>

<div class="vscode-block"><div><span style="color: #24292e;">client</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">(</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">AF_INET</span><span style="color: #24292e;">, </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">SOCK_DGRAM</span><span style="color: #24292e;">)</span></div></div>

<p>用户端的 UDP 套接字将报文发送到服务端的套接字里：</p>

<div class="vscode-block"><div><span style="color: #24292e;">message</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">input</span><span style="color: #24292e;">(</span><span style="color: #032f62;">'Enter something to send: '</span><span style="color: #24292e;">).</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">()</span></div><div><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">sendto</span><span style="color: #24292e;">(</span><span style="color: #24292e;">message</span><span style="color: #24292e;">, (</span><span style="color: #24292e;">server_name</span><span style="color: #24292e;">, </span><span style="color: #24292e;">server_port</span><span style="color: #24292e;">))</span></div><br><div><span style="color: #24292e;">received_message</span><span style="color: #24292e;">, </span><span style="color: #24292e;">address</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">recvfrom</span><span style="color: #24292e;">(</span><span style="color: #005cc5;">2048</span><span style="color: #24292e;">)</span></div><div><span style="color: #6f42c1;">print</span><span style="color: #24292e;">(</span><span style="color: #24292e;">received_message</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">decode</span><span style="color: #24292e;">())</span></div></div>

<p>发送时，操作系统会自动将源主机地址附加在分组上，无需显式通过代码完成。发送之后，客户端可能还需要再次接收来自服务端的响应报文。在这里，客户端已经不需要使用了，可以主动关闭：</p>

<div class="vscode-block"><div><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">close</span><span style="color: #24292e;">()</span></div></div>

<p>在本地主机上分别运行这两个套接字程序，即可看到实验现象：</p>

<section class="codeblock compare">
    <div class="codeblock code-console">$ <span class="codetoken command">python</span> <span class="codetoken option">-u</span> server.py
</div>
    <div class="codeblock code-console">$ <span class="codetoken command">python</span> -u client.py
Enter something to send: <span class="codetoken input">Hello, world!</span>
Hello, world! (13)</div>
</section>

<h4>TCP 套接字编程</h4>

<p>TCP 是一个面向连接的协议，因此客户和服务器需要先握手创建一个 TCP 连接，然后才能够开始互相发送数据。TCP 连接的一端与客户套接字相联系，另一端与服务器套接字相联系。</p>

<p>当客户指定服务器套接字的地址与端口号后，客户会在运输层与服务器发起连接请求，然后服务器会生成一个新的用于连接的套接字，并且该连接套接字仅用于该客户。</p>

<p>当创建该连接套接字后，一侧要向另一侧发送数据时，它只需经过连接套接字将数据送入 TCP 连接；而 UDP 连接每次在发送数据时，都需要附加上目的地地址。</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/06/02-tcp-socket.jpg" alt="" width="350">
    <figcaption>TCP 套接字的通信过程</figcaption>
</figure>

<ul>
    <li><strong>TCP 客户端套接字程序</strong></li>
</ul>

<p>首先处理客户端的套接字程序。客户端套接字为了连接到服务器套接字，同样需要标识出服务器的地址和套接字端口：</p>

<div class="vscode-block"><div><span style="color: #a8a8a8;"># client.py</span></div><div><span style="color: #d73a49;font-weight: bold;">import</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span></div><br><div><span style="color: #24292e;">server_name</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #032f62;">'localhost'</span></div><div><span style="color: #24292e;">server_port</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #005cc5;">12000</span></div></div>

<p>TCP 套接字和 UDP 套接字程序的区别首先是套接字的创建：</p>

<div class="vscode-block"><div><span style="color: #24292e;">client</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">(</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">AF_INET</span><span style="color: #24292e;">, </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">SOCK_STREAM</span><span style="color: #24292e;">)</span></div></div>

<p><code>socket.SOCK_STREAM</code> 指定了该套接字是一个 TCP 套接字。</p>

<p>TCP 套接字在向服务器发送数据之前，必须在客户与服务器之间创建一个 TCP 连接，因此 TCP 客户端套接字的程序存在以下代码：</p>

<div class="vscode-block"><div><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">connect</span><span style="color: #24292e;">((</span><span style="color: #24292e;">server_name</span><span style="color: #24292e;">, </span><span style="color: #24292e;">server_port</span><span style="color: #24292e;">))</span></div></div>

<p><code>.connect(<em>address</em>)</code> 方法执行后，会发生三次握手，并在客户端和服务器之间创建一条 TCP 连接。</p>

<p>TCP 套接字的通信过程也和 UDP 有一定区别：</p>

<div class="vscode-block"><div><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">send</span><span style="color: #24292e;">(</span><span style="color: #24292e;">message</span><span style="color: #24292e;">)</span></div><div><span style="color: #24292e;">received_message</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">recv</span><span style="color: #24292e;">(</span><span style="color: #005cc5;">1024</span><span style="color: #24292e;">)</span></div></div>

<p>由于连接已经建立了，因此客户端套接字程序在发送数据时，无需再附加上目的地址和端口号，在接收数据时，也无需接收发送方的地址和端口号，只需要简单调用 <code>.send()</code> 和 <code>.recv()</code> 方法就可以发送和接收数据。</p>

<p>UDP 连接也可以调用 <code>.connect()</code> 方法，但这种情况下只是简单地标明目标服务器的地址，之后调用 <code>.send()</code> 和 <code>.recv()</code> 方法时附加目的地址和端口号会自动完成，但没有经历连接并传输其它的信息这一过程，并且实际还是会在数据中添加目的地址和端口号。</p>

<p>最后，客户端在使用完成后，同样需要主动关闭套接字：</p>

<div class="vscode-block"><div><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">close</span><span style="color: #24292e;">()</span></div></div>

<ul>
    <li><strong>TCP 服务端套接字程序</strong></li>
</ul>

<p>服务端的 TCP 套接字也需要先创建一个套接字对象，然后将其与服务器的端口号关联起来：</p>

<div class="vscode-block"><div><span style="color: #a8a8a8;"># server.py</span></div><div><span style="color: #d73a49;font-weight: bold;">import</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span></div><br><div><span style="color: #24292e;">server_port</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #005cc5;">12000</span></div><br><div><span style="color: #24292e;">server</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">(</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">AF_INET</span><span style="color: #24292e;">, </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">SOCK_STREAM</span><span style="color: #24292e;">)</span></div><div><span style="color: #24292e;">server</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">bind</span><span style="color: #24292e;">((</span><span style="color: #032f62;">''</span><span style="color: #24292e;">, </span><span style="color: #24292e;">server_port</span><span style="color: #24292e;">))</span></div></div>

<p>对于 TCP 连接，还需要调用 <code>.listen(<em>num</em>)</code> 让套接字监听该端口号，获取用户的连接请求。该方法的参数决定了同时请求连接的最大数量：</p>

<div class="vscode-block"><div><span style="color: #24292e;">server</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">listen</span><span style="color: #24292e;">(</span><span style="color: #005cc5;">1</span><span style="color: #24292e;">)</span></div></div>

<p>TCP 套接字的循环部分为：</p>

<div class="vscode-block"><div><span style="color: #d73a49;font-weight: bold;">while</span><span style="color: #24292e;"> </span><span style="color: #005cc5;">True</span><span style="color: #24292e;">:</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #24292e;">connection</span><span style="color: #24292e;">, </span><span style="color: #24292e;">address</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #24292e;">server</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">accept</span><span style="color: #24292e;">()</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #24292e;">received_message</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #24292e;">connection</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">recv</span><span style="color: #24292e;">(</span><span style="color: #005cc5;">1024</span><span style="color: #24292e;">)</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #24292e;">message</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #24292e;">received_message</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">decode</span><span style="color: #24292e;">()</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #24292e;">connection</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">send</span><span style="color: #24292e;">(</span><span style="color: #d73a49;font-weight: bold;">f</span><span style="color: #032f62;">'</span><span style="color: #005cc5;">{</span><span style="color: #24292e;">message</span><span style="color: #005cc5;">}</span><span style="color: #032f62;"> (</span><span style="color: #005cc5;">{</span><span style="color: #6f42c1;">len</span><span style="color: #24292e;">(</span><span style="color: #24292e;">message</span><span style="color: #24292e;">)</span><span style="color: #005cc5;">}</span><span style="color: #032f62;">)'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">())</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #24292e;">connection</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">close</span><span style="color: #24292e;">()</span></div></div>

<p>当客户开始连接后，程序通过调用 <code>.accept()</code> 方法来接收连接请求，每次调用该方法都会等待一个新的客户连接该服务器，然后返回一个新的套接字，用于管理该连接的数据收发。借助于创建的 TCP ，客户可以直接与服务器收发信息，并且发送的所有内容可以按正确的顺序到达。</p>

<p>由于 TCP 通信下，每个连接都使用唯一的套接字，因此连接结束后，服务端对应的套接字也需要关闭。</p>

<p>同样可以在一台主机中运行这两个套接字程序，所得的现象与 UDP 套接字实验相同，这里不再展示。在下一章运输层中，还会结合运输层服务的内容对这几个程序中的细节作进一步分析。</p>

<h2 id="email">电子邮件与SMTP协议</h2>

<h3>应用层协议</h3>

<p><strong>应用层协议</strong>(application-layer protocol)定义了在不同端系统上的应用程序如何相互传递报文，如：</p>

<ul>
    <li>交换的报文类型</li>
    <li>报文类型的语法</li>
    <li>字段信息的含义</li>
    <li>进程发送报文的时间及方式、响应规则</li>
</ul>

<p>例如，当在浏览器中输入一个网址时，浏览器从网站服务器中从发送请求到完整显示网页的过程中，就会利用应用层的超文本传输协议(HyperText Transfer Protocol, HTTP)。HTTP 对请求和响应的报文都做了非常严格的规定，以下是 HTTP 响应部分的内容格式：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/06/02-http-response.jpg" alt="" width="540">
    <figcaption>HTTP 响应包体</figcaption>
</figure>

<p>其中头部字段包含许多数据，例如响应包体数据的类型（是文本、图像还是视频等）、响应包含的用户信息等，浏览器会综合这类信息决定如何将响应包体的内容展示到标签页中。</p>

<p>HTTP 是一个非常复杂的应用层协议，涉及的内容需要一本完整的书才能完全介绍。接下来介绍电子邮件所涉及的一个简单的应用层协议 SMTP ，并通过编写代码实现该协议来发生一封简单的邮件。</p>

<h3>电子邮件的收发过程</h3>

<p>互联网电子邮件主要由两个部分组成：<strong>用户代理</strong>(user agent)和<strong>邮件服务器</strong>(mail server)，它们之间传输数据（发送邮件）采用的应用层协议主要是<strong>简单邮件传输协议</strong>(Simple Mail Transfer Protocol, SMTP)。</p>

<p>电子邮件服务的核心是邮件服务器，每个接收方在某个邮件服务器中都有一个<strong>邮箱</strong>(mailbox)，发送邮件时，邮件从发生方的用户代理传输到发送方的邮件服务器，由接收方的邮件服务器分发到接收方的邮箱中。如果发生方的服务器不能将邮件传给接收方的服务器，那么它会在一个<strong>报文队列</strong>(message queue)中保留该邮件，并每隔一定时间尝试重新发生，直到认为发送失败了为止。邮件发送过程中一般没有中间服务器。</p>

<p>SMTP 是因特网电子邮件中主要的应用层协议。它使用 TCP 传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件，因此它是一个<strong>推协议</strong>(push protocol)，TCP 连接由要发送该文件的机器发起。</p>

<p>SMTP 要求每个报文的所有内容都采用 7bit ASCII 码格式，如果报文包含非 7bit ASCII 字符或二进制数据，则报文必须被编码。</p>

<p>接收方要访问邮件则需要使用<strong>拉协议</strong>(pull protocol)来获取报文，目前常见的邮件访问协议包括第三版邮局协议(Post Office Protocol-Version 3, POP3)、互联网邮件访问协议(Internet Mail Access Protocol, IMAP)以及 HTTP 。</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/06/02-mail-transfer.jpg" alt="" width="540">
    <figcaption>邮件发送的过程</figcaption>
</figure>

<p>标准规定，SMTP 的套接字程序运行在 25 号端口上，并且 25 号端口也只能用于 SMTP 进程。</p>

<p>POP3 是一个非常简单的邮件访问协议，它使用 TCP 连接，运行在 110 号端口上。POP3 的处理分为 3 步：</p>

<ol>
    <li>验证(authorizarion)：用户代理发送用户名和口令，鉴别用户身份</li>
    <li>事务处理：可以取回报文、标记删除或撤销标记，以及邮件的统计信息</li>
    <li>更新：结束该 POP3 会话，并执行删除邮件</li>
</ol>

<p>POP3 功能简陋，而 IMAP 则具有更多的功能。IMAP 服务器将每一个邮件和一个文件夹联系，用户可以将一个邮件移动到另外的文件夹内，还可以按指定条件查询匹配的邮件，或获取邮件报文的某些部分等。IMAP 同样使用 TCP 连接，使用端口号 143 。</p>

<blockquote>
    <p>以上介绍的几个协议，运行这些协议的应用程序都具有确定的端口号。这样在编写套接字程序时，就可以按照规定直接将数据发送到正确的应用程序中并被解析。</p>
    <p>端口号主要可以被划分为以下三类：</p>
    <ul>
        <li>知名端口：端口号范围 0~1023 ，被分配给最重要、最常见的服务，一般情况下不能运行别的服务</li>
        <li>注册端口：端口号范围 1024~49151 ，被许多应用较广泛的网络服务占用，但如果它们不在使用时，用户也可以运行自己的服务</li>
        <li>其它端口：端口号范围 49152~65535 ，用户可以随意使用</li>
    </ul>
    <p>所有用于互联网标准协议的端口号能够在 http://www.iana.org/ 处查询到。</p>
    <p>在客户端发送数据时，由于会将发送的 IP 地址和端口号附在发送的报文内提供给接收方，因此可以随意使用端口号。操作系统在用户没有确定端口号时，也会从其它端口中任意取出一个可用的端口号提供给客户端的应用程序。</p>
</blockquote>

<p>Python 中，可以通过如下形式查询某个服务的端口号：</p>

<div class="vscode-block"><div><span style="color: #d73a49;">&gt;&gt;&gt;</span><span style="color: #24292e;"> </span><span style="color: #d73a49;font-weight: bold;">import</span><span style="color: #24292e;"> socket</span></div><div><span style="color: #d73a49;">&gt;&gt;&gt;</span><span style="color: #24292e;"> socket.getservbyname(</span><span style="color: #032f62;">'smtp'</span><span style="color: #24292e;">)</span></div><div><span style="color: #005cc5;">25</span></div></div>

<p>在 Linux 系统上，比较常用的服务名与对应的端口号保存在文件 <var class="file">/etc/services</var> 里。</p>

<h3>实验：SMTP发送</h3>

<p>一个电子邮件主要由首部和报文体组成，两者之间以一个空行(CRLF)隔开。首部中的每一行由关键字、冒号及其值组成，<code>From:</code> 首部行和 <code>To:</code> 首部行是必须的，它们标识出发送方和接收方的邮箱地址；而 <code>Subject:</code> 等首部行则是可选的。</p>

<p>准备几个实验用的关键变量如下：</p>

<div class="vscode-block"><div><span style="color: #a8a8a8;"># mail-client.py</span></div><div><span style="color: #d73a49;font-weight: bold;">import</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span></div><br><div><span style="color: #24292e;">mail_server</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #032f62;">'smtp.qiye.aliyun.com'</span></div><div><span style="color: #24292e;">mail_from</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #032f62;">'web@localhost'</span></div><div><span style="color: #24292e;">mail_to</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #032f62;">'alterdellusion@gmail.com'</span></div><br><div><span style="color: #24292e;">mail</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #d73a49;font-weight: bold;">f</span><span style="color: #032f62;">'From: </span><span style="color: #005cc5;">{</span><span style="color: #24292e;">mail_from</span><span style="color: #005cc5;">}\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">\</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #d73a49;font-weight: bold;">f</span><span style="color: #032f62;">'To: </span><span style="color: #005cc5;">{</span><span style="color: #24292e;">mail_to</span><span style="color: #005cc5;">}\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">\</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #032f62;">'Subject: Hello World</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">\</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #032f62;">'</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">\</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #032f62;">'Hello, world!</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span></div></div>

<p>SMTP 使用 TCP 连接，端口号为 25 ，因此首先生成客户端套接字并连接：</p>

<div class="vscode-block"><div><span style="color: #24292e;">client</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">(</span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">AF_INET</span><span style="color: #24292e;">, </span><span style="color: #6f42c1;">socket</span><span style="color: #24292e;">.</span><span style="color: #24292e;">SOCK_STREAM</span><span style="color: #24292e;">)</span></div><div><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">connect</span><span style="color: #24292e;">((</span><span style="color: #24292e;">mail_server</span><span style="color: #24292e;">, </span><span style="color: #005cc5;">25</span><span style="color: #24292e;">))</span></div></div>

<p>当连接到邮件服务器后，邮件服务器会主动发送就绪应答码 220 给用户，应答码后面可能会跟随一些描述信息。这里使用如下代码接收并检查邮件服务器返回的信息：</p>

<div class="vscode-block"><div><span style="color: #24292e;">received_message</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">recv</span><span style="color: #24292e;">(</span><span style="color: #005cc5;">1024</span><span style="color: #24292e;">).</span><span style="color: #6f42c1;">decode</span><span style="color: #24292e;">()</span></div><div><span style="color: #6f42c1;">print</span><span style="color: #24292e;">(</span><span style="color: #24292e;">received_message</span><span style="color: #24292e;">, </span><span style="color: #e36209;">end</span><span style="color: #d73a49;">=</span><span style="color: #032f62;">''</span><span style="color: #24292e;">)</span></div><div><span style="color: #d73a49;font-weight: bold;">if</span><span style="color: #24292e;"> </span><span style="color: #24292e;">received_message</span><span style="color: #24292e;">[:</span><span style="color: #005cc5;">3</span><span style="color: #24292e;">] </span><span style="color: #d73a49;">!=</span><span style="color: #24292e;"> </span><span style="color: #032f62;">'220'</span><span style="color: #24292e;">:</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #d73a49;font-weight: bold;">raise</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">RuntimeError</span><span style="color: #24292e;">(</span><span style="color: #032f62;">'220 reply not received from server'</span><span style="color: #24292e;">)</span></div></div>

<p>接下来，用户可以向服务器发送 <code>HELO <em>identity</em></code> 指令，<code><em>identity</em></code> 表示用户身份。若服务器认为身份有效，则返回应答码 250 。公共的邮件服务器在发送邮件之前，用户需要通过 <code>auth login</code> 指令登录邮箱，服务器接收后返回应答码 334 并提示用户输入用户名。以上行为翻译为代码就是：</p>

<div class="vscode-block"><div><span style="color: #d73a49;font-weight: bold;">def</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #e36209;">msg</span><span style="color: #24292e;">, </span><span style="color: #e36209;">status</span><span style="color: #24292e;">):</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; </span><span style="color: #d73a49;font-weight: bold;">while</span><span style="color: #24292e;"> </span><span style="color: #005cc5;">True</span><span style="color: #24292e;">:</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">send</span><span style="color: #24292e;">(</span><span style="color: #e36209;">msg</span><span style="color: #24292e;">)</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #24292e;">received_message</span><span style="color: #24292e;"> </span><span style="color: #d73a49;">=</span><span style="color: #24292e;"> </span><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">recv</span><span style="color: #24292e;">(</span><span style="color: #005cc5;">1024</span><span style="color: #24292e;">).</span><span style="color: #6f42c1;">decode</span><span style="color: #24292e;">()</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #6f42c1;">print</span><span style="color: #24292e;">(</span><span style="color: #24292e;">received_message</span><span style="color: #24292e;">, </span><span style="color: #e36209;">end</span><span style="color: #d73a49;">=</span><span style="color: #032f62;">''</span><span style="color: #24292e;">)</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #d73a49;font-weight: bold;">if</span><span style="color: #24292e;"> </span><span style="color: #24292e;">received_message</span><span style="color: #24292e;">[:</span><span style="color: #005cc5;">3</span><span style="color: #24292e;">] </span><span style="color: #d73a49;">==</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">str</span><span style="color: #24292e;">(</span><span style="color: #e36209;">status</span><span style="color: #24292e;">):</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #d73a49;font-weight: bold;">break</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #d73a49;font-weight: bold;">else</span><span style="color: #24292e;">:</span></div><div><span style="color: #24292e;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #d73a49;font-weight: bold;">raise</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">RuntimeError</span><span style="color: #24292e;">(</span><span style="color: #032f62;">'Bad response from server'</span><span style="color: #24292e;">)</span></div><br><div><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #032f62;">'HELO mailserver</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">(), </span><span style="color: #005cc5;">250</span><span style="color: #24292e;">)</span></div><div><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #032f62;">'auth login</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">(), </span><span style="color: #005cc5;">334</span><span style="color: #24292e;">)</span></div></div>

<p>注意每条指令都需要使用一个 CRLF 回车换行表示结束。</p>

<p>部分邮件服务器为了能够接收非 ASCII 字符，使用 base64 编码后传输。本例中将待发送的用户名使用 base64 编码后发送，若服务器认为用户名存在，便会再次返回 334 应答码并提示用户继续发送口令。使用 base64 编码发送口令后，若验证通过，服务器则会返回 235 应答码。以上行为翻译为代码就是：</p>

<div class="vscode-block"><div><span style="color: #d73a49;font-weight: bold;">from</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">base64</span><span style="color: #24292e;"> </span><span style="color: #d73a49;font-weight: bold;">import</span><span style="color: #24292e;"> </span><span style="color: #6f42c1;">b64encode</span></div><br><div><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #6f42c1;">b64encode</span><span style="color: #24292e;">(</span><span style="color: #24292e;">mail_from</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">()) </span><span style="color: #d73a49;">+</span><span style="color: #24292e;"> </span><span style="color: #d73a49;font-weight: bold;">b</span><span style="color: #032f62;">'</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">, </span><span style="color: #005cc5;">334</span><span style="color: #24292e;">)</span></div><div><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #6f42c1;">b64encode</span><span style="color: #24292e;">(</span><span style="color: #032f62;">'password123'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">()) </span><span style="color: #d73a49;">+</span><span style="color: #24292e;"> </span><span style="color: #d73a49;font-weight: bold;">b</span><span style="color: #032f62;">'</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">, </span><span style="color: #005cc5;">235</span><span style="color: #24292e;">)</span></div></div>

<p>为了发送一封邮件，用户需要用 <code>MAIL FROM &lt;<em>from_address</em>&gt;</code> 指定邮件的发件邮箱，用 <code>RCPT TO &lt;<em>to_address</em>&gt;</code> 指定收件邮箱。若服务器认为邮箱有效，则返回应答码 250 ，用户便可以使用指令 <code>DATA</code> 告知服务器准备发送邮件内容，邮件服务器使用应答码 354 表明准备接收这部分内容。</p>

<p>当用户发送完成所有内容后，需要发送结束符 <code>\r\n.\r\n</code> ，若邮件服务器接收完毕，则返回应答码 250 。发送结束后，用户发送指令 <code>QUIT</code> 请求断开连接，邮件服务器则返回应答码 221 并主动断开连接。</p>

<p>以上行为翻译为代码就是：</p>

<div class="vscode-block"><div><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #d73a49;font-weight: bold;">f</span><span style="color: #032f62;">'MAIL FROM: &lt;</span><span style="color: #005cc5;">{</span><span style="color: #24292e;">mail_from</span><span style="color: #005cc5;">}</span><span style="color: #032f62;">&gt;</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">(), </span><span style="color: #005cc5;">250</span><span style="color: #24292e;">)</span></div><div><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #d73a49;font-weight: bold;">f</span><span style="color: #032f62;">'RCPT TO: &lt;</span><span style="color: #005cc5;">{</span><span style="color: #24292e;">mail_to</span><span style="color: #005cc5;">}</span><span style="color: #032f62;">&gt;</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">(), </span><span style="color: #005cc5;">250</span><span style="color: #24292e;">)</span></div><div><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #032f62;">'DATA</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">(), </span><span style="color: #005cc5;">354</span><span style="color: #24292e;">)</span></div><div><span style="color: #24292e;">client</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">send</span><span style="color: #24292e;">(</span><span style="color: #24292e;">mail</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">())</span></div><div><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #032f62;">'</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">.</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">(), </span><span style="color: #005cc5;">250</span><span style="color: #24292e;">)</span></div><div><span style="color: #6f42c1;">send_message</span><span style="color: #24292e;">(</span><span style="color: #032f62;">'QUIT</span><span style="color: #005cc5;">\r\n</span><span style="color: #032f62;">'</span><span style="color: #24292e;">.</span><span style="color: #6f42c1;">encode</span><span style="color: #24292e;">(), </span><span style="color: #005cc5;">221</span><span style="color: #24292e;">)</span></div></div>

<p>运行以上程序，即可看到实验现象：</p>

<div class="codeblock code-console">$ <span class="codetoken command">python</span> <span class="codetoken option">-u</span> client.py
220 smtp.aliyun-inc.com MX AliMail Server
250 Ok
334 dXNlcm5hbWU6
334 UGFzc3dvcmQ6
235 Authentication successful
250 Mail Ok
250 Rcpt Ok
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
250 Data Ok: queued as freedom
221 Bye</div>

<p><code>dXNlcm5hbWU6</code> 使用 base64 解码即为 <code>Username:</code> ，而 <code>UGFzc3dvcmQ6</code> 使用 base64 解码即为 <code>Password:</code> 。如果邮件没有被服务器判定为垃圾邮件，那么即可在目标邮箱内接收到该邮件。</p>

<p>在本节中，简单介绍了应用层体系结构。应用层本身主要通过应用程序来实现特定的互联网功能。应用层本身不参与数据的传输，因此需要操作系统提供的运输服务。应用层协议是计算机网络建立的最终目的，也是近几年计算机网络发展的最快的部分，各种各样的应用层协议层出不穷，让互联网在多媒体浏览、文件传输、远程主机登录，乃至工业物联网通信间的各种场景中可以自由发挥。</p>

<p>在下一节中，将介绍 DNS 应用层协议，它是一种用于实现网络设备名字到主机地址映射的网络服务。</p>



<p></p>
<p><a rel="nofollow" href="/archives/403">计算机网络02-应用层概览与SMTP电子邮件发送</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/403/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
