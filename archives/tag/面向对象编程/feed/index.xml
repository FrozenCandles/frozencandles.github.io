<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>面向对象编程归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/feed?simply_static_page=3803" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Thu, 11 May 2023 15:19:15 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>面向对象编程归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Python面向对象编程04-类与实例的方法</title>
		<link>/archives/1059</link>
					<comments>/archives/1059#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 27 Mar 2023 01:08:07 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=1059</guid>

					<description><![CDATA[<p>类方法和静态方法 实例方法 在第一节中，便已经介绍过&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1059">Python面向对象编程04-类与实例的方法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>类方法和静态方法</h2>

<h3>实例方法</h3>

<p>在<a href="/archives/442" class="link-internal">第一节</a>中，便已经介绍过实例方法。实例方法需要有一个实例才能调用，而这个实例是通过第一个通常名为 <code>self</code> 的参数表示的，因此借助该参数可以在定义方法时就去操作一个抽象的实例对象。例如，假设有一个这样的类和实例的定义：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>:</div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">method</span>(self, arg):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">self</span>, arg)</div><br><div><span style="color: #268bd2;">c</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">C</span>()</div></div>

<p>那么可以使用这样的方式通过实例调用该方法，实例对象将会自动作为第一个位置参数传入：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">c</span>.<span style="color: #268bd2;">method</span>(arg<span style="color: #859900;">=</span><span style="color: #cb4b16;">...</span>)</div></div>

<p>许多编程语言在方法内部，对实例的引用是通过 <code>this</code> 关键字完成的；而 Python 则与之不同，实例的引用是通过显式的参数传递的。这样做的好处在于，一是通过显式定义来强调默认定义的方法是实例方法，二是也可以把方法当做第一个参数是实例的函数一样调用：</p>

<div class="vscode-block"><div><span style="color: #cb4b16;">C</span>.<span style="color: #268bd2;">method</span>(<span style="color: #268bd2;">c</span>, arg<span style="color: #859900;">=</span><span style="color: #cb4b16;">...</span>)</div></div>

<p>例如，多个字符串连接默认是通过字符串的 <code>.join()</code> 方法实现，这里调用该方法的字符串实例将被插入被连接的字符串之间：</p>

<div class="vscode-block"><div><span style="color: #2aa198;">'||'</span>.<span style="color: #268bd2;">join</span>([<span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'c'</span>])</div><div><span style="color: #a8a8a8;"># 'a||b||c'</span></div></div>

<p>如果觉得用被插入的字符串去调用该方法比较奇怪，也可以通过 <code>str</code> 类调用该方法，并将被插入的字符串作为第一个位置参数主动传入：</p>

<div class="vscode-block"><div><span style="color: #cb4b16;">str</span>.<span style="color: #268bd2;">join</span>(<span style="color: #2aa198;">'||'</span>, [<span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'c'</span>])</div></div>

<!-- <div class="vscode-block"><div><span style="color: #cb4b16;">str</span>.<span style="color: #268bd2;">replace</span>(<span style="color: #2aa198;">'%time</span><span style="color: #cb4b16;">%-%</span><span style="color: #2aa198;">name%.jpg'</span>, <span style="color: #2aa198;">'%time%'</span>, <span style="color: #268bd2;">ctime</span>())</div></div> -->

<p>因此，实例方法的实质就是一个函数，只不过它的主要用途是处理实例。Python 允许实例方法可以直接由实例调用，使得调用的表示更加简洁。</p>

<h3>类方法</h3>

<p>与实例方法相对应的是<strong>类方法</strong>。类方法是类本身具有的方法，它可以在不需要实例的情况下使用类本身来调用。</p>

<p>Python 中类方法和实例方法相似，但是它需要传入一个名为 <code>cls</code> 的参数，用来代表这个类本身（同样，这个名字不必是 <code>cls</code> ，可以是 <code>typ</code> 或 <code>Lei</code> 等）。但是为了与实例方法区分，类方法在定义时需要使用 <code>@classmethod</code> 装饰器。</p>

<p>因此，一个完整的类方法的定义为：</p>

<div class="codeblock code-template">
    @classmethod<br>
    <strong>def</strong> <em>method_name</em>(cls, ...):<br>
    &nbsp; &nbsp; ...
</div>

<p>类方法有几种比较常见的应用场景。首先是构造前交互，有些时候需要在实例化前做一些准备，例如一个代表数据库的类，可以通过类方法读取配置文件并连接到数据库中，这样随后对实例的操作可以实时反映到对数据库的更新中。由于读取配置文件这种操作需要在得到任意一个实例之前完成，因此可以借助类方法实现。</p>

<p>类方法还可以用于以别的方式构建实例。例如，<code>datetime</code> 是一个用于处理日期与时间的标准库，其中 <code>date</code> 是一个用于表示日期的类。如果要通过该类生成一个具体的日期，在初始化时需要传入代表年、月、日的参数：</p>

<div class="codeblock code-console">>>> from datetime import date
>>> date(2023, 3, 19)
datetime.date(2023, 3, 19)</div>

<p>但有些时候，拿到的信息可能未必包含年月日，它可能是具有特定格式的表示时间的字符串，还有可能是浮点型的时间戳。此时，可以使用 <code>date</code> 类提供的类方法使用这几种信息构造一个日期实例：</p>

<div class="codeblock code-console">>>> date.fromisoformat('2023-03-19')  # python3.7+
datetime.date(2023, 3, 19)
>>> date.fromtimestamp(time.time())
datetime.date(2023, 3, 19)</div>

<p>仿照这种思路，可以为之前自定义的 <code>Point</code> 类编写一个类方法来通过格式字符串构造实例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, x, y):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> x, y</div><div>&#160; &#160; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">classmethod</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">from_format</span>(cls, format):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">format</span>[<span style="color: #d33682;">1</span>:<span style="color: #859900;">-</span><span style="color: #d33682;">1</span>].split(<span style="color: #2aa198;">','</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">cls</span>(<span style="color: #cb4b16;">int</span>(<span style="color: #268bd2;">x</span>), <span style="color: #cb4b16;">int</span>(<span style="color: #268bd2;">y</span>)) &#160;<span style="color: #a8a8a8;"># same as Point(...)</span></div></div>

<p>注意，这里的参数 <code>cls</code> 在调用时会替换为 <code>Point</code> ，因此调用 <code>cls(...)</code> 等价于类的实例化 <code>Point(...)</code></p>

<p>使用这个类方法可以返回一个实例，就像正常方式得到的实例一样可以调用各种方法：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">p</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">from_format</span>(<span style="color: #2aa198;">'(10,40)'</span>)</div><div><span style="color: #268bd2;">p</span>.<span style="color: #268bd2;">distance_to_origin</span>() &#160;<span style="color: #a8a8a8;"># returns 41.23</span></div></div>

<p>从技术上说，也可以用一个普通函数来构造实例。但使用类方法的好处在于，一是使用者容易明白构造出的实例是属于哪个类的，二是当类被重命名后类方法无需跟着修改，降低了因为疏忽导致错误的可能性。</p>

<p>这里顺便说一下，既然实例可以调用类属性，那么实例也可以调用类方法，这等价于用它的类调用类方法。不过一般不推荐利用实例调用类方法，因为这样做可能有些奇怪。</p>

<h3>静态方法</h3>

<p>除了类方法和实例方法外，还有一个特殊的方法称为<strong>静态方法</strong>。静态方法不是类或实例所特有的，它可以被任意的类或实例调用。静态方法不涉及对类和实例的操作，因此被称为静态方法。</p>

<p>静态方法需要使用 <code>@staticmethod</code> 装饰器，并且不需要添加像 <code>self</code> 或 <code>cls</code> 这种特殊的参数，因此不参与对任意属性的修改。</p>

<p>一个静态方法的定义为：</p>

<div class="codeblock code-template">
    @staticmethod<br>
    <strong>def</strong> <em>method_name</em>(...):<br>
    &nbsp; &nbsp; ...
</div>

<p>不难看出，静态方法脱离了类和实例，表现得更像一个普通的函数。</p>

<hr>

<p>实际上，Python 中的方法和函数除了是否位于类的定义中外，并没有本质的区别。Python 中的类可以看作一个独立的<em>命名空间</em>。在 <code>class</code> 关键字引导的代码块中，可以包含各种语句，例如常见的 <code>for</code> 循环和 <code>with</code> 语句：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Type</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">s</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">i</span> <span style="color: #859900;font-weight: bold;">in</span> <span style="color: #cb4b16;">range</span>(<span style="color: #d33682;">10</span>):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">s</span> <span style="color: #859900;">+=</span> <span style="color: #268bd2;">i</span> <span style="color: #859900;">**</span> <span style="color: #d33682;">2</span></div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">with</span> <span style="color: #268bd2;">open</span>(<span style="color: #2aa198;">'settings.txt'</span>, <span style="color: #2aa198;">'r'</span>) <span style="color: #859900;font-weight: bold;">as</span> <span style="color: #268bd2;">f</span>:</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">settings</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">dict</span>([</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">kv</span>.<span style="color: #268bd2;">split</span>(<span style="color: #2aa198;">'='</span>) <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">kv</span> <span style="color: #859900;font-weight: bold;">in</span> <span style="color: #268bd2;">f</span>.<span style="color: #268bd2;">read</span>().<span style="color: #268bd2;">split</span>(<span style="color: #2aa198;">'</span><span style="color: #cb4b16;">\n</span><span style="color: #2aa198;">'</span>)</div><div>&#160; &#160; &#160; &#160; ])</div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">settings</span>.<span style="color: #268bd2;">get</span>(<span style="color: #2aa198;">'value'</span>):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">property</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">value</span>(self):</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">settings</span>[<span style="color: #2aa198;">'value'</span>]</div></div>

<p>注意，这里使用 <code>if</code> 语句动态地定义了一个方法，这是完全可以的。除此之外，在类内定义另一个类也是很常见的情况，这个嵌套类一般用于提供基本的元信息。</p>

<p>在类之中这个独立的命名空间内，可以直接访问其中定义的变量（或者说属性）。而在类外部，访问这些变量需要通过类名来标识其所位于的命名空间：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">Type</span>.<span style="color: #268bd2;">s</span>) &#160;<span style="color: #a8a8a8;"># 285</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">Type</span>().<span style="color: #268bd2;">value</span>) &#160;<span style="color: #a8a8a8;"># 1</span></div></div>

<p>从这个角度上说，类和模块并没有太大的差别。实际上，当模块导入后，它就是一个普通的 Python 对象，只不过是 <code>&lt;class 'module'></code> 类型的对象。所以在 Python 中使用方法时，实际上就是使用一个函数，Python 解释器只是额外提供了一个语法糖，将调用方法的实例自动填写到函数的 <code>self</code> 参数上，仅此而已。</p>

<h2>特殊方法</h2>

<p>在<a href="" class="link-internal">第一节</a>介绍过实例方法时，同时介绍了一个特殊的实例方法 <code>.__init()__</code> ，它会在类初始化时自动调用，以此完成一些初始化工作。之前介绍时同时提及了类还有很多类似的特殊方法，它们都以双下划线开头结尾，有时也被称为双下方法。</p>

<p>Python 的特点是一切皆对象，任何 Python 的变量都是一个对象。而 Python 对这些变量的操作，例如构造、初始化、删除、获取属性，甚至比较、索引、和迭代，都是通过调用一些特殊的方法实现的，这些方法称为 Python 的<strong>特殊方法</strong>(special method)或<strong>魔法方法</strong>(magic method)，它们的名称以双下划线开始，以双下划线结束，代表着对象的一种特殊的操作。一般情况下，使用类方法或实例方法就可以完成类的功能；但在必要时，可以使用或者重写这些特殊方法，来为自己的类提供更加规范的接口。</p>

<p>在后续篇章中，对 Python 面向对象的介绍几乎都围绕这些特殊方法。通过对这些特殊方法的介绍，可以从根本上了解 Python 的运行机制，从而编写出更加优雅、更 Pythonic 的代码。</p>

<p>本节先介绍类的三个特殊方法：<code>.__init__()</code> 、<code>.__new__()</code> 和 <code>.__del__()</code> ，它们参与着实例的生命周期。</p>

<h3>初始化方法</h3>

<p>初始化方法 <code>.__init()__</code> 是第一个介绍的特殊方法，可能也是最常用的特殊方法。每当生成一个实例后，它便会调用该方法，以此完成一些初始化工作。</p>

<p>需要注意的是，<code>.__init__()</code> 方法不能有任何非 <code>None</code> 的返回值，否则就会引起 <code class="error">TypeError</code> ，错误内容将提示该方法应该返回 <code>None</code> 。</p>

<h3>构造方法</h3>

<p><code>.__new__()</code> 被称为构造方法，因为它负责创建一个新的实例。而 <code>.__init__()</code> 负责创建后的初始化，从中也可以明白它们的用途以及调用的先后顺序。</p>

<p><code>.__new__()</code> 负责创建类的实例，它的第一个位置通常名为 <code>cls</code> ，代表生成实例的类，其余参数应该是 <code>.__init__()</code> 方法的其余参数。虽然看起来很像一个类方法，但它却是一个静态方法，并且无需使用 <code>@staticmethod</code> 装饰器。这也是特殊方法和普通方法的根本区别：Python 解释器已经规定了如何使用特殊方法，因此没必要额外声明其它东西。</p>

<p>它的返回值是新的对象实例（通常是 <code>cls</code> 的实例）。例如以下类 <code>Card</code> ，它使用 <code>.__new__()</code> 方法，在每次生成一个实例时，便给予它唯一的一个 <code>.id_</code> 属性：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Card</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">id_</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__new__</span>(cls, <span style="color: #859900;">*</span>args, <span style="color: #859900;">**</span>kwargs):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__new__</span>(<span style="color: #268bd2;">cls</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">id_</span> <span style="color: #859900;">+=</span> <span style="color: #d33682;">1</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">instance</span>.<span style="color: #268bd2;">id_</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">id_</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">instance</span></div><br><div><span style="color: #268bd2;">c01</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c02</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c03</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c03</span>.<span style="color: #268bd2;">id_</span> &#160;<span style="color: #a8a8a8;"># 3</span></div></div>

<p>注意，虽然它表现得很像一个类方法，但不能像之前介绍的类方法一样通过 <code>cls(...)</code> 来创建实例，因为这样做实质上就是在调用该方法，会陷入无限递归。一般来说对象的创建是底层 C 语言的任务，而 Python 中只需要使用 CPython 提供的接口即可，例如使用 <code>super().__new__(cls, ...)</code> 调用 <code>object</code> 类提供的基本 <code>.__new__()</code> 方法，然后在返回之前根据需要修改新创建的实例即可。</p>

<p>由于涉及到对类属性的修改，因此使用 <code>.__init__()</code> 方法不太好实现（当然不是不能实现，在后续会介绍）。同时使用 <code>.__new__()</code> 方法也方便了继承，子类可以正常编写 <code>.__init__()</code> 方法而不影响 <code>.id_</code> 的分配。</p>

<p>通过之前的介绍可以明白构造方法和初始化方法的执行顺序：<code>.__new__()</code> 方法会优先 <code>.__init__()</code> 初始化方法在生成实例前调用。执行了 <code>.__new__()</code> 并不一定会进入 <code>.__init__()</code> ；只有 <code>.__new__()</code> 返回了当前类的实例（即便是父类的实例也不行），才会进入 <code>.__init__()</code> 并为该实例做一定初始化，否则没有东西可以用于初始化。</p>

<p>利用这种特性，可以在 Python 中创建单例。单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。单例提供了创建与访问其唯一对象的方式。使用 <code>.__new__()</code> 方法可以自由控制创建的对象，从而比较方便地实现单例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Singleton</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">_has_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">False</span></div><div>&#160; &#160; <span style="color: #268bd2;">__single_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">None</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__new__</span>(cls, <span style="color: #859900;">*</span>args, <span style="color: #859900;">**</span>kwargs):</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #859900;">not</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">_has_instance</span>:</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">_has_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">True</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">__single_instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__new__</span>(<span style="color: #268bd2;">cls</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">__single_instance</span></div><div>&#160; &#160; </div><div><span style="color: #268bd2;">one_task</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Singleton</span>()</div><div><span style="color: #268bd2;">another_task</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Singleton</span>(<span style="color: #d33682;">123</span>, name<span style="color: #859900;">=</span><span style="color: #2aa198;">'another'</span>)</div><div><span style="color: #268bd2;">one_task</span> <span style="color: #859900;">is</span> <span style="color: #268bd2;">another_task</span> <span style="color: #859900;">is</span> <span style="color: #cb4b16;">Singleton</span>(<span style="color: #2aa198;">'abs'</span>) &#160;<span style="color: #a8a8a8;"># True</span></div></div>

<p>可以看到，不管该类被实例化多少次，如何实例化，得到的都是唯一的实例。单例提供了一种共享数据的方式，并且方便使用 <code><strong>is</strong></code> 判断。但考虑到 Python 能使用全局变量完成相同的工作，因此一般来说在 Python 中没必要使用单例。</p>

<h3>析构方法</h3>

<p>与构造方法相反，析构方法 <code>.__del__()</code> 用于在销毁一个类实例时调用，它对应的是 Python 中的 <code>del</code> 语句。</p>

<p>当一个对象即将被销毁时，它便会调用 <code>.__del__()</code> 方法，通常该方法用于释放实例用到的一些额外的资源（如关闭已经打开的文件）。</p>

<p><code>.__del__()</code> 是实例相关的方法，因此第一个参数应该为 <code>self</code> 。注意区别于 <code>property</code> 的 <code>@.deleter</code> 装饰器，它装饰的方法在删除某个属性时调用，而不是整个实例。由于垃圾回收是后台处理的，且 <code>del</code> 是一个语句，因此 <code>.__del__()</code> 的返回值并没有任何意义。并且在该方法内引发任何异常也是没有作用的，它既不能被所处的 <code>try</code> 块捕获，也不会中断程序的运行。</p>

<p>注意，<code>del</code> 语句在调用时，并没有直接调用实例的 <code>.__del__()</code> 方法，这是因为如果变量仅仅是对实例的一个引用，那么 <code>del</code> 语句只会销毁这个引用的对象。只有当所有的引用都被销毁了，那么 <code>del</code> 语句才会调用 <code>.__del__()</code> 方法来清除这个实例。因此，通过在 <code>.__del__()</code> 中为对象添加一个引用可以暂时推迟对象的删除，但这是很不建议的做法。</p>

<p>通过 <code>.__del__()</code> 方法，可以研究 Python 的垃圾回收机制。例如，以下是在命令行中的一个小测试：</p>

<div class="codeblock code-console">>>> GCTest()
&lt;__main__.GCTest object at 0x00000282CE8907B8>
>>> t = GCTest()
>>> del t
object deleted
>>> 'now delete "_"'
object deleted
'now delete "_"'
</div>

<p>第一个实例被自动保存在 <code>_</code> 变量中，只有这个引用改变了，它才会被删除。</p>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization">https://docs.python.org/3/reference/datamodel.html#basic-customization</a><br>
    Python3 语言参考——数据模型部分，该部分介绍了绝大多数常用的特殊方法、特殊属性与 Python 的运行机制，是深入理解 Python 最好的文档。
</p>
<p><a rel="nofollow" href="/archives/1059">Python面向对象编程04-类与实例的方法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1059/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python面向对象编程03-类的继承</title>
		<link>/archives/579</link>
					<comments>/archives/579#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 28 Jul 2022 14:08:34 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=579</guid>

					<description><![CDATA[<p>类的继承 什么是继承 在 Python 中，有些时候&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/579">Python面向对象编程03-类的继承</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>类的继承</h2>

<h3>什么是继承</h3>

<p>在 Python 中，有些时候会遇到一个已经写好的类，这个类实现了一些基本的功能、方法，但是并不完善。例如，假设要编写一个游戏，在游戏中实现了怪物类 <code>Monster</code> ，它具有一些基本的属性和交互逻辑：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Monster</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, hp, damage):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">max_hp</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__hp</span> <span style="color: #859900;">=</span> hp</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__damage</span> <span style="color: #859900;">=</span> damage</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">attack</span>(self, target):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target.hp <span style="color: #859900;">-=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__damage</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">cure</span>(self, hp<span style="color: #859900;">=</span><span style="color: #b58900;">None</span>):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> hp <span style="color: #859900;">is</span> <span style="color: #b58900;">None</span> <span style="color: #859900;">or</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__hp</span> <span style="color: #859900;">+</span> hp <span style="color: #859900;">&gt;</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">max_hp</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__hp</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">max_hp</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">else</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__hp</span> <span style="color: #859900;">+=</span> <span style="color: #268bd2;">self</span>.hp</div></div>

<p>通过实例化该类，就可以往合适的位置添加一些怪物，并且每只怪物都可以拥有独立的攻击力等属性。</p>

<p>然而，游戏中往往存在许多类型的怪物，同类怪物还可以细分为许多不同的形态，如果要为每一种怪物都从头编写一个类，考虑到这些基础的属性及方法的定义都不会改变，就必须将这些重复的代码片段复制过来，就像：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Slime</span>:</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">attack</span>(self, target):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target.hp <span style="color: #859900;">-=</span> <span style="color: #268bd2;">self</span>.__damage</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Zombie</span>:</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">attack</span>(self, target):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target.hp <span style="color: #859900;">-=</span> <span style="color: #268bd2;">self</span>.__damage</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Guardian</span>:</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">attack</span>(self, target):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target.hp <span style="color: #859900;">-=</span> <span style="color: #268bd2;">self</span>.__damage</div></div>

<p>这很明显是一种低效的方法：一个实现了基本功能的类可能有上百行代码，如果将所有代码复制过来，显然不方便调整和修改，容易产生疏漏，而且一旦游戏的底层逻辑被更新（例如增加了护甲这一概念），那么要为涉及的所有类重写方法，显然非常不合适。</p>

<p>在面向对象编程中，<strong>继承</strong>(inheritance)机制经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），此时可以不用直接复制代码，而是通过<mark>继承获取被继承类拥有的属性与方法</mark>，从而轻松实现类的复用。</p>

<p>在 Python 中，定义类的时候如果在类名称后面加上一个小括号，里面传入需要继承的类名，表示这个类是继承基于已定义的类的：</p>

<div class="codeblock code-template">
    <strong>class</strong> <em>DerivedType</em>(BaseType):<br>
    &nbsp; &nbsp; ...
</div>

<p>这里的 <code>DerivedType</code> 是继承自 <code>BaseType</code> ，它拥有 <code>BaseType</code> 的所有属性和方法。被继承的类称为<strong>父类</strong>或超类，继承得到的对象称为<strong>子类</strong>(subclass)。在明确父类的定义后，子类通过继承获得的所有属性与方法实现均与父类相同。</p>

<p>由于子类继承的方法实际上是对父类方法的引用，因此当父类方法更新时，子类的调用结果也会随之改变。</p>

<p>对于上述类 <code>Monster</code> ，可以通过继承它来创建一个新的类，例如：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Goblin</span>(<span style="color: #cb4b16;">Monster</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">enrage</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__damage</span> <span style="color: #859900;">*</span> <span style="color: #d33682;">2</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">max_hp</span> <span style="color: #859900;">*</span> <span style="color: #d33682;">1.25</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">cure</span>()</div></div>

<p>子类无需额外编写包括初始化在内的所有方法，就可以直接使用父类提供的属性操作，不仅省时省力，还降低了出现疏漏的可能。</p>

<h3>继承与面向对象</h3>

<p>面向对象编程思想的最终目的就包括使程序灵活性、重用性和可扩展性得以提升，而类的继承便很好地满足了该目的。</p>

<p>继承使子类可以拥有父类所有的属性和方法，在实际应用时，往往会提前写好一些具有基本功能的<strong>基类</strong>，在使用时要做的就是继承它们，然后添加上合适的业务功能，使开发效率可以大幅提升。</p>

<p>例如，以下是第三方库 SQLAlchemy 的使用示例。SQLAlchemy 用于处理 SQL 数据库，它已经提前编写好了数据表操作的基类，通过继承该基类，可以创建一个自定义的数据表：</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">import</span> <span style="color: #cb4b16;">sqlalchemy</span> <span style="color: #859900;font-weight: bold;">as</span> <span style="color: #cb4b16;">sa</span></div><div><span style="color: #859900;font-weight: bold;">from</span> <span style="color: #cb4b16;">sqlalchemy</span>.<span style="color: #cb4b16;">ext</span>.<span style="color: #cb4b16;">declarative</span> <span style="color: #859900;font-weight: bold;">import</span> <span style="color: #268bd2;">declarative_base</span></div><div><span style="color: #268bd2;">Base</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">declarative_base</span>()</div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">User</span>(<span style="color: #268bd2;">Base</span>):</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">__tablename__</span> <span style="color: #859900;">=</span> <span style="color: #2aa198;">'user'</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">id</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Column</span>(<span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Integer</span>, primary_key<span style="color: #859900;">=</span><span style="color: #b58900;">True</span>, autoincrement<span style="color: #859900;">=</span><span style="color: #b58900;">True</span>)</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">username</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Column</span>(<span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">String</span>(<span style="color: #d33682;">64</span>), unique<span style="color: #859900;">=</span><span style="color: #b58900;">True</span>)</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">password</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Column</span>(<span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">String</span>(<span style="color: #d33682;">64</span>))</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">email</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Column</span>(<span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">String</span>(<span style="color: #d33682;">128</span>), unique<span style="color: #859900;">=</span><span style="color: #b58900;">True</span>)</div></div>

<p>继承得到的类只需要考虑数据表具有什么样的字段，而无需知道如何与数据库交互。在合适的时候，基类的方法会被调用，自动执行数据的更新或查找等操作，而无需考虑这些方法到底如何实现。</p>

<p>当有一个现有的、功能已经相当完善的类时，有些时候为了扩展这些类的功能，也会继承它并定义一些新方法，这样可以在保留原有类的优点时丰富它的功能。Python 标准库中的类都是很好的继承对象。</p>

<p>以字典类为例，可以基于它实现一个自己的字典：</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">from</span> <span style="color: #cb4b16;">collections</span> <span style="color: #859900;font-weight: bold;">import</span> <span style="color: #cb4b16;">OrderedDict</span></div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">SortableDict</span>(<span style="color: #cb4b16;">OrderedDict</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">sort_value</span>(self, reverse<span style="color: #859900;">=</span><span style="color: #b58900;">False</span>):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">item_list</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">list</span>(<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">items</span>())</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">item_list</span>.<span style="color: #268bd2;">sort</span>(key<span style="color: #859900;">=</span><span style="color: #586e75;font-weight: bold;">lambda</span> x: x[<span style="color: #d33682;">1</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> reverse:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">item_list</span>.<span style="color: #268bd2;">reverse</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #cb4b16;">OrderedDict</span>(<span style="color: #268bd2;">item_list</span>)</div></div>

<p>对于这一个继承的字典类，它保留了字典的所有性质，并可以通过方法 <code>.sort_value()</code> 对值进行排序。它完全可以像字典一样使用：</p>

<div class="codeblock code-console">&gt;&gt;&gt; scores = SortableDict(John=72, Tom=83, Joe=75, Emma=92)
&gt;&gt;&gt; scores.sort_value(reverse=True)
OrderedDict([('Emma', 92), ('Tom', 83), ('Joe', 75), ('John', 72)])</div>

<p>子类也可以被继承，类可以这样无限继承下去，每继承一次，它的功能就更丰富了一层。</p>

<p>事实上，在 Python3 中定义一个类时，如果没有明确类是继承自哪一个类的，那么这个类便自动继承自内置类 <code>object</code> 。<code>object</code> 是 Python 类的基础，它实现了一些最基本的方法例如分配资源、名称表示等，可以说任何定义的类最终都是它的子类。</p>

<p>方法重写也是面向对象编程常用的一种手段。尽管有一些类已经实现了某个方法，但为了适应不同的业务逻辑，有时也需要重写父类提供的方法。</p>

<p>例如，以下是第三方库 Scrapy 的一个简单示例，通过继承 <code>scrapy.Spider</code> 基类，可以创建一个网络爬虫类。该类已经写好了完整了爬虫处理过程并在合适的时候调用相应的方法，而用户要做的就是重写关键的方法来适应当前爬虫业务。例如替换要爬取的网站等关键信息，以及重写 <code>.parse()</code> 方法来处理数据的解析流程：</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">import</span> scrapy</div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">BookSpider</span>(<span style="color: #cb4b16;">scrapy</span>.<span style="color: #6c71c4;">Spider</span>):</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">name</span> <span style="color: #859900;">=</span> <span style="color: #2aa198;">'books'</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">start_urls</span> <span style="color: #859900;">=</span> [<span style="color: #2aa198;">'https://scrapy.org/resources/'</span>]</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">parse</span>(self, response):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">resource</span> <span style="color: #859900;">in</span> response.css(<span style="color: #2aa198;">'div.resource'</span>):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">link</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">resource</span>.xpath(<span style="color: #2aa198;">'./div/a/@href'</span>).extract_first()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">title</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">resource</span>.xpath(<span style="color: #2aa198;">'./div/a/text()'</span>).extract_first()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">yield</span> {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #2aa198;">'link'</span>: <span style="color: #268bd2;">link</span>,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #2aa198;">'title'</span>: <span style="color: #268bd2;">title</span>,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div></div>

<p>重写之后该方法就可以替换原有流程的数据解析部分，而执行请求、解析数据等方法可以让父类提供，也可以通过重写实现自己的要求。</p>

<p>继承和重写使类的设计更模块化，在编写类的时候可以将整个过程拆解为一个个的方法，如果需要修改过程中的某一步，只需要继承该类并重写对应的方法，只要方法的参数和返回值等符合上下文调用的需求，即可简洁、清晰地做局部调整。</p>

<p>继承和重写也符合面向对象编程中<strong>多态</strong>的概念，即当多个类继承某一个类时，如果这些类都重写了某些方法，那么对不同的类调用相同的方法，就可以得到不同的结果。例如对以上的爬虫类，对不同的爬虫调用 <code>.parse()</code> 方法，解析数据的方式也不尽相同。</p>

<p>在 Python 中，继承还有一个很典型的应用场景就是异常。通过继承异常类型，可以逐步缩减异常涉及的范围，从而易于通过 <code>except</code> 语句捕获不同异常。</p>

<h3>多继承</h3>

<p>在 Python 中，一个类可以继承自多个类，只需要在代表继承的括号中输入多个类名：</p>

<div class="codeblock code-template">
    <strong>class</strong> <em>DerivedType</em>(BaseType01, BaseType02, ...):<br>
    &nbsp; &nbsp; ...
</div>

<p>这个新的子类就会保留继承的所有父类的属性和方法，同时兼具继承的所有类的特性。</p>

<p>对于多个父类中包含同名的类属性与方法，Python 会根据子类继承时圆括号中父类的前后次序决定，括号中排在前面的属性与方法会覆盖后面的同名属性与方法。</p>

<p>在使用多继承时，往往将其中一部分类用作接口。接口类定义了这些类中需要具有什么特性，也就是说需要拥有什么属性与方法。</p>

<p>在继承时，可以编写一种特殊的抽象基类。抽象基类不具有实际含义，不能被实例化，仅用于在继承时提示被继承的类具有什么特性，这种抽象基类往往被用于接口。<code>collections.abc</code> 模块提供了基础的抽象基类，继承该模块的抽象基类提示该类应该实现某些方法来实现特殊操作。</p>

<p>例如，以下的 <code>Directory</code> 类继承自 <code>Path</code> 类，提示它拥有路径的一些操作（例如切换目录、计算相对路径等），同时它还继承自 <code>Iterable</code> 类，这说明该类<em>应该</em>实现了某些方法，从而变成一个可迭代对象，</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">from</span> <span style="color: #cb4b16;">collections</span>.<span style="color: #cb4b16;">abc</span> <span style="color: #859900;font-weight: bold;">import</span> <span style="color: #cb4b16;">Iterable</span></div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Path</span>:</div><div>&nbsp; &nbsp; <span style="color: #cb4b16;">...</span></div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Directory</span>(<span style="color: #cb4b16;">Path</span>, <span style="color: #cb4b16;">Iterable</span>):</div><div>&nbsp; &nbsp; <span style="color: #cb4b16;">...</span></div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># Some methods need to be implemented to support for loop</span></div></div>

<p>可以使用 <code>for</code> 循环从该类中迭代每一个成员（例如目录中的每一个文件或子目录）。关于可迭代对象的概念将会在后续介绍。</p>

<h2>继承与super类</h2>

<h3>为什么要使用super类</h3>

<p>前文中介绍了多继承，多继承允许一个类使用所有父类的属性与方法。然而这样做有一个很严重的问题：那就是父类之间的方法或属性标识符可能会冲突，从而相互之间发生覆盖造成一定问题。</p>

<p>考虑以下简单示例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Sequence</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self): <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">size</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">11</span></div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Window</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self): <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">size</span> <span style="color: #859900;">=</span> (<span style="color: #d33682;">400</span>, <span style="color: #d33682;">300</span>)</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">create</span>(self): </div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #586e75;font-weight: bold;">f</span><span style="color: #2aa198;">'window created with size </span><span style="color: #cb4b16;">{</span><span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">size</span><span style="color: #cb4b16;">}</span><span style="color: #2aa198;">'</span>)</div></div>

<p>这两个类在单独编写或继承时，并没有什么问题。但是在多继承时，便会产生问题了：</p>

<div class="codeblock code-console">&gt;&gt;&gt; class Windows(Sequence, Window):
...     pass
...
&gt;&gt;&gt; Windows().create()
window created with size 11</div>

<p>两个类的初始化方法发生了覆盖，造成同名变量的赋值也被覆盖，这种覆盖是十分危险的。由于初始化方法需要为实例准备一些必要的属性，如果缺失这一步会造成缺少方法需要的资源，从而产生错误。</p>

<p>一种更复杂的继承情况涉及单继承和多继承的结合，这种情况下，多次调用同一方法也可能造成一定问题。例如，考虑以下继承关系：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">A</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is A'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">B</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">A</span>.<span style="color: #268bd2;">identify</span>(<span style="color: #268bd2;">self</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is B'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">A</span>.<span style="color: #268bd2;">identify</span>(<span style="color: #268bd2;">self</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is C'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">D</span>(<span style="color: #cb4b16;">B</span>, <span style="color: #cb4b16;">C</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">B</span>.<span style="color: #268bd2;">identify</span>(<span style="color: #268bd2;">self</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">C</span>.<span style="color: #268bd2;">identify</span>(<span style="color: #268bd2;">self</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is D'</span>)</div></div>

<p>这种继承关系如下所示，箭头之间构成了一个菱形，因此有时也称为菱形继承：</p>

<div class="codeblock code-console">    A
 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2197.png" alt="↗" class="wp-smiley" style="height: 1em; max-height: 1em;" />  <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2196.png" alt="↖" class="wp-smiley" style="height: 1em; max-height: 1em;" />
B      C
 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2196.png" alt="↖" class="wp-smiley" style="height: 1em; max-height: 1em;" />  <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2197.png" alt="↗" class="wp-smiley" style="height: 1em; max-height: 1em;" />
   D</div>

<p>在菱形继承中，各种类方法之间复杂地纠缠在一起，稍不注意就可能产生混乱的调用问题。在以上示例中，尝试调用 <code>D</code> 类的方法：</p>

<div class="codeblock code-console">D().identify()
This is A 
This is B 
This is A 
This is C 
This is D</div>

<p>从中可以看出，调用两个父类的方法时都各自调用了一遍 <code>A</code> 类的方法。当继承关系进一步变复杂时，调用还会更加混乱。</p>

<p>这种时候，可以使用 Python 内置的 <code>super</code> 类。</p>

<h3>使用super类</h3>

<p><code>super(<em>type</em>, <em>object_or_type</em>)</code> 将得到一个父类或同级类的代理对象(proxy object)，用于访问已在类中重写的继承方法。</p>

<p>其中，参数 <code><em>type</em></code> 是一个类名，而 <code><em>object_or_type</em></code> 必须是一个该类或该类的子类的实例化对象。</p>

<p>如果用在在类的实例方法内部，<code>super()</code> 函数的两个参数是可以省略的。这种情况下该类代表父类，可以用该类得到的实例来调用父类的方法，例如：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">A</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">m</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'=&gt; A.m &lt;='</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">B</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">m</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">sth</span><span style="color: #859900;">=</span><span style="color: #cb4b16;">super</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">sth</span>.<span style="color: #268bd2;">m</span>()</div></div>

<p>那么此时如果调用 <code>B().m()</code> ，通过 <code>super</code> 类就可以调用父类的方法，在控制台中打印提示文本。</p>

<p>在这个最简单的使用场景中，<code>super</code> 类充当了对父类的一个隐式引用，通过它来调用父类的方法。当然也可以直接使用父类调用父类的方法，不过采用 <code>super</code> 类含义更加明确，也更不容易出现疏漏。</p>

<p>在许多继承场合中，都需要额外调用父类的初始化方法来准备一些必要的属性，例如 Python 用于编写简易用户界面的标准库 tkinter 中，如果想继承一个控件类实现自己的控件，就需要调用这些类的初始化方法，为界面绘制提供参数：</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">import</span> <span style="color: #cb4b16;">tkinter</span> <span style="color: #859900;font-weight: bold;">as</span> <span style="color: #cb4b16;">tk</span></div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">MainPanel</span>(<span style="color: #cb4b16;">tk</span>.<span style="color: #cb4b16;">Frame</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, master):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__init__</span>(master) &nbsp;<span style="color: #a8a8a8;"># ignore this will cause an error</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">...</span></div></div>

<p>当然也可以直接通过父类调用初始化方法 <code>tk.Frame.__init__(self, master)</code> 。</p>

<h3>super类与多继承</h3>

<p>以上对 <code>super</code> 类的应用似乎可有可无。解决多继承问题才是该类提出的根本目的。</p>

<p>在介绍 <code>super</code> 类处理多继承前，需要先了解 Python 的 MRO 。MRO(Method Resolution Order, 方法解析顺序)是 Python 中定义类的继承顺序的依据，用来处理多继承时的继承顺序。</p>

<p>在创建一个类时，Python 都会自动为该类创建一个 <code>.__mro__</code> 属性，这个属性就是 Python 的 MRO 机制生成的。可以通过类的 <code>.__mro__</code> 属性或类的 <code>.mro()</code> 方法来查看上面菱形继承的 <code>D</code> 类的 <code>__mro__</code> 属性值：</p>

<div class="codeblock code-console">&gt;&gt;&gt; D.__mro__
    (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)
</div>

<p><code>.mro()</code> 方法除了返回的结果是列表而不是元组外，结果是相同的。</p>

<blockquote>
    <p>目前 Python3 采用 C3 算法来获取类的 MRO 信息，该算法的细节可以在 <a href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a> 查询到，这里对此做简要介绍，仅供了解所用。</p>
    
    <p>如下是一个复杂的继承关系，箭头指向父类，并且先继承的类位于左侧：</p>

    <figure>
        <img decoding="async" src="/wordpress/wp-content/uploads/2022/07/mro.png" alt="" width="140">
    </figure>
    
    <p>当要生成 F 的继承顺序时，C3 算法过程如下：首先将被指向箭头数量为 0 的节点（没有被继承的类）F 放入 MRO 列表，并将这些节点及与有关箭头从继承树中删除；接下来继续找相似特征的节点，此时如果同时找到符合条件的类，则取左侧优先放入 MRO 列表并从树中删除下一步查找满足的节点有 A 和 E ，根据左侧优先取出 A ，按如此顺序得到的 MRO 为 <code>F,D,A,E,B,C</code> 。不过注意，Python 所有类都有一个共同的父类 <code>object</code> ，因此最后会将 <code>object</code> 放入列表末尾。</p>

    <p>最终生成列表中元素顺序为：<code>F→D→A→E→B→C→object</code> 。感兴趣的话可以编写代码验证。</p>
</blockquote>

<p>当用 super 调用父类的方法时，会按照 __mro__ 属性中的元素顺序逐个查找方法，<code><em>object_or_type</em></code> 对应的类负责确定 <code>__mro__</code> 属性，而 <code><em>type</em></code> 参数在 <code>__mro__</code> 中寻找上一个类作为父类。</p>

<p>如果不是很理解这个表述，请看以下复杂继承的示例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">A</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is A'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">B</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is B'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is C'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">D</span>(<span style="color: #cb4b16;">A</span>, <span style="color: #cb4b16;">B</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is D'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">E</span>(<span style="color: #cb4b16;">B</span>, <span style="color: #cb4b16;">C</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is E'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">F</span>(<span style="color: #cb4b16;">D</span>, <span style="color: #cb4b16;">E</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is F'</span>)</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">A</span>, <span style="color: #cb4b16;">F</span>()).identify()</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">B</span>, <span style="color: #cb4b16;">F</span>()).identify()</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">D</span>, <span style="color: #cb4b16;">F</span>()).<span style="color: #268bd2;">identify</span>()</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">E</span>, <span style="color: #cb4b16;">F</span>()).<span style="color: #268bd2;">identify</span>()</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">F</span>, <span style="color: #cb4b16;">F</span>()).<span style="color: #268bd2;">identify</span>()</div></div>

<p>以上代码一共得到了 5 种不同的代理对象，它们的指代分别为：</p>

<div class="codeblock code-console">This is E
This is C
This is A
This is B
This is D</div>

<p>尽管 <code>A</code> 类看起来与 <code>E</code> 类没有任何关系，但是代表的却是 E 类的实例。回顾一下这种继承关系得到的 MRO 顺序：</p>

<div class="codeblock code-template">
    F→D→A→E→B→C→object
</div>

<p>结果便不言而喻了。记住 <code><em>type</em></code> 参数确定的父类的是 <code><em>object_or_type</em></code> 参数在 MRO 中指向的后一个类。</p>

<blockquote>
    <p>之前说过 <code>super()</code> 的第二个参数也可以是一个类，不过这是对于调用类方法而言的。有关类方法的内容将会在下一节介绍</p>
</blockquote>

<p>回到之前提出的第二个问题，如果采用 <code>super</code> 类来调用父类方法：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">A</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is A'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">B</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">identify</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is B'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">identify</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is C'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">D</span>(<span style="color: #cb4b16;">B</span>, <span style="color: #cb4b16;">C</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">identify</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is D'</span>)</div></div>

<p>那么就不会出现重复调用的情况了：</p>

<div class="codeblock code-console">&gt;&gt;&gt; D().identify()
This is A 
This is C 
This is B 
This is D</div>

<p>任意复杂的继承情况，每一个类在 MRO 中只会出现一次，因此这样避免了方法的重复调用，使得复杂的继承也不容易出错。</p>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://docs.python.org/3/tutorial/classes.html#inheritance">https://docs.python.org/3/tutorial/classes.html#inheritance</a><br>
    Python3 官方文档对继承的介绍，不过这部分比较简洁
</p>

<p>
    <a href="https://docs.python.org/3/library/functions.html#super">https://docs.python.org/3/library/functions.html#super</a><br>
    Python3 官方文档对内置函数 <code>super</code> 的介绍
</p>
<p><a rel="nofollow" href="/archives/579">Python面向对象编程03-类的继承</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/579/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python面向对象编程02-类与实例的属性</title>
		<link>/archives/448</link>
					<comments>/archives/448#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Tue, 05 Jul 2022 04:13:11 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=448</guid>

					<description><![CDATA[<p>实例的属性 在上一节中，已经详细解释了实例的属性。实&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/448">Python面向对象编程02-类与实例的属性</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>实例的属性</h2>

<p>在上一节中，已经详细解释了实例的属性。实例的属性可以使用 <code>instance.<em>attribute</em></code> 来访问并赋值。假设有一个类 <code>Stack</code> ，它的属性可以有栈长度、栈顶位置、栈段，那么该类的实现可以是：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Stack</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, length):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">length</span> <span style="color: #859900;">=</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">body</span> <span style="color: #859900;">=</span> [<span style="color: #d33682;">0</span>] <span style="color: #859900;">*</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">push</span>(self, value):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">&gt;=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">length</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">OverflowError</span>(<span style="color: #2aa198;">'Not enough space to push'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">body</span>[<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span>] <span style="color: #859900;">=</span> value</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">+=</span> <span style="color: #d33682;">1</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">pop</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">&lt;</span> <span style="color: #d33682;">0</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">OverflowError</span>(<span style="color: #2aa198;">'Stack is empty'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">elem</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">body</span>[<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span>]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">-=</span> <span style="color: #d33682;">1</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">elem</span></div></div>

<p>这里为其编写了一个初始化方法用于构造栈所需的属性，以及两个普通方法用于入栈和出栈。这里属性还充当着在多个方法间传递数据的角色，这样不用使用参数和返回值，就可以在一个方法执行完后，将栈顶位置的变化实时作用在另一个方法上。</p>

<h2>受保护属性和私有属性</h2>

<p>属性不但可以用于表示一个类具有哪些特征，而且可以保存这些特征的变化。然而有些时候，并不希望属性直接被访问到，因为多个属性间往往具有一定的关联，对单个属性的修改可能会导致这个关联被破坏掉。</p>

<p>例如，以上实现的 <code>Stack</code> 类，栈元素和栈顶之间具有一定关联，一般只期望通过提供的 <code>.push()</code> 和 <code>.pop()</code> 方法一并修改它们，如果只修改栈顶位置的话，有些栈元素可能再也无法访问了。</p>

<p>针对上述问题，Python的一个默认约定是使用下划线 <code>_</code> 开头的名称来作为实例属性，来表示受保护属性。那么栈的初始化可以改成这样：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Stack</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, length):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">length</span> <span style="color: #859900;">=</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">body</span> <span style="color: #859900;">=</span> [<span style="color: #d33682;">0</span>] <span style="color: #859900;">*</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div></div>

<p>这样，属性 <code>self._top</code> 就是一个受保护属性。在一般情况下，不应该去访问它并且修改这个属性。</p>

<p>不过需要注意的是，受保护属性是 Python 编程时的一个约定，它并没有阻止访问 <code>._top</code> 这个属性，只是一般情况下，如果不是刻意，编程时很少会特地访问这些以下划线开头的属性，从而减少受保护属性被意外修改的可能性。</p>

<hr>

<p>实际上，Python 还可以创建实例的私有属性。相比受保护属性，私有属性进一步降低了属性被意外修改的误操作。</p>

<p>许多编程语言都提供了 <code>private</code>关键字。而在 Python 中，私有属性是以两个下划线 <code>__</code> 开头的实例属性，例如 <code>self.__length</code> 。这样一来，在实例化一个类后，便不再能够访问该属性。如果想要强行访问如 <code>stack.__length</code> ，会引起 <code class="error">AttributeError</code> ，错误内容大概是没有这个属性。</p>

<p>通过使用私有属性，可以很好地将一个属性隐藏起来。例如以上的 <code>Stack</code> 类，正常情况下栈段和栈的长度都是不应该通过直接访问的形式去修改的，那么就可以将这两个属性变成私有属性：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Stack</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, length):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__length</span> <span style="color: #859900;">=</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__body</span> <span style="color: #859900;">=</span> [<span style="color: #d33682;">0</span>] <span style="color: #859900;">*</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">push</span>(self, value):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span> <span style="color: #859900;">&gt;=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__length</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">OverflowError</span>(<span style="color: #2aa198;">'Not enough space to push'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__body</span>[<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span>] <span style="color: #859900;">=</span> value</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span> <span style="color: #859900;">+=</span> <span style="color: #d33682;">1</span></div></div>

<p>以上说的实例的私有属性无法访问，是针对类定义的外部，操作实例时而言的。如果在类的定义内，知道自己在做什么，当然可以继续使用 <code>self.__length</code> 。</p>

<p>因此，一个常见的做法是为类编写一个方法，提供查看私有属性的接口，例如：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Stack</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">get_length</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__length</span></div></div>

<p>这样，使用该类时只能利用提供的确定、合理的的接口获取类的属性，或者对类进行一些操作。在本文的最后，还会介绍一个 Python 给出的更高级、更优雅的解决方式。</p>

<hr>

<p>实际上，私有属性和受保护属性一样，也没有真正阻止通过实例来修改它的属性。如果使用内置的 <code>dir()</code> 函数来查看一个实例支持的一些属性和方法，结果为：</p>

<div class="codeblock code-console">&gt;&gt;&gt; stack = Stack(10)
&gt;&gt;&gt; dir(stack)
['_Stack__body', '_Stack__length', '__class__', ..., '__weakref__', '_top', 'get_length', 'pop', 'push']
</div>

<p>在结果返回的列表中，没有找到什么名为 <code>.__length</code> 之类的属性。但是注意，实例却有两个属性 <code>._Stack__body</code> 和 <code>._Stack__length</code> 。试着访问一下它们：</p>

<div class="codeblock code-console">&gt;&gt;&gt; stack._Stack__body
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</div>

<p>原来，实例的私有属性并不是真正的私有，只不过将一个实例的属性命名以双下划线开头，在结束类的定义后，Python就会将该属性的名称前面再加上 <code>_<em>ClassName</em></code> ，即一个下划线和对应类的名称。如此一来，要访问实例的属性难度变得更大了，也更不易出错了。</p>

<p>尽管这样做已经可以避免在实际编程中意外修改实例的私有属性，并允许刻意去修改这些私有属性。不过仍然有一些细节需要注意：首先，尽量不要将实例的其它属性命名为私有属性加上保护前缀后的属性。尽管在类定义中不会有什么影响，但这可能造成实例化一个对象后的命名冲突。其次，以两个下划线开头结尾的双下属性并不受该规则影响，但是<a href="/archives/442" class="internal">上一节</a>也说过了，它们可能是一个实例的特殊属性，对它们的任意赋值及修改可能会打乱类的运行，造成意想不到的问题。</p>

<h2>类属性和实例属性</h2>

<p>实例属性是每一个实例所独自拥有的、不同实例间通过实例属性的区别而可能产生一定的差异。在上文中，已经见过了许多实例属性，对于每一个 <code>Stack</code> 实例，它们的大小、栈顶位置、包含的元素都不尽相同，因此需要通过属性予以区分。如果该类还没有一个实例，那么这些属性只是一个笼统的概念，无法进行具体的讨论，也就无法仅通过类来访问实例属性并获取值。</p>

<p>与实例属性相对的概念是类属性。在类中，方法之外创建的变量称为<strong>类属性</strong>。例如，以下为 <code>Point</code> 类创建了一个类属性：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">3</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, x, y, z):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">z</span> <span style="color: #859900;">=</span> x, y, z</div></div>

<p>类属性的特点是，所有类的实例化对象都同时共享类属性。也就是说，类变量在所有实例化对象中是共有的。这也很好理解，对于定义的类 <code>Point</code> 来说，它是三维的点，因此它所有的实例 <code>.dimensions</code> 都是 <code>3</code> ，这是无法更改的事实，因此所有该类的实例都必须具有这一个确定的属性。</p>

<p>类属性与实例属性的一个区别是类属性可以由类直接访问。当创建了一个实例对象时，通过实例对象也可以访问类的属性，例如：</p>

<div class="codeblock code-console">&gt;&gt;&gt; Point.dimensions
3
&gt;&gt;&gt; p01 = Point(3, 4, 5)
&gt;&gt;&gt; p01.dimensions
3</div>

<p>类属性是一个确定的定义，只要实例是属于该类的，那么它们都必须和类一样具有这个共同的属性。</p>

<p>事实上，在实例内部定义的方法，同样属于这个类的类属性。因此可以使用匿名函数与赋值的方式来定义一个方法，也是完全可以的：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">3</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">get_coordinates</span> <span style="color: #859900;">=</span> <span style="color: #586e75;font-weight: bold;">lambda</span> self: (<span style="color: #268bd2;">self</span>.x, <span style="color: #268bd2;">self</span>.y, <span style="color: #268bd2;">self</span>.z)</div></div>

<p>在类内部定义一个方法，可以理解为定义一个函数后，将其作为类属性放在类内部。</p>

<p>通过类和实例都可以访问类属性，类属性也可以通过赋值语句进行修改。但是如果是通过类修改的类属性，会影响到所有实例来访问这个类属性。而通过实例修改这个类属性，则不会影响到类和实例中访问的类属性。例如：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">p02</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>(<span style="color: #d33682;">3</span>, <span style="color: #d33682;">7</span>, <span style="color: #d33682;">9</span>)</div><div><span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #2aa198;">'three'</span> &nbsp;<span style="color: #a8a8a8;"># 通过实例修改类属性</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>, <span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>, <span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>)</div><div><span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">4</span> &nbsp; &nbsp; &nbsp;<span style="color: #a8a8a8;"># 通过类修改类属性</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>, <span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>, <span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>)</div></div>

<p>结果为：</p>

<div class="codeblock code-console">python -u demo.py
three 3 3
three 4 4
</div>

<p>注意到当通过类修改类属性后，第一个实例的属性并没有被修改，但是第二个实例的属性却被修改了。</p>

<p>关于这一点，可以通过内置的 <code>id()</code> 函数来查看对应的类属性的身份变化：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>))</div><div><span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #2aa198;">'three'</span> &nbsp;<span style="color: #a8a8a8;"># 通过实例修改类属性</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>))</div><div><span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">4</span> &nbsp; &nbsp; &nbsp;<span style="color: #a8a8a8;"># 通过类修改类属性</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>))</div></div>

<p>结果为：</p>

<div class="codeblock code-console">python -u demo.py
15757472 15757472 15757472
26266752 15757472 15757472
26266752 15757488 15757488</div>

<p>观察结果不难发现，当实例化一个类后，通过实例访问的属性仅仅是对类属性的一个引用，因此通过类修改类属性会引起实例访问类属性的变化。而通过实例修改类属性后，实际上是创建了一个新的实例属性，因此通过类修改类属性，当然不会影响这个实例属性。</p>

<p>要解释以上原因的底层原理还为时过早。在后续介绍描述符这一概念时，才会明白属性查找的原理。</p>

<h2>使用类的property</h2>

<h3>为什么需要用property</h3>

<p>在前面章节中，一直使用 <code>instance.<em>attribute</em></code> 的方式来访问实例的属性，但是有些情况下希望属性应该是隐藏的，只允许通过提供的接口方法来间接实现对实例属性的访问和修改。</p>

<p>例如，以下实现了一个类 <code>Color</code> ，用来表示计算机存储的颜色数据：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, red, green, blue):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span> <span style="color: #859900;">=</span> red, green, blue</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_hsv_update</span>()</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">_hsv_update</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">_max</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">max</span>(<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">_min</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">min</span>(<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__v</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">max</span>(<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__s</span> <span style="color: #859900;">=</span> (<span style="color: #268bd2;">_max</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">_min</span>) <span style="color: #859900;">/</span> <span style="color: #268bd2;">_max</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span> <span style="color: #859900;">==</span> <span style="color: #268bd2;">_max</span>: </div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__h</span> <span style="color: #859900;">=</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span>) <span style="color: #859900;">/</span> (<span style="color: #268bd2;">_max</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">_min</span>) <span style="color: #859900;">*</span> <span style="color: #d33682;">60</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span> <span style="color: #859900;">==</span> <span style="color: #268bd2;">_max</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__h</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">120</span> <span style="color: #859900;">+</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>) <span style="color: #859900;">/</span> (<span style="color: #268bd2;">_max</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">_min</span>) <span style="color: #859900;">*</span> <span style="color: #d33682;">60</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span> <span style="color: #859900;">==</span> <span style="color: #268bd2;">_max</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__h</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">240</span> <span style="color: #859900;">+</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>) <span style="color: #859900;">/</span> (<span style="color: #268bd2;">_max</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">_min</span>) <span style="color: #859900;">*</span> <span style="color: #d33682;">60</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__h</span> <span style="color: #859900;">&lt;</span> <span style="color: #d33682;">0</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; H <span style="color: #859900;">+=</span> <span style="color: #d33682;">360</span></div></div>

<p>由于计算机存储的色彩空间未必是 RGB ，这里也提供了 HSV 色彩空间的支持，并且每次在更新了 RGB 色值后，会将这个更新实时反应到 HSV 上。因此这里将 RGB 属性都设置为私有属性，为了就是防止 RGB 色值被意外修改而造成两种色彩空间不同步。</p>

<p>如果确实需要对颜色做一些调整，或者获取当前的 RGB 色值，可以编写一些 <code>.get()</code> 和 <code>.set()</code> 等接口方法，在设置颜色时确保可以将其同步到 HSV 色彩空间中：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">get_red</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">set_red</span>(self, red):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #859900;">not</span> <span style="color: #d33682;">0</span> <span style="color: #859900;">&lt;=</span> red <span style="color: #859900;">&lt;=</span> <span style="color: #d33682;">255</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">ValueError</span>(<span style="color: #2aa198;">'red must be between 0 and 255'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span> <span style="color: #859900;">=</span> red</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_hsv_update</span>()</div></div>

<p>对于其它两种基本颜色属性，也可以编写类似函数。</p>

<p>以上是比较传统的想法，通过将实例属性设置成私有属性，然后提供 <code>.get()</code> 和 <code>.set()</code> 等接口方法来获取或设置属性，并在设置属性时进行一些合适的检查。但实际上，Python 提供了一些内置的工具，可以更为方便地操作实例的属性。</p>

<h3>property类</h3>

<p>Python 中，一个 <code>property</code> 类可以将众多 <code>.get()</code> 和 <code>.set()</code> 等接口方法封装成一个属性，这样通过对该属性访问和赋值等操作，实际上就是在调用这些接口方法。<code>property</code> 类的完整初始化函数形式为：</p>

<div class="codeblock code-template">
    property(<em>fget</em>=None, <em>fset</em>=None, <em>fdel</em>=None, <em>doc</em>=None)
</div>

<p>通过实例化该类，可以为该类添加一个特殊的 <code>property</code> 实例属性。在它的参数中：</p>

<ul>
    <li><code>fget</code> 是获取属性值时调用的接口方法</li>
    <li><code>fset</code> 是设置属性值时调用的接口方法</li>
    <li><code>fdel</code> 是删除属性时调用的接口方法</li>
    <li><code>doc</code> 则用来创建属性的 docstring</li> 
</ul>

<p>例如，如果采用 <code>property</code> 属性对 <code>color</code> 类做以下封装：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">del_red</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_hsv_update</span>()</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">red</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">property</span>(<span style="color: #268bd2;">get_red</span>, <span style="color: #268bd2;">set_red</span>, <span style="color: #268bd2;">del_red</span>, <span style="color: #2aa198;">"Red component of color"</span>)</div></div>

<p>如果 <code>background</code> 是一个 <code>Color</code> 类的实例，那么访问 <code>background.<em>red</em></code> 会调用它的 <code>.get_red()</code> 方法；<code>background.<em>red</em> = <em>value</em></code> 会调用它的 <code>.set_red()</code> 方法，并将 <code>value</code> 作为第二个参数；而 <code>del background.<em>red</em></code> 会调用它的 <code>.del_red()</code> 方法。</p>

<p>如果 <code>doc</code> 不为 <code>None</code> ，那么可以在类内通过 <code>red.__doc__</code> 来访问它的 docstring（注意，不能通过 <code>background.red.__doc__</code> 的方式访问它的 docstring ，因为前半部分会先运算而得到红色数值）。否则，<code>property</code> 会将 <code>fget</code> 函数的 docstring 拷贝为 <code>background</code> 的 docstring 。</p>

<p>需要特别注意的是，在 <code>.get_red()</code> 方法中，一定要使用私有属性，而不能直接使用 <code>property</code> 封装的实例属性；否则，当在 <code>.get_red()</code> 内访问 <code>self.red</code> 的话，又会调用该方法，造成无限递归引起程序终止。</p>

<h3>@property装饰器</h3>

<p>如果程序中不希望支持修改或删除这些属性，那么可以在初始化方法中将对应的接口方法设置为 <code>None</code> 。除了使用 <code>property</code> 类，还有一种更清晰的方法是使用 <code>@property</code> 装饰器，它用来装饰一个类的方法，将该方法名变成同名的属性。如果对装饰器这一概念比较陌生，可以阅读<a class="internal" href="/archives/276">这篇文章</a>。</p>

<p>下面以 <code>Color</code> 类的绿色属性为例介绍该装饰器的使用方法。<code>@property</code> 装饰器可以将类方法变成同名属性的 <code>.get()</code> 接口。这样一来，便可以通过 <code>instance.<em>attribute</em></code> 的方式来访问它了：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">property</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">green</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #2aa198;">"""Green component of color"""</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span></div></div>

<p>访问 <code>@property</code> 包装后的 <code>.<em>attribute</em></code> 属性，相当于访问属性的 <code>.get()</code> 方法。除此之外，<code>.property</code> 属性还支持 <code>.set()</code> 和 <code>.delete()</code> 方法，它们需要使用 <code>@<em>attribute</em>.setter</code> 装饰器和 <code>@<em>attribute</em>.deleter</code> 装饰器。例如：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">@</span><span style="color: #268bd2;">green</span><span style="color: #268bd2;">.setter</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">green</span>(self, green):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #859900;">not</span> <span style="color: #d33682;">0</span> <span style="color: #859900;">&lt;=</span> green <span style="color: #859900;">&lt;=</span> <span style="color: #d33682;">255</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">ValueError</span>(<span style="color: #2aa198;">'green must be between 0 and 255'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span> <span style="color: #859900;">=</span> green</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_hsv_update</span>()</div></div>

<p>当为属性 <code>background.green</code> 赋值时，会调用它的 <code>@green.setter</code> 装饰器装饰的方法。类似地可以编写一个 <code>@green.deleter</code> 装饰器装饰的方法，以被 <code>del</code> 语句删除属性时调用。注意：这些方法名必须和 <code>@property</code> 包装的属性名相同，代表为属性设置新的操作接口。</p>

<p>试着编写一些代码：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">background</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Color</span>(<span style="color: #d33682;">128</span>, <span style="color: #d33682;">64</span>, <span style="color: #d33682;">192</span>)</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">red</span>)</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">hue</span>)</div><div><span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">green</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">255</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">hue</span>)</div><div><span style="color: #859900;font-weight: bold;">del</span> <span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">blue</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">hue</span>)</div></div>

<p>结果为：</p>

<div class="codeblock code-console">$ python -u demo.py
128
270.0
150.23622047244095
89.88235294117646</div>

<p>可以看到对 RGB 色值的更新实时反应在 HSV 上。</p>

<p>本节介绍了类与实例属性的概念，并提出了私有属性的概念，私有属性配合接口方法，可以避免实例的完整性被破坏，使对属性的操作更规范。这也符合面向对象编程中常用的<strong>封装</strong>思路，即隐藏对象的属性和实现细节，仅对外公开接口，以控制在程序中属性的访问和修改。</p>

<p>通过 <code>property</code> 可以简化接口的操作方式，使代码更优雅。如果仅看 <code>property</code> 的使用方式，可能会觉得比较费解，比如这样定义的明明像一个类属性，为什么得到的却是一个实例属性？要解释以上原因的底层原理还为时过早，同样在后续介绍描述符时，才会介绍其根本原因，到时候将会对类与实例的属性有更深刻的认知。</p>

<h2>参考资料/延伸阅读</h2>

<p><a href="https://docs.python.org/3/library/functions.html#property">https://docs.python.org/3/library/functions.html#property</a></p>

<p>Python3 官方文档对 <code>property</code> 的介绍。</p>

<p>本文使用的 RGB to HSV 转换算法来自百度百科 <a href="https://baike.baidu.com/item/HSV/547122">https://baike.baidu.com/item/HSV/547122</a></p>
<p><a rel="nofollow" href="/archives/448">Python面向对象编程02-类与实例的属性</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/448/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python面向对象编程01-类的定义与使用</title>
		<link>/archives/442</link>
					<comments>/archives/442#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sun, 03 Jul 2022 12:45:12 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=442</guid>

					<description><![CDATA[<p>类和对象的基本概念 什么是类 在编程时，往往需要通过&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/442">Python面向对象编程01-类的定义与使用</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>类和对象的基本概念</h2>

<h3>什么是类</h3>

<p>在编程时，往往需要通过程序修改变量。但有时候多个变量间可能有很强的关联，是一个整体。此时，可以使用结构体描述这一个整体。然而，结构体只能包含数据成员，却不包含对这些数据操作所需要的函数。</p>

<p>如果把需要描述并操作的某些变量和函数看成一个整体，这个整体就称为<strong>类</strong>(type)。类定义了该集合中每个对象所共有的属性和支持的操作。例如，对于每一种数据结构如链表、栈、二叉树等，每个集合可能都具有一些相同的属性例如后向指针、栈顶位置、树结点值，但还有一些操作如增(add)、删(remove)、改(update)、查(find)，不同的数据结构执行的操作也不一样。这种将一系列属性与方法作为一个整体封装成一个类的编程思路，称为 <strong>面向对象编程</strong> (object-oriented programming)。面向对象编程是一种编程思路而不是具体的编程语言，使用 C 语言照样可以编写具有面向对象编程思想的代码，只是实现起来比较麻烦。</p>

<p>Python 是一种原生支持 面向对象编程 的编程语言，可以轻松实现面向对象编程的大多数要求。Python 提供了许多内置的类，例如列表就是其中之一。<code>list</code> 类的属性有各个元素（暂且可以这么认为），方法有修改，排序数据等。除此之外还可以实现自己的类，例如向量类，这个类的属性有方向和大小，它的方法有获取模长、标量放缩等。</p>

<p>在 Python 中，实现一个最简单的类是这样的：</p>

<div class="codeblock code-template">
    <strong>class</strong> SomeType:<br>
    &nbsp; &nbsp; ...
</div>

<p>类的定义以关键字 <code>class</code> 开头，之后跟着一个类名，并且以冒号和缩进确定类的主体。</p>

<p>类名是一个标识符，必须符合 Python 标识符的命名规则。一般建议类的命名应该遵循大驼峰式标记，即类的任意一个英文单词都应该以大写字母开头。</p>

<p>紧跟类的定义后是类的内容，并且需要缩进。由于第一个类目前并没有实际完成一些事情，因此使用了 <code>pass</code> 关键字表示类的主体暂时忽略。</p>

<p>可以使用内置函数 <code>type()</code> 来查看刚刚定义的类的类型：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">SomeType</span>:</div><div>&nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">pass</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">SomeType</span>, <span style="color: #cb4b16;">type</span>(<span style="color: #cb4b16;">SomeType</span>))</div></div>

<p>结果为：</p>

<div class="codeblock code-console">$ python -u demo.py
    &lt;class '__main__.SomeType'&gt; &lt;class 'type'&gt; 
</div>

<p>结果表明，<code>SomeType</code> 的类型是“类”</p>

<h3>什么是实例</h3>

<p>有了类以后，还需要一个具体的<strong>实例</strong>(instance)来完成具体的行为。对于内置的 <code>list</code> 类，需要有一个存储了具体数据的列表来完成对列表的操作。同样，对于上述的自定义类向量，也需要一个具体的向量实例来完成取模、计算等操作。</p>

<p>对于以上定义的类，获得一个类的实例的方法如下：</p>

<div class="vscode-block"><div>SomeType()</div></div>

<p>通过输入类名并紧跟一对小括号，便可以获得一个类的对象。这种由类创建出的具体对象称为实例(instance)。类是抽象的概念，而实例是具体的概念。</p>

<p>例如，假设有一个类 Fruit(水果)，显然它有一些属性例如 taste(味道)、color(颜色) 等，但只有获得了一个实例 apple(苹果) 后，这些属性才能具体描述。</p>

<p>回到上述语句，获得一个实例有点像调用一个函数，当然这实际上是根据类名生成了一个类的实例。并且由于这个类缺乏具体描述，因此小括号中暂时不需要传入参数。</p>

<p>可以将实例赋值给一个变量，并且每次使用括号，都会为该类生成一个新的实例。例如，以下代码生成了两个类，并使用 <code>type()</code> 函数查看它们的类型：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">one_instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">SomeType</span>()</div><div><span style="color: #268bd2;">another_instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">SomeType</span>()</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">one_instance</span>, <span style="color: #cb4b16;">type</span>(<span style="color: #268bd2;">another_instance</span>))</div></div>

<p>结果为：</p>

<div class="codeblock code-console">$ python -u demo.py
    &lt;__main__.SomeType object at 0x0000020644132FD0&gt; &lt;class '__main__.SomeType'&gt;
</div>

<p>观察上述结果，打印实例变量时，它输出了一个地址，这表明每一个实例之间都是独一无二的。另外，结果显示实例 <code>another_instance</code> 的类型是“当前文件的 <code>SomeType</code> 类”。</p>

<h3>什么是属性</h3>

<p>以上创建的类和实例看起来没有任何作用，它不包含任何数据，也不做任何事情。对于一个已经创建的类，最首要的就是明确类的<strong>属性</strong>(attribute)。</p>

<p>前文说过，属性用来描述一个类有哪些特性。对于一个类，它的每个实例属性具体的值可能不太一样，但是它们都存在这个属性。</p>

<p>假设将平面上的一个点看出一个类，那么可以这样定义它：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">pass</span></div><div><span style="color: #268bd2;">one_point</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>()</div></div>

<p>这个类 <code>Point</code> 需要描述它的坐标，可以通过点记法给一个实例赋予任意的属性。例如，可以这样描述它的属性：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">one_point</span>.x <span style="color: #859900;">=</span> <span style="color: #d33682;">5</span></div><div><span style="color: #268bd2;">one_point</span>.y <span style="color: #859900;">=</span> <span style="color: #d33682;">6</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">one_point</span>.x, <span style="color: #268bd2;">one_point</span>.y)</div></div>

<p>以上描述为实例添加属性的语法为：</p>

<div class="codeblock code-template">
    instance.<em>attribute</em> = <em>value</em>
</div>

<p>这种语法称为点记法，它的赋值过程和变量的赋值是一样的，值可以是任意的，甚至是一个函数或者另一个类。</p>

<p>通过在实例后面加上一个点，就可以表示它的属性，这种方式就和结构体访问字段是一样的。运行以上代码，即可打印属性值：</p>

<div class="codeblock code-console">$ python -u demo.py
    5 6
</div>

<p>这几行代码表明，<code>one_point</code> 实例被添加了两个属性，一个是代表横坐标的 <code>x</code> ，一个是代表纵坐标的 <code>y</code> 。并且它们的属性都被赋予了一个具体的整数值。</p>

<h3>什么是方法</h3>

<p>之前说过，类是属性和操作的集合。获得一个带属性的类以后，这个类还需要完成一些事情，来改变这些属性。改变属性的行为称为<strong>方法</strong>(method)。</p>

<p>例如，对于内置类 <code>list</code> ，它有一些方法，比如增加数据(<code>append</code> 、<code>insert</code> 、<code>extend</code> )、移除数据(<code>remove</code>)等，每个具体的方法实现的效果都不一样。对于自定义的向量类，可以使用方法对它做一些放缩、运算、取模等操作。对于抽象一些的类 Fruit(水果) 来说，它也可以定义一些方法，例如 cut(把一个具体的水果切成小块) 、flavor(给水果加上调料改变味道) 等。</p>

<p>从之前实现的 <code>Point</code> 类开始，可以给它添加一个叫做 <code>move_to_origin</code> 的方法，该方法用来将这个点移动到原点。包含该方法后，完整的类的定义为：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">move_to_origin</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div></div>

<p>Python 中类的方法和定义一个函数类似，都以关键字 <code>def</code> 开头，然后是一个函数/方法名和一对小括号，括号内包含一些参数，以冒号引出函数/方法的主体。一般推荐方法名遵循蛇形命名规则，即名称中的单词字母全部小写并以下划线连接。</p>

<p>注意方法和函数有一点不一样，所有针对实例的方法都必须包含一个参数，这个参数通常被称为 <code>self</code> ，它必须是第一个位置参数，不过它的名称不一定要是 <code>self</code> ，也可以改成 <code>this</code> 或者 <code>Hello</code> 。一般情况下，定义方法的语法为：</p>

<div class="codeblock code-template">
    <strong>def</strong> method(self, ...):<br>
    &nbsp; &nbsp; ...
</div>

<p>一个方法中的 <code>self</code> 参数，是对调用这个方法对象的一个引用。</p>

<p>不过无需手动传入这个 <code>self</code> 参数，调用一个实例方法的方式是实例名后面跟上一个点，再跟上一个方法名，后面像调用函数一样加上一个括号，即：</p>

<div class="codeblock code-template">
    instance.<em>method</em>(...)
</div>

<p>Python 会自动将一个具体的实例作为第一个参数传给 <code>self</code> 。此时，<code>self.x</code> 实际上就是 <code>instance.x</code> ，替换为实际参数后可以看出形式参数 <code>self</code> 用来代表某个具体的实例，而执行方法时将某个具体的实例对象传给这个形式参数。</p>

<p>例如，以下尝试调用该方法：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">another_point</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>()</div><div><span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">x</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">10</span></div><div><span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">20</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">y</span>)</div><div><span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">move_to_origin</span>()</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">y</span>)</div></div>

<p>结果为：</p>

<div class="codeblock code-console">$ python -u demo.py
10 20 
0 0</div>

<p>可以看出执行了 <code>.move_to_origin()</code> 方法后，该点确实被移到了原点。如果在定义方法时忘记了 <code>self</code> 参数，那么通过实例调用方法时，会产生 <code class="error">TypeError</code> ，错误信息是某方法需要 0 个参数，却传入了 1 个，这就是因为调用方法时需要参数 <code>self</code> 来代表一个具体的实例，才能通过参数去获取、更改它的属性。</p>

<p>实际上也可以在类中调用这个函数，并且将类的一个实例作为实际参数传给方法：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">p</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>()</div><div><span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">move_to_origin</span>(<span style="color: #268bd2;">p</span>)</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">p</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">p</span>.<span style="color: #268bd2;">y</span>)</div></div>

<p>两者是完全一样的。许多面向对象编程的语言都使用关键字 <code>this</code> 表示对实例的一个引用，而 Python 使用这种参数的形式来获取实例，加强了类与实例间的联系。</p>

<p>以下定义了一个更复杂的方法 <code>scale</code> ，用来在坐标轴上按相对位置缩放一个点：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">scale</span>(self, scalar: <span style="color: #cb4b16;">float</span>, relative: <span style="color: #cb4b16;">Point</span><span style="color: #859900;">=</span><span style="color: #b58900;">None</span>):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> relative <span style="color: #859900;">is</span> <span style="color: #b58900;">None</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relative <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relative.<span style="color: #268bd2;">x</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relative.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span> <span style="color: #859900;">=</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span> <span style="color: #859900;">-</span> relative.<span style="color: #268bd2;">x</span>) <span style="color: #859900;">*</span> scalar</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">-</span> relative.<span style="color: #268bd2;">y</span>) <span style="color: #859900;">*</span> scalar</div></div>

<p>通过这个方法，可以看出方法和函数一样，都可以有多个参数，都可以有返回值，甚至可以拥有类型标注。通过实例调用一个方法就类似于直接执行一个函数，只不过第一个位置参数是自动传入的。</p>

<h2>类的初始化</h2>

<p>在上一节中，定义了一个类 <code>Point</code> ，并使用 <code>.x</code> 和 <code>.y</code> 属性来描述它的坐标，<code>.move_to_origin()</code> 和 <code>.scale()</code> 方法来多点执行一些操作。然而，在每次实例化一个类后，都需要给它的 <code>.x</code> 和 <code>.y</code> 属性赋一个具体值，否则会访问不到它们的属性，产生 <code class="error">AttributeError</code> 。</p>

<p>最好能在实例化类时，就能给实例的属性赋予一个具体值，这样即使后续忘记赋值，也不影响程序的执行。然而，为了给实例添加上属性，只能通过 <code>self.</code> 的格式从形式参数中获取类的实例，然而只有在有实例时，该方法才能调用，也就是说还是只能在生成实例后手动为每一个实例添加属性。</p>

<p>事实上，类有一个特殊的方法 <mark><code>.__init__()</code></mark> ，它是一个初始化方法，用来初始化类的属性。类还有很多类似的<strong>特殊方法</strong>(special method, or magic method)，它们都以双下划线开头，双下划线结尾，有时也被称为双下方法(dunder method)。所有的特殊方法在以后会逐一介绍。</p>

<p>在创建自己的方法时，尽量不要以双下划线开头结尾，否则一旦创建了一些特殊的方法，可能会在不必要的时刻被调用，从而招致莫名其妙的错误。</p>

<blockquote>
    <p><code>.__init__()</code> 方法类似别的面向对象编程语言的构造方法，不过 Python 的构造方法另有它用，<code>.__init__()</code> 的实际效果等效于构造方法。</p>
</blockquote>

<p>一旦类拥有了这样一个初始化方法，在实例化该类时，使用类名加上一对圆括号，实际上就是在调用这个方法。假设下面有一个类 <code>Vector</code> ：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Vector</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, direction, magnitude):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">direction</span> <span style="color: #859900;">=</span> direction</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">magnitude</span> <span style="color: #859900;">=</span> magnitude</div></div>

<p>在初始化时，调用 <code>Vector()</code> 实际上就是在调用它的初始化方法。由于 <code>.__init__()</code> 方法有两个参数，因此实例化时，也需要传入两个参数：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">v</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Vector</span>(direction<span style="color: #859900;">=</span><span style="color: #d33682;">90</span>, magnitude<span style="color: #859900;">=</span><span style="color: #d33682;">6</span>)</div></div>

<p>这样，在初始化时，就向实例传入了两个参数，这样确保了只要成功生成了一个实例，它就自动执行一些代码，生成了一些属性，无需后续再手动添加属性，减少了代码量和出错率。</p>

<p>试着调用一下实例的属性：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">v</span>.<span style="color: #268bd2;">direction</span>, <span style="color: #268bd2;">v</span>.<span style="color: #268bd2;">magnitude</span>)</div></div>

<div class="codeblock code-console">$ python -u demo.py
90 6</div>

<p>可以看出在初始化时，它成功地创建了一些属性。</p>

<p>当然，初始化方法也不一定要添加参数，它也可以仅包含 <code>self</code> 参数，但这样就不能在创建时通过传参为每个实例添加不同的属性了。仅包含 <code>self</code> 参数的 <code>.__init__()</code> 构造方法，又称为类的默认构造方法。在有些时候只需要确定的实例属性，当然可以这么做。</p>

<p>本节介绍了面向对象编程的基础和使用 Python 编写面向对象程序的基本语法。面向对象编程是一种非常实用，也应用非常广泛的编程思想，许多编程语言都提供了面向对象编程的语法支持。本节对面向对象编程的思想介绍并不深刻，有兴趣的读者可以自行去 stackoverflow 、知乎等网站搜索，许多人都对其有自己独到的理解。</p>

<h2>参考资料/延伸阅读</h2>

<p><a href="https://docs.python.org/3/tutorial/classes.html">https://docs.python.org/3/tutorial/classes.html</a></p>

<p>Python3 官方文档对 Python 面向对象编程的简介，目前仍是 Python 面向对象编程入门的最好教程。</p>
<p><a rel="nofollow" href="/archives/442">Python面向对象编程01-类的定义与使用</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/442/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
