<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>数据处理归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/feed?simply_static_page=3767" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Fri, 17 Mar 2023 09:55:49 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>数据处理归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Python数据分析-pandas04:索引与缺失值</title>
		<link>/archives/1054</link>
					<comments>/archives/1054#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 17 Mar 2023 09:55:47 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[pandas]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1054</guid>

					<description><![CDATA[<p>上一节介绍了 pandas 中的索引，本节补充关于索&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1054">Python数据分析-pandas04:索引与缺失值</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p><a class="link-internal">上一节</a>介绍了 pandas 中的索引，本节补充关于索引对齐的更多内容。</p>

<p>在 <var type="module">numpy</var> 中对两个数组做运算，如果它们形状既不完全一致，也不满足广播规则，那么会产生错误：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a01 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div>a02 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>linspace<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div><span style="color: #39adb5;font-weight: bold;">try</span><span style="color: #39adb5;">:</span></div><div>&#160; &#160; a01 <span style="color: #7c4dff;">+</span> a02</div><div><span style="color: #39adb5;font-weight: bold;">except</span> <span style="color: #8796b0;">ValueError</span> <span style="color: #39adb5;font-weight: bold;">as</span> e<span style="color: #39adb5;">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span>e<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">operands could not be broadcast together with shapes (4,) (5,) </div>
</div>

<p>但是对两个类似的 <code>Series</code> 对象做运算时，就不会产生这种错误：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">))</span></div><div>s02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>linspace<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">))</span></div><div>s01 <span style="color: #7c4dff;">+</span> s02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    2.0
1    4.0
2    6.0
3    8.0
4    NaN
dtype: float64</div>
</div>

<p>虽然不会产生错误，但是注意到得到的 <code>Series</code> 包含 5 个元素，并且最后一个元素似乎不是数值数据。同时结果的类型由整数变为了浮点数。</p>

<p>这两个现象就包含了本节的内容。接下来逐一介绍。</p>

<h2>索引对齐</h2>

<p>当在两个 <code>Series</code> 或 <code>DataFrame</code> 对象上做计算时，<var type="module">pandas</var> 会按照索引值配对计算元素，而不是按位置配对：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>divide<span style="color: #39adb5;">(</span>pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">ABCD</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)),</span></div><div>&#160; &#160; &#160; &#160; &#160; pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">ACBD</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">A    1.000000
B    0.666667
C    1.500000
D    1.000000
dtype: float64</div>
</div>

<p>这实际上是由于 <var type="module">pandas</var> 会在计算过程中对齐两个对象的索引。索引对齐确保计算可以得到合理的结果，并且当处理不完整的数据时也更方便。</p>

<p>例如，以下根据现有的地区面积和人口数据，计算人口密度：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>territory <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">D0</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">1708</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D1</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">9403</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">3640</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D3</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">3360</span><span style="color: #39adb5;">},</span></div><div>&#160; &#160; <span style="color: #e53935;">name</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">territory</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>population <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">D0</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">14300</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">13900</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D3</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">33280</span><span style="color: #39adb5;">},</span></div><div>&#160; &#160; <span style="color: #e53935;">name</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">population</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>population <span style="color: #7c4dff;">/</span> territory</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">D0    8.372365
D1         NaN
D2    3.818681
D3    9.904762
dtype: float64</div>
</div>

<p>结果数组的索引是两个输入数组索引的并集，并用索引相同的元素做运算。这样一来不需要使两个 <code>Series</code> 都是完整且顺序一致的，也能根据索引完成配对元素的计算。</p>

<p>在计算两个 <code>DataFrame</code> 时，类似的索引对齐规则也同样会出现在列索引中：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;">(</span>pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">6</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">AB</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">))</span> <span style="color: #7c4dff;">+</span> </div><div>&#160;pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">9</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">BAC</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>A</th><th>B</th><th>C</th>
        </tr>
        <tr>
            <td>0</td><td>1</td><td>1</td><td>NaN</td>
        </tr>
        <tr>
            <td>1</td><td>6</td><td>6</td><td>NaN</td>
        </tr>
        <tr>
            <td>2</td><td>11</td><td>11</td><td>NaN</td>
        </tr>
    </table></div>
</div>

<p>因此，索引对齐就是在计算时根据配对的索引完成元素的运算。如果有一个运算对象缺少该索引，该位置的数据会用 <code>NaN</code> 填充。这是 <var type="module">pandas</var> 表示缺失值的方法，接下来会介绍缺失值的处理方法。</p>

<h2>处理缺失值</h2>

<h3>认识缺失值</h3>

<p>在 Python 中，空值一般用 <code>None</code> 对象表示。它是一个特殊的 Python <code>object</code> 对象 ，由 Python 解释器提供并处理。</p>

<p><code>None</code> 作为一个 Python 对象，并不能兼容任何 <var type="module">numpy</var> 的原生类型。如果在创建数组时包含 <code>None</code> ，那么数组的类型会被强制提升为 <code>object</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">None</span><span style="color: #39adb5;">])</span></div><div>a1</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 1, 3, None], dtype=object)</div>
</div>

<p>然而，使用 <code>object</code> 作为数组类型会严重拖慢计算速度，因为它在底层不但占用更多空间，并且无法通过向量化加速运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">10000</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>np<span style="color: #39adb5;">.</span>int32<span style="color: #39adb5;">)</span></div><div>a3 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">10000</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">object</span><span style="color: #39adb5;">)</span></div><div><span style="color: #7c4dff;">%</span>timeit a2 <span style="color: #7c4dff;">/</span> <span style="color: #f76d47;">2</span></div><div><span style="color: #7c4dff;">%</span>timeit a3 <span style="color: #7c4dff;">/</span> <span style="color: #f76d47;">2</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">9.99 µs ± 51.7 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)
199 µs ± 1.35 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)</div>
</div>

<p>可以看到即便对于简单的除法运算，两者都有 20 倍的速度差异。除此之外，数组中一旦包含 <code>None</code> 值，那么它就无法参与各种运算，因为 Python 并没有实现 <code>None</code> 和其它类型的运算方法。</p>

<p>不过好在 <var type="module">numpy</var> 提供了另一种缺失值：<code>NaN</code> 。它全称 Not a Number ，即非数字，是一种按照 IEEE 754 标准设计的特殊<em>浮点数</em>：（有关 <code>NaN</code> 与浮点数的更多底层设计可以参见<a href="https://en.wikipedia.org/wiki/NaN">维基百科</a>）</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 1., nan,  2.,  3.])</div>
</div>

<p><code>NaN</code> 作为一种浮点数，在大多数编程语言中都可以被处理。浮点类型使得含 <code>NaN</code> 的数组可以使用向量化计算，获得很快的运算速度。</p>

<p><code>NaN</code> 的一个特性是：它与任何数字的运算结果都是它本身。也就是说无论 <code>NaN</code> 参与何种运算，最终结果都是 <code>NaN</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>nan <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">nan</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>nan <span style="color: #7c4dff;">/</span> np<span style="color: #39adb5;">.</span>nan <span style="color: #7c4dff;">*</span> <span style="color: #f76d47;">0</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">nan</div>
</div>

<p>这种特性使得在对含有 <code>NaN</code> 的数组做聚合处理时，虽然不会引起异常，但结果不一定有效：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a5 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div><div>a5<span style="color: #39adb5;">.</span>sum<span style="color: #39adb5;">(),</span> a5<span style="color: #39adb5;">.</span>max<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(nan, nan)</div>
</div>

<p>为此，<var type="module">numpy</var> 提供了一些以 <var>nan</var> 开头的特殊累计函数，它们可以忽略数组中的缺失值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>nansum<span style="color: #39adb5;">(</span>a5<span style="color: #39adb5;">),</span> np<span style="color: #39adb5;">.</span>nanmax<span style="color: #39adb5;">(</span>a5<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(6.0, 3.0)</div>
</div>

<h3>处理缺失值</h3>

<p><code>NaN</code> 虽然不像 <code>None</code> 的问题那么明显，但也容易出现奇怪的问题。接下来看看 <var type="module">pandas</var> 中对 <code>NaN</code> 的处理方式。</p>

<p>考虑到空值 <code>None</code> 的副作用太过明显，<var type="module">pandas</var> 会将空值自动转换为 <code>NaN</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">None</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">])</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
1    NaN
2    NaN
3    1.0
dtype: float64</div>
</div>

<p><code>Series</code> 和 <code>DataFrame</code> 均可以使用 <code>.isnull()</code> 和 <code>.notnull()</code> 方法来发现缺失值，它们像通用函数一样返回布尔数组，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">.</span>isnull<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    False
1     True
2     True
3    False
dtype: bool</div>
</div>

<p>这种布尔数组可以配合数组索引直接修改缺失值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">[</span>s03<span style="color: #39adb5;">.</span>isnull<span style="color: #39adb5;">()]</span> <span style="color: #7c4dff;">=</span> <span style="color: #f76d47;">2</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
1    2.0
2    2.0
3    1.0
dtype: float64</div>
</div>

<p><var type="module">pandas</var> 还提供了两种很好用的缺失值处理方式，分别是 <code>.dropna()</code> 和 <code>.fillna()</code> 方法，分别用于剔除缺失值和填充缺失值。在 <code>Series</code> 上使用这些方法比较易懂：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">.</span>dropna<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
3    1.0
dtype: float64</div>
</div>

<p>更复杂的情况涉及对 <code>DataFrame</code> 的缺失值处理，因为 <code>DataFrame</code> 增删的最小单元是一行或一列。默认情况下，<code>DataFrame.dropna()</code> 会剔除任何包含缺失值的整行数据。可以设置按不同的坐标轴剔除缺失值，比如 <code>axis=1</code>（或 <code>axis='columns'</code> ）会剔除任何包含缺失值的整列数据：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">([[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span>np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">]])</span></div><div>df01<span style="color: #39adb5;">.</span>dropna<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th><th>1</th><th>2</th>
        </tr>
        <tr>
            <td>1</td><td>2.0</td><td>3.0</td><td>5</td>
        </tr>
    </table></div>
</div>

<p>这种做法会把非缺失值一并剔除。有时候可能只需要剔除缺失值较多的行或列，这种需求可以通过以下两个参数来满足：</p>

<ul>
    <li><code><em>how</em></code> 参数的默认值是 <code>'any'</code> ，表示只要有缺失值就剔除整行或整列。还可以传入 <code>'all'</code> ，从而剔除全部是缺失值的行或列</li>
    <li><code><em>thresh</em></code> 参数用于设置需要保留的行或列中非缺失值的最小数量</li>
</ul>

<p>剔除缺失值时只关注特定的列也是一种常见的需求，因为有时 <code>DataFrame</code> 只有部分列会参与运算，而其它列无论是否包含缺失值都想保留下了。这时可以通过向 <code><em>subset</em></code> 参数传入包含列名的列表来指定剔除缺失值时只关注表的哪些部分。</p>

<p>除此之外，<code><em>inplace</em></code> 当然也是 <code>.dropna()</code> 方法具有的参数，说明该方法默认情况下也不修改原有表，而是得到一个剔除缺失值后的副本。</p>

<p><code>.fillna()</code> 方法用于填充缺失值。对于 <code>Series</code> 而言，该方法就是一个简单的替换：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">.</span>fillna<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
1    3.0
2    3.0
3    1.0
dtype: float64</div>
</div>

<p>对于 <code>DataFrame</code> 而言，除了用单个值填充所有的缺失位置外，还可以使用字典为不同列指定不同的填充值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span style="color: #39adb5;">.</span>fillna<span style="color: #39adb5;">({</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">20</span><span style="color: #39adb5;">})</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th><th>1</th><th>2</th>
        </tr>
        <tr>
            <td>0</td><td>1.0</td><td>20.0</td><td>2</td>
        </tr>
        <tr>
            <td>1</td><td>2.0</td><td>3.0</td><td>5</td>
        </tr>
        <tr>
            <td>2</td><td>10.0</td><td>4.0</td><td>6</td>
        </tr>
    </table></div>
</div>

<p><code>.fillna()</code> 方法还有以下两个常用参数：</p>

<ul>
    <li><code><em>method</em></code> ：参数指定填充的方法，例如 <code>"pad"</code> 或 <code>"ffill"</code> 用缺失值前或上面的有效值填充；<code>"bfill"</code> 或 <code>"backfill"</code> 用缺失值后或下面的有效值填充。默认用自定义行为填充</li>
    <li><code><em>limit</em></code> ：填充的最大数量</li>
</ul>

<!-- 可以用适当的对象方法代替运算符，并使用参数 <code><em>fill_value</em></code> 填充缺失的数据后再参与运算。 -->

<h3>可空类型</h3>

<p>最后要说明的是，尽管 <var type="module">pandas</var> 为处理 <code>NaN</code> 提供了很多便利的工具，但是尽可能不要向表中引入 <code>NaN</code> 。因为一旦表中出现一个 <code>NaN</code> ，会使得一列的数据类型都变成浮点数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">int32</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>df02<span style="color: #39adb5;">.</span>iloc<span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>nan</div><div>df02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th><th>1</th><th>2</th><th>3</th>
        </tr>
        <tr>
            <td>0</td><td>0</td><td>1.0</td><td>2</td><td>3</td>
        </tr>
        <tr>
            <td>1</td><td>4</td><td>5.0</td><td>6</td><td>7</td>
        </tr>
        <tr>
            <td>2</td><td>8</td><td>NaN</td><td>10</td><td>11</td>
        </tr>
    </table></div>
</div>

<p>浮点数可能使得表在处理时出现问题。例如，如果一个整型或布尔数组出现了一个浮点数，那么它便无法用于索引。</p>

<p>为此，<var type="module">pandas</var> 提供了一类特别的可空类型，向可空类型中引入空值并不会使 <code>Series</code> 变为浮点数。目前 <var type="module">pandas</var> 具有的可空类型包括各种长度的 <code>Int</code> 和 <code>Float</code> 类型（注意首字母大写）、<code>string</code> 类型和 <code>boolean</code> 类型。</p>

<p>如果在创建 <code>Series</code> 时使用 <code><em>dtype</em></code> 参数指定类型为以上这些可空类型，那么其中的缺失值便会使用特别的缺失值指示器 <code>pd.NA</code> 代替：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s04 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">None</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> pd<span style="color: #39adb5;">.</span>NA<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">],</span> </div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">Int32</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>s04</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0       0
1    &lt;NA&gt;
2    &lt;NA&gt;
3    &lt;NA&gt;
4       1
dtype: Int32</div>
</div>

<p><code>pd.NA</code> 不代表任何实际的值，因此可以用在任何数组中而不会改变其原有类型。例如，如果创建一个类型为 <code>boolean</code> 的可空布尔数组，那么它便可用于索引，并且其中的 <code>pd.NA</code> 会被当做 <code>False</code> 用于索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">s05 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> pd</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">Series</span><span style="color: #39adb5;">([</span><span style="color: #f76d47;">True</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">None</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">nan</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">False</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">boolean</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">[</span>s05<span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    1
dtype: int32</div>
</div>

<p>但截至 pandas 1.5 ，该功能似乎仍然处于实验阶段。</p>
<p><a rel="nofollow" href="/archives/1054">Python数据分析-pandas04:索引与缺失值</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1054/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-pandas03:深入认识索引</title>
		<link>/archives/1048</link>
					<comments>/archives/1048#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 06 Mar 2023 09:35:45 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[pandas]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1048</guid>

					<description><![CDATA[<p>Pandas索引机制 pandas 相比 numpy&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1048">Python数据分析-pandas03:深入认识索引</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>Pandas索引机制</h2>

<p><var type="module">pandas</var> 相比 <var type="module">numpy</var> ，一个很重要的特点就在于它引入了显式的索引机制。显式的索引在方便数据获取的同时，也可能造成学习上的困惑。接下来首先详细介绍 <var type="module">pandas</var> 的索引机制。</p>

<h3>Series与索引</h3>

<p>之前说过，<code>Series</code> 对象可以看作一种字典，它提供了索引与值对的映射，因此可以使用字典一样的方式获取值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">4</span><span token="symbol">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">c</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">])</span></div><div>s01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1</div>
</div>

<p><code>Series</code> 的许多操作都和 Python 字典很像，例如可以通过 item assignment 增加新的索引-值对，这等价于向 <code>Series</code> 添加新的一项：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">e</span><span token="symbol">'</span><span token="symbol">]</span> <span style="color: #7c4dff;">=</span> <span token="number">10</span></div></div>
</div>

<p>这种自定义的索引是显式的，它是真实存在的，因此可以向字典一样获取所有的索引-值对：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #8796b0;">list</span><span token="symbol">(</span>s01<span token="symbol">.</span>items<span token="symbol">())</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 10)]</div>
</div>

<p><code>Series</code> 不仅有着和字典一样的索引操作，还具备和 <var type="module">numpy</var> 数组一样的数组数据选择功能，例如数组索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
d    3
dtype: int32</div>
</div>

<p>这么看来，<code>Series</code> 的索引除了允许自定义外，和 <code>ndarray</code> 的索引好像没什么区别。不过注意，<code>Series</code> 的索引是允许重复的，这可能会导致一次性获取到多个值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s02 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">5</span><span token="symbol">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">])</span></div><div>s02<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
b    2
b    4
dtype: int32</div>
</div>

<p>此外，这种索引在用作切片时，得到的结果将包含后端的值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">:</span><span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
c    2
d    3
dtype: int32</div>
</div>

<p>这样做的好处是不用明白它后一项的索引是什么。但如果索引有重复的话，将不能用于切片操作：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s02<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">:</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">Exception</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span><span style="color: #8796b0;">type</span><span token="symbol">(</span>e<span token="symbol">),</span> e<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'KeyError'> "Cannot get right slice bound for non-unique label: 'b'"</div>
</div>

<p>这种索引机制可能会导致数据获取的不便。但实际上，<code>Series</code> 依然保留了 <var type="module">numpy</var> 数组从零开始、切片时前闭后开的隐式索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="number">1</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="number">1</span><span token="symbol">:</span><span token="number">3</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
c    2
dtype: int32</div>
</div>

<p>这两种索引方式很容易造成混淆，尤其是使用自定义整数作索引时，它可能会覆盖隐式索引，使得某些操作失效：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">4</span><span token="symbol">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">1</span><span token="symbol">,</span> <span token="number">5</span><span token="symbol">))</span></div><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s03<span token="symbol">[</span>s03<span token="symbol">.</span>argmin<span token="symbol">()]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">Exception</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span><span style="color: #8796b0;">type</span><span token="symbol">(</span>e<span token="symbol">),</span> e<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'KeyError'> 0</div>
</div>

<p>因此 <var type="module">pandas</var> 提供了一些<strong>索引器</strong>作为取值的方法，它们是 <code>Series</code> 对象暴露取值与切片接口的属性。</p>

<p>第一种索引器是 <code>.loc</code> 属性，表示用的是自定义、可重复、类型不限、切片时包含两端的显式索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">.</span>loc<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">:</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">a    0
b    1
dtype: int32</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s01<span token="symbol">.</span>loc<span token="symbol">[</span><span token="number">1</span><span token="symbol">]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">KeyError</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span>e<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1</div>
</div>

<p>第二种索引器是 <code>.iloc</code> 属性，表示用的是从 0 开始、切片前闭后开的整数隐式(<span style="font-weight: bold;">i</span>mplicit)索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>iloc<span token="symbol">[</span>s03<span token="symbol">.</span>argmin<span token="symbol">()]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0</div>
</div>

<p>这两种索引器独立工作，不能混用，因此可以各自用于需要的场景中。</p>

<h3>DataFrame与索引</h3>

<p>之前说过 <code>DataFrame</code> 也可以看作一种字典，它提供了列索引与 <code>Series</code> 对的映射，因此可以使用字典一样的方式由列索引获取一个 <code>Series</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>DataFrame<span token="symbol">(</span></div><div>&#160; &#160; <span token="symbol">{</span><span token="symbol">'</span><span style="color: #91b859;">units</span><span token="symbol">'</span><span token="symbol">:</span> <span token="symbol">{</span><span token="symbol">'</span><span style="color: #91b859;">pencil</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">95</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">binder</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">30</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">paperclip</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">81</span><span token="symbol">},</span></div><div>&#160; &#160; &#160;<span token="symbol">'</span><span style="color: #91b859;">unitcost</span><span token="symbol">'</span><span token="symbol">:</span> <span token="symbol">{</span><span token="symbol">'</span><span style="color: #91b859;">pencil</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">1.99</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">binder</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">19.99</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">paperclip</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">4.99</span><span token="symbol">}})</span></div><div>df01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td>
        </tr>
        <tr>
            <td>binder</td><td>30</td><td>19.99</td>
        </tr>
        <tr>
            <td>paperclip</td><td>81</td><td>4.99</td>
        </tr>
    </table></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">unitcost</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">pencil        1.99
binder       19.99
paperclip     4.99
Name: unitcost, dtype: float64</div>
</div>

<p>和前面介绍的 <code>Series</code> 对象一样，也可以用 item assignment 增加一列：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">total</span><span token="symbol">'</span><span token="symbol">]</span> <span style="color: #7c4dff;">=</span> df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">units</span><span token="symbol">'</span><span token="symbol">]</span> <span style="color: #7c4dff;">*</span> df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">unitcost</span><span token="symbol">'</span><span token="symbol">]</span></div><div>df01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th><th>total</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td><td>189.05</td>
        </tr>
        <tr>
            <td>binder</td><td>30</td><td>19.99</td><td>599.70</td>
        </tr>
        <tr>
            <td>paperclip</td><td>81</td><td>4.99</td><td>404.19</td>
        </tr>
    </table></div>
</div>

<p>因此对列索引而言，它和 <code>Series</code> 的索引机制比较像。但是由于 <code>DataFrame</code> 行列都有索引，因此单级的显式索引只能作用于列，否则操作很容易引起歧义。</p>

<p>除此之外，直接对行或列应用隐式索引会引起错误。从概念上来说，对行和列的隐式索引容易存在误解：如果将 <code>DataFrame</code> 看作结构数组，那么一列就代表一个结构成员，列与列之间并没有严格的先后关系，直接取第几列这种操作无法让人明白其意图。而行虽然没有这种误解，但是会产生一个更关键的问题：直接取某一行使得行索引不再被用到而丢弃，返回一个 <code>Series</code> ，但是 <code>Series</code> 要求所有元素的类型一致，而一个结构各成员间往往有着各自各样的类型，强行统一它们的类型会造成类型提升，为后续操作带来更多问题。</p>

<p>一种特殊的情况是切片。切片将会保留行索引，得到的仍然是一个 <code>DataFrame</code> 。如果切片涉及的范围只有一行，那么就基本等价于获取 <code>DataFrame</code> 的某一行（虽然得到的仍然是一个二维数组）：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">[</span><span token="number">0</span><span token="symbol">:</span><span token="number">1</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th><th>total</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td><td>189.05</td>
        </tr>
    </table></div>
</div>

<p>因此，除了对列应用显式索引外，其它形式的索引不仅应该使用索引器，而且应该使用 <var type="module">numpy</var> 高维数组的索引方式。</p>

<p>例如，以下使用隐式索引器获取 <code>DataFrame</code> 的元素。这里在代表取值的方括号内传入了一个元组，第一个元素指代行的隐式索引，第二个元素指代列的隐式索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">.</span>iloc<span token="symbol">[</span><span token="number">2</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">4.99</div>
</div>

<p>根据隐式索引的规则，获取的应该是第 3 行第 2 列位置的元素。</p>

<p>再如，以下使用显式索引器得到指定几行的元素。这里对行应用数组索引，对列使用单个冒号 <code>:</code> 表示全部切片：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">.</span>loc<span token="symbol">[[</span><span token="symbol">'</span><span style="color: #91b859;">pencil</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">paperclip</span><span token="symbol">'</span><span token="symbol">],</span> <span token="symbol">:]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th><th>total</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td><td>189.05</td>
        </tr>
        <tr>
            <td>paperclip</td><td>81</td><td>4.99</td><td>404.19</td>
        </tr>
    </table></div>
</div>

<p>最后，下图总结了 <code>DataFrame</code> 的索引：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/03/09-dataframe-indexes.png" alt="" width="520">
</figure>

<h2>层级索引</h2>

<h3>层级索引的概念</h3>

通过之前的介绍可以认识到，<code>DataFrame</code> 是一种二维的结构。但有些时候，处理的数据可能不止两个维度。例如，在操作 Excel 时，经常可以看到这样的表格：

<table>
    <tr>
        <th></th><th></th>
        <th colspan="2">2021</th><th colspan="2">2022</th>
    </tr>
    <tr>
        <th></th><th></th>
        <th>mid term</th><th>end of term</th>
        <th>mid term</th><th>end of term</th>
    </tr>
    <tr>
        <td rowspan="3">grade 1</td>
        <td>class 1</td>
        <td>86</td><td>88</td>
        <td>89</td><td>90</td>
    </tr>
    <tr>
        <td>class 2</td>
        <td>88</td><td>87</td>
        <td>91</td><td>89</td>
    </tr>
    <tr>
        <td>class 3</td>
        <td>84</td><td>86</td>
        <td>86</td><td>85</td>
    </tr>
    <tr>
        <td rowspan="3">grade 2</td>
        <td>class 1</td>
        <td>86</td><td>94</td>
        <td>90</td><td>91</td>
    </tr>
    <tr>
        <td>class 2</td>
        <td>85</td><td>84</td>
        <td>87</td><td>91</td>
    </tr>
    <tr>
        <td>class 3</td>
        <td>87</td><td>91</td>
        <td>90</td><td>90</td>
    </tr>
</table>

<p>这种数据可以从四个维度聚合：对列来说，可以得出每个年度的得分平均值，也可以得出历年期中和期末的得分平均值；对行也是同理。只凭借二维数据无法实现这样的关系，这时就需要使用层级索引。层级索引可以从多个角度来描述数据的分组。</p>

<p><var type="module">pandas</var> 中的索引类型不仅限于数值和字符串，甚至还能使用元组，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01 <span style="color: #7c4dff;">=</span> <span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">3</span><span token="symbol">),</span></div><div>&#160; &#160; &#160; &#160;<span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">3</span><span token="symbol">)]</span></div><div>s03 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">([</span><span token="number">1341</span><span token="symbol">,</span> <span token="number">1412</span><span token="symbol">,</span> <span token="number">1263</span><span token="symbol">,</span> <span token="number">643</span><span token="symbol">,</span> <span token="number">632</span><span token="symbol">,</span> <span token="number">685</span><span token="symbol">],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>i01<span token="symbol">)</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(A, 1)    1341
(A, 2)    1412
(A, 3)    1263
(B, 1)     643
(B, 2)     632
(B, 3)     685
dtype: int64</div>
</div>

<p>元组表示存储了多个值，是多级索引的基础。<var type="module">pandas</var> 的 <code>MultiIndex</code> 类提供了更丰富的操作方法。可以用它的类方法从元组创建一个多级索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i02 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_tuples<span token="symbol">(</span>i01<span token="symbol">,</span> <span style="color: #e53935;">names</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">class</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">group</span><span token="symbol">'</span><span token="symbol">])</span></div></div>
</div>

<p>通过 <code><em>names</em></code> 参数可以为这两个层级指定名称，方面区分各索引层。层级名称会保存到索引对象的 <code>.names</code> 属性中。</p>

<p>如果将前面创建的 <code>Series</code> 对象使用 <code>.reindex()</code> 方法将它的索引重置为 <code>MultiIndex</code> 对象，就会看到一个层级索引结构：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> s03<span token="symbol">.</span>reindex<span token="symbol">(</span><span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>i02<span token="symbol">)</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">class  group
A      1        1341
       2        1412
       3        1263
B      1         643
       2         632
       3         685
dtype: int64</div>
</div>

<p>关于层级索引，需要记住的是：层级索引可以看作一个元素对应多个索引，或者说一个索引元组。如果检查层级索引的 <code>.values</code> 属性，会发现每个索引都使用多个值来描述：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>index<span token="symbol">.</span>values</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([('A', 1), ('A', 2), ('A', 3), ('B', 1), ('B', 2), ('B', 3)],
      dtype=object)</div>
</div>

<p>因此在获取元素的时候，也需要通过多个值，或者说一个元组来获取：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1412</div>
</div>

<p>多个值或一个元组构成的索引也可以用于切片。除了索引由一个值变成一个元组外，均遵循一维 <code>Series</code> 的切片规则，例如可以使用显式索引器 <code>.loc</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">):(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">class  group
A      2        1412
       3        1263
B      1         643
dtype: int64</div>
</div>

<p>显式索引器使切片包含两端的元素。返回检查层级索引的 <code>.values</code> 属性可以发现，包含两端的元素确实是 3 个。</p>

<p>这里需要注意，如果层级索引不是有序的，那么大多数切片操作都会失败。以下演示一种会导致错误的操作：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>rand <span style="color: #7c4dff;">=</span> np<span token="symbol">.</span>random<span token="symbol">.</span>RandomState<span token="symbol">(</span><span token="number">3</span><span token="symbol">)</span></div><div>s04 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>rand<span token="symbol">.</span>rand<span token="symbol">(</span><span token="number">6</span><span token="symbol">),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_product<span token="symbol">([[</span><span token="symbol">'</span><span style="color: #91b859;">C</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="symbol">[</span><span token="number">1</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">]]))</span></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s04<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">C</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">):(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">)]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">Exception</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span><span style="color: #8796b0;">type</span><span token="symbol">(</span>e<span token="symbol">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'pandas.errors.UnsortedIndexError'></div>
</div>

<p>问题出在切片和许多其它相似的操作都要求 <code>MultiIndex</code> 的各级索引是有序的。为此，<var type="module">pandas</var> 提供了一些操作可以实现对索引的排序，最简单的方法是 <code>.sort_index()</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s04<span token="symbol">.</span>sort_index<span token="symbol">(</span><span style="color: #e53935;">inplace</span><span style="color: #7c4dff;">=</span><span token="number">True</span><span token="symbol">)</span></div><div>s04<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">):(</span><span token="symbol">'</span><span style="color: #91b859;">C</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">B  2    0.510828
C  1    0.550798
   2    0.708148
dtype: float64</div>
</div>

<p>经过索引排序后的切片结果就正常了。这里再次使用 <code><em>inplace</em></code> 参数来提醒默认情况下排序后得到的是一个新的对象，而不是在原有对象的基础上做修改。</p>

<p>层级索引相比普通的索引，索引类型由一个值变为多个值（或者说一个元组）。这看似多此一举，但是它允许从不同层面来处理一维的数据。如果访问层级索引的 <code>.level</code> 属性，可以得到：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>index<span token="symbol">.</span>levels</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">FrozenList([['A', 'B'], [1, 2, 3]])</div>
</div>

<p>这说明该层级索引有两层：从索引的角度看，第一层有 2 种不同的索引，第二层有 3 种不同的索引；从数据的角度看，根据第一层索引可以将数据分为 2 类，根据第二层可以将数据分为 3 类。因此数据在聚合、变换时，可以根据不同的索引层级，从不同的<em>角度</em>处理。例如，对于以上具有层级索引的 <code>Series</code> ，可以统计每个 <code>"class"</code> 的数值平均值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>sum<span token="symbol">(</span><span style="color: #e53935;">level</span><span style="color: #7c4dff;">=</span><span token="symbol">'</span><span style="color: #91b859;">class</span><span token="symbol">'</span><span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">class
A    4016
B    1960
dtype: int64</div>
</div>

<p>新版本的 <var type="module">pandas</var> 可能已经弃用了这种使用方式，或者抛出 <code>FutureWarning</code> ，提示说应该使用对表作分组计算后再合并，这就是以后介绍的内容了。</p>

<p>具有层级索引的 <code>Series</code> 很像一个 <code>DataFrame</code> 。事实上，使用对象的 <code>.unstack()</code> 方法可以将一个多级索引的 <code>Series</code> 转化为普通索引的 <code>DataFrame</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>unstack<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>group</th><th>1</th><th>2</th><th>3</th>
        </tr>
        <tr>
            <td>class</td><td></td><td></td><td></td>
        </tr>
        <tr>
            <td>A</td><td>1341</td><td>1412</td><td>1263</td>
        </tr>
        <tr>
            <td>B</td><td>643</td><td>632</td><td>685</td>
        </tr>
    </table></div>
</div>

<p>或者使用 <code>.stack()</code> 方法实现相反的效果，将一个 <code>DataFrame</code> 变成具有多级索引的 <code>Series</code> 。 既然可以用含多级索引的一维 <code>Series</code> 数据表示二维数据，那么就可以用 <code>Series</code> 或 <code>DataFrame</code> 表示三维甚至更高维度的数据。借助多级索引，可以使三维及以上的数据以一种较为易读的形式表示出来。层级索引每增加一层，就表示数据增加一维，使得 <code>DataFrame</code> 可以表示任意维度的数据。因此 <var type="module">pandas</var> 并没有提供三维及以上的数量类型。</p>

<h3>DataFrame与层级索引</h3>

<p>在 <code>DataFrame</code> 使用层级索引和在 <code>Series</code> 上使用层级索引是一致的，只不过列索引和行索引都可以设置为层级索引。</p>

<p>以下创建一个较为复杂的、行列都具有两级索引的 <code>DataFrame</code> 用于演示：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>DataFrame<span token="symbol">(</span>rand<span token="symbol">.</span>randint<span token="symbol">(</span><span token="number">50</span><span token="symbol">,</span> <span token="number">95</span><span token="symbol">,</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span token="symbol">(</span><span token="number">4</span><span token="symbol">,</span> <span token="number">6</span><span token="symbol">)),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_product<span token="symbol">([[</span><span token="number">2020</span><span token="symbol">,</span> <span token="number">2021</span><span token="symbol">],</span> <span token="symbol">[</span><span token="number">1</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">]],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span style="color: #e53935;">names</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">year</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">term</span><span token="symbol">'</span><span token="symbol">]),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span>pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_product<span token="symbol">([[</span><span token="symbol">'</span><span style="color: #91b859;">Tim</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">Mary</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">John</span><span token="symbol">'</span><span token="symbol">],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">physics</span><span token="symbol">'</span><span token="symbol">]],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span style="color: #e53935;">names</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">name</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">subject</span><span token="symbol">'</span><span token="symbol">])</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="symbol">)</span></div><div>df03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>name</th><th colspan="2">Tim</th><th colspan="2">Mary</th><th colspan="2">John</th>
        </tr>
        <tr>
            <th></th><th>subject</th><th>math</th><th>physics</th><th>math</th><th>physics</th><th>math</th><th>physics</th>
        </tr>
        <tr>
            <th>year</th><th>term</th><td></td><td></td><td></td><td></td><td></td><td></td>
        </tr>
        <tr>
            <td rowspan="2">2020</td><td>1</td><td>92</td><td>74</td><td>53</td><td>58</td><td>50</td><td>71</td>
        </tr>
        <tr>
            <td>2</td><td>69</td><td>60</td><td>93</td><td>91</td><td>60</td><td>71</td>
        </tr>
        <tr>
            <td rowspan="2">2021</td><td>1</td><td>88</td><td>82</td><td>70</td><td>94</td><td>79</td><td>89</td>
        </tr>
        <tr>
            <td>2</td><td>64</td><td>76</td><td>67</td><td>76</td><td>72</td><td>52</td>
        </tr>
    </table></div>
</div>

<p>对 <code>DataFrame</code> 索引和 <code>Series</code> 基本一致，需要通过元组形式的索引来获取一个 <code>Series</code> ，并会保留行的层级索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">John</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">year  term
2020  1       50
      2       60
2021  1       79
      2       72
Name: (John, math), dtype: int32</div>
</div>

<p>索引器和切片的用法都是一致的：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="number">2020</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">):(</span><span token="number">2020</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">),</span> <span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">John</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">Mary</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">)]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>name</th><th>John</th><th>Mary</th>
        </tr>
        <tr>
            <th>subject</th><th>math</th><th>math</th>
        </tr>
        <tr>
            <th>year</th><th>term</th><th></th><td></td>
        </tr>
        <tr>
            <td>2020</td><td>1</td><td>50</td><td>53</td><td></td>
        </tr>
        <tr>
            <td></td><td>2</td><td>60</td><td>93</td>
        </tr>
    </table></div>
</div>

<p>不过这种索引元组的用法不是很方便，因为这个 <code>DataFrame</code> 实际上可以看作四维数据，但是只能在两个维度上切片。如果想获取所有人在第 1 学期的数学成绩，那么可能需要这样的索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03<span token="symbol">.</span>loc<span token="symbol">[(:,</span> <span token="number">1</span><span token="symbol">),</span> <span token="symbol">(:,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">  Cell In [35], line 1
        df03.loc[(:, 1), (:, 'math')]
                  ^
<span style="color: red;">SyntaxError</span>: invalid syntax</div>
</div>

<p>这是错误的用法，它会直接导致解释出错。为此，<var type="module">pandas</var> 提供了 <code>IndexSlice</code> 对象，专门用来解决高维 <code>DataFrame</code> 的切片问题，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>Idx <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>IndexSlice</div><div>df03<span token="symbol">.</span>loc<span token="symbol">[</span>Idx<span token="symbol">[:,</span> <span token="number">1</span><span token="symbol">],</span> Idx<span token="symbol">[:,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>name</th><th>Tim</th><th>Mary</th><th>John</th>
        </tr>
        <tr>
            <th></th><th>subject</th><th>math</th><th>math</th><th>math</th>
        </tr>
        <tr>
            <td>year</td><td>term</td><td></td><td></td><td></td>
        </tr>
        <tr>
            <td>2020</td><td>1</td><td>92</td><td>53</td><td>50</td>
        </tr>
        <tr>
            <td>2021</td><td>1</td><td>88</td><td>70</td><td>79</td>
        </tr>
    </table></div>
</div>

<p>下图总结了 <code>DataFrame</code> 的层级索引：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/03/09-dataframe-multi-indexes.png" alt="" width="720">
</figure>
<p><a rel="nofollow" href="/archives/1048">Python数据分析-pandas03:深入认识索引</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1048/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-pandas01:基本数据类型</title>
		<link>/archives/1041</link>
					<comments>/archives/1041#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 27 Feb 2023 07:03:43 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[pandas]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1041</guid>

					<description><![CDATA[<p>Pandas简介 之前详细介绍了 NumPy 和它的&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1041">Python数据分析-pandas01:基本数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>Pandas简介</h2>

<p><a href="/all/data-science">之前</a>详细介绍了 <var type="module">NumPy</var> 和它的 <code>ndarray</code> 多维数组对象，为 Python 多维数组提供了高效的存储和处理方法。</p>

<p>本章基于前面的知识，继续学习 <a href="https://pandas.pydata.org/">Pandas</a> 库提供的数据操作方法。<code>Pandas</code> 是在 <code>NumPy</code> 基础上建立的另一个第三方库，提供了一种高效的 <code>DataFrame</code> 数据结构。<code>DataFrame</code> 本质上是一种带行标签和列标签、支持相同类型数据和缺失值的多维数组。<code>Pandas</code> 不仅为带各种标签的数据提供了便利的存储与展示接口，还实现了许多强大的计算、查找和分类等操作。</p>

<p><var type="module">pandas</var> 在底层存储时使用的是 <var type="module">numpy</var> 的数组，因此在安装 <var type="module">pandas</var> 之前，需要确保已经安装了 <var type="module">numpy</var> 。</p>

<p>在安装完成 <code>pandas</code> 之后，可以导入它检查一下版本号：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">import</span> pandas</div><div>pandas.__version__</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">'1.3.1'</div>
</div>

<p>和之前导入 <var type="module">numpy</var> 并使用别名 <code>np</code> 一样，之后将导入 <var type="module">pandas</var> 并使用别名 <code>pd</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">import</span> pandas <span style="color: #f76d47;">as</span> pd</div></div>
</div>

<h2>Pandas的数据对象</h2>

<h3>Series对象</h3>

<p><var type="module">pandas</var> 最简单的数据类型是 <code>Series</code> 。<code>Series</code> 对象是一个带索引数据构成的一维数组。可以用一个数组创建 <code>Series</code> 对象，如下所示：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">])</span></div><div>s01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    1
1    2
2    3
3    4
dtype: int64</div>
</div>

<p><code>Series</code> 对象将一组数据和一组索引绑定在一起，可以通过 <code>.values</code> 属性获取数据，通过 <code>.index</code> 属性获取索引。<code>.values</code> 属性返回的结果就是底层的 <var type="module">numpy</var> 数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">.</span>values</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([1, 2, 3, 4], dtype=int64)</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #6182b8;">isinstance</span><span style="color: #39adb5;">(</span>s01<span style="color: #39adb5;">.</span>values<span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>ndarray<span style="color: #39adb5;">)</span></div></div>    
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">True</div>
</div>

<p><code>.index</code> 属性返回的结果是一个类型为 <code>Index</code> 的索引对象。索引是 <var type="module">pandas</var> 的特点之一，将在后面的内容里详细介绍它。</p>

<p>和 <var type="module">numpy</var> 数组一样，可以通过中括号实现索引或切片：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">3</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1    2
2    3
3    4
dtype: int64</div>
</div>

<p>这么看来，<var type="module">pandas</var> 的 <code>Series</code> 与 <var type="module">numpy</var> 的一维数组很类似。但 <code>Series</code> 为数组提供了一种更加强大的索引系统：<var type="module">numpy</var> 数组通过隐式定义的整数索引获取数值，而 <var type="module">pandas</var> 的 <code>Series</code> 对象用可以手动指定索引与数值关联。</p>

<p>显式索引的定义让 <code>Series</code> 拥有了更好的可读性。例如，索引不再仅仅是整数，还可以是任意想要的类型。如果需要，完全可以用字符串定义索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0.25</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">0.5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">0.75</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1.0</span><span style="color: #39adb5;">],</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">b</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">c</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">d</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">])</span></div><div>s02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">a    0.25
b    0.50
c    0.75
d    1.00
dtype: float64</div>
</div>

<p>在使用索引访问元素时，可以通过之前定义的字符索引获取数值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">b</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.5</div>
</div>

<p>这种数值的访问形式很像 Python 字典，可以将每个索引作为键映射到一个值。因此可以直接使用 Python 的字典创建一个 <code>Series</code> 对象，让两者的类比更加清晰：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">({</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">key1</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">key2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">keyi</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">keyn</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">10</span></div><div><span style="color: #39adb5;">})</span></div></div>
</div>

<p>由于 Python3.6+ 的字典是有序的，因此创建的 <code>Series</code> 对象索引也默认按照顺序排列。</p>

<p>除了可以使用像字典一样按键获取数值外，<code>Series</code> 的索引还可以用于切片操作：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">key2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">keyn</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">key2     2
keyi     5
keyn    10
dtype: int64</div>
</div>

<p>这种切片是包括终点位置的元素的，这和普通的索引形式不同。后续会详细介绍这种索引规则。</p>

<h3>DataFrame对象</h3>

<p><var type="module">pandas</var> 的另一个基础数据结构是 <code>DataFrame</code> 。<code>DataFrame</code> 可以看作是一种二维数组，但它既有行索引，又有列索引，因此它经常被当做一个表格使用。注意，<code>DataFrame</code> 是 <var type="module">pandas</var> 的非常重要的一个数据类型，因为它可以很好地表达日常生活中处理的各种表格结构。<code>DataFrame</code> 与 Excel 中表格或 SQL 中表的概念非常相似，可以实现大多数 Excel 或 SQL 的表操作。</p>

<p><code>DataFrame</code> 有许多创建方式，每种创建方式都代表着对它的理解。例如，和 <code>Series</code> 对象一样，<code>DataFrame</code> 可以看作一个更灵活的 <var type="module">numpy</var> 二维数组。因此可以直接使用二维数据创建 <code>DataFrame</code> ，只要手动指定符合形状的行列索引即可：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">)),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">A</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">B</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">C</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">])</span></div><div>df01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>A</th><th>B</th><th>C</th><th>D</th>
        </tr>
        <tr>
            <td>1</td><td>0</td><td>1</td><td>2</td><td>3</td>
        </tr>
        <tr>
            <td>2</td><td>4</td><td>5</td><td>6</td><td>7</td>
        </tr>
        <tr>
            <td>3</td><td>8</td><td>9</td><td>10</td><td>11</td>
        </tr>
    </table></div>
</div>

<p>也可以把 <code>DataFrame</code> 看成是一种结构数组，每行表示一个结构元素，行索引表示每个结构元素的索引，列索引则表示的是结构的字段名。因此，当然可以使用 <var type="module">numpy</var> 的结构数组来创建 <code>DataFrame</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">A</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">i8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">),</span> <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">B</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">f8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)]))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>A</th><th>B</th>
        </tr>
        <tr>
            <td>0</td><td>0</td><td>0.0</td>
        </tr>
        <tr>
            <td>1</td><td>0</td><td>0.0</td>
        </tr>
        <tr>
            <td>2</td><td>0</td><td>0.0</td>
        </tr>
    </table></div>
</div>

<p>结构数组的表述便于理解，但实际上可能会带来一些误解。例如，<code>DataFrame</code> 的索引和 <var type="module">numpy</var> 的二维数组索引不太一样：在 <var type="module">numpy</var> 的二维数组里，<code>arr[0]</code> 被认为是一个嵌套数组返回包含的第一个子数组；而在 <var type="module">pandas</var> 中，第一层索引得到的结果是一个列的数据：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">A</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1    0
2    4
3    8
Name: A, dtype: int32</div>
</div>

<p>对 <code>DataFrame</code> 一种更好的理解方式是看作一个数组字典，每一个索引都可以看作是字典的一个键，对应一个列的数据；这些数据是一系列同种类型的数值，或者说一个 <code>Series</code> 。也就是说，<code>DataFrame</code> 是具有共同索引的若干 <code>Series</code> 对象组合。</p>

<p>因此，使用单个 <code>Series</code> 创建的是一个单列的 <code>DataFrame</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">bread</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">279</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">biscuit</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">78</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">strawberry</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">26</span><span style="color: #39adb5;">}))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th>
        </tr>
        <tr>
            <td>bread</td><td>279</td>
        </tr>
        <tr>
            <td>biscuit</td><td>78</td>
        </tr>
        <tr>
            <td>strawberry</td><td>26</td>
        </tr>
    </table></div>
</div>

<p>如果能接受这种 <code>DataFrame</code> 的理解方式，不仅容易记住它的创建方式，也有助于明白对它的操作会得到什么样的结果。</p>

<p>创建 <code>DataFrame</code> 的方式非常丰富，只要能表达出这种二维的 <span class="code-font">{column: series}</span> 的映射关系基本都可以用于创建它。例如，可以使用一组具有<em>相同索引</em>的 <code>Series</code> 对象创建它；由于 <code>Series</code> 可以被看作特殊的字典，因此也可以使用一个二维字典来创建一个 <code>DataFrame</code> 对象：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>price <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">cake</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">23</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">cookie</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">bread</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">}</span></div><div>sales <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">cake</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">cookie</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">14</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">bread</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">23</span><span style="color: #39adb5;">}</span></div><div>df02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">({</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">price</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> price<span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">sales</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> sales<span style="color: #39adb5;">})</span></div><div>df02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>price</th><th>sales</th>
        </tr>
        <tr>
            <td>cake</td><td>23</td><td>5</td>
        </tr>
        <tr>
            <td>cookie</td><td>6</td><td>14</td>
        </tr>
        <tr>
            <td>bread</td><td>10</td><td>23</td>
        </tr>
    </table></div>
</div>

<p>如果明白“<code>DataFrame</code> 是一组具有<em>相同索引</em>的 <code>Series</code> 对象组合”，就会知道字典的嵌套与被嵌套的关系：内层的字典应该要具有相同的键。</p>

<p>如果能理解这种嵌套关系，那么就可以很自然地明白数据获取方式：第一次索引将以列索引值为键，得到一个列作为字典；第二次索引将以行索引值为键，从得到字典中获取相应的元素：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">price</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">cookie</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">6</div>
</div>

<p>和 Python 字典一样，<code>Series</code> 和 <code>DataFrame</code> 还支持 item assignment ，对 <code>Series</code> 的操作结果是更新项或添加项，对 <code>DataFrame</code> 的操作结果是更新列或添加列：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">sum</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">price</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">*</span> df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">sales</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div><div>df02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>price</th><th>sales</th><th>sum</th>
        </tr>
        <tr>
            <td>cake</td><td>23</td><td>5</td><td>115</td>
        </tr>
        <tr>
            <td>cookie</td><td>6</td><td>14</td><td>84</td>
        </tr>
        <tr>
            <td>bread</td><td>10</td><td>23</td><td>230</td>
        </tr>
    </table></div>
</div>

<h3>Index对象</h3>

<p><var type="module">pandas</var> 的 <code>Index</code> 对象是构成 <code>Series</code> 和 <code>DataFrame</code> 显式索引的基础。</p>

<p><code>Series</code> 是一维的数据，因此需要一个 <code>Index</code> 对象用于获取数据，这个对象被保存在它的 <code>.index</code> 属性中。而二维的 <code>DataFrame</code> 需要两个 <code>Index</code> 对象来定位数据，它们分别是代表行的 <code>.index</code> 属性和代表列的 <code>.columns</code> 属性：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">.</span>index</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Index(['cake', 'cookie', 'bread'], dtype='object')</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">.</span>columns</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Index(['price', 'sales'], dtype='object')</div>
</div>

<p><code>Index</code> 对象可以看作是一个不可变数组，因此可以像创建数组一样创建 <code>Index</code> 对象：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Index<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">])</span></div><div>i01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 3, 5, 6, 7], dtype='int64')</div>
</div>

<p>除了没有那么丰富的创建方法外，<code>Index</code> 对象的许多属性与操作都像数组，例如索引与切片：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01<span style="color: #39adb5;">[[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">]]</span> &#160;<span style="color: #a8a8a8;"># array indexing</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 3, 5], dtype='int64')</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01<span style="color: #39adb5;">[:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 5], dtype='int64')</div>
</div>

<p>两者之间的不同在于 <code>Index</code> 对象是不可变的，这种特征使得多个 <code>DataFrame</code> 等类型之间共享索引时更加安全，可以避免修改索引而破坏表的结构。</p>

<p>一种对 <code>Index</code> 更精确的描述是<em>有序集合</em>。<var type="module">pandas</var> 对象被设计用于实现许多操作，如合并数据集，这就要求相同列之间需要合并。<code>Index</code> 对象遵循 Python 标准库的集合 <code>set</code> 数据结构的许多习惯用法，包括并集、交集、差集等：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Index<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">9</span><span style="color: #39adb5;">])</span></div><div>i03 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Index<span style="color: #39adb5;">([</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">11</span><span style="color: #39adb5;">])</span></div><div>i02 <span style="color: #7c4dff;">&amp;</span> i03 &#160;<span style="color: #a8a8a8;"># intersection</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([3, 5, 7], dtype='int64')</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i02<span style="color: #39adb5;">.</span>union<span style="color: #39adb5;">(</span>i03<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 2, 3, 5, 7, 9, 11], dtype='int64')</div>
</div>

<p>高版本的 <var type="module">pandas</var> 可能已经弃用了运算符重载的形式，或对其抛出警告，因此一般更推荐直接调用对象的方法实现这些运算。</p>
<p><a rel="nofollow" href="/archives/1041">Python数据分析-pandas01:基本数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1041/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy06:高级数据类型</title>
		<link>/archives/816</link>
					<comments>/archives/816#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 17 Oct 2022 11:45:52 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=816</guid>

					<description><![CDATA[<p>复合数据类型 结构化数组 前面介绍过，在创建数组时使&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/816">Python数据分析-numpy06:高级数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>复合数据类型</h2>

<h3>结构化数组</h3>

<p>前面介绍过，在创建数组时使用 <code>dtype</code> 参数可以指定数组元素的类型：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>np<span style="color: #39adb5;">.</span>complex128<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j])</div>
</div>

<p><var type="module">numpy</var> 提供了许多数据类型，可以满足各种场景的使用。但是这种方式创建的数组只能容纳同种类型的元素。</p>

<p>通过在列表内安排多个数据类型，可以指定复合数据类型，构造一个结构化数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>empty<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[</span></div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>unicode_<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">16</span><span style="color: #39adb5;">),</span> </div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>int16<span style="color: #39adb5;">),</span></div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>float_<span style="color: #39adb5;">)</span></div><div><span style="color: #39adb5;">])</span></div><div>students<span style="color: #39adb5;">.</span>dtype</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">dtype([('name', '&lt;U16'), ('age', '&lt;i2'), ('score', '&lt;f8')])</div>
</div>

<p>这种复合数据类型可以通过字段名来区分各个数据成员，就像命名元组一样。</p>

<p>当检查该数组的类型时，可以看到复合数据类型由多个简单数据类型组合而成。这里基本数据类型以简写形式表达，<code>U16</code> 表示“长度不超过 16 的 Unicode 字符串”，<code>i2</code> 表示“ 2 字节（16 位）整型”，f8 表示“ 8 字节（64 位）浮点型”。最前方的小于号 <code>&lt;</code> 表示以低字节序(little endian)存储。</p>

<p>更多字符对应的 numpy 的数据类型如下表所示：</p>

<table>
    <tr>
        <th>数据类型符号</th><th>描述</th>
        <th>数据类型符号</th><th>描述</th>
    </tr>
    <tr>
        <td class="code">'b'</span></td><td>字节型</td>
        <td class="code">'c'</span></td><td>浮点型复数</td>
    </tr>
    <tr>
        <td class="code">'i'</span></td><td>有符号整型</td>
        <td class="code">'S', 'a'</span></td><td>字符串</td>
    </tr>
    <tr>
        <td class="code">'u'</span></td><td>无符号整型</td>
        <td class="code">'U'</span></td><td>Unicode 字符串</td>
    </tr>
    <tr>
        <td class="code">'f'</span></td><td>浮点型</td>
        <td class="code">'V'</span></td><td>原生数据</td>
    </tr>
</table>

<p>除了元组列表外，还可以通过字典的形式表达复合数据类型：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">{</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">names</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">),</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">formats</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">&lt;U16</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">&lt;i2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">&lt;f8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div><span style="color: #39adb5;">})</span></div></div>
</div>

<p>还可以忽略字段名称，仅用一个逗号分隔的字符串来指定复合类型：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>dtype<span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">S16,i2,f8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">dtype([('f0', 'S16'), ('f1', '&lt;i2'), ('f2', '&lt;f8')])</div>
</div>

<p>这种通过 <code>dtype</code> 类构造的类型也可以直接用作传参。</p>

<p>现在生成了一个空的数组容器，可以将列表数据放入数组中：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">Alice</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Tim</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Duff</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div><div>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">25</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">19</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">31</span><span style="color: #39adb5;">]</span></div><div>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">75.0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">61.3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">57.9</span><span style="color: #39adb5;">]</span></div><div>students</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([('Alice', 25, 75. ), ('Tim', 19, 61.3), ('Duff', 31, 57.9)],
       dtype=[('name', '&lt;U16'), ('age', '&lt;i2'), ('score', '&lt;f8')])</div>
</div>

<p>结构化数组所有的数据被安排在一个内存块中，因此它的存储和运算效率都优于元组列表。</p>

<p>可以通过索引或名称查看相应的值。例如，以下获取结构数组所有 <code>name</code> 字段的内容：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> &#160;<span style="color: #a8a8a8;"># name field</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array(['Alice', 'Tim', 'Duff'], dtype='&lt;U16')</div>
</div>

<p>以下获取数据的第一个结构：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span> &#160;<span style="color: #a8a8a8;"># first struct</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">('Alice', 25, 75.)</div>
</div>

<p>以下获取最后一个结构的 <code>name</code> 字段：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">'Duff'</div>
</div>

<p>利用布尔数组数据，还可以做一些更复杂的操作，如按照分数筛选结构，再提取结构字段：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>students<span style="color: #39adb5;">[</span>students<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">&gt;</span> <span style="color: #f76d47;">60</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array(['Alice', 'Tim'], dtype='&lt;U16')</div>
</div>

<h3>更高级的复合类型</h3>

<p><var type="module">numpy</var> 中也可以定义更高级的复合数据类型，其中每个字段又是一个复合数据类型。</p>

<p>例如，可以创建一种结构，其中每个元素都包含一个数组或矩阵：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>im3_3 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>dtype<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">[(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">id</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">i8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">),</span> <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">matrix</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">f8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">))]</span></div><div><span style="color: #39adb5;">)</span></div></div>

    <div class="juputer-separator"></div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>c1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>im3_3<span style="color: #39adb5;">)</span></div><div>c1<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(0, [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])</div>
</div>

<p>使用第三个参数可以确定数组的形状。</p>

<p>使用这种规则还可以创建嵌套结构类型，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>classroom <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>dtype<span style="color: #39adb5;">([</span></div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">teacher</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>dtype<span style="color: #39adb5;">([</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>unicode_<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">16</span><span style="color: #39adb5;">),</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>int16<span style="color: #39adb5;">)</span></div><div>&#160; &#160; <span style="color: #39adb5;">])),</span></div><div>&#160; &#160; <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">students</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> student<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div><div><span style="color: #39adb5;">])</span></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>grade_7 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>empty<span style="color: #39adb5;">(</span><span style="color: #f76d47;">8</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>classroom<span style="color: #39adb5;">)</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">teacher</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Mr.C</span><span style="color: #39adb5;">'</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">teacher</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #f76d47;">32</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">students</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">name</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">Alice</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Tim</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">Duff</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">students</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">age</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">25</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">19</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">31</span><span style="color: #39adb5;">]</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">students</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">score</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">75.0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">61.3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">57.9</span><span style="color: #39adb5;">]</span></div><div>grade_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(('Mr.C', 32), [('Alice', 25, 75. ), ('Tim', 19, 61.3), ('Duff', 31, 57.9)])</div>
</div>

<p>它的使用方法和普通的数组并没有太大差异。</p>

<p><var type="module">numpy</var> 还提供了 <code>recarray</code> 类。它和前面介绍的结构化数组几乎相同，但是它有一个独特的特征：字段可以像属性一样获取，而不是像字典的键那样获取。</p>

<p>例如，以下使用 <code>.view()</code> 方法，将一个数组通过视图表现为 <code>recarray</code> 类。这种类型的转换不修改底层数据，只改变数据的处理方式：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>graderec_7 <span style="color: #7c4dff;">=</span> grade_7<span style="color: #39adb5;">.</span>view<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>recarray<span style="color: #39adb5;">)</span></div><div>graderec_7<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">].</span>students<span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">].</span>name</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">'Tim'</div>
</div>

<h2>NumPy与I/O</h2>

<p>在处理大量数据时，将结果暂时保存到磁盘上是有必要的。<var type="module">numpy</var> 提供了一系列 I/O 操作，可以与磁盘交互。</p>

<p>最基本的 <code>save(<em>file</em>, <em>arr</em>, <em>allow_pickle</em>=True, <em>fix_imports</em>=True)</code> 函数将数组保存到扩展名为 <code>.npy</code> 的文件中。<code><em>allow_pickle</em></code> 参数使用序列化形式保存数组对象。<code><em>fix_imports</em></code> 参数则是为了处理 Python2 与 Python3 的版本差异：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>save<span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">grade7</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> grade_7<span style="color: #39adb5;">)</span></div></div>
</div>

<p>然后同级目录下就会得到一个 <code>grade7.npy</code> 的文件。由于对其做了序列化操作，因此该文件是二进制形式的，不能通过一般的文本编辑器打开。</p>

<p>读取则使用 <code>load()</code> 函数。如果不想使用二进制的形式保存数据，可以调用 <code>savetxt()</code> 以简单的文本形式存储数据，对应的使用 <code>loadtxt()</code> 函数读取文本数据。不过文本形式无法保存复杂的结构化数组数据，因此不建议使用。</p>
<p><a rel="nofollow" href="/archives/816">Python数据分析-numpy06:高级数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/816/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy05:数组统计与排序</title>
		<link>/archives/807</link>
					<comments>/archives/807#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 13 Oct 2022 09:32:07 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=807</guid>

					<description><![CDATA[<p>数组的统计 有时要获取数组的某些统计值，例如最值、总&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/807">Python数据分析-numpy05:数组统计与排序</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>数组的统计</h2>

<p>有时要获取数组的某些统计值，例如最值、总和、方差等。这种统计值可以使用 <var type="module">numpy</var> 相关的函数来获取：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>rand <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>RandomState<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div>a1 <span style="color: #7c4dff;">=</span> rand<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>mean<span style="color: #39adb5;">(</span>a1<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">4.3</div>
</div>

<p>相比 Python 内置的相同作用的函数，<var type="module">numpy</var> 对数组操作做了一些底层的优化，计算会更快一些：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>big_array <span style="color: #7c4dff;">=</span> rand<span style="color: #39adb5;">.</span>rand<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1000000</span><span style="color: #39adb5;">)</span></div><div><span style="color: #7c4dff;">%</span>timeit <span style="color: #6182b8;">sum</span><span style="color: #39adb5;">(</span>big_array<span style="color: #39adb5;">)</span></div><div><span style="color: #7c4dff;">%</span>timeit np<span style="color: #39adb5;">.</span>sum<span style="color: #39adb5;">(</span>big_array<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">113 ms ± 1.16 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
1.5 ms ± 32.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</div>
</div>

<p>下表列出了 <var type="module">numpy</var> 提供的统计函数：</p>

<table>
    <tr>
        <th>函数名称</th><th>描述</th>
        <th>函数名称</th><th>描述</th>
    </tr>
    <tr>
        <td class="code">sum()</td><td>计算元素的和</td>
        <td class="code">min()</td><td>得到最小值</td>
    </tr>
    <tr>
        <td class="code">prod()</td><td>计算元素的积</td>
        <td class="code">max()</td><td>得到最大值</td>
    </tr>
    <tr>
        <td class="code">mean()</td><td>计算元素的平均值</td>
        <td class="code">argmin()</td><td>得到最小值的索引</td>
    </tr>
    <tr>
        <td class="code">average()</td><td>计算元素的加权平均值</td>
        <td class="code">argmax()</td><td>得到最大值的索引</td>
    </tr>
    <tr>
        <td class="code">median()</td><td>计算元素的中位数</td>
        <td class="code">ptp()</td><td>计算元素的最值之差</td>
    </tr>
    <tr>
        <td class="code">std()</td><td>计算元素的标准差</td>
        <td class="code">percentile()</td><td>计算元素的百分比位数</td>
        
    </tr>
    <tr>
        <td class="code">var()</td><td>计算元素的方差</td>
        <td class="code">any()</td><td>验证是否存在元素为真</td>
    </tr>
    <tr>
        <td class="code"></td><td></td>
        <td class="code">all()</td><td>验证所有元素是否都为真</td>
    </tr>
</table>

<p>除了 <code>any()</code> 和 <code>all()</code> 外，这些函数都有一个以 nan 开头、对 NaN 值的安全处理版本，在计算时忽略所有的缺失值。</p>

<p>对于这些聚合函数，一种更简洁的形式是对数组对象直接调用对应的方法：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a1<span style="color: #39adb5;">.</span>std<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">3.257299494980466</div>
</div>

<p><code>any()</code> 和 <code>all()</code> 是比较特殊的聚合函数，因为它们只针对布尔数组。配合<a href="/archives/800">上一节</a>介绍的通用函数，可以快速检查数组是否符合某一条件。例如，可以使用以下代码来检查数组中是否有值为 10 的元素：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>any<span style="color: #39adb5;">(</span>a1 <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">False</div>
</div>

<p><var type="module">numpy</var> 提供的统计函数还允许操作多维数组时，沿着某一个维度聚合。例如，对于一个二维数组，可以对某一行或某一列聚合：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">))</span></div><div>a2<span style="color: #39adb5;">.</span>sum<span style="color: #39adb5;">(</span><span style="color: #e53935;">axis</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 6, 22, 38])</div>
</div>

<p>下图展示了数组“在 <code>axis=1</code> 上聚合”的原理：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/05-array-aggregate.png" alt="" width="200">
</figure>

<p>注意，聚合得到的结果比原数组低 1 个维度。</p>

<h2>数组的排序</h2>

<p><var type="module">numpy</var> 的 <code>sort()</code> 函数可以实现数组的高效排序。<code>sort()</code> 函数返回的是原始数组的副本：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a3 <span style="color: #7c4dff;">=</span> rand<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">8</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>sort<span style="color: #39adb5;">(</span>a3<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([2, 7, 7, 8, 8, 8, 9, 9])</div>
</div>

<p>如果希望用排序好的数组替代原始数组，可以使用数组的 <code>.sort()</code> 方法。</p>

<p>另一个相关的函数是 <code>argsort()</code> ，该函数返回的是原始数组排序完成的索引值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>argsort<span style="color: #39adb5;">(</span>a3<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([3, 1, 5, 0, 2, 6, 4, 7], dtype=int32)</div>
</div>

<p>这些索引值可以用作索引数组，来得到这个数组有序的视图：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a3<span style="color: #39adb5;">[</span>np<span style="color: #39adb5;">.</span>argsort<span style="color: #39adb5;">(</span>a3<span style="color: #39adb5;">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 7,  8,  9,  9, 12, 17, 18, 18])</div>
</div>

<p>使用 <var type="module">numpy</var> 的排序函数可以通过 <code>axis</code> 参数，沿着某个维度排序。例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a4 <span style="color: #7c4dff;">=</span> rand<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">))</span></div><div>np<span style="color: #39adb5;">.</span>sort<span style="color: #39adb5;">(</span>a4<span style="color: #39adb5;">,</span> <span style="color: #e53935;">axis</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[0, 1, 7, 9],
       [0, 1, 4, 7],
       [0, 3, 6, 8]])</div>
</div>

<p>对单一数组排序可能会遇到几个相同的值。可以综合多个数组使用 <code>lexsort()</code> 函数排序，该排序得到的结果也是索引数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div><div>x2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">8</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">])</span></div><div>x3 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div><div><span style="color: #a8a8a8;"># sort by x3, then sort by x1, then sort by x2</span></div><div>np<span style="color: #39adb5;">.</span>lexsort<span style="color: #39adb5;">((</span>x2<span style="color: #39adb5;">,</span> x1<span style="color: #39adb5;">,</span> x3<span style="color: #39adb5;">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([2, 0, 5, 1, 3, 4], dtype=int32)</div>
</div>

<p><code>partition()</code> 函数可以用于找到数组中 K 个最小值。该函数得到的结果是一个新数组，最左边是 K 个最小值，往右是任意顺序的其他值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>partition<span style="color: #39adb5;">(</span>a1<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 0, 0, 3, 6, 8, 4, 7, 6, 9])</div>
</div>

<p>类似的也有一个 <code>argpartition()</code> 函数，不过返回的结果是索引。</p>
<p><a rel="nofollow" href="/archives/807">Python数据分析-numpy05:数组统计与排序</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/807/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy04:通用函数与广播规则</title>
		<link>/archives/800</link>
					<comments>/archives/800#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sun, 09 Oct 2022 08:51:39 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=800</guid>

					<description><![CDATA[<p>通用函数 通用函数的概念 numpy 的数组在底层使&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/800">Python数据分析-numpy04:通用函数与广播规则</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>通用函数</h2>

<h3>通用函数的概念</h3>

<p><var type="module">numpy</var> 的数组在底层使用了C语言构造存储效率更高，如果对 <var type="module">numpy</var> 的数组使用 Python 的遍历方式，那么效率很低。例如，以下是一个 Python 函数，用于计算数组内每个元素的倒数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #7c4dff;font-weight: bold;">def</span> <span style="color: #6182b8;">reciprocal</span><span style="color: #39adb5;">(</span><span style="color: #e53935;">values</span><span style="color: #39adb5;">):</span></div><div>&#160; &#160; output <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>empty<span style="color: #39adb5;">(</span><span style="color: #6182b8;">len</span><span style="color: #39adb5;">(</span>values<span style="color: #39adb5;">))</span></div><div>&#160; &#160; <span style="color: #39adb5;font-weight: bold;">for</span> i <span style="color: #7c4dff;">in</span> <span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #6182b8;">len</span><span style="color: #39adb5;">(</span>values<span style="color: #39adb5;">)):</span></div><div>&#160; &#160; &#160; &#160; output<span style="color: #39adb5;">[</span>i<span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #f76d47;">1.0</span> <span style="color: #7c4dff;">/</span> values<span style="color: #39adb5;">[</span>i<span style="color: #39adb5;">]</span></div><div>&#160; &#160; <span style="color: #39adb5;font-weight: bold;">return</span> output</div></div>
</div>

<p>如果对 <var type="module">numpy</var> 的数组调用该函数，计算的速度比较慢：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>big_array <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">100</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">1000000</span><span style="color: #39adb5;">)</span></div><div><span style="color: #7c4dff;">%</span>timeit reciprocal<span style="color: #39adb5;">(</span>big_array<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">2.25 s ± 18.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</div>
</div>

<p>纯 Python 执行的效率偏低，不过好在 <var type="module">numpy</var> 为数组的各种操作提供了非常方便且高效的接口，这种接口称为通用函数(universal function, ufunc)，也称为向量操作。</p>

<p>通用函数使得对数组的简单操作，将会作用于数组的每一个元素。例如，以上倒数的计算可以以运算符“ <code>/</code> ”直接操作数组对象和一个整数，而实际的运算将会发生在数组的每一个元素之间：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>small_array <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span>reciprocal<span style="color: #39adb5;">(</span>small_array<span style="color: #39adb5;">))</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1.0</span> <span style="color: #7c4dff;">/</span> <span style="color: #39adb5;">(</span>small_array<span style="color: #39adb5;">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[0.14285714 0.11111111 0.125      0.11111111 0.16666667]
[0.14285714 0.11111111 0.125      0.11111111 0.16666667]</div>
</div>

<p>通用函数的实际计算由 numpy 底层执行，可以做到 CPU 级别的优化，这样会取得非常快的执行效率：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #7c4dff;">%</span>timeit <span style="color: #39adb5;">(</span><span style="color: #f76d47;">1.0</span> <span style="color: #7c4dff;">/</span> big_array<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">2.82 ms ± 106 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</div>
</div>

<p>计算大型数组时，使用通用函数的效率高得多。</p>

<h3>使用通用函数</h3>

<p>通用函数有一元通用函数和二元通用函数，可以操作一个数组、一个数组和一个数值，甚至两个数组。</p>

<p><var type="module">numpy</var> 的通用函数重载了 Python 的运算符，因此可以像对一个数值的运算一样对数组内的每个元素做运算。以下是一些示例：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a1 + 5 &#160;=</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a1 <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a1 // 2 =</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a1 <span style="color: #7c4dff;">//</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a1 ** 2 =</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a1 <span style="color: #7c4dff;">**</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">-a1 &#160; &#160; =</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #7c4dff;">-</span>a1<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">a2 + 5  = [5 6 7 8 9]
a2 // 2 = [0 0 1 1 2]
a2 ** 2 = [ 0  1  4  9 16]
-a2     = [ 0 -1 -2 -3 -4]</div>
</div>

<p>还可以将这些运算符任意组合使用，并且组合使用也遵循运算符的优先级：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #7c4dff;">-</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">0.5</span> <span style="color: #7c4dff;">*</span> a1 <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span> <span style="color: #7c4dff;">**</span> <span style="color: #f76d47;">2</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([-1.  , -2.25, -4.  , -6.25, -9.  ])</div>
</div>

<p>所有的运算符都是 <var type="module">numpy</var> 内置函数的简单封装器。例如，运算符“ <code>+</code> ”就是一个 <code>add()</code> 函数的封装：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>add<span style="color: #39adb5;">(</span>a1<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([5, 6, 7, 8, 9])</div>
</div>

<p>下表列出了 <var type="module">numpy</var> 重载的运算符与其对应的函数：</p>

<table>
    <tr>
        <th>运算符</th><th>对应的通用函数</th><th>描述</th>
    </tr>
    <tr>
        <td class="code">+</td><td class="code">add()</td><td>加法运算</td>
    </tr>
    <tr>
        <td class="code">-</td><td class="code">subtract()</td><td>减法运算</td>
    </tr>
    <tr>
        <td class="code">-</td><td class="code">negative()</td><td>负数运算</td>
    </tr>
    <tr>
        <td class="code">*</td><td class="code">multiply()</td><td>乘法运算</td>
    </tr>
    <tr>
        <td class="code">/</td><td class="code">divide()</td><td>除法运算，得到的结果是小数</td>
    </tr>
    <tr>
        <td class="code">//</td><td class="code">floor_divide()</td><td>整数除法运算，得到的结果是向下截断的整数</td>
    </tr>
    <tr>
        <td class="code">**</td><td class="code">power()</td><td>指数运算</td>
    </tr>
    <tr>
        <td class="code">%</td><td class="code">mod()</td><td>模运算（余数运算）</td>
    </tr>
</table>

<p>除了运算符外，<var type="module">numpy</var> 还重载了 Python 内置的运算函数，使这些函数可以应用于数组。</p>

<p>例如，可以使用 <code>abs()</code> 函数取绝对值。当该函数作用于复数数组时，绝对值返回的是该复数在复平面上对应向量的模长：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">3</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">4</span><span style="color: #7c4dff;font-weight: bold;">j</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">3</span><span style="color: #7c4dff;font-weight: bold;">j</span><span style="color: #39adb5;">,</span> <span style="color: #7c4dff;">-</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #7c4dff;">-</span><span style="color: #f76d47;">5</span><span style="color: #7c4dff;font-weight: bold;">j</span><span style="color: #39adb5;">])</span></div><div>np<span style="color: #39adb5;">.</span>abs<span style="color: #39adb5;">(</span>a2<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([5., 5., 2., 5.])</div>
</div>

<p>该重载方法对应的 <var type="module">numpy</var> 通用函数是 <code>absolute()</code> ，并且在 <var type="module">numpy</var> 内还有一个别名也为 <code>abs()</code> 。</p>

<p><var type="module">numpy</var> 还提供了计算三角函数的通用函数，包括正弦、余弦、正切以及它们对应的反三角函数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>theta <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>linspace<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>pi<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">theta &#160; &#160; &#160;:</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> theta<span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">sin(theta) :</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>sin<span style="color: #39adb5;">(</span>theta<span style="color: #39adb5;">))</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">tan(theta) :</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>tan<span style="color: #39adb5;">(</span>theta<span style="color: #39adb5;">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">theta      : [0.         1.57079633 3.14159265]
sin(theta) : [0.0000000e+00 1.0000000e+00 1.2246468e-16]
tan(theta) : [ 0.00000000e+00  1.63312394e+16 -1.22464680e-16]</div>
</div>

<p>另一类常用的通用函数是指数运算，包括以 e 为底数的指数函数 <code>exp()</code> 、以 2 为底数的指数函数 <code>exp2()</code> 、任意数为底数的指数函数 <code>pow()</code> 。不是特殊的指数运算也可以直接使用指数运算符“ <code>**</code> ”计算，该运算符对应的通用函数是 <code>power()</code> 。</p>

<p>指数运算的逆运算，即对数运算也是很有用的。最基本的 <code>log()</code> 给出的是以 e 为底数的对数，还有包括以 2 为底数的对数函数 <code>log2()</code> 、以 10 为底数的对数函数 <code>log10()</code> 。</p>

<p>还有一些特殊的函数例如 <code>expm1()</code> 用于计算 e<sup>x</sup> - 1 ，以及 <code>log1p()</code> 用于计算 ln(x + 1) ，它们在底层做了一定优化，对于非常小的输入值可以保持很好的精度，比间接计算再组合更精确。</p>

<p>通用函数非常灵活，甚至可以对两个数组进行运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span> <span style="color: #7c4dff;">/</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0.        , 0.5       , 0.66666667, 0.75      , 0.8       ])</div>
</div>

<p>不仅限于一维函数，也可以用于多维数组的计算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a6 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">6</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">))</span></div><div><span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">**</span> a6</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 1,  2,  4],
       [ 8, 16, 32]], dtype=int32)</div>
</div>

<h3>通用函数与布尔运算</h3>

<p>通用函数除了计算外，还有一种实用的用法是布尔运算。这些比较运算符和其对应的通用函数如下表所示：</p>

<table>
    <tr>
        <th>运算符</th><th>对应的通用函数</th>
    </tr>
    <tr>
        <td class="code">==</td><td class="code">equal()</td>
    </tr>
    <tr>
        <td class="code">!=</td><td class="code">not_equal()</td>
    </tr>
    <tr>
        <td class="code">&lt;</td><td class="code">less()</td>
    </tr>
    <tr>
        <td class="code">&lt;=</td><td class="code">less_equal()</td>
    </tr>
    <tr>
        <td class="code">&gt;</td><td class="code">greater()</td>
    </tr>
    <tr>
        <td class="code">&gt;=</td><td class="code">greater_equal()</td>
    </tr>
</table>

<p>对一个数组对象的布尔运算将对每个元素做布尔运算，并得到一个新的布尔数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a1 <span style="color: #7c4dff;">%</span> <span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([False,  True, False,  True, False])</div>
</div>

<p>如果需要对两个布尔结果做布尔逻辑运算，可以通过 Python 的逐位逻辑运算符“ & ”、“ | ”、“ ^ ”和“ ~ ”来实现。当作用与布尔数组时，可以表示布尔逻辑运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;">(</span>a1 <span style="color: #7c4dff;">&gt;</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span> <span style="color: #7c4dff;">&amp;</span> <span style="color: #39adb5;">(</span>a1 <span style="color: #7c4dff;">%</span> <span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([False, False, False,  True, False])</div>
</div>

<p>下表总结了逐位的布尔运算符和其对应的通用函数：</p>

<table>
    <tr>
        <th>运算符</th><th>对应通用函数</th><th>逻辑含义</th>
    </tr>
    <tr>
        <td class="code">&amp;</td><td class="code">bitwise_and()</td><td>与</td>
    </tr>
    <tr>
        <td class="code">|</td><td class="code">bitwise_or()</td><td>或</td>
    </tr>
    <tr>
        <td class="code">^</td><td class="code">bitwise_xor()</td><td>异或</td>
    </tr>
    <tr>
        <td class="code">~</td><td class="code">bitwise_not()</td><td>非</td>
    </tr>
</table>

<p>这种布尔数组实用之处在于，可以将其作为数组索引，从而快速选出在 <code>True</code> 位置的所有元素。例如，以下操作可以选择数组中的所有偶数元素：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a9 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>RandomState<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">).</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">9</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span><span style="color: #39adb5;">,))</span></div><div>a9<span style="color: #39adb5;">[</span>a9 <span style="color: #7c4dff;">%</span> <span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([8, 0, 0, 6, 2, 4])</div>
</div>

<p>注意：这种情况下 <code>a % 2</code> 和 <code>a % 2 != 0</code> 表示的不是一个意思。前者得到的是一个数值数组，将其作为索引时每个元素表示的意思是索引值位置的元素；后者得到的是一个布尔数组，将其作为索引时每个元素表示的意思是是否取用当前位置的元素。</p>

<p>可以使用 <code>where()</code> 函数将后一种布尔数组转为等价的索引数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>where<span style="color: #39adb5;">(</span>a9 <span style="color: #7c4dff;">%</span> <span style="color: #f76d47;">2</span> <span style="color: #7c4dff;">==</span> <span style="color: #f76d47;">0</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(array([1, 3, 4, 7, 8, 9], dtype=int32),)</div>
</div>

<p><code>where()</code> 函数一般用在高维的索引查询中，每个数组相应位置元素组合的结果就是元素在高维数组的索引。</p>

<h3>通用函数高级特性</h3>

<p>通用函数有两种表现形式：函数对象和运算符。显式使用通用函数代替运算符的好处在于，可以使用通用函数提供的一些参数。</p>

<p>例如，有时需要指定一个用于存放这些运算结果的数组。所有的通用函数都可以通过设置 <code>out</code> 参数的值来指定计算结果的存放位置：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a7 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>empty<span style="color: #39adb5;">(</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>multiply<span style="color: #39adb5;">(</span>a4<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">out</span><span style="color: #7c4dff;">=</span>a7<span style="color: #39adb5;">)</span></div><div>a7</div></div>
</div>

<p>这个特性也可用于向数组视图内输出数据。例如可以将计算结果写入指定数组间隔的位置：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a8 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>ones<span style="color: #39adb5;">(</span><span style="color: #f76d47;">8</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>add<span style="color: #39adb5;">(</span>a7<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">out</span><span style="color: #7c4dff;">=</span>a8<span style="color: #39adb5;">[::</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div><div>a8</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 5.,  1.,  7.,  1., 11.,  1., 23.,  1.])</div>
</div>

<p>对于较大的数组，使用 <code>out</code> 参数可以有效节约内存。</p>

<hr>

<p>通用函数对象还提供了一些方法，可以完成更高级的运算需求。例如，调用通用函数对象的 <code>.reduce()</code> 方法会对给定的元素连续执行操作，直到得到单个的结果，类似 <code>functools</code> 库的 <code>reduce()</code> 函数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>multiply<span style="color: #39adb5;">.</span>reduce<span style="color: #39adb5;">(</span>a8<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">8855.0</div>
</div>

<p>类似于 <code>itertools</code> 库的 <code>accumulate()</code> 函数，可以使用通用函数对象的 <code>.accumulate()</code> 方法来存储每次计算的中间结果：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>add<span style="color: #39adb5;">.</span>accumulate<span style="color: #39adb5;">(</span>a9<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 5, 13, 18, 18, 18, 19, 26, 32, 34, 38], dtype=int32)</div>
</div>

<p>任何通用函数对象都可以使用 <code>.outer()</code> 方法获得两个不同输入数组的所有元素对的运算结果。例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>multiply<span style="color: #39adb5;">.</span>outer<span style="color: #39adb5;">(</span>a2<span style="color: #39adb5;">,</span> a7<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[  6.  -8.j,  12. -16.j,  24. -32.j,  60. -80.j],
       [  8.  -6.j,  16. -12.j,  32. -24.j,  80. -60.j],
       [ -4.  +0.j,  -8.  +0.j, -16.  +0.j, -40.  +0.j],
       [  0. -10.j,   0. -20.j,   0. -40.j,   0.-100.j]])</div>
</div>

<p>上一节提过：当使用数组索引修改值时，如果索引数组包含多个相同的索引元素，那么只有最后一次对索引位置的操作才有效。如果想要每次使用索引时立即执行给定的操作，可以使用通用函数的 <code>.at()</code> 方法：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a_cnt <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div>a_rnd <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>RandomState<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">).</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">10000</span><span style="color: #39adb5;">)</span></div><div>np<span style="color: #39adb5;">.</span>add<span style="color: #39adb5;">.</span>at<span style="color: #39adb5;">(</span>a_cnt<span style="color: #39adb5;">,</span> a_rnd<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div><div>a_cnt</div></div>
</div>

<h2>广播规则</h2>

<h3>广播规则简介</h3>

<p>如果二元通用函数作用于两个数组，那么将对相应元素逐个计算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div><div>x2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">])</span></div><div>x1 <span style="color: #7c4dff;">+</span> x2</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([6, 6, 8])</div>
</div>

<p>这种操作很容易理解。但是二元操作也可以用于不同大小的数组，例如可以简单地将一个标量（可以认为是零维的数组）和一个数组相加：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x2 <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">4</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([9, 8, 9])</div>
</div>

<p><strong>广播规则</strong>(broadcasting rule)允许二元操作用于不同大小的数组。例如，甚至可以将一个一维数组与二维数组做运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>y1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>full<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">),</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)</span></div><div>x1 <span style="color: #7c4dff;">+</span> y1</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[3, 4, 5],
       [3, 4, 5],
       [3, 4, 5]])</div>
</div>

<p>广播规则并没有特别规定这两个数组的运算次序，其实质上是扩展了数组的形状，使两个数组形状匹配再做运算：当一维数组与标量运算时，标量将复制若干份形成一个形状匹配的一维数组；当一维数组与二维数组运算时，一维数组将自身复制若干份向着另一个维度扩展，从而匹配二维数组的形状。</p>

<p>以下是 <var type="module">numpy</var> 官网提供的一个很好的图解，来表示广播时的形状扩展：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/04-broadcasting-2.png" alt="">
</figure>

<p>更复杂的情况涉及到对两个数组的同时广播。例如对一个行向量和一个列向量做运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x3 <span style="color: #7c4dff;">=</span> x1<span style="color: #39adb5;">[:,</span> np<span style="color: #39adb5;">.</span>newaxis<span style="color: #39adb5;">]</span></div><div>x1 <span style="color: #7c4dff;">+</span> x3</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[2, 3, 4],
       [3, 4, 5],
       [4, 5, 6]])</div>
</div>

<p><code>x1</code> 必须复制自身以扩展到二维，但 <code>x3</code> 也需要在第二个维度扩展以匹配出一个公共的形状。</p>

<h3>广播规则的原理</h3>

<p><var type="module">numpy</var> 的广播遵循一套严格的规则，这套规则是为了决定两个数组间的操作：</p>

<ul>
    <li>规则 1 ：如果两个数组的维度不相同，那么更小维度的数组首先需要将自身提高一个维度（形状在左边补 1 ）；</li>
    <li>规则 2 ：如果两个数组的形状还是不匹配，那么数组将会沿着只有一个元素（形状值为 1 ）的维度将这个元素复制若干份，以扩展并匹配另外一个数组的形状；</li>
    <li>规则 3 ：如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度只有一个元素，那么会引发异常。</li>
</ul>

<p>接下来看几个广播的示例。对于以下两个相加的数组：</p>

<table>
    <tr>
        <td class="code">l.shape == (2, 3)</td>
        <td class="code">r.shape == (3,)</td>
    </tr>
</table>

<p>根据规则 1 ，数组 <code>r</code> 的维度更小，因此需要提升一个维度（在其左边补 1 ）：</p>

<table>
    <tr>
        <td class="code">l.shape == (2, 3)</td>
        <td class="code">r.shape => (1, 3)</td>
    </tr>
</table>

<p>根据规则 2 ，第一个维度不匹配，因此扩展该维度以匹配数组：</p>

<table>
    <tr>
        <td class="code">l.shape == (2, 3)</td>
        <td class="code">r.shape => (2, 3)</td>
    </tr>
</table>

<p>现在两个数组形状匹配了，最终结果也就是该形状。</p>

<p>再来看一个示例，对于一个行向量和一个列向量：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 1)</td>
        <td class="code">r.shape == (3,)</td>
    </tr>
</table>

<p>根据规则 1 ，在数组 <code>r</code> 的左边补 1 ：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 1)</td>
        <td class="code">r.shape => (1, 3)</td>
    </tr>
</table>

<p>根据规则 2 ，扩展其值为 1 的维度匹配数组 <code>l</code> ：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 1)</td>
        <td class="code">r.shape => (3, 3)</td>
    </tr>
</table>

<p>这个时候两个数组的形状仍然不匹配。不过数组 <code>l</code> 还有元素个数为 1 的维度，因此根据规则 2 ，继续扩展其值为 1 的维度匹配数组 <code>r</code> ：</p>

<table>
    <tr>
        <td class="code">l.shape => (3, 3)</td>
        <td class="code">r.shape == (3, 3)</td>
    </tr>
</table>

<p>现在两个数组形状匹配了，并且得到一个公共的形状。</p>

<p>最后看一个类似的相加：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 2)</td>
        <td class="code">r.shape == (3,)</td>
    </tr>
</table>

<p>根据规则 1 ，同样在数组 <code>r</code> 的左边补 1 ：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 2)</td>
        <td class="code">r.shape => (1, 3)</td>
    </tr>
</table>

<p>根据规则 2 ，在数组 <code>r</code> 的第一个维度进行扩展，以匹配数组l的维度：</p>

<table>
    <tr>
        <td class="code">l.shape == (3, 2)</td>
        <td class="code">r.shape => (3, 3)</td>
    </tr>
</table>

<p>现在根据规则 3 ，最终的形状还是不匹配，但是也没有任何一个数组的维度值为 1 ，因此这样的两个数组相加会产生错误：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x4<span style="color: #39adb5;">,</span> y4 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>ones<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)),</span> np<span style="color: #39adb5;">.</span>ones<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,))</span></div><div><span style="color: #39adb5;font-weight: bold;">try</span><span style="color: #39adb5;">:</span></div><div>&#160; &#160; x4 <span style="color: #7c4dff;">+</span> y4</div><div><span style="color: #39adb5;font-weight: bold;">except</span> <span style="color: #8796b0;">Exception</span> <span style="color: #39adb5;font-weight: bold;">as</span> e<span style="color: #39adb5;">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span>e<span style="color: #39adb5;">.</span>__class__<span style="color: #39adb5;">,</span> e<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'ValueError'> operands could not be broadcast together with shapes (3,2) (3,) </div>
</div>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://numpy.org/doc/stable/user/basics.ufuncs.html">https://numpy.org/doc/stable/user/basics.ufuncs.html</a>
</p>

<p>
    <a href="https://numpy.org/doc/stable/user/basics.broadcasting.html">https://numpy.org/doc/stable/user/basics.broadcasting.html</a>
</p>
<p><a rel="nofollow" href="/archives/800">Python数据分析-numpy04:通用函数与广播规则</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/800/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy03:数组索引与切片</title>
		<link>/archives/795</link>
					<comments>/archives/795#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 05 Oct 2022 03:00:55 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=795</guid>

					<description><![CDATA[<p>数组的索引与切片 数组的索引 类似 Python 的&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/795">Python数据分析-numpy03:数组索引与切片</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>数组的索引与切片</h2>

<h3>数组的索引</h3>

<p>类似 Python 的列表，<var type="module">numpy</var> 中的数组也可以用中括号指定获取索引值位置的元素。索引值同样从零开始计数，且可以使用负数索引获取末尾元素：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">arange</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> a1</span><span style="color: #39adb5;">[</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0 4 8</div>
</div>

<p>不同与 Python 的嵌套列表，可以用逗号分隔的索引元组获取多维数组的某一元素，而不需要多次索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">arange</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span><span style="color: #90a4ae;">reshape</span><span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">))</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> a2</span><span style="color: #39adb5;">[</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
0 9 3</div>
</div>

<p>索引元组是多次切片的一个便捷替代，因此前面的值代表的是外层数组的索引。</p>

<p>可以用以上的索引方式为数组内某个位置的元素分配一个新值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">23</span></div><div><span style="color: #90a4ae;">a2</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8, 23, 10, 11]])</div>
</div>

<p>注意，<var type="module">numpy</var> 的数组是固定类型的，当将一个不同类型的元素插入数组时，它会被隐式地截短转换：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">10.55</span></div><div><span style="color: #90a4ae;">a1</span></div></div>

    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([10,  0,  3,  3,  7,  9])</div>
</div>

<h3>数组的切片</h3>

<p><var type="module">numpy</var> 的数组也支持切片语法，语法和 Python 对序列的切片一致。如果 <code>arr</code> 是一个数组，可以用以下语法对 <code>arr</code> 切片：</p>

<div class="code-template">
    arr[<em>start</em>:<em>stop</em>:<em>step</em>]
</div>

<p>对一维数组的切片很简单，与 Python 切片语法一致。例如以下几个简单示例：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">7</span><span style="color: #39adb5;">])</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[:</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">])</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">6</span><span style="color: #39adb5;">::</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[4 5 6]
[9 8 7 6]
[6 4 2 0]</div>
</div>

<p>多维数组的切片也采用类似索引的方法处理：可以用逗号分隔的切片对象来逐维切片，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[:</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> &nbsp;</span><span style="color: #a8a8a8;"># slice to line, slice to col</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[32,  5,  2],
       [ 7,  6,  8]])</div>
</div>

<p>该切片的意思是先在第二个维度（列方向）取前 2 项元素，再在第一个维度（行方向）取前三项元素。下面再给出一个更复杂的示例：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">::</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 4,  6],
       [ 8, 10]])</div>
</div>

<p>一种常见的需求是获取多维数组的特定行和列。这种情况下，可以用索引与切片组合起来实现该功能，用单个冒号“ <code>:</code> ”表示空切片（即不做切片，获取该维度的所有元素）：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[:,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 4, 8])</div>
</div>

<p>意思是不对第二个维度做切片（保留所有行），然后获取每行的首个元素。再如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:]</span><span style="color: #90a4ae;"> &nbsp;</span><span style="color: #a8a8a8;"># equals to a2[0]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 1, 2, 3])</div>
</div>

<p>在更高维的数组切片中，还可以使用省略号来表示多个连续的空切片，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a3 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">arange</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">*</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">*</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">).</span><span style="color: #90a4ae;">reshape</span><span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">))</span></div><div><span style="color: #90a4ae;">a3</span><span style="color: #39adb5;">[</span><span style="color: #90a4ae;">...</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> &nbsp;</span><span style="color: #a8a8a8;"># equals to a3[:, :, -1]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 4,  9, 14, 19],
       [24, 29, 34, 39],
       [44, 49, 54, 59]])</div>
</div>

<p>为了不发生歧义，一个切片中最多只能使用一个省略号。</p>

<p>最后关于数组切片需要注意的是，切片返回的也是数组的视图，因此在切片中修改元素也会影响原数组。如果确实需要得到一个副本子数组的话，可以对切片对象使用 <code>.copy()</code> 方法得到副本。</p>

<h3>切片与数组升维</h3>

<p>切片还可用于给数组增加维度。一种常见的需求是将一个数组变成二维数组的行或列，此时可以在数组切片中使用 <code>np.newaxis</code> 变量给数组添加新维度，具体操作为：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[:,</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">newaxis</span><span style="color: #39adb5;">][:</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[10],
       [ 1],
       [ 2]])</div>
</div>

<p>以上操作在 <code>np.newaxis</code> 对应的位置加上了一个维度，使数组的形状变成了 <code>(-1, 1)</code> ，形成二维数组（列向量）。</p>

<p>可以结合以下升维再切片降维的过程理解，两个切片互为逆过程：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #90a4ae;">np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">newaxis</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:,</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">newaxis</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">newaxis</span><span style="color: #39adb5;">][</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([10,  1,  2,  3,  4,  5,  6,  7,  8,  9])</div>
</div>

<p><code>np.newaxis</code> 实际上是 <code>None</code> 的别名。该过程虽然是升维，但得到的也是数组的视图。</p>

<h2>高级索引机制</h2>

<h3>数组索引</h3>

<p>接下来简单介绍另外一种索引方式<strong>数组索引</strong>，也称作花哨的索引(fancy indexing)。花哨的索引和前面那些简单的索引非常类似，但是传递的是索引数组，而不是单个标量。这种强大的索引能够快速获得并修改复杂的数组值的子数据集。</p>

<p>如果在索引中传递单个列表或数组，它包括的元素会被当做索引值，可以获取若干元素构成的数组（视图）：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">8</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([10,  1,  2,  4,  8,  9])</div>
</div>

<p>数组索引得到的数组形状与索引的形状一致，而不是与原数组的形状一致：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">ind1 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">array</span><span style="color: #39adb5;">([[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">8</span><span style="color: #39adb5;">]])</span></div><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #90a4ae;">ind1</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[10,  1],
       [ 5,  8]])</div>
</div>

<p>这种索引方式也适用于多维数组，不过多维数组下的数组索引是这样工作的：如果向索引内传入多个数组，那么每个数组分别确定每个维度的索引。例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 4, 23, 11])</div>
</div>

<p>以上两个数组结合确定了三个位置：[1, 0] [2, 1] 和 [2, 3] 。</p>

<p>可以将普通索引、切片和数组索引组合使用，使数组在某些维度做普通索引，某些维度做切片，某些维度用数组索引。例如，索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([4, 5, 6])</div>
</div>

<p>取第二行的数组中除最后一个元素外的所有元素，但不改变数组间的嵌套关系。再如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a2</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 4,  7],
       [ 8, 11]])</div>
</div>

<p>取第一行及往后的第一个和最后一个元素，但不改变数组间的嵌套关系。</p>

<h3>用数组索引修改值</h3>

<p>切片和数组索引可以用于获取部分元素，并且返回的是数组视图。如果对视图内的元素赋值，可以批量修改数组的一部分数据，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">20</span></div><div><span style="color: #90a4ae;">a1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([20, 20, 20, 20, 20,  5,  6,  7,  8,  9])</div>
</div>

<p>可以做任意的赋值操作，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">//=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">4</span></div><div><span style="color: #90a4ae;">a1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([5, 5, 5, 5, 5, 5, 6, 7, 8, 9])</div>
</div>

<p>数组索引有一种特殊情况，那就是对同一个位置做了多次索引，导致重复获取该位置的值。如果对一个位置做重复的赋值，会导致前面的赋值被覆盖：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[[</span><span style="color: #f76d47;">9</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">13</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 5,  5,  5,  5,  5,  5,  6,  7,  8, 13])</div>
</div>

<p>因为该操作对最后一个位置的元素赋值了两次。覆盖的本质是只有最后一次对元素的操作才有效，因此对同一个元素的多次复合运算赋值不会累计起效：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">a1</span><span style="color: #39adb5;">[[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]]</span><span style="color: #90a4ae;"> </span><span style="color: #7c4dff;">-=</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">10</span></div><div><span style="color: #90a4ae;">a1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([-5,  5,  5,  5,  5,  5,  6,  7,  8, 13])</div>
</div>

<p>本节对数组的索引机制暂时到这边结束。下一节将介绍通用函数和数组的广播机制，可以结合数组索引做一些更复杂的操作。</p>
<p><a rel="nofollow" href="/archives/795">Python数据分析-numpy03:数组索引与切片</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/795/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy02:数组变形与组合</title>
		<link>/archives/777</link>
					<comments>/archives/777#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sat, 01 Oct 2022 16:36:17 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=777</guid>

					<description><![CDATA[<p>数组的变形 数组常用属性 上一节介绍了 numpy &#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/777">Python数据分析-numpy02:数组变形与组合</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>数组的变形</h2>

<h3>数组常用属性</h3>

<p><a href="/archives/772">上一节</a>介绍了 <var type="module">numpy</var> 创建数组的方式。<var type="module">numpy</var> 中的数组是一个 <code>ndarray</code> 对象，它提供了高效的存储与操作的方式，适合处理大量数据。</p>

<p>每个数组有 <code>.nidm</code>（数组的维度）、<code>.shape</code>（数组每个维度的大小）和 <code>.size</code>（数组的总大小）属性：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a3 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">))</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a3 ndim &#160;:</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a3<span style="color: #39adb5;">.</span>ndim<span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a3 shape :</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a3<span style="color: #39adb5;">.</span>shape<span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a3 size &#160;:</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a3<span style="color: #39adb5;">.</span>size<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">a3 ndim  : 3
a3 shape : (3, 4, 5)
a3 size  : 60</div>
</div>

<p>其它常用的属性包括表示每个数组元素字节大小的 <code>.itemsize</code> ，以及表示数组总字节大小的属性 <code>.nbytes</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">itemsize :</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a3<span style="color: #39adb5;">.</span>itemsize<span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">bytes</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div><span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">nbytes :</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> a3<span style="color: #39adb5;">.</span>nbytes<span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">bytes</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">itemsize : 4 bytes
nbytes : 240 bytes</div>
</div>

<p>一般来说，可以认为 <code>.nbytes</code> 跟 <code>.itemsize</code> 和 <code>.size</code> 的乘积大小相等。</p>

<h3>数组变形</h3>

<p>变形是一种实用的操作，通过变形可以产生有一定规则，但难以直接创建的数组。</p>

<p>下表总结了常用的变形函数或方法，接下来会详细介绍：</p>

<table>
    <tr>
        <th>函数</th>
        <th>作用</th>
        <th>返回结果</th>
    </tr>
    <tr>
        <td><code>.reshape(<em>shape</em>, <em>order</em>='C')</code></td>
        <td>用数组现有元素重组变形</td>
        <td>视图</td>
    </tr>
    <tr>
        <td><code>.resize(<em>new_shape</em>)</code></td>
        <td>用数组现有元素重组变形</td>
        <td>原始数组</td>
    </tr>
    <tr>
        <td><code>.T</code></td>
        <td>转置</td>
        <td>视图</td>
    </tr>
    <tr>
        <td><code>.transpose(<em>axes</em>=None)</code></td>
        <td>高维转置</td>
        <td>视图</td>
    </tr>
    <tr>
        <td><code>.flatten(<em>order</em>='C')</code></td>
        <td>碾平为一维数组</td>
        <td>副本</td>
    </tr>
    <tr>
        <td><code>.ravel(<em>order</em>='C')</code></td>
        <td>碾平为一维数组</td>
        <td>视图</td>
    </tr>
    <tr>
        <td><code>.squeeze(<em>axis</em>=None)</code></td>
        <td>合并元素个数为 1 的维度</td>
        <td>视图</td>
    </tr>
    <tr>
        <td><code>.swapaxes(axis1, axis2)</code></td>
        <td>交换数轴</td>
        <td>视图</td>
    </tr>
</table>

<p>数组变形最灵活的实现方式是通过 <code>.reshape()</code> 方法实现。例如，以下通过变形将数字 0~9 放入一个 3×3 的矩阵中：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m1 <span style="color: #7c4dff;">=</span> np.arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span>, <span style="color: #f76d47;">10</span><span style="color: #39adb5;">)</span>.reshape<span style="color: #39adb5;">(</span>(<span style="color: #f76d47;">3</span>, <span style="color: #f76d47;">3</span>)<span style="color: #39adb5;">)</span></div><div><span style="color: #f76d47;">print</span>(m1)</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[[1 2 3]
 [4 5 6]
 [7 8 9]]</div>
</div>

<p>注意，原始数组的大小（元素个数）必须要和变形后数组的大小一致。可以使用负数来自动计算某一维度的元素个数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])</div>
</div>

<p>如果转换后形状无法兼容，则会产生 <code class="error">ValueError</code> 异常。</p>

<p>该方法不会修改原有数组。如果想修改原有数组，可以调用 <code>.resize()</code> ，或者直接通过修改 <code>.shape</code> 属性实现：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m1<span style="color: #39adb5;">.</span>shape <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">(</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div><div>m1</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([1, 2, 3, 4, 5, 6, 7, 8, 9])</div>
</div>

<p><code>.T</code> 属性用于转置原有数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">6</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">))</span></div><div>m2</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[0, 1, 2],
       [3, 4, 5]])</div>
</div>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m2<span style="color: #39adb5;">.</span>T</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[0, 3],
       [1, 4],
       [2, 5]])</div>
</div>

<p>或者可以使用 <code>.transpose(<em>axes</em>=None)</code> 方法，该方法的优点是可以转置更高维的矩阵：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m3 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">))</span></div><div>m3<span style="color: #39adb5;">.</span>transpose<span style="color: #39adb5;">((</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">)).</span>shape</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(2, 2, 3)</div>
</div>

<p>注意，两种转置返回的结果都是数组的<strong>视图</strong>(view)而不是副本。视图是原有数组中的部分元素重新按一定规律输出的结果，对视图内的元素做修改也会实时更新到原有数组内：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m2_T <span style="color: #7c4dff;">=</span> m2<span style="color: #39adb5;">.</span>transpose<span style="color: #39adb5;">()</span></div><div>m2_T<span style="color: #39adb5;">[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> <span style="color: #f76d47;">100</span></div><div>m2</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[100,   2,   3],
       [100,   5,   6]])</div>
</div>

<p><code>.reshape()</code> 方法返回的也是数组的视图，因为它只涉及部分元素的重新排布。这种方式在处理大量数据时运行会更快，并可以减少副本占用的缓存空间。</p>

<p>有关数组的索引与切片将在下一节介绍。</p>

<h3>变形与维度转换</h3>

<p>有时要对数组的维度做变换，此时就会涉及数组的变形。使用 <code>.flatten(<em>order</em>='C')</code> 可以将高维数组碾平为一维数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a4 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([[[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">]]])</span></div><div>a4<span style="color: #39adb5;">.</span>flatten<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([1, 2, 3, 4, 5, 6])</div>
</div>

<p>该方法不会修改原有数组，返回的是原有数组的副本。</p>

<p><code>.ravel(<em>order</em>='C')</code> 也用于碾平数组，不过返回结果是数组的视图。</p>

<p><code>.squeeze(axis=None)</code> 用于将元素个数为 1 的维度并入其它维度中，即去除 <code>.shape</code> 属性中值为 1 的维度：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a5 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([[[[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">]],</span> <span style="color: #39adb5;">[[</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">4</span><span style="color: #39adb5;">]]]])</span></div><div>a5<span style="color: #39adb5;">.</span>squeeze<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[1, 2],
       [3, 4]])</div>
</div>

<p><code>.swapaxes(axis1, axis2)</code> 用于交换数值的两个维度。对于一个高维数组来说，最内层的数组的 axis 被记为 0 ，次外层为 1 ，以此类推：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m3</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[[ 0,  1],
        [ 2,  3],
        [ 4,  5]],

       [[ 6,  7],
        [ 8,  9],
        [10, 11]]])</div>
    <div class="jupyter-separator"></div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m3<span style="color: #39adb5;">.</span>swapaxes<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[[ 0,  2,  4],
        [ 1,  3,  5]],

       [[ 6,  8, 10],
        [ 7,  9, 11]]])</div>
</div>

<p>该操作返回视图。交换最直观的反应就是 <code>.shape</code> 对应位置的值被互换了。</p>

<h2>数组的拼接和拆分</h2>

<p>以上所有的操作都是针对单一数组的，但有时也需要将多个数组合并为一个，或者将一个数组分裂为多个。</p>

<h3>数组的拼接</h3>

<p>下表列出了拼接或连接数组常用的方法：</p>

<table>
    <tr>
        <th>函数</th>
        <th>效果</th>
    </tr>
    <tr>
        <td><code>concatenate(<em>arrays</em>, <em>axis</em>=0)</code></td>
        <td>拼接多个数组</td>
    </tr>
    <tr>
        <td><code>append(<em>arr</em>, <em>values</em>, <em>axis</em>=None)</code></td>
        <td>拼接两个数组，未指定维度则碾平后拼接</td>
    </tr>
    <tr>
        <td><code>vstack(<em>arrays</em>)</code> 、<code>row_stack(<em>arrays</em>)</code></td>
        <td>垂直拼接多个数组，即将数组的行之间拼接</td>
    </tr>
    <tr>
        <td><code>hstack(<em>arrays</em>)</code> 、<code>column_stack(<em>arrays</em>)</code></td>
        <td>水平拼接多个数组，即将数组的列之间拼接</td>
    </tr>
    <tr>
        <td><code>dstack(<em>arrays</em>)</code></td>
        <td>沿第三个维度，即高度方向拼接多个数组</td>
    </tr>
    <tr>
        <td><code>stack(<em>arrays</em>, <em>axis</em>=0)</code></td>
        <td>拼接多个数组，且拼接完之后会变高一维</td>
    </tr>
</table>

<p><code>concatenate()</code> 将数组元组或数组列表作为第一个参数，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>x1 <span style="color: #7c4dff;">=</span> np.array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div><div>y1 <span style="color: #7c4dff;">=</span> np.array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">])</span></div><div>np.concatenate<span style="color: #39adb5;">([</span>x1<span style="color: #39adb5;">,</span> y1<span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([1, 2, 3, 3, 2, 1])</div>
</div>

<p>该函数也可以一次性拼接多个数组，或用于二维数组的拼接。</p>

<p>对于多维数组，有时还需要向别的方向拼接。在了解如何拼接前，需要进一步认识 <var type="module">numpy</var> 的坐标轴。最外层的元素（维度 1 ）的轴记为 0 ，它们包含的数组（维度 2 ）轴记为 1 ，这些数组包含的数组（维度 3 ）记为 2 ，以此类推：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/02-array-axis.png" alt="" width="600">
</figure>

<p>可以通过 <code>axis</code> 参数指定拼接的轴。下图展示了“在 <code>axis=1</code> 轴上拼接”的原理：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/02-array-concat.png" alt="" width="360">
</figure>

<p>此时最内层的数组之间被拼接，示例如下：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m2</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[1, 2, 3],
       [4, 5, 6]])</div>
    <div class="juputer-separator"></div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.concatenate<span style="color: #39adb5;">([</span>m2<span style="color: #39adb5;">,</span> m2<span style="color: #39adb5;">]</span>, <span style="color: #e53935;">axis</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[1, 2, 3, 1, 2, 3],
       [4, 5, 6, 4, 5, 6]])</div>
</div>

<p><code>append()</code> 函数用于拼接两个数组，如果不指定 <code>axis</code> 会先调用 <code>.ravel()</code> 碾平（不改变原数组）再拼接，因此可用于拼接不同形状的数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>append<span style="color: #39adb5;">(</span>m2<span style="color: #39adb5;">,</span> x1<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 1, 2, 3, 4, 5, 1, 2, 3])</div>
</div>

<p>拼接完成之后再将其修改为需要的形状即可。</p>

<p>沿着固定维度处理数组时，使用 <code>vstack()</code> 函数进行垂直拼接，或使用 <code>hstack()</code> 函数进行水平拼接会更加方便：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.vstack<span style="color: #39adb5;">([</span>x1<span style="color: #39adb5;">,</span> m2<span style="color: #39adb5;">])</span> &#160;<span style="color: #a8a8a8;"># vertical</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[1, 2, 3],
       [1, 2, 3],
       [4, 5, 6]])</div>
    <div class="jupyter-separator"></div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>y2 <span style="color: #7c4dff;">=</span> np.array<span style="color: #39adb5;">([[</span><span style="color: #f76d47;">100</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">200</span><span style="color: #39adb5;">]])</span></div><div>np.hstack<span style="color: #39adb5;">([</span>m2<span style="color: #39adb5;">,</span> y2<span style="color: #39adb5;">])</span> &#160;<span style="color: #a8a8a8;"># horizontal</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[  1,   2,   3, 100],
       [  4,   5,   6, 200]])</div>
</div>

<p>这两个函数还分别有别名 <code>row_stack()</code> 和 <code>column_stack()</code> ，从名字上也可以看出来它们分别用于拼接行和列。</p>

<p>与此类似，<code>dstack()</code> 函数用于将三维数组沿着高度作拼接。</p>

<p><code>stack()</code> 有时也用于拼接数组，其特点是拼接得到的结果必定比原数组高一个维度：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>stack<span style="color: #39adb5;">([</span>m2<span style="color: #39adb5;">,</span> m2<span style="color: #39adb5;">],</span> <span style="color: #e53935;">axis</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[[0, 1, 2],
        [0, 1, 2]],

       [[3, 4, 5],
        [3, 4, 5]]])</div>
</div>

<h3>数组的拆分</h3>

<p>与拼接过程相反的是分裂。分裂主要通过以下函数来实现：</p>

<table>
    <tr>
        <th>函数</th>
        <th>效果</th>
    </tr>
    <tr>
        <td><code>split(<em>arr</em>, <em>indices_or_sections</em>, <em>axis</em>)</td>
        <td>分裂成多个数组</td>
    </tr>
    <tr>
        <td><code>hsplit(<em>arr</em>, <em>indices_or_sections</em>)</code></td>
        <td>沿水平方向分裂，即分裂数组的列</td>
    </tr>
    <tr>
        <td><code>vsplit(<em>arr</em>, <em>indices_or_sections</em>)</code></td>
        <td>沿垂直方向分裂，即分裂数组的行</td>
    </tr>
    <tr>
        <td><code>dsplit(<em>arr</em>, <em>indices_or_sections</em>)</code></td>
        <td>沿第三个维度分裂，即分裂数组的高</td>
    </tr>
</table>

<p>可以向以上函数传递一个索引列表作为参数，索引列表记录的是分裂点的位置：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a6 <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span></div><div>sub1, sub2, sub3 <span style="color: #7c4dff;">=</span> np.split<span style="color: #39adb5;">(</span>a6, <span style="color: #39adb5;">[</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">])</span></div><div><span style="color: #f76d47;">print</span>(sub1, sub2, sub3)</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[1 2 3] [4 4] [3 2 1]</div>
</div>

<p>每遇到对应位置便会拆出一个新数组，因此 N 个分裂点会得到 N+1 个子数组。</p>

<p>高维数组的分裂可以使用 <code>axis</code> 参数指定分裂的维度，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>sub4<span style="color: #39adb5;">,</span> sub5<span style="color: #39adb5;">,</span> sub6 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>split<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">),</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">],</span> <span style="color: #e53935;">axis</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div><div>sub4</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[0],
       [6]])</div>
</div>

<p>下图指出了“在 <code>axis=1</code> 轴上分裂”的原理：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/10/02-array-split.png" alt="" width="360">
</figure>

<p>相关的 <code>hsplit()</code> 和 <code>vsplit()</code> 的用法也类似：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>m3 <span style="color: #7c4dff;">=</span> np.arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">16</span><span style="color: #39adb5;">)</span>.reshape<span style="color: #39adb5;">(</span>(<span style="color: #f76d47;">4</span>, <span style="color: #f76d47;">4</span>)<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>upper, lower <span style="color: #7c4dff;">=</span> np.vsplit<span style="color: #39adb5;">(</span>m3, <span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div><div><span style="color: #f76d47;">print</span>(upper)</div><div><span style="color: #f76d47;">print</span>(lower)</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[[0 1 2 3]
 [4 5 6 7]]
[[ 8  9 10 11]
 [12 13 14 15]]</div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>left, right <span style="color: #7c4dff;">=</span> np.hsplit<span style="color: #39adb5;">(</span>m3, <span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div><div><span style="color: #f76d47;">print</span>(left)</div><div><span style="color: #f76d47;">print</span>(right)</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[[ 0  1]
 [ 4  5]
 [ 8  9]
 [12 13]]
[[ 2  3]
 [ 6  7]
 [10 11]
 [14 15]]</div>
</div>

<p>同样，<code>dsplit()</code> 函数将沿着第三个维度分裂。</p>
<p><a rel="nofollow" href="/archives/777">Python数据分析-numpy02:数组变形与组合</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/777/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-numpy01:数组操作</title>
		<link>/archives/772</link>
					<comments>/archives/772#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 28 Sep 2022 05:02:49 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=772</guid>

					<description><![CDATA[<p>NumPy简介 NumPy（Numerical Py&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/772">Python数据分析-numpy01:数组操作</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>NumPy简介</h2>

<p>NumPy（Numerical Python 的简称）提供了高效存储和操作密集数据缓存的接口。在某些方面，NumPy 数组与 Python 内置的列表类型非常相似。但是随着数组在维度上变大，NumPy 数组提供了更加高效的存储和数据操作。</p>

<p>Python 的列表为了兼顾更多的情况，在运算时需要包含大量的额外信息，这不但占用大量的内存，还会造成遍历、修改与重排的速度都非常缓慢。NumPy 的数组在存储和运算上都比 Python 的列表更加高效。</p>

<p>NumPy 是 Python 在数据科学中最常用，也是最基础的库。后续介绍的许多科学计算库，都是基于 NumPy 建立的。</p>

<p>可以使用 <code>pip</code> 来安装 NumPy ：</p>

<div class="codeblock code-console">$ pip install numpy
</div>

<p>安装完成后，可以在命令行中检查是否成功安装，并查看安装的版本：</p>

<div class="codeblock code-console">>>> import numpy
>>> numpy.__version__
'1.21.1'    
</div>

<p>一般来说，工程中使用以下的方式在导入 NumPy 并重命名为 <code>np</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">import</span> numpy <span style="color: #f76d47;">as</span> np</div></div>
</div>

<p>NumPy 的官方网站为 <a href="https://numpy.org/">https://numpy.org/</a> ，从中可以找到 NumPy 的文档以及各种学习资料。</p>

<h2>创建数组</h2>

<p>构成 <var type="module">numpy</var> 的基础就是它特有的多维数组对象 <code>ndarray</code> 。在介绍如何操作数组对象之前，首先介绍如何创建数组。</p>

<h3>从已有数据创建数组</h3>

<p>可以使用 <code>array()</code> 函数从 Python 的列表对象创建数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([1, 3, 2, 5, 4])</div>
</div>

<p>不同于 Python 列表，<var type="module">numpy</var> 为了确保数组的一致性，要求数组必须包含同一类型的数据。如果类型不匹配，<var type="module">numpy</var> 将会尝试向上转换。例如，整型被转换为浮点型：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">3.14</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">])</span></div></div>
        <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([3.14, 2.  , 6.  ])</div>
</div>

<p>如果希望明确设置数组的数据类型，可以用 <code>dtype</code> 参数指定：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">]</span>, <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">float32</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div></div>
        <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([1., 2., 3., 4.], dtype=float32)</div>
</div>

<p><var type="module">numpy</var> 可用的数据类型将在之后介绍。</p>

<p><var type="module">numpy</var> 数组可以被指定为多维的。以下是用嵌套列表从初始化创建多维数组的一种方法：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.array<span style="color: #39adb5;">([</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span>i, i <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span> <span style="color: #39adb5;font-weight: bold;">for</span> i <span style="color: #7c4dff;">in</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">]])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[2, 3, 4],
       [4, 5, 6],
       [6, 7, 8]])</div>
</div>

<p>内层的列表被当作二维数组的行。</p>

<h3>从头创建数组</h3>

<p>如果需要创建包含大量有规律数据的数组，用 <var type="module">numpy</var> 内置的函数从头创建数组是一种更高效的方法。</p>

<p>可以使用 <code>zeros(<em>shape</em>)</code> 函数来创建数组，其中的每个元素都是 0 ；或者可以使用 <code>ones(<em>shape</em>)</code> 函数来创建每个元素都是 1 的数组。</p>

<p>以下创建一个长度为 9 的数组，数组的值都是 0 ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">9</span>, <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">int</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">np.zeros(9, dtype=int)</div>
</div>

<p>还可以使用 <code>full(<em>shape</em>, <em>fill_value</em>)</code> 函数来利用某一数据创建数组，其用法和上面两个函数类似。这些从头创建数组的函数都具有一个参数 <code>shape</code> ，可以通过一个数值指定一维数组的长度，还可以通过元组或列表指定多维数组的形状（数组每个维度的长度）。该参数有时候也写作 <code>size</code></p>

<p>例如，以下创建了一个 3×4 的浮点型数组，数组的值都是 3.14 ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>full<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">),</span> <span style="color: #f76d47;">3.14</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[3.14, 3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14, 3.14]])</div>
</div>

<hr>

<p>除了从单一元素创建数组，也可以按照一定规律创建数组。</p>

<p>可以利用 <code>arange()</code> 函数创建一个数组，它和 Python 内置的 <code>range()</code> 函数类似，都有 <code>start</code> 、<code>stop</code> 、<code>step</code> 三个参数，并且部分参数可以省略：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span>, <span style="color: #f76d47;">14</span>, <span style="color: #f76d47;">2</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 0,  2,  4,  6,  8, 10, 12])</div>
</div>

<p><code>linspace()</code> 函数与之类似，只不过它包含起点和终点，第三个参数是数组元素个数，以此自动分割区间并计算步长：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.linspace<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span>, <span style="color: #f76d47;">2</span>, <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0. , 0.5, 1. , 1.5, 2. ])</div>
</div>

<h3>随机数数组</h3>

<p><var type="module">numpy</var> 的 <var type="module">random</var> 模块提供了随机数函数，可以用于创建随机数组。</p>

<p><code>np.random</code> 模块和 Python 标准库中的随机数函数具有一定的相似之处，下表列出了 <><var type="module">np.random</var> 中内容相似的函数：</>

<table>
    <tr>
        <th>函数</th>
        <th>说明</th>
    </tr>
    <tr>
        <td><code>seed(<em>seed</em>)</code></td>
        <td>设置随机种子</td>
    </tr>
    <tr>
        <td><code>random(<em>size</em>:tuple)</code></td>
        <td>创建在 0~1 范围内的随机小数组成的数组</td>
    </tr>
    <tr>
        <td><code>randint(<em>low</em>, <em>higt</em>, <em>size</em>)</code></td>
        <td>创建范围内随机整数构成的数组。与标准库不同的是，它不包含 <code><em>high</em></code> 端点的整数</td>
    </tr>
    <tr>
        <td><code>uniform(<em>low</em>, <em>higt</em>, <em>size</em>)</code></td>
        <td>创建 low~high 范围内的随机小数组成的数组</td>
    </tr>
    <tr>
        <td><code>choice(<em>a</em>, <em>size</em>, <em>replace</em>, <em>p</em>)</code></td>
        <td>按照指定概率从序列中抽取一个元素组成数据，参数 <code><em>replace</em></code> 决定是否包含重复元素</td>
    </tr>
    <tr>
        <td><code>shuffle(<em>a</em>)</code></td>
        <td>打乱数组顺序（会改变原数组）</td>
    </tr>
</table>

<p>以下是几个简单的示例：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">(</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[0, 3, 1, 0],
       [2, 1, 2, 0]])</div>
    <div class="jupyter-seperator"></div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>choice<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">7</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([6, 9, 1, 0, 1, 8, 8])</div>
</div>

<p>除了纯粹随机的数组，<var type="module">numpy</var> 还可以使用 <code>normal(<em>loc</em>, <em>scale</em>, <em>size</em>)</code> 函数来创建一个正态分布的随机数数组，参数 <code><em>loc</em></code> 代表均值，<code><em>scale</em></code> 代表方差：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np.random.normal<span style="color: #39adb5;">(</span><span style="color: #f76d47;">0</span>, <span style="color: #f76d47;">1</span>, (<span style="color: #f76d47;">2</span>, <span style="color: #f76d47;">3</span>)<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[ 0.39728546,  1.07566559, -1.65804868],
       [ 0.60838938,  1.91130974,  1.40033962]])</div>
</div>

<p>或者使用 <code>randn(<em>size</em>)</code> 创建服从标准正态分布的随机数数组。</p>

<p>还可以基于 <code>RandomState</code> 类根据种子创建一个随机的状态，再由该随机状态创建随机数组。这样做可以防止使全局随机状态被污染：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>rand <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>RandomState<span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span><span style="color: #39adb5;">)</span></div><div>rand<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">(</span><span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0.77132064, 0.02075195, 0.63364823, 0.74880388, 0.49850701])</div>
</div>

<p>除此之外，还有一些特殊的函数：<code>eye(<code>n</code>)</code> 可以创建一个阶数为 <code><em>n</em></code> 的单位矩阵数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>eye<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])</div>
</div>

<p><code>empty(<em>shape</em>)</code> 可以创建一个空数组，但不初始化，因此得到的元素可能是内存中的任意值。</p>

<h2>NumPy数据类型</h2>

<p><var type="module">numpy</var> 数组需要包含同一类型的值。由于 <var type="module">numpy</var> 是在C语言的基础上开发的，因此这些数据类型类似C语言对应的数据类型。</p>

<p>标准的 <var type="module">numpy</var> 数据类型可以在 <a href="https://numpy.org/doc/stable/user/basics.types.html">https://numpy.org/doc/stable/user/basics.types.html</a> 中查到，下表列出了一些比较典型的示例：</p>

<table>
    <tr>
        <th>数据类型</th><th>描述</th>
    </tr>
    <tr>
        <td><code>bool_</code></td><td>布尔值（真/ <code>True</code> 或假/ <code>False</code> ），用一个字节存储</td>
    </tr>
    <tr>
        <td><code>intc</code></td><td>同C语言的 <code>int</code> 相同，且由平台指定具体位数</td>
    </tr>
    <tr>
        <td><code>intp</code></td><td>用作索引的整型（和C语言的 <code>ssize_t</code> 相同，且由平台指定具体位数</td>
    </tr>
    <tr>
        <td><code>int8</code></td><td>8 位整数（字节，范围从 –128 到 127 ）</td>
    </tr>
    <tr>
        <td><code>uint16</code></td><td>无符号整数（范围从 0 到 65535 ）</td>
    </tr>
    <tr>
        <td><code>float32</code></td><td>32 位浮点数（1 位符号，8 位指数，23 位尾数）</td>
    </tr>
    <tr>
        <td><code>complex128</code></td><td>由两个 64 位浮点数表示的复数</td>
    </tr>
</table>

<p>当构建一个数组时，可以用一个字符串参数来指定数据类型：</p>

<div class="vscode-block"><div>np.zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span>, <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">int16</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div></div>

<p>或者用相关的 <var type="module">numpy</var> 对象来指定：</p>

<div class="vscode-block"><div>np.zeros<span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span>, <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>np.int16<span style="color: #39adb5;">)</span></div></div>

<p>还可以使用更高级的数据类型，例如指定高位字节数或低位字节数。<var type="module">numpy</var> 也支持复合数据类型，将在后续介绍。</p>

<p>一个数组的数据类型保存在它的 <code>.dtype</code> 属性中。不过如果要修改数组的数据类型，不能直接修改该属性，而是要调用数组的 <code>.astype()</code> 方法：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>arr <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>random<span style="color: #39adb5;">.</span>randint<span style="color: #39adb5;">(</span><span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">))</span></div><div>arr<span style="color: #39adb5;">.</span>astype<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>float32<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[2., 6., 0., 9.],
       [2., 6., 6., 2.]], dtype=float32)</div>
</div>

<p>这个操作会得到一个新的数组，不改变原有数组的数据类型。</p>
<p><a rel="nofollow" href="/archives/772">Python数据分析-numpy01:数组操作</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/772/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
