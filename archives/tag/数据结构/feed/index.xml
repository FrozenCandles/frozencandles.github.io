<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>数据结构归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/feed?simply_static_page=3770" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Mon, 12 Dec 2022 11:33:25 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>数据结构归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>数据结构08-图</title>
		<link>/archives/743</link>
					<comments>/archives/743#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 15 Sep 2022 03:41:15 +0000</pubDate>
				<category><![CDATA[数据结构与算法]]></category>
		<category><![CDATA[数据结构]]></category>
		<category><![CDATA[算法]]></category>
		<guid isPermaLink="false">/?p=743</guid>

					<description><![CDATA[<p>图存储结构 图结构简介 在之前的章节中已经见过了一对&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/743">数据结构08-图</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>图存储结构</h2>

<h3>图结构简介</h3>

<p>在之前的章节中已经见过了一对一和一对多的数据结构，它们分别可以使用<a href="/archives/586">线性表</a>和<a href="/archives/622">树</a>来描述。本节介绍一种典型的多对多数据结构：<strong>图</strong>(graph)。</p>

<p>下面展示了一个简单的图结构，可以看出每两个数据之间都可能有对应关系：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-graph-concept.png" alt="" width="260">
</figure>

<p>这种对应关系使得图不能简单地使用节点和指针表示，否则一个节点需要大量空间来表示这种对多的关系。在介绍图的表示方法之前，可以了解一下图的定义。</p>

<h3>图的若干定义</h3>

<p>一个图 <span class="math">\\( G=(V,E) \\)</span> 由<strong>顶点</strong>(vertex)集合 <span class="math">\\( V \\)</span> 和<strong>边</strong>(edge)集合 <span class="math">\\( E \\)</span> 组成。顶点类似于树节点的概念，边是一对顶点的关联 <span class="math">\\( (v, w) \\)</span> 其中 <span class="math">\\( v, w \in V \\)</span> ，边有时也称为<strong>弧</strong>(arc)。</p>

<p>有时候顶点之间并不是双向联系，而是像树一样的单方面指向，这种图称为<strong>有向图</strong>(digraph)。有向图的顶点对是有序的。下面展示了一个有向图，每两个数据之间的对应关系可能是指向也可能是被指向：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-digraph-concept.png" alt="" width="220">
</figure>

<p>有向图中顶点的<strong>入度</strong>(indegree)指的是箭头指向它的数量，而<strong>出度</strong>(outdegree)指的是它指出的箭头数量。</p>

<p>两个顶点 <span class="math">\\( v \\)</span> 和 <span class="math">\\( w \\)</span> <strong>邻接</strong>(adjacent)指的是边 <span class="math">\\( (v, w) \in E \\)</span> ，即两个顶点之间有直接连接（且符合指向顺序）的边。</p>

<p>一个边有时也具有<strong>值</strong>(cost)或称为<strong>权</strong>(weight)。例如在一个地图中，两个地点（顶点）之间路线（边）的权可以反映它们的距离。</p>

<p>图的一条<strong>路径</strong>(path)从一个顶点到另一顶点途经的所有顶点组成的序列，用数学描述就是是一个顶点序列 <span class="math">\\( w_1, w_2, \dots, w_N \\)</span> 使得 <span class="math">\\( (w_i, w_{i+1}) \in E \\)</span> 。从一个顶点到自身可以看作一条路径，这种路径不包含边，路径长为 0 。</p>

<p>如果一个顶点到其自身存在一条边 <span class="math">\\( (v, v) \\)</span> ，那么路径 <span class="math">\\( v,v \\)</span> 称为<strong>环</strong>(loop)，一般来说很少有图的应用需要有这种直接与自身有关联的顶点。</p>

<p>与环相似的概念是<strong>圈</strong>(cycle)，如果路径中第一个顶点和最后一个顶点相同，且路径的长度至少为 1（至少涉及两个顶点），则这样的路径就是圈。对于无向图还要求边之间互不相同，防止在两个顶点间左右横跳被认为是圈。</p>

<p>如果在一个无向图中从每一个顶点到其它顶点中都存在一条路径，则称该无向图是<strong>连通</strong>(connected)的。具有这样性质的有向图称为<strong>强连通</strong>(strongly connected)的；如果它不具备这样的性质，但它的边去掉方向所退化为的无向图是连通的，那么该有向图是<strong>弱连通</strong>(weakly connected)的。一个比较典型的实例是航空系统，如果航空网络构成的图是强连通的，那么说明从任意一个航站到另一个航站都只需要若干次换乘；否则还需要借助其它交通方式才能到达。</p>

<h3>图的实现</h3>

<p>下面以有向图为例说明图的实现。无向图可以看作每一条边都是双向连接的有向图。</p>

<p>表示图的一种最简单的方式是使用二维数据，一个维度存储这些顶点，另一个维度存储顶点之间的对应关系：如果存在边 <span class="math">\\( (u, v) \\)</span> ，那么就置 <span class="math">\\( A[u][v] \\)</span> 为 1 或它的权；否则将其清零或使用 <span class="math">\\( \infty \\)</span> 等表示。</p>

<p>这种二维数组称为<strong>邻接矩阵</strong>(adjacency matrix)，使用邻接矩阵表示图易于理解，且对无向图来说由于指向具有对称性，存储时可以采用上三角或下三角矩阵进一步压缩空间。</p>

<p>然而邻接矩阵的空间要求还是太多了，它的空间复杂度为 <span class="math">\\( O(|V|^2) \\)</span> ，除非图中顶点间的关联基本都存在，否则邻接矩阵的大多数位置都不会被用到。</p>

<p>如果要提高空间利用率，那么就需要只存储存在的数据而不存储不存在的数据。那么就可以使用链表这种长度可以灵活调整的数据结构：对于每一个顶点，使用一个链表存放所有邻接的顶点，这样空间需求只为 <span class="math">\\( O(|V|+|E|) \\)</span> 。这种图的表现形式称为<strong>邻接表</strong>(adjacency list)。</p>

<p>以下展示了图的邻接表表示方法，左侧是图的直观结构：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-adjacency-list.png" alt="" width="570">
</figure>

<p>可以看到这种结构类似于分离链接散列表。邻接表是表示图的基本方法，接下来的操作都以邻接表为例。邻接表的定义可以参考如下：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">graph_arc</span> <span token="type">graph_arc</span>;</div><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">graph_vertex</span> {</div><div>&nbsp; &nbsp; <span token="type">elemtype</span> <span style="color: #7fdbca;">data</span>;</div><div>&nbsp; &nbsp; <span token="type">graph_arc</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">firstarc</span>;</div><div>} <span token="type">graph_vertex</span>;</div><div><span token="keyword">struct</span> <span token="type">graph_arc</span> {</div><div>&nbsp; &nbsp; <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">vertex</span>;</div><div>&nbsp; &nbsp; <span token="keyword">struct</span> <span token="type">graph_arc</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">nextarc</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">weight</span>;</div><div>};</div><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">graph</span> {</div><div>&nbsp; &nbsp; <span token="type">graph_vertex</span><span style="color: #7fdbca;">**</span> <span style="color: #7fdbca;">vertices</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">vertex_num</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">arc_num</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">size</span>;</div><div>} <span style="color: #7fdbca;">*</span> <span token="type">graph</span>;</div></div>

<p>接下来介绍几个关于图的典型问题。</p>

<h2 id="top-sort">拓扑排序</h2>

<p>拓扑排序是一种针对有向图顶点的一种排序，由于有向图有指向关系，因此可以通过该指向关系来为顶点安排先后顺序。</p>

<p>一种典型的拓扑排序应用就是选课流程：为了确保知识的连贯性，有些课程必须学完之后才可以继续学习下一门课程，那么这些课程之间就可以按学习顺序构成一个有向图，使用拓扑排序可以确定如何安排课程。</p>

<p>因此，被排序的图除了是有向的外，还要求它没有圈，不然圈上的元素没有严格的先后关系。</p>

<p>例如，以下图：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-top-sort.png" alt="" width="310">
</figure>

<p>顶点的指向顺序从左向右。特别地，顶点 C 和 D 之间是并列的，没有严格的先后关系，两者任意一个排在前面都可以。因此，以上图的拓扑排序可以有两种结果：</p>

<div class="codeblock code-template">
    A→B→C→D→E<br>
    A→B→D→C→E
</div>

<p>拓扑排序的思路也很简单：如果一个顶点可以排在最前面，那么应该没有顶点指向它，即它的入度为 0 ；那么只需要找出入度为 0 的顶点，然后将它和它指出的边暂时排除，继续寻找下一个符合条件（入度为 0 ）的顶点即可。以下展示了这一步骤：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-top-sort-steps.png" alt="" width="560">
</figure>

<p>以上算法可以做一个小的优化：每一次查找入度为 0 的顶点都花费 <span class="math">\\( O(|V|) \\)</span> 的时间，但只取出一个顶点做处理，如果下一次还是遍历图去寻找入度为 0 的顶点，会使得算法的运行时间达到了平方级 <span class="math">\\( O(|V|^2) \\)</span> 。在第一次扫描时，可以将入度为 0 的顶点放入一个表中，然后逐个取出表中的顶点，检查它指向的顶点入度减 1 后是否为 0 ：只要一个顶点的入度降为 0 ，说明去除那些指向它的顶点后它就可以作为下一位置的顶点，可以同样地将它放入表中继续处理。</p>

<p>这样就只需一次扫描顶点和边并建立表，使执行时间可以变为 <span class="math">\\( O(|V|+|E|) \\)</span> 。这种表可以使用栈或队列。这里使用<a href="/archives/609#queue">队列</a>以实现顺序处理。</p>

<p>拓扑排序的代码实现为：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">TopSort</span>(<span token="type">graph</span> <span style="color: #d7dbe0;">g</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">indegree</span>[<span style="color: #82aaff;">VERTEX_MAXNUM</span>];</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">memset</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">&amp;</span><span token="variable">indegree</span><span style="color: #82aaff;">, </span><span token="number">0</span><span style="color: #82aaff;">, </span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;"> </span><span token="variable">indegree</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">Graph_GatherInDegree</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">g</span><span style="color: #82aaff;">, </span><span token="variable">indegree</span><span style="color: #82aaff;">)</span>;</div><br><div>&nbsp; &nbsp; <span token="type">queue</span> <span token="variable">q</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Queue_New</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;">VERTEX_MAXNUM</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">size</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">indegree</span>[<span token="variable">i</span>] <span style="color: #c792ea;">==</span> <span token="number">0</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">Queue_Enqueue</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">g</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">vertices</span><span style="color: #82aaff;">[</span><span token="variable">i</span><span style="color: #82aaff;">]-&gt;</span><span style="color: #7fdbca;">data</span><span style="color: #82aaff;">)</span>;</div><br><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">counter</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; <span token="keyword">while</span> (<span style="color: #c792ea;">!</span><span style="color: #82aaff;">Queue_IsEmpty</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">)</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span token="variable">v</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Graph_GetVertexByData</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">g</span><span style="color: #82aaff;">, </span><span style="color: #82aaff;">Queue_Dequeue</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">))</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">printf</span><span style="color: #82aaff;">(</span><span style="color: #d9f5dd;">"</span><span style="color: #82aaff;">%d</span><span style="color: #ecc48d;"> &gt;</span><span style="color: #d9f5dd;">"</span><span style="color: #82aaff;">, </span><span token="variable">v</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">data</span><span style="color: #82aaff;">)</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> print in topological order</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">counter</span><span style="color: #c792ea;">++</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">for</span> (<span token="type">graph_arc</span><span style="color: #7fdbca;">*</span> <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">v</span>-&gt;<span style="color: #7fdbca;">firstarc</span>; <span token="variable">arc</span>; <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">nextarc</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span token="variable">w</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #7fdbca;">--</span><span token="variable">indegree</span>[<span style="color: #82aaff;">Graph_GetVertexIndex</span>(<span style="color: #d7dbe0;">g</span>, <span token="variable">w</span>)] <span style="color: #c792ea;">==</span> <span token="number">0</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">Queue_Enqueue</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">, </span><span token="variable">w</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">data</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">counter</span> <span style="color: #c792ea;">!=</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertex_num</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">warning</span><span style="color: #82aaff;">(</span><span style="color: #d9f5dd;">"</span><span style="color: #ecc48d;">Graph has a cycle</span><span style="color: #d9f5dd;">"</span><span style="color: #82aaff;">)</span>;</div><br><div>&nbsp; &nbsp; <span style="color: #82aaff;">Queue_Delete</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">)</span>;</div><div>}</div></div>

<p>由于图的实现比较复杂，本节涉及到的代码一般会将一些细节抽象为函数，使用类似伪代码的形式展现。如果要获取包括拓扑排序在内的完整图论算法实现，以及图的创建等其它操作实现，可以访问 <a href="https://github.com/FrozenCandles/example-code/blob/master/DataStructure/Src/graph.c">GitHub 仓库</a>。</p>

<p>这个程序比较复杂，它可以分为几个部分理解。在计算入度时，由于邻接表只记录一个顶点指出的边，因此要计算入度时需要遍历所有的顶点才能完整得出指向一个顶点的所有边。这里使用一个数组 <code>indegree[]</code> 在一次遍历时便统计出所有顶点的边，加快运行的同时方便处理。</p>

<p>由于图中可能存在圈，但无法通过简单的方式来判断。不过如果存在圈，圈上的顶点就不会降到 0 ，使得它们不会被排序。那么最后只需要判断排序的顶点数是否等于图中包含的顶点数，就知道图中是否存在圈了。</p>

<h2>图的遍历</h2>

<p>遍历也是图常用的一种操作。遍历的要求是从图中的某一个顶点开始，访问每个路径上能到达的顶点且每个顶点应该只访问一次。遍历可以用于规划路线、安排流量、计算其它数学量等。</p>

<h3>深度优先搜索</h3>

<p><strong>深度优先搜索</strong>(depth-first search, DFS)的原理是从某个顶点搜索时，当搜索到下一个顶点时，再递归地从下一个顶点继续搜索下一个顶点。</p>

<p>下图展示了深度优先搜索某一时刻顶点的搜索情况，可以看出远处的顶点可能会被先搜索到：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-DFS.png" alt="" width="360">
</figure>

<p>深度优先搜索可以使用递归的形式来求解。另外为了让每个顶点只遍历一次，还需要有一个额外的顶点字段或数组记录顶点是否被访问过。</p>

<p>以下代码是深度优先搜索的一个通用形式：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">Graph_DepthFirstSearch</span>(<span token="type">graph</span> <span style="color: #d7dbe0;">g</span>, <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">v</span>) {</div><div>&nbsp; &nbsp; <span token="variable">visited</span>[<span style="color: #d7dbe0;">v</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">true</span>;</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="type">graph_arc</span><span style="color: #7fdbca;">*</span> <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">v</span>-&gt;<span style="color: #7fdbca;">firstarc</span>; <span token="variable">arc</span>; <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">nextarc</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span token="variable">w</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span token="variable">visited</span>[<span token="variable">w</span>-&gt;<span style="color: #7fdbca;">data</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">Graph_DepthFirstSearch</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">g</span><span style="color: #82aaff;">, </span><span token="variable">w</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; }</div><div>}</div></div>

<p>值的注意的是，如果图是无向不连通或有向弱连通的，未必所有顶点都会在此过程中访问到。</p>

<h3>广度优先搜索</h3>

<p>深度优先搜索的缺点是有时要搜索的顶点可能离它较近，但程序可能会花费很多不必要的时间处理更远的顶点。这在图很大时不利于处理较近的顶点。<strong>广度优先搜索</strong>(breadth-first search)则优先处理较近的顶点，然后再处理更远的顶点。</p>

<p>广度优先搜索的原理为：从某一顶点开始搜索时，遍历每一个顶点时，依次遍历其所有的邻接点，然后再从这些邻接点出发，同样依次访问它们的邻接点。按照此过程，直到图中所有被访问过的顶点的邻接点都被访问到。</p>

<p>下图展示了广度优先搜索某一时刻顶点的搜索情况，搜索的顶点从起点开始向外辐射展开：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-BFS.png" alt="" width="360">
</figure>

<p>广度优先搜索需要在访问一批顶点时保存这些顶点的信息，这样下一次才能向外拓展一层。保存已访问但还没向外拓展的顶点可以使用队列来实现，并且使用队列可以让先向外拓展的顶点下一次也先向外拓展。</p>

<p>以下代码是广度优先搜索的一个通用形式：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">Graph_BreadthFirstSearch</span>(<span token="type">graph</span> <span style="color: #d7dbe0;">g</span>, <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">v</span>) {</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">bool</span> <span token="variable">visited</span>[<span style="color: #d7dbe0;">g</span>-&gt;<span token="variable">size</span>];</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">memset</span><span style="color: #82aaff;">(</span><span token="variable">visited</span><span style="color: #82aaff;">, </span><span token="number">0</span><span style="color: #82aaff;">, </span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;"> </span><span token="variable">visited</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="type">queue</span> <span token="variable">q</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Queue_New</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;">VERTEX_MAXNUM</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span token="variable">visited</span>[<span style="color: #d7dbe0;">v</span>-&gt;<span style="color: #7fdbca;">data</span>]) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">visited</span>[<span style="color: #d7dbe0;">v</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">true</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">Queue_Enqueue</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">v</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">data</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">while</span> (<span style="color: #c792ea;">!</span><span style="color: #82aaff;">Queue_IsEmpty</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">)</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span token="variable">w</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Graph_GetVertexByData</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">g</span><span style="color: #82aaff;">, </span><span style="color: #82aaff;">Queue_Dequeue</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">))</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">for</span> (<span token="type">graph_arc</span><span style="color: #7fdbca;">*</span> <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">w</span>-&gt;<span style="color: #7fdbca;">firstarc</span>; <span token="variable">arc</span>; <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">nextarc</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span token="variable">visited</span>[<span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>-&gt;<span style="color: #7fdbca;">data</span>]) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">visited</span>[<span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">true</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">Queue_Enqueue</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">, </span><span token="variable">arc</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">vertex</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">data</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">Queue_Delete</span><span style="color: #82aaff;">(</span><span token="variable">q</span><span style="color: #82aaff;">)</span>;</div><div>}</div></div>

<p>图的两种遍历方式各有侧重点，它们都有比较典型的应用。</p>

<h2>最短路径算法</h2>

<p>图的顶点之间会互相联系，形成一种网状结构。这个时候查找两个顶点之间的最短路径就是一个常见的问题。例如，导航和游戏在寻路时都需要在地图上的两点内规划一条最短的路线。</p>

<h3>无权图的最短路径</h3>

<p>无权图在寻找最短路径时只需要考虑边的条数，而不需要考虑边的权重，因此这种情况实现起来比较简单：在计算顶点 <span class="math">\\( v_1 \\)</span> 到 <span class="math">\\( v_2 \\)</span> 的最短路径时，只需要使路径上具有最少的边即可。</p>

<p>无权图的最短路径可以使用广度优先搜索的思想解决：广度优先搜索每向外拓展一层，那么路径长便增加 1 ，并且第一次遇到一个顶点时的路径是离起点最短的路径。</p>

<p>可以通过一个附加的顶点字段或数组记录每个顶点离起点的最短路径，并且它可以代替之前使用的 <code>visited[]</code> 数组：在起始时置所有顶点的路径为 -1（无限远），每搜索到一个顶点，只要它是无限远，那就说明没有访问过，将其路径长置为上一级顶点的路径长多 1 。</p>

<p>无权图计算最短路径的实现方式和广度优先算法比较相似。接下来介绍有权图最短路径的算法实现。</p>

<h3>有权图的最短路径</h3>

<p>如果在计算最短路径时要考虑到边上的权，那么计算最短路径就会复杂许多，不过基本的处理思路依然可以参考无权图。</p>

<p>Dijkstra 算法是一个解决有权最短路径问题的较好的算法。该算法和无权最短路径问题一样分阶段执行：每个阶段该算法选择在未访问顶点中路径长 <span class="math">\\( d_v \\)</span> 最小的顶点 <span class="math">\\( v \\)</span> ，并通过该顶点更新邻接顶点的长度：如果从 <span class="math">\\( v \\)</span> 到邻接顶点 <span class="math">\\( w \\)</span> 的路径比从其它顶点到 <span class="math">\\( w \\)</span> 的路径更短，那么就更新 <span class="math">\\( w \\)</span> 最短路径。</p>

<p>例如，假设要在以下有向有权图中寻找从 <span class="math">\\( v_1 \\)</span> 到 <span class="math">\\( v_8 \\)</span> 的最短路径：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Dijkstra-step-1.png" alt="" width="320">
</figure>

<p>那么首先从 <span class="math">\\( v_1 \\)</span> 开始，标记出从它到邻接顶点的路径，并暂时视为最短路径：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Dijkstra-step-2.png" alt="" width="320">
</figure>

<p>然后找到未访问且具有最短路径的顶点，即顶点 <span class="math">\\( v_2 \\)</span> ，再标记出经由它到邻接顶点的路径：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Dijkstra-step-3.png" alt="" width="320">
</figure>

<p>每次更新完邻接顶点的路径后，都继续从未访问的顶点中找出具有最短路径的顶点。</p>

<p>本次找到的顶点为 <span class="math">\\( v_6 \\)</span> ，计算它邻接顶点的路径长时，发现从它到 <span class="math">\\( v_3 \\)</span> 比从已到达的顶点到 <span class="math">\\( v_3 \\)</span> 路径更短，那么就更新到 <span class="math">\\( v_3 \\)</span> 的最短路径：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Dijkstra-step-4.png" alt="" width="320">
</figure>

<p>重复以上步骤，直到确定了 <span class="math">\\( v_1 \\)</span> 与图中所有顶点的最短路径后才结束算法。</p>

<p>例如，接下来两步是处理 <span class="math">\\( v_3 \\)</span> 和 <span class="math">\\( v_4 \\)</span> 顶点并更新它们邻接顶点的路径长：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Dijkstra-step-5.png" alt="" width="320">
</figure>

<p>Dijkstra 算法也可用于处理无向图的最短路径，甚至可以用于处理无权图的最短路径（无权图可以将每条边的权看作 1 ）。</p>

<p>Dijkstra 算法的代码大致实现如下：</p>

<div class="vscode-block"><div><span token="keyword">int</span> <span style="color: #82aaff;">Graph_WeightedPath_Dijkstra</span>(<span token="type">graph</span> <span style="color: #d7dbe0;">g</span>, <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">v</span>, <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">w</span>) {</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">bool</span> <span token="variable">visited</span>[<span style="color: #82aaff;">VERTEX_MAXNUM</span>];</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">minpathlen</span>[<span style="color: #82aaff;">VERTEX_MAXNUM</span>];</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">memset</span><span style="color: #82aaff;">(</span><span token="variable">visited</span><span style="color: #82aaff;">, </span><span token="number">0</span><span style="color: #82aaff;">, </span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;"> </span><span token="variable">visited</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #82aaff;">VERTEX_MAXNUM</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>) <span token="variable">minpathlen</span>[<span token="variable">i</span>] <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">INT_MAX</span>;</div><div>&nbsp; &nbsp; </div><div>&nbsp; &nbsp; <span token="variable">minpathlen</span>[<span style="color: #d7dbe0;">v</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">size</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertices</span>[<span token="variable">i</span>]) <span token="keyword">continue</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">minv</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">minlen</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">INT_MAX</span>;</div><br><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">j</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">j</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">size</span>; <span token="variable">j</span><span style="color: #c792ea;">++</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span token="variable">visited</span>[<span token="variable">j</span>] <span style="color: #c792ea;">&amp;&amp;</span> <span token="variable">minpathlen</span>[<span token="variable">j</span>] <span style="color: #c792ea;">&lt;</span> <span token="variable">minlen</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">minv</span> <span style="color: #c792ea;">=</span> <span token="variable">j</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">minlen</span> <span style="color: #c792ea;">=</span> <span token="variable">minpathlen</span>[<span token="variable">minv</span>];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">visited</span>[<span token="variable">minv</span>] <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">true</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span token="variable">v_k</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Graph_GetVertexByData</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">g</span><span style="color: #82aaff;">, </span><span token="variable">minv</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">for</span> (<span token="type">graph_arc</span><span style="color: #7fdbca;">*</span> <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">v_k</span>-&gt;<span style="color: #7fdbca;">firstarc</span>; <span token="variable">arc</span>; <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">nextarc</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="type">graph_vertex</span><span style="color: #7fdbca;">*</span> <span token="variable">u</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span token="variable">visited</span>[<span token="variable">u</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">&amp;&amp;</span> (<span token="variable">minlen</span> <span style="color: #7fdbca;">+</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">weight</span> <span style="color: #c792ea;">&lt;</span> <span token="variable">minpathlen</span>[<span token="variable">u</span>-&gt;<span style="color: #7fdbca;">data</span>]))</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">minpathlen</span>[<span token="variable">u</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">=</span> <span token="variable">minlen</span> <span style="color: #7fdbca;">+</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">weight</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">minpathlen</span>[<span style="color: #d7dbe0;">w</span>-&gt;<span style="color: #7fdbca;">data</span>];</div><div>}</div></div>

<p>注意一个已计算路径最小值的顶点未必被访问过。</p>

<p>Dijkstra 算法需要花费线性的时间处理完所有顶点；每处理一个顶点，接下来还需要花费线性时间查找未访问顶点的路径最小值，而所有顶点的最小路径长需要遍历所有边才能得出一个确定的结果，因此该算法的时间复杂度为 <span class="math">\\( O(|V|^2+|E|) = O(|V|^2 \\)</span> 。</p>

<p>如果图较为稠密（每两个顶点间基本都有边，<span class="math">\\( |E| \approx |V|^2 \\)</span> ），那么该算法的效率基本已经是最优的了。</p>

<p>否则当边较为稀疏时，以上算法还有优化的空间。优化主要体现在线性时间的最小值查找上，可以借助优先队列（堆）降低查找的时间。由于优先队列的删除最小值需要 <span class="math">\\( O(\log N) \\)</span> 时间，因此使用优先队列的 Dijkstra 算法花费的总时间为 <span class="math">\\( O(|E|\log |V| + |V|\log |V|) = O(|E| log |V|) \\)</span> ，在边数较少时可以加快运行效率。</p>

<p>使用堆存储路径长的缺点是二叉堆不支持查找，难以修改一个顶点的最小路径长。要改进这个问题只能使用更高级的优先队列结构，这里暂不讨论这个问题。</p>

<p>除此之外，Dijkstra 算法在某些情况下也可能失效。例如当边的权为负值的时候，那么一个已访问的顶点并不一定已经计算出最短路径，因为可能从未访问顶点有一条负值很大的路径指向它使得从更远的顶点到这里反而可能变得更短，问题是该顶点已经用于计算邻接顶点的最短路径，不能只更新该顶点的最短路径长。一个最坏的情况下，图中可能有含有负值边的圈，并且这个负值可能很大使得每走完一圈路径反而会变短。如果不处理这种情况很容易会造成无限循环。</p>

<p>无权最短路径和有权最短路径的算法都可以得出最短路径：可以增加一个辅助顶点字段或数组，记录到达该顶点的最短路径的上一个顶点的信息，最后收集这些信息，就可以从目的顶点逆序到达起始顶点。</p>

<h2>最小生成树</h2>

<p><strong>最小生成树</strong>(minimum spanning tree)是一个主要针对无向图的问题。一个无向图的最小生成树就是由图中所有顶点和部分边构成的另一个图，且边的权重之和最小。</p>

<p>例如，以上是上一节示例退化的无向图及其最小生成树：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-minimum-spanning-tree.png" alt="" width="580">
</figure>

<p>最小生成树也有典型的实际应用。例如，假设要在若干地点间建立通信路线，那么需要通过最小生成树来规划建立需要的最短线路长度或最少花费。</p>

<p>最小生成树之所以称为“树”，是因为这样得到的无向图是没有圈的，因此它将退化为树形结构。如果无向图有圈，那么圈上的两个顶点之间就会有两条不一样的路径，但这是不必要的，会增加总的路径长度，只需要保留更短的路径即可。</p>

<p>并且由于无向图是没有圈的，无向图边的条数为 <span class="math">\\( |V| - 1 \\)</span> ，因为除了根之外，每个顶点都需要一条边来接到图中；如果多了一条边，那么某个顶点就会接到图中两次，形成一个不必要的圈。</p>

<p>具有最小生成树的图需要是连通的。计算图的最小生成树有两种常用的算法。</p>

<h3>Prim算法</h3>

<p>Prim 是一种易于理解的最小生成树算法。该算法先将每个顶点独立出来，然后每次从独立的顶点中选择离生成树最近的顶点，将它和它的边插入生成树中。</p>

<p>一开始可以随机选择一个顶点作为生成树的根。下图展示了该算法计算以上图最小生成树的前几步：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Prim-steps.png" alt="" width="440">
</figure>

<p>Prim 算法原理比较直观，但有一些细节需要谨慎处理。Prim 算法的实现可以参照以下思路完成：</p>

<p>该思路要求每个顶点有两个字段：分别记录还不在生成树的顶点离生成树的最近路径长与离生成树最近的顶点。</p>

<p>首先，任取一个顶点放入生成树中，并将其邻接的顶点视为离生成树最近的顶点，更新这些顶点的最近路径长与最近顶点：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Prim-step-1.png" alt="" width="320">
</figure>

<p>每个顶点的最近路径长一开始被置为 <span class="math">\\( \infty \\)</span> 或 <code>INT_MAX</code> 。如果一个顶点的最近路径长为 0 ，那么说明该顶点已经位于生成树中。</p>

<p>接下来每次都选取离生成树最近的顶点，将其插入到生成树中，并更新该顶点邻接的顶点信息。例如，下一次离生成树最近的顶点是 <span class="math">\\( v_2 \\)</span> ，则将其插入生成树中。更新 <span class="math">\\( v_2 \\)</span> 邻接顶点时发现 <span class="math">\\( v_3 \\)</span> 离它比离 <span class="math">\\( v_1 \\)</span> 更近，因此将该顶点的相关字段更新：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Prim-step-2.png" alt="" width="320">
</figure>

<p>下一步继续选择离生成树最近的顶点，依照上述方式插入到生成树中并更新邻接顶点的信息：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Prim-step-3.png" alt="" width="320">
</figure>

<p>Prim 算法的简单代码实现可以参考如下，它与 Dijkstra 算法的实现上非常相似：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">Graph_MinSpanTree_Prim</span>(<span token="type">graph</span> <span style="color: #d7dbe0;">g</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">min_vtx</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertices</span>[<span token="number">0</span>]-&gt;<span style="color: #7fdbca;">data</span>;</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="type">graph_arc</span><span style="color: #7fdbca;">*</span> <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertices</span>[<span token="number">0</span>]-&gt;<span style="color: #7fdbca;">firstarc</span>; <span token="variable">arc</span>; <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">nextarc</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">minpathfrom</span>[<span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">=</span> <span token="variable">min_vtx</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">minpathlen</span>[<span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">weight</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="variable">minpathlen</span>[<span token="variable">min_vtx</span>] <span style="color: #c792ea;">=</span> <span token="number">0</span>;<span style="color: #637777;"> &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> put it in the tree</span></div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; /* Add new edge ( minpathfrom[min_vtx] --- min_len --&gt; min_vtx ) */</span></div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">1</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">size</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertices</span>[<span token="variable">i</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">continue</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">min_len</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">INT_MAX</span>;<span style="color: #637777;"> &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> find the closest vertex</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">j</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">j</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">size</span>; <span token="variable">j</span><span style="color: #c792ea;">++</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">minpathlen</span>[<span token="variable">j</span>] <span style="color: #c792ea;">!=</span> <span token="number">0</span> <span style="color: #c792ea;">&amp;&amp;</span> <span token="variable">minpathlen</span>[<span token="variable">j</span>] <span style="color: #c792ea;">&lt;</span> <span token="variable">min_len</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">min_len</span> <span style="color: #c792ea;">=</span> <span token="variable">minpathlen</span>[<span token="variable">j</span>];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">min_vtx</span> <span style="color: #c792ea;">=</span> <span token="variable">j</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">minpathlen</span>[<span token="variable">min_vtx</span>] <span style="color: #c792ea;">=</span> <span token="number">0</span>;<span style="color: #637777;"> &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> put it in the tree</span></div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; &nbsp; &nbsp; /* update adjacent vertex */</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">for</span> (<span token="type">graph_arc</span><span style="color: #7fdbca;">*</span> <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Graph_GetVertexByData</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">g</span><span style="color: #82aaff;">, </span><span token="variable">min_vtx</span><span style="color: #82aaff;">)</span>-&gt;<span style="color: #7fdbca;">firstarc</span>; <span token="variable">arc</span>; <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">nextarc</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">minpathlen</span>[<span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">!=</span> <span token="number">0</span> <span style="color: #c792ea;">&amp;&amp;</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">weight</span> <span style="color: #c792ea;">&lt;</span> <span token="variable">minpathlen</span>[<span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>-&gt;<span style="color: #7fdbca;">data</span>]) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">minpathfrom</span>[<span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">=</span> <span token="variable">min_vtx</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">minpathlen</span>[<span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>-&gt;<span style="color: #7fdbca;">data</span>] <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">weight</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div><div>}</div></div>

<p>该算法的复杂度分析也和 Dijkstra 算法一致：不使用优先队列时复杂度为 <span class="math">\\( O(|V|^2) \\)</span> ，使用优先队列的复杂度为 <span class="math">\\( O(|E|\log |V|) \\)</span> 。</p>

<h3>Kruskal算法</h3>

<p>Kruskal 是另一种计算最小生成树的算法，它的实现较为简单：同样将顶点独立出来并向其中添加边，每次都从图中的所有边选取权重最小的边，如果加上该边后的图不会形成圈，则说明该边是最小生成树的一部分。</p>

<p>还是以上面那个图为例，首先选择权重最小的边加入图中：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Kruskal-step-1.png" alt="" width="320">
</figure>

<p>然后继续选择未添加的权重最小的边尝试放入图中：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Kruskal-step-2.png" alt="" width="320">
</figure>

<p>继续添加边，但添加边 <span class="math">\\( (v_1, v_4) \\)</span> 时发现会形成圈，因此需要抛弃该边：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Kruskal-step-3.png" alt="" width="320">
</figure>

<p>重复以上步骤即可建立最小生成树。</p>

<p>Kruskal 算法也不难理解，不过实现时也有很多细节要注意。最大的问题是如何判断添加边后是否会形成圈：如果为连通图中的某个顶点添加一条边会形成圈，那么说明该边指向的还是这一连通图。那么只需要将图中的连通部分各做一个独立的标记，如果准备插入一个边时发现该边的两端同属一个连通图，那么就说明插入该边会产生圈。</p>

<p>例如，以上是某个图调用 Kruskal 算法的中间结果，它形成了三个互相独立的连通图：（这里使用不同颜色作为连通图的标记）</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/11-Kruskal-has-cycle.png" alt="" width="290">
</figure>

<p>如果要向顶点 <span class="math">\\( v_4 \\)</span> 和 <span class="math">\\( v_6 \\)</span> 之间插入一条边，那么就需要先判断这两个顶点的标记是否相同：如果相同，说明它们属于同一个连通图，两者已经存在了一条路径，再向它们之间插入一条边，则又增加了一条路径，使得无向图产生了一个圈。</p>

<p>Kruskal 算法大致可以由以下方式实现：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">Graph_MinSpanTree_Kruskal</span>(<span token="type">graph</span> <span style="color: #d7dbe0;">g</span>) {</div><br><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">size</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>)<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> collect arcs</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertices</span>[<span token="variable">i</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">for</span> (<span token="type">graph_arc</span><span style="color: #7fdbca;">*</span> <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertices</span>[<span token="variable">i</span>]-&gt;<span style="color: #7fdbca;">firstarc</span>; <span token="variable">arc</span>; <span token="variable">arc</span> <span style="color: #c792ea;">=</span> <span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">nextarc</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">arcs</span>[<span token="variable">arcs_ptr</span><span style="color: #c792ea;">++</span>] <span style="color: #c792ea;">=</span> (<span token="keyword">struct</span> <span token="type">_graph_arc</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .from<span style="color: #c792ea;">=</span><span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertices</span>[<span token="variable">i</span>]-&gt;<span style="color: #7fdbca;">data</span>, .to<span style="color: #c792ea;">=</span><span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">vertex</span>-&gt;<span style="color: #7fdbca;">data</span>, .weight<span style="color: #c792ea;">=</span><span token="variable">arc</span>-&gt;<span style="color: #7fdbca;">weight</span> };</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">qsort</span><span style="color: #82aaff;">(</span><span token="variable">arcs</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">g</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">arc_num</span><span style="color: #82aaff;">, </span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span token="keyword">struct</span><span style="color: #82aaff;"> </span><span style="color: #82aaff;text-decoration: underline;">_graph_arc</span><span style="color: #82aaff;">), </span><span style="color: #82aaff;">CompareByWeight</span><span style="color: #82aaff;">)</span>;</div><br><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">arcs_inserted</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">arc_num</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">conn_mark</span>[<span token="variable">arcs</span>[<span token="variable">i</span>].<span token="variable">from</span>] <span style="color: #c792ea;">!=</span> <span token="variable">conn_mark</span>[<span token="variable">arcs</span>[<span token="variable">i</span>].<span token="variable">to</span>]) {</div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* insert edge (arcs[i].from &lt;-- arcs[i].weight --&gt; arcs[i].to) to tree */</span></div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* union sets between edge */</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">k</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">k</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertex_num</span>; <span token="variable">k</span><span style="color: #c792ea;">++</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">conn_mark</span>[<span token="variable">k</span>] <span style="color: #c792ea;">==</span> <span token="variable">conn_mark</span>[<span token="variable">arcs</span>[<span token="variable">i</span>].<span token="variable">to</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">conn_mark</span>[<span token="variable">k</span>] <span style="color: #c792ea;">=</span> <span token="variable">conn_mark</span>[<span token="variable">arcs</span>[<span token="variable">i</span>].<span token="variable">from</span>];</div><br><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">arcs_inserted</span><span style="color: #c792ea;">++</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">arcs_inserted</span> <span style="color: #c792ea;">==</span> <span style="color: #d7dbe0;">g</span>-&gt;<span style="color: #7fdbca;">vertex_num</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>)<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> minimum spanning tree has created</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">break</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div><div>}</div></div>

<p>以上代码首先收集所有的边（注意如果用邻接表表示无向图的话每条边只应该收集一次），然后对所有边做<a href="/archives/735">排序</a>，以实现从小到大插入合适的边。</p>

<p>在插入前需要判断边两侧顶点的标记是否相同，如果不相同便可插入，插入完成后还需更新两侧连通图的标记为同一连通图。修改标记的方式为：遍历所有顶点标记，将和边一侧顶点相同的标记修改为另一侧的标记。</p>

<p>这种合并方式虽然易于理解，但效率不高。如果要使用更高效的合并，需要使用某些特殊的集合数据结构才能实现。</p>
<p><a rel="nofollow" href="/archives/743">数据结构08-图</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/743/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>数据结构07-排序算法</title>
		<link>/archives/735</link>
					<comments>/archives/735#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 09 Sep 2022 03:09:22 +0000</pubDate>
				<category><![CDATA[数据结构与算法]]></category>
		<category><![CDATA[数据结构]]></category>
		<category><![CDATA[算法]]></category>
		<guid isPermaLink="false">/?p=735</guid>

					<description><![CDATA[<p>本节暂时不讨论数据结构，而是研究算法。排序是一个经典&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/735">数据结构07-排序算法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>本节暂时不讨论数据结构，而是研究算法。排序是一个经典的算法问题，有许多算法都可以用于排序，但是它们各有优缺点。本节讨论各种排序算法并分析其特点。</p>

<p>为了方便起见，本节介绍的排序算法都用于将数组内的元素排序，只要知道其原理就可以将其应用到其余需要的数据结构中。排序的依据是元素的大小。也就是说两个元素可以直接做比较。</p>

<h2>排序算法</h2>

<h3>选择排序</h3>

<p><strong>选择排序</strong>(selection sort)应该是最易于理解的排序算法，早在<a href="/archives/586">第一节</a>中就已经介绍过其原理，这里再次重复一遍：先找出数组的最小元素并移动到数组的起始位置，然后每次都从剩余未排序元素中<em>选择</em>最小元素并放到已排序序列的末尾，直到没有待排序元素为止。</p>

<p>根据以上介绍，选择排序的代码实现如下：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">SelectionSort</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">len</span>) {</div><div>&#160; &#160; <span token="keyword">int</span> <span token="variable">min</span>;</div><div>&#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">len</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>) {</div><div>&#160; &#160; &#160; &#160; <span token="variable">min</span> <span style="color: #c792ea;">=</span> <span token="variable">i</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">j</span> <span style="color: #c792ea;">=</span> <span token="variable">i</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span>; <span token="variable">j</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">len</span>; <span token="variable">j</span><span style="color: #c792ea;">++</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span>] <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">min</span>])</div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="variable">min</span> <span style="color: #c792ea;">=</span> <span token="variable">j</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">array_swap</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="variable">min</span><span style="color: #82aaff;">, </span><span token="variable">i</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; }</div><div>}</div></div>

<p>选择排序是一个典型的时间复杂度为 <span class="math">\\( O(N^2) \\)</span> 的排序算法，因为代码中有两层嵌套的循环，每层循环的次数都与 <span class="math">\\( N \\)</span> 有关，并且循环不会中断。</p>

<p>从原理上理解，不管原始数组如何，代码都需要花费线性时间找出数组的最小值，然后又花费线性时间找出数组的次小值，一共有线性个元素需要寻找，因此时间复杂度为 <span class="math">\\( O(N^2) \\)</span> 。</p>

<p>这种排序算法平平无奇，很难有改进的余地，接下来再看一个同样简单的排序算法：插入排序。</p>

<h3>插入排序</h3>

<p><strong>插入排序</strong>(insertion sort)同样是一种简单的排序算法，其原理是：顺序扫描整个数组，将扫描的每个元素依次<em>插入</em>已排序序列的适当位置。</p>

<p>插入排序的代码实现为：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">InsertionSort</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">len</span>) {</div><div>&#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">len</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>) {</div><div>&#160; &#160; &#160; &#160; <span token="type">elemtype</span> <span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">i</span>];</div><div>&#160; &#160; &#160; &#160; <span token="keyword">int</span> <span token="variable">j</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">for</span> (<span token="variable">j</span> <span style="color: #c792ea;">=</span> <span token="variable">i</span>; <span token="variable">j</span> <span style="color: #c792ea;">&gt;</span> <span token="number">0</span> <span style="color: #c792ea;">&amp;&amp;</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>] <span style="color: #c792ea;">&gt;</span> <span token="variable">temp</span>; <span token="variable">j</span><span style="color: #7fdbca;">--</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>];</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span>] <span style="color: #c792ea;">=</span> <span token="variable">temp</span>;</div><div>&#160; &#160; }</div><div>}</div></div>

<p>插入排序也有两层嵌套的循环，且每层循环也和 <span class="math">\\( N \\)</span> 有关。但是内层循环是可能终止的：如果待排序元素比已排序序列末尾（最大）的元素还大，那么它就无需移动，放在原位就可以作为已排序序列的一部分，这就避免了插入时需要找到合适位置的线性复杂度。</p>

<p>在极端情况下，如果一个数组本身就是有序的，那么顺序扫描整个数组时，程序会发现数组与之前的序列总是能直接构成有序序列，这样每一个元素都无需移动，时间复杂度可以达到 <span class="math">\\( O(N) \\)</span> 。</p>

<p>如果原始数组越有序，那么无需移动的元素个数也越多，排序需要花费的时间也越短。在平均情况下，如果数组完全是随机的，那么显然需要移动的元素个数随着数组的大小线性增长，而移动又要花费线性时间，因此插入排序的平均时间复杂度仍然为 <span class="math">\\( O(N^2) \\)</span> 。</p>

<h3>希尔排序</h3>

<p><strong>希尔排序</strong>(Shell sort)是最早突破二次时间屏障的算法之一，它利用了插入排序在数组偏向有序时效率会更高的特点。</p>

<p>希尔排序使用一个<strong>增量序列</strong>(increment sequence) <span class="math">\\( h_1, h_2, \dots, h_t \\)</span> ，在使用 <span class="math">\\( h_k \\)</span> 做一次排序之后，数组中所有相隔为 <span class="math">\\( h_k \\)</span> 的元素都被排序。也就是说，将 <span class="math">\\( h_k, h_k + 1, \dots, N-1 \\)</span> 每个位置的元素使用插入排序放到 <span class="math">\\( i, i-h_k, i-2h_k, \dots \\)</span> 中的正确位置上。</p>

<p>提出者 Donald Shell 建议的增量序列的选择为：</p>

<div class="math">
\\[
    h_1 = \lfloor N / 2 \rfloor \\
    h_{k+1} = \lfloor h_k / 2 \rfloor
\\]
</div>

<p>该增量并不是效率最高的增量，但是比较流行。使用该增量编写的希尔排序如下：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">ShellSort</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">len</span>) {</div><div>&#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">inc</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">len</span> <span style="color: #7fdbca;">/</span> <span token="number">2</span>; <span token="variable">inc</span> <span style="color: #c792ea;">&gt;</span> <span token="number">0</span>; <span token="variable">inc</span> <span style="color: #c792ea;">/=</span> <span token="number">2</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="variable">inc</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">len</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>) {</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="type">elemtype</span> <span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">i</span>];</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">int</span> <span token="variable">j</span>;</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">for</span> (<span token="variable">j</span> <span style="color: #c792ea;">=</span> <span token="variable">i</span>; <span token="variable">j</span> <span style="color: #c792ea;">&gt;=</span> <span token="variable">inc</span>; <span token="variable">j</span> <span style="color: #c792ea;">-=</span> <span token="variable">inc</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="variable">temp</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span> <span style="color: #7fdbca;">-</span> <span token="variable">inc</span>])</div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span> <span style="color: #7fdbca;">-</span> <span token="variable">inc</span>];</div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">else</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">break</span>;</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span>] <span style="color: #c792ea;">=</span> <span token="variable">temp</span>;</div><div>&#160; &#160; &#160; &#160; }</div><div>}</div></div>

<p>有了以上函数，就可以分析其复杂度了。虽然以上函数有三层嵌套循环，但并不意味着时间复杂度就为三次函数。希尔排序在条件最差的情况下，其时间复杂度为 <span class="math">\\( O(N^2) \\)</span> 。</p>

<p>在增量为 <span class="math">\\( h_k \\)</span> 时，需要有 <span class="math">\\( h_k \\)</span> 组，每组 <span class="math">\\( N / h_k \\)</span> 个元素做插入排序。假设这些插入排序都是平均或最坏情况的二次时间，那么该增量下排序的总时间花费为：</p>

<div class="math">
\\[
    O(h_k \dot (N/h_k)^2) = O(N^2/h_k)
\\]
</div>

<p>对所有增量下排序的时间总和为：</p>

<div class="math">
\\[
    O(\sum_{i=1}^{t}N^2/h_i)=O(N^2\sum_{i=1}^{t} 1/h_i)
\\]
</div>

<p>由于 <span class="math">\\( h_t \\)</span> 的取值为 1 ，其余值应该大于前一个值的两倍，因此该数列是一个等比数列，总和小于 2 ，故时间复杂度为 <span class="math">\\( O(N^2) \\)</span> 。</p>

<p>希尔排序的时间复杂度是一个复杂的问题，甚至许多增量下平均情况的时间复杂度都还没解决。目前还不能确定取什么增量具有最好的时间复杂度，不过它确实有优于二次函数的时间复杂度：当增量序列取用 <span class="math">\\( 2^k-1, \dots, 7, 3, 1 \\)</span> 时，其时间复杂度为 <span class="math">\\( O(N^{3/2}) \\)</span> ，不过证明该结论需要一定数论知识。</p>

<p>还有许多不同的增量序列可供选取，例如 <span class="math">\\( 2^{k-1} + 1, \dots, 9, 5, 3, 2, 1 \\)</span> 或 <span class="math">\\( 0.5(3^{k-1}-1), \dots, 40, 13, 4, 1 \\)</span> 等。在选取增量序列时需要注意序列的最后一个值需要为 1 ，使数组最终要让所有元素都一起参与排序；并且序列中的值不要有除 1 以外的其它公因数，否则这些位置上的值会多次一并参与排序，影响效率。</p>

<h3>堆排序</h3>

<p>在<a href="/archives/717">上一节</a> 中介绍了堆的概念。二叉堆能以 <span class="math">\\( O(1) \\)</span> 的时间做插入，并以 <span class="math">\\( O(\log N) \\)</span> 的时间删除最小值。</p>

<p>删除是有序的，因此可以借由该性质完成排序：如果将数组内的每个元素插入二叉堆中，然后再按值的大小顺序出队，那么就可以得到一个有序的结果。</p>

<p>单个插入需要 <span class="math">\\( O(1) \\)</span> 的时间，插入所有元素就需要 <span class="math">\\( O(N) \\)</span> 的时间。删除最小值并放到数组中的合适位置需要花费 <span class="math">\\( O(\log N) \\)</span> 的时间，将所有元素依次删除就需要花费 <span class="math">\\( O(N\log N) \\)</span> 的时间。两者是先后执行的关系，总的时间复杂度也是二者之和，因此总的时间复杂度为 <span class="math">\\( O(N\log N) \\)</span> 。</p>

<p>这是目前为止效率最好的排序算法，不过它需要一个额外的数组来构建二叉树，因此需要 <span class="math">\\( O(N) \\)</span> 的空间复杂度。</p>

<p>可以对二叉堆做一定调整来避免额外的线性空间要求：注意到二叉堆在删除一个元素时，堆的最后一个元素空缺了出来，并且随着删除的继续，数组从后向前腾出空间。如果将每次删除的元素放在因删除而空缺出的位置上，就可以利用单个数组构建二叉堆并排序为数组。</p>

<p>不过这样得到的最终数组后面位置的元素小而前面位置的元素大。如果想得到升序排列的数组，可以对二叉堆做一定改进，使其每次在删除时，删除的是最大的元素而不是最小的元素。</p>

<p>这种堆称为 max-堆。它的堆序性质与上一节介绍的二叉堆是相反的：大的元素在上，小的元素在下。下图展示了一个 max-堆的结构：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/10-max-heap.png" alt="" width="260">
</figure>

<p>除此之外，max-堆的操作思路都与普通的二叉堆相同。例如，可以将堆中的任意一个元素调整到合适的位置上：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">#</span><span token="keyword">define</span> <span style="color: #82aaff;">leftchild</span><span style="color: #d9f5dd;">(</span><span style="color: #d7dbe0;">pos</span><span style="color: #d9f5dd;">)</span> (<span token="number">2</span> <span style="color: #7fdbca;">*</span> (pos) <span style="color: #7fdbca;">+</span> <span token="number">1</span>)</div><br><div><span token="keyword">static</span> <span token="keyword">void</span> <span style="color: #82aaff;">PercolateDown</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">len</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">pos</span>) {</div><div>&#160; &#160; <span token="keyword">int</span> <span token="variable">child</span>;</div><div>&#160; &#160; <span token="type">elemtype</span> <span token="variable">temp</span>;</div><div>&#160; &#160; <span token="keyword">for</span> (<span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">pos</span>]; <span style="color: #82aaff;">leftchild</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">pos</span><span style="color: #82aaff;">)</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">len</span>; <span style="color: #d7dbe0;">pos</span> <span style="color: #c792ea;">=</span> <span token="variable">child</span>) {</div><div>&#160; &#160; &#160; &#160; <span token="variable">child</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">leftchild</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">pos</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="variable">child</span> <span style="color: #c792ea;">!=</span> <span style="color: #d7dbe0;">len</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span> <span style="color: #c792ea;">&amp;&amp;</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">child</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span>] <span style="color: #c792ea;">&gt;</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">child</span>])</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="variable">child</span><span style="color: #c792ea;">++</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="variable">temp</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">child</span>])</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">pos</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">child</span>];</div><div>&#160; &#160; &#160; &#160; <span token="keyword">else</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">break</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">pos</span>] <span style="color: #c792ea;">=</span> <span token="variable">temp</span>;</div><div>}</div></div>

<p>注意：使用堆对数组排序时，索引值为 0 的位置上是有元素的，因此左子节点的计算方式略有不同。</p>

<p>堆的构建与删除都是基于该基本操作实现的：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">HeapSort</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">len</span>) {</div><div>&#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">len</span> <span style="color: #7fdbca;">/</span> <span token="number">2</span>; <span token="variable">i</span> <span style="color: #c792ea;">&gt;=</span> <span token="number">0</span>; <span token="variable">i</span><span style="color: #7fdbca;">--</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">PercolateDown</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">len</span><span style="color: #82aaff;">, </span><span token="variable">i</span><span style="color: #82aaff;">)</span>;<span style="color: #637777;"> </span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> build heap</span></div><div>&#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">len</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>; <span token="variable">i</span> <span style="color: #c792ea;">&gt;</span> <span token="number">0</span>; <span token="variable">i</span><span style="color: #7fdbca;">--</span>) {</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">array_swap</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="number">0</span><span style="color: #82aaff;">, </span><span token="variable">i</span><span style="color: #82aaff;">)</span>;<span style="color: #637777;"> &#160; &#160; &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> delete max</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">PercolateDown</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="variable">i</span><span style="color: #82aaff;">, </span><span token="number">0</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; }</div><div>}</div></div>

<p>在构建堆时，只需要将前半个数组的元素调整到合适的高度上，后半个数组的元素会在此过程中自动调整，且它们没有子节点，无需做进一步的调整。</p>

<h3>归并排序</h3>

<p><strong>归并排序</strong>(merge sort)同样是一种很快的排序算法。它的基本思想是合<em>并</em>：如果给定两个已排序的子数组，如果要将其合并为一个数组，只需要顺序遍历两个数组，不断将较小值放入合并数组的下一个位置即可。</p>

<p>假设要将一个数组的左右两部分合并成一个完整的数组：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/09/10-merge-array.png" alt="" width="290">
</figure>

<p>那么合并的代码实现如下：</p>

<div class="vscode-block"><div><span token="keyword">static</span> <span token="keyword">void</span> <span style="color: #82aaff;">Merge</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">temp</span><span token="keyword">[]</span>, </div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">int</span> <span style="color: #d7dbe0;">left</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">right</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">end</span>) {</div><div>&#160; &#160; <span token="keyword">int</span> <span token="variable">leftend</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">right</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>;</div><div>&#160; &#160; <span token="keyword">int</span> <span token="variable">elems</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">end</span> <span style="color: #7fdbca;">-</span> <span style="color: #d7dbe0;">left</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span>;</div><div>&#160; &#160; <span token="keyword">int</span> <span token="variable">curpos</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">left</span>;</div><br><div>&#160; &#160; <span token="keyword">while</span>(<span style="color: #d7dbe0;">left</span> <span style="color: #c792ea;">&lt;=</span> <span token="variable">leftend</span> <span style="color: #c792ea;">&amp;&amp;</span> <span style="color: #d7dbe0;">right</span> <span style="color: #c792ea;">&lt;=</span> <span style="color: #d7dbe0;">end</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">left</span>] <span style="color: #c792ea;">&lt;=</span> <span style="color: #d7dbe0;">arr</span>[ <span style="color: #d7dbe0;">right</span> ])</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">temp</span>[<span token="variable">curpos</span><span style="color: #c792ea;">++</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">left</span><span style="color: #c792ea;">++</span>];</div><div>&#160; &#160; &#160; &#160; <span token="keyword">else</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">temp</span>[<span token="variable">curpos</span><span style="color: #c792ea;">++</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">right</span><span style="color: #c792ea;">++</span>];</div><br><div>&#160; &#160; <span token="keyword">while</span> (<span style="color: #d7dbe0;">left</span> <span style="color: #c792ea;">&lt;=</span> <span token="variable">leftend</span>)<span style="color: #637777;"> </span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> Copy rest of first half</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">temp</span>[<span token="variable">curpos</span><span style="color: #c792ea;">++</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">left</span><span style="color: #c792ea;">++</span>];</div><div>&#160; &#160; <span token="keyword">while</span> (<span style="color: #d7dbe0;">right</span> <span style="color: #c792ea;">&lt;=</span> <span style="color: #d7dbe0;">end</span>)<span style="color: #637777;"> &#160; &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> Copy rest of second half</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">temp</span>[<span token="variable">curpos</span><span style="color: #c792ea;">++</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">right</span><span style="color: #c792ea;">++</span>];</div><br><div>&#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span token="variable">elems</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>, <span style="color: #d7dbe0;">end</span><span style="color: #7fdbca;">--</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">end</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">temp</span>[<span style="color: #d7dbe0;">end</span>];<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> Copy temp back</span></div><div>}</div></div>

<p>程序中需要考虑处理完一个数组的情况，此时只需要将另一个数组剩余的部分全部拼接到合并数组的末尾即可。</p>

<p>归并排序很适合使用递<em>归</em>的方式解决：只需要一开始将每个元素都看作一个有序的子数组，然后不断对有序的子数组之间两两合并，就可以逐渐将小数组合并为大数组，直至合并为一个完整的有序数组。</p>

<p>递归实现下，使用代码描述非常简单：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">_MergeSort</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">temp</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">left</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">right</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">left</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">right</span>) {</div><div>&#160; &#160; &#160; &#160; <span token="keyword">int</span> <span token="variable">center</span> <span style="color: #c792ea;">=</span> (<span style="color: #d7dbe0;">left</span> <span style="color: #7fdbca;">+</span> <span style="color: #d7dbe0;">right</span>) <span style="color: #7fdbca;">/</span> <span token="number">2</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">_MergeSort</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">temp</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">left</span><span style="color: #82aaff;">, </span><span token="variable">center</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">_MergeSort</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">temp</span><span style="color: #82aaff;">, </span><span token="variable">center</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">right</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">Merge</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">temp</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">left</span><span style="color: #82aaff;">, </span><span token="variable">center</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">right</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; }</div><div>}</div></div>

<p>先将待排序数组尽量均分，然后递归地对这两部分实施归并排序，最后再将两个排序完成的子数组合并起来。</p>

<p>该函数一般不用于直接执行，还需要一个入口函数驱动它：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">MergeSort</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">len</span>) {</div><div>&#160; &#160; <span token="type">elemtype</span><span style="color: #7fdbca;">*</span> <span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">elemtype</span><span style="color: #82aaff;">) </span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">len</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span token="variable">temp</span>) {</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">_MergeSort</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="variable">temp</span><span style="color: #82aaff;">, </span><span token="number">0</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">len</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">free</span><span style="color: #82aaff;">(</span><span token="variable">temp</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; }</div><div>}</div></div>

<p>从直观上看，每一次合并主要花费的时间在于顺序遍历数组，因此对数组做一次（影响每个元素的）排序并合并需要花费线性时间。第一次排序可以将单独元素的数组合并为两个元素的数组，第二次合并将两个元素的数组合并为 4 个元素的数组，那么最终经过对数次数的合并，就可以将其合并为包含所有元素的数组，因此归并排序的时间复杂度为 <span class="math">\\( O(N \log N) \\)</span> 。</p>

<p>此外，归并排序必须使用一个辅助数组用于存储排序的中间结果。不过需要的额外空间不会超过原始数组大小，因此归并排序的空间复杂度为 <span class="math">\\( O(N) \\)</span> 。</p>

<h3>快速排序</h3>

<p>和它的名字一样，<strong>快速排序</strong>(quick sort)速度很快。快速排序的思想是首先从数列中随机选出一个元素作为<strong>枢纽元</strong>(pivot)，将比枢纽元大的元素放在它的左端，将比枢纽元小的元素放在它的右端，此时枢纽元就相对它的左右端有序，再递归地将左端和右端按这种方式排序即可。</p>

<p>归并排序将小数组合并为大数组，而快速排序将大数组分割为小数组再互相排序。当数组足够小（如元素个数小于等于 3 个）时已经无需划分，可以使用其余比较简单的排序方式（如插入排序）即可。</p>

<p>枢纽元的选取非常重要，因为它应该能反映一个比较中间的位置，如果选取的是数组内元素的最值，那么它将花费线性的时间将其它元素都移到它的同一边，且一次只能将一个元素排到合适的位置，使快速排序达到最坏的情况 <span class="math">\\( O(N^2) \\)</span> 。</p>

<p>一个比较合理且速度较快的方法是<strong>三数中值分割法</strong>(median-of-three partitioning)，即随机选取三个数并取用它们的中值。不过一般不会随机选取，而是取用数组的首端、末端和中间端的元素，再取它们的中值。三数中值分割法的代码实现如下：</p>

<div class="vscode-block"><div><span token="keyword">static</span> <span token="type">elemtype</span> <span style="color: #82aaff;">Median3</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">left</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">right</span>) {</div><div>&#160; &#160; <span token="keyword">int</span> <span token="variable">center</span> <span style="color: #c792ea;">=</span> (<span style="color: #d7dbe0;">left</span> <span style="color: #7fdbca;">+</span> <span style="color: #d7dbe0;">right</span>) <span style="color: #7fdbca;">/</span> <span token="number">2</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">left</span>] <span style="color: #c792ea;">&gt;</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">center</span>])</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">array_swap</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">left</span><span style="color: #82aaff;">, </span><span token="variable">center</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">left</span>] <span style="color: #c792ea;">&gt;</span> <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">right</span>])</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">array_swap</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">left</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">right</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">arr</span>[<span token="variable">center</span>] <span style="color: #c792ea;">&gt;</span> <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">right</span>])</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">array_swap</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="variable">center</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">right</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span style="color: #82aaff;">array_swap</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="variable">center</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">right</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span><span style="color: #82aaff;">)</span>;<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> hide pivot</span></div><div>&#160; &#160; <span token="keyword">return</span> <span style="color: #d7dbe0;">arr</span>[<span style="color: #d7dbe0;">right</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>];<span style="color: #637777;"> &#160; &#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> return pivot</span></div><div>}</div></div>

<p>以上在寻找中值时将涉及到的元素放在合适的位置，方便后续程序处理。</p>

<p>快速排序的主要实现如下：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">#</span><span token="keyword">define</span> <span style="color: #82aaff;">QUICKSORT_CUTOFF</span> (<span token="number">3</span>)</div><br><div><span token="keyword">static</span> <span token="keyword">void</span> <span style="color: #82aaff;">_QuickSort</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">left</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">right</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">left</span> <span style="color: #7fdbca;">+</span> <span style="color: #82aaff;">QUICKSORT_CUTOFF</span> <span style="color: #c792ea;">&lt;=</span> <span style="color: #d7dbe0;">right</span>) {</div><div>&#160; &#160; &#160; &#160; <span token="type">elemtype</span> <span token="variable">pivot</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Median3</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">left</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">right</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">left</span>; </div><div>&#160; &#160; &#160; &#160; <span token="keyword">int</span> <span token="variable">j</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">right</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">while</span> (<span token="number">1</span>) {</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">while</span> (<span style="color: #d7dbe0;">arr</span>[<span style="color: #c792ea;">++</span><span token="variable">i</span>] <span style="color: #c792ea;">&lt;</span> <span token="variable">pivot</span>) <span token="keyword">continue</span>;</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">while</span> (<span style="color: #d7dbe0;">arr</span>[<span style="color: #7fdbca;">--</span><span token="variable">j</span>] <span style="color: #c792ea;">&gt;</span> <span token="variable">pivot</span>) <span token="keyword">continue</span>;</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span token="variable">j</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #82aaff;">array_swap</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="variable">i</span><span style="color: #82aaff;">, </span><span token="variable">j</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">else</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">break</span>;</div><div>&#160; &#160; &#160; &#160; }</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">array_swap</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="variable">i</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">right</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span><span style="color: #82aaff;">)</span>;<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> restore pivot</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">_QuickSort</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">left</span><span style="color: #82aaff;">, </span><span token="variable">i</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">_QuickSort</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="variable">i</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">right</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span token="keyword">else</span><span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> do an insertion sort on the subarray</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">InsertionSort</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span> <span style="color: #7fdbca;">+</span> <span style="color: #d7dbe0;">left</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">right</span> <span style="color: #7fdbca;">-</span> <span style="color: #d7dbe0;">left</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span><span style="color: #82aaff;">)</span>;</div><div>}</div></div>

<p>每一趟排序中，程序从左右两边向中间扫描，并将左边较大的元素和右边较小的元素交换位置，两边交汇的位置即为枢纽元应该位于的中值位置，该位置左边的元素都比枢纽元小，右边的元素都比枢纽元大。由于在寻找枢纽元时将其移动到了数组的末端，因此最后一步需要将其移动到合适的位置。</p>

<p>每一趟排序涉及数组内的每一个元素，因此需要花费线性时间；平均上看来，第一次排序将一个元素放在合适的位置，并分割为左右两端的子数组再排序，而下一次排序又将左右两端的子数组的各一个元素放在合适的位置，并再次分割为四个子数组。由此可见平均情况下已排序的元素将随着每趟排序指数增长，总的时间是两者之积 <span class="math">\\( O(N\log N) \\)</span> 。</p>

<p>尽管时间复杂度都是 <span class="math">\\( O(N\log N) \\)</span> ，但快速排序在多数情况下比堆排序和归并排序快。这是由于快速排序在每趟排序中，基本上只有一半左右的元素需要移动，而归并排序在每趟排序时每个元素都需要参与合并的移动；堆排序在插入和删除时也涉及所有元素的移动，因此它们的操作都比快速排序复杂，使得函数的常数项比快速排序大，相对来说运行的时间没有快速排序快。</p>

<!-- <div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">QuickSort</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">len</span>) {</div><div>&#160; &#160; <span style="color: #82aaff;">_QuickSort</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">arr</span><span style="color: #82aaff;">, </span><span token="number">0</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">len</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span><span style="color: #82aaff;">)</span>;</div><div>}</div></div> -->

<p>最后，总结一下本节涉及到的所有排序算法的特点：</p>

<table>
    <tr>
        <th>排序算法</th>
        <th>最好运行时间</th>
        <th>平均运行时间</th>
        <th>最坏运行时间</th>
        <th>额外空间需求</th>
    </tr>
    <tr>
        <td>选择排序</td>
        <td><span class="math">\\( O(N^2) \\)</span></td>
        <td><span class="math">\\( O(N^2) \\)</span></td>
        <td><span class="math">\\( O(N^2) \\)</span></td>
        <td><span class="math">\\( O(1) \\)</span></td>
    </tr>
    <tr>
        <td>插入排序</td>
        <td><span class="math">\\( O(N) \\)</span></td>
        <td><span class="math">\\( O(N^2) \\)</span></td>
        <td><span class="math">\\( O(N^2) \\)</span></td>
        <td><span class="math">\\( O(1) \\)</span></td>
    </tr>
    <tr>
        <td>希尔排序</td>
        <td><span class="math">\\( O(N) \\)</span></td>
        <td><span class="math">\\( O(N^{5/4}) \\)</span>（与增量选取有关）</td>
        <td><span class="math">\\( O(N^{3/2}) \\)</span>（与增量选取有关）</td>
        <td><span class="math">\\( O(1) \\)</span></td>
    </tr>
    <tr>
        <td>堆排序</td>
        <td><span class="math">\\( O(N\log N) \\)</span></td>
        <td><span class="math">\\( O(N\log N) \\)</span></td>
        <td><span class="math">\\( O(N\log N) \\)</span></td>
        <td><span class="math">\\( O(1) \\)</span></td>
    </tr>
    <tr>
        <td>归并排序</td>
        <td><span class="math">\\( O(N\log N) \\)</span></td>
        <td><span class="math">\\( O(N\log N) \\)</span></td>
        <td><span class="math">\\( O(N\log N) \\)</span></td>
        <td><span class="math">\\( O(N) \\)</span></td>
    </tr>
    <tr>
        <td>快速排序</td>
        <td><span class="math">\\( O(N\log N) \\)</span></td>
        <td><span class="math">\\( O(N\log N) \\)</span></td>
        <td><span class="math">\\( O(N^2) \\)</span></td>
        <td><span class="math">\\( O(1) \\)</span></td>
    </tr>
</table>

<p>排序算法有非常多种，本节只介绍了其中几个比较典型的排序算法。堆排序将数据结构二叉堆的性质应用在算法之中，建立了数据结构与算法之间的联系。</p>

<p>归并排序和快速排序是一种典型的分治(divide-and-conquer)算法：它将一个大的问题（数组排序）分成一系列较小的问题（数组的一部分排序），再将得到的各个部分合并为一个完整的答案，因此分治问题非常适合使用递归来实现。</p>
<p><a rel="nofollow" href="/archives/735">数据结构07-排序算法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/735/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>数据结构06-优先队列(堆)</title>
		<link>/archives/717</link>
					<comments>/archives/717#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sun, 21 Aug 2022 09:36:41 +0000</pubDate>
				<category><![CDATA[数据结构与算法]]></category>
		<category><![CDATA[数据结构]]></category>
		<guid isPermaLink="false">/?p=717</guid>

					<description><![CDATA[<p>优先队列的概念 优先队列的概念可以由队列引出。队列可&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/717">数据结构06-优先队列(堆)</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>优先队列的概念</h2>

<p>优先队列的概念可以由<a href="/archives/609#queue">队列</a>引出。队列可以让先到达的元素先处理，适用于很多需要边处理边容纳新元素的场合。</p>

<p>然而，队列的处理过程也有一些不足：队列只能按顺序逐个处理，此时如果新入队了一个需要紧急处理的元素，队列不允许它插队，只能排队等待处理。</p>

<p><strong>优先队列</strong>(priority queue)是一种特殊的队列，它可以像队列一样插入与删除元素，不过它的特点是只能删除队列中的最小值（或者说优先级最高的元素）。这样，通过调整每一个入队元素的优先级，就可以自行调控出队的顺序。</p>

<p>二叉查找树是有序的，可以快速找到最小值，因此可以用于实现优先队列。然而如果直接将二叉树作为优先队列，它支持了太多不必要的操作使得运行速度可能较慢。并且如果要频繁地删除最小值时，二叉查找树需要从左向右删除，那么整棵树就会变得不平衡，还需要做额外的调整。</p>

<p>接下来介绍的优先队列数据结构使用了二叉树的思想，不过它是一棵特别地二叉树，可以更好地实现优先队列。</p>

<h2 id="binary-heap">二叉堆</h2>

<h3>二叉堆的概念</h3>

<p><strong>二叉堆</strong>(binary heap)是一棵被完全填满的二叉树，这种二叉树除了最底层外，所有位置都有元素；最底层元素从左到右填入，如下所示：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-complete-binary-tree.png" alt="" width="480">
</figure>

<p>这种二叉树称为<strong>完全二叉树</strong>(complete binary tree)，非常适合用于实现优先队列，甚至“堆”在数据结构中多用于指代优先队列。因为完全二叉树很紧凑，因此可以使用数组表示：对于数组中位置 <span class="math">\\( i \\)</span> 上的元素，它的左侧子节点在位置 <span class="math">\\( 2i \\)</span> 处，右侧子节点在随后的位置 <span class="math">\\( 2i+1 \\)</span> 处。下图说明了数组表示完全二叉树的基本原理：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-binary-tree-array.png" alt="" width="460">
</figure>

<p>因此，二叉堆的类型声明如下：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">size</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">length</span>;</div><div>&nbsp; &nbsp; <span token="type">elemtype</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">body</span>;</div><div>} <span token="type">binheap</span>;</div></div>

<p>使用数组表示完全二叉树不需要指针，并且可以很容易地遍历树；不过这种情况下树的大小需要提前估计。当然普通的二叉树也可以这么表示，但是普通的二叉树比较散，许多节点（尤其是中间位置的节点）都是空的，使用数组存储还需要给空的节点也预留所有后代的位置，存储效率不高。</p>

<h3>二叉堆的堆序性质</h3>

<p>二叉堆的一个重要的性质是堆序(heap order)，堆序使堆的最小值可以被快速找到。因此，最小值应该被放在堆（数组）的最前面。同时为了使子树也是一个二叉堆这种递归性质，那么任意节点都应该小于它的所有后代元素。</p>

<p>下图展示了一个二叉堆的树状结构：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-binary-heap-example.png" alt="" width="240">
</figure>

<p>因此，二叉堆的创建过程如下：</p>

<div class="vscode-block"><div><span token="type">binheap</span><span style="color: #7fdbca;">*</span> <span style="color: #82aaff;">BinHeap_New</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">size</span>) {</div><div>&nbsp; &nbsp; <span token="type">binheap</span><span style="color: #7fdbca;">*</span> <span token="variable">heap</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">binheap</span><span style="color: #82aaff;">))</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">heap</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #82aaff;">NULL</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of memory</span></div><div>&nbsp; &nbsp; <span token="variable">heap</span>-&gt;<span style="color: #7fdbca;">body</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">elemtype</span><span style="color: #82aaff;">) </span><span style="color: #7fdbca;">*</span><span style="color: #82aaff;"> (</span><span style="color: #d7dbe0;">size</span><span style="color: #82aaff;"> </span><span style="color: #7fdbca;">+</span><span style="color: #82aaff;"> </span><span token="number">1</span><span style="color: #82aaff;">))</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">heap</span>-&gt;<span style="color: #7fdbca;">body</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #82aaff;">NULL</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of memory</span></div><div>&nbsp; &nbsp; <span token="variable">heap</span>-&gt;<span style="color: #7fdbca;">size</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">size</span>;</div><div>&nbsp; &nbsp; <span token="variable">heap</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; <span token="variable">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="number">0</span>] <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">HEAP_MIN_ELEM</span>;</div><div>}</div></div>

<p>注意，使用数组创建二叉堆时，其首位置将空缺出来，使剩下的元素可以直接使用下标值找到对应的父/子节点。</p>

<p>首先研究二叉堆的插入。由于二叉堆是一棵数组描述的完全二叉树，因此为了将一个元素插入到堆中，需要在数组的后一个空闲位置分配一个空闲项。同时，待插入元素可能比该位置的父元素小，不满足二叉堆的定义，需要将该元素与其父元素调换位置。</p>

<p>例如，如果要向以下二叉堆插入元素 3 ，那么首先需要分配一个额外的位置：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-binary-heap-insert-1.png" alt="" width="240">
</figure>

<blockquote>
    <p>为了直观起见，这里将二叉堆绘制成树状结构，但是底层实现依然使用数组。</p>
</blockquote>

<p>如果向该位置直接插入 3 ，不符合二叉堆的定义，需要将该位置向上提一层，并与上层的位置对调：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-binary-heap-insert-2.png" alt="" width="240">
</figure>

<p>该位置还是不符合二叉堆的定义，还需要再向上提一层：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-binary-heap-insert-3.png" alt="" width="240">
</figure>

<p>此时，向该位置插入 3 便满足二叉堆的定义了。这种插入策略称为上浮或<strong>向上渗透</strong>(percolate up)。其代码实现如下：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">BinHeap_Insert</span>(<span token="type">binheap</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">heap</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #82aaff;">BinHeap_IsFull</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">heap</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of space</span></div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span style="color: #c792ea;">++</span><span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">length</span>; <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span> <span style="color: #7fdbca;">/</span> <span token="number">2</span>] <span style="color: #c792ea;">&gt;</span> <span style="color: #d7dbe0;">elem</span>; <span token="variable">i</span> <span style="color: #c792ea;">/=</span> <span token="number">2</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span> <span style="color: #7fdbca;">/</span> <span token="number">2</span>];</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[i] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">elem</span>;</div><div>}</div></div>

<p>注意，在插入时可能会一直浮到顶端，此时应该退出循环，否则它还会向索引值为 0 的位置继续移动，甚至造成无限循环。在创建二叉堆时可以通过在 0 号位置放入一个很小的元素，例如 <code>INT_MIN</code> 来避免这一点，同时简化代码的实现。</p>

<p>和插入相反的过程是删除，优先队列只允许删除最小值。最小值默认出现在树的根部，删除该值很快也很容易，但还需要对数组做一定调整使其符合二叉堆的堆序性质。</p>

<p>例如，假设需要从以上二叉堆中删除最小值：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-binary-heap-remove-1.png" alt="" width="240">
</figure>

<p>那么肯定要移除树根位置的元素。为了维持堆序性质，需要有其余位置的元素来填补该空缺，不管什么位置的元素来填补该空缺，数组少了一个元素因此最后一个位置必须被释放，该位置的元素必须被移动。</p>

<p>不过该位置的元素不能直接移动到树根处，否则便违背了二叉堆的大小关系。只有树根的两个子节点的元素才能直接移动到树根处。由于左侧节点的值较小，因此移动到树根处不破坏二叉堆的性质：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-binary-heap-remove-2.png" alt="" width="240">
</figure>

<p>此时又产生了一个空缺位置，并且最后一个位置的元素还是不能直接移到该空缺处。因此再重复几次以上的步骤：将较小的子节点的值移到空缺处，然后观察最后位置的元素是否适合移动到空缺处：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-binary-heap-remove-3.png" alt="" width="240">
</figure>

<p>这样空缺处逐渐移动到了树叶位置，此时可以将最后位置的值移动到空缺处了：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-binary-heap-remove-4.png" alt="" width="240">
</figure>

<p>整个删除过程完毕。这种删除策略称为下沉或<strong>向下渗透</strong>(percolate down)。它的原理并不会比插入复杂多少，不过考虑的细节较多。以下展示了删除的代码实现：</p>

<div class="vscode-block"><div><span token="type">elemtype</span> <span style="color: #82aaff;">BinHeap_RemoveMin</span>(<span token="type">binheap</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">heap</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #82aaff;">BinHeap_IsEmpty</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">heap</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="number">0</span>];<span style="color: #637777;"> &nbsp; </span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> empty priority queue</span></div><div>&nbsp; &nbsp; <span token="type">elemtype</span> <span token="variable">minimum</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="number">1</span>];</div><div>&nbsp; &nbsp; <span token="type">elemtype</span> <span token="variable">last</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">length</span><span style="color: #7fdbca;">--</span>];</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; <span token="keyword">while</span> (<span token="variable">i</span> <span style="color: #7fdbca;">*</span> <span token="number">2</span> <span style="color: #c792ea;">&lt;=</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">size</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">child</span> <span style="color: #c792ea;">=</span> <span token="variable">i</span> <span style="color: #7fdbca;">*</span> <span token="number">2</span>;<span style="color: #637777;"> &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> find smaller child</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">child</span> <span style="color: #c792ea;">!=</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #c792ea;">&amp;&amp;</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">child</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span>] <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">child</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">child</span><span style="color: #c792ea;">++</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">last</span> <span style="color: #c792ea;">&gt;</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">child</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">child</span>];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">else</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">break</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="variable">child</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span>] <span style="color: #c792ea;">=</span> <span token="variable">last</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">minimum</span>;</div><div>}</div></div>

<p>删除过程中需要考虑一个节点可能未必都会有两个子节点，还可能出现只有一个子节点的情况。不过如果只存在一个子节点，那么此时已经到达了数组的结尾。</p>

<p>接下来分析二叉堆操作的时间复杂度。从直观上看，如果插入过程中待插入元素很小，那么需要花费 <span class="math">\\( O(\log N) \\)</span> 的时间才完成插入；但问题是待插入元素未必很小，它应该被插入的层级也应该是 <span class="math">\\( O(\log N) \\)</span> 的增长规律，因此插入的时间复杂度为 <span class="math">\\( O(1) \\)</span> 。</p>

<blockquote>
    <p>这里进一步解释插入的时间复杂度为什么是常数级。如果将一个元素从底层插入堆中，因为每层包含的元素都是上一层的两倍，它应该有 <span class="math">\\( 1/2 \\)</span> 的概率插入到最底层，此时节点不需要移动；还有 <span class="math">\\( 1/2^2 \\)</span> 的概率插入到次底层，此时路径上的节点需要向下移动 1 层；并且有 <span class="math">\\( 1/2^3 \\)</span> 的概率插入到再次底层，此时路径上的节点需要向下移动 2 层，以此类推。</p>

    <p>将这些动作的耗时按概率加起来就是总的复杂度：</p>

    <div class="math">
    \\[
        \begin{aligned}
        T(N) &amp;= 0 \cdot 1/2 + 1 \cdot 1/4 + 2 \cdot 1/8 + \cdots\\
            &amp;= 1 \\
            &amp;= O(1)
        \end{aligned}
    \\]
    </div>
</blockquote>

<p>因此，如果将 <span class="math">\\( N \\)</span> 个元素使用插入的方式创建一个二叉堆，其时间复杂度将为 <span class="math">\\( O(N) \\)</span> 。</p>

<p>在删除时，去除的最小值位于二叉堆的根部，而树叶处的一个元素需要被移动，这使得基本上从树根到树叶这一路径上的每一个元素都需要被移动，因此其时间复杂度为 <span class="math">\\( O(\log N) \\)</span> 。</p>

<h3>d-堆</h3>

<p>二叉堆的左/右子节点不像二叉查找树一样具有明确的含义，因此子节点的个数不必局限于两个。d-堆是对二叉堆的一个简单的推广，每个节点都有 d 个子节点。</p>

<p>下图展示了一个 3-堆的结构：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-3-heap.png" alt="" width="320">
</figure>

<p>二叉堆实质就是一个 2-堆。d-堆的深度随着 d 的增大而快速减小，插入操作的时间为 <span class="math">\\( O(\log_d N) \\)</span> 。</p>

<p>不过在删除时，由于子节点变多了，要从中找出最小值也需要更多时间，使得删除的时间复杂度为 <span class="math">\\( O(d \log_d N) \\)</span> 。除此之外，如果 d 不为 2 ，节点对应的索引值的计算也更加复杂一些。因此，d 值应该谨慎选择。</p>

<h2 id="leftist-heap">左式堆</h2>

<h3>左式堆的概念</h3>

<p>将两个堆合并是一种比较复杂的操作。如果要对两个二叉堆做合并，最简单的操作就是遍历二叉堆，并将每个元素插入到另一个二叉堆中。然而，遍历需要花费 <span class="math">\\( O(N) \\)</span> 的时间，这在堆较大时效率并不高。</p>

<p><strong>左式堆</strong>(leftist heap)是另一种优先队列的实现，它除了支持堆序性质和优先队列需要的操作外，还提供了一种更快速的合并操作。</p>

<p>如果要实现比线性级更快的插入操作，那么便需要使用指针，因为调整一次指针能够影响堆的一部分而不仅是单一元素。因此左式堆像传统的二叉树一样使用类似链表一样的思路来管理树，但是处理指针肯定比处理索引更复杂，这会使左式堆在一般的操作下会花费同一量级的稍多时间。</p>

<p>左式堆也是一棵二叉树，不过它趋于非常不平衡。要了解左式堆的性质，需要知道零路径长的定义。节点的零路径长(null path length, NPL)指的是一个节点到一个不全有两个子节点的节点的最短路径的长，记为 <span class="math">\\( Npl(X) \\)</span> 。</p>

<p>显然，不全有两个子节点的节点的 <span class="math">\\( Npl \\)</span> 为 0 ，任一节点的 <span class="math">\\( Npl \\)</span> 比它两个子节点的零路径长的最小值多 1 。根据该结论，可以认为 <span class="math">\\( Npl(NULL) = -1 \\)</span> 。</p>

<p>左式堆的特点为：对堆中的每一个节点，左子节点的 <span class="math">\\( Npl \\)</span> 不比右子节点的 <span class="math">\\( Npl \\)</span> 小。因此一个左式堆的任意子堆还是左式堆。</p>

<p>使用如下方式定义左式堆：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">leftheap_node</span> {</div><div>&nbsp; &nbsp; <span token="type">elemtype</span> <span style="color: #7fdbca;">elem</span>;</div><div>&nbsp; &nbsp; <span token="keyword">struct</span> <span token="type">leftheap_node</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">left</span>;</div><div>&nbsp; &nbsp; <span token="keyword">struct</span> <span token="type">leftheap_node</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">right</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">Npl</span>;</div><div>} <span token="type">leftheap_node</span>, <span style="color: #7fdbca;">*</span> <span token="type">leftheap</span>;</div></div>

<p>下图展示了一棵合理的左式堆，每个节点的 <span class="math">\\( Npl \\)</span> 标注在节点内：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-leftist-heap-example.png" alt="" width="240">
</figure>

<p>由此可见，左式堆很不平衡，总有向左生长的特性。左式堆的元素排布和二叉堆一样，都是上小下大。接下来看看这些特性是如何使左式堆可以快速合并的。假设需要合并如下两个左式堆：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-leftist-heap-merge-1.png" alt="" width="480">
</figure>

<p>那么首先需要比较两个堆树根的大小，以确定哪个根将作为新根。由于 <span class="math">\\( H_1 \\)</span> 的根部更小，因此将 <span class="math">\\( H_2 \\)</span> 和 <span class="math">\\( H_1 \\)</span> 的右子树做合并：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-leftist-heap-merge-2.png" alt="" width="720">
</figure>

<p>注意到合并破坏了左式堆的性质。不过由于 <span class="math">\\( H_2 \\)</span> 和 <span class="math">\\( H_1 \\)</span> 的左子树保持左式堆不变，只需要将 <span class="math">\\( H_1 \\)</span> 的两个子节点做交换即可重新变为左式堆。</p>

<p>以上合并还没有完成，因为 <span class="math">\\( H_1 \\)</span> 的右子树还没有合并进去，还需要将这一部分与 <span class="math">\\( H_2 \\)</span> 做合并：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-leftist-heap-merge-3.png" alt="" width="640">
</figure>

<p>合并仍然是朝右子树方向。同样地，接下来还需要对 <span class="math">\\( H_2 \\)</span> 的右子树做合并：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-leftist-heap-merge-4.png" alt="" width="290">
</figure>

<p>不过，合并破坏了 <span class="math">\\( H_2 \\)</span> 的左式堆性质，需要交换子节点元素做调整：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-leftist-heap-merge-5.png" alt="" width="320">
</figure>

<p>调整完成后，总体看一下 <span class="math">\\( H_1 \\)</span> ，两个左式堆确实完美地合并了：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/09-leftist-heap-merge-6.png" alt="" width="430">
</figure>

<p>左式堆的合并代码比较难以编写，因为各种循环需要考虑的条件有点多。使用递归是一种比较简洁的实现方式。首先需要一个入口函数，判断两个堆的合成主被动关系：</p>

<div class="vscode-block"><div><span token="type">leftheap</span> <span style="color: #82aaff;">LeftHeap_Merge</span>(<span token="type">leftheap</span> <span style="color: #d7dbe0;">heap_A</span>, <span token="type">leftheap</span> <span style="color: #d7dbe0;">heap_B</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">heap_A</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>) <span token="keyword">return</span> <span style="color: #d7dbe0;">heap_B</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">heap_B</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>) <span token="keyword">return</span> <span style="color: #d7dbe0;">heap_A</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">heap_A</span>-&gt;<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">heap_B</span>-&gt;<span style="color: #7fdbca;">elem</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #82aaff;">_LeftHeap_Merge</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">heap_A</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">heap_B</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">else</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #82aaff;">_LeftHeap_Merge</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">heap_B</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">heap_A</span><span style="color: #82aaff;">)</span>;</div><div>}</div></div>

<p>如果需要将 <span class="math">\\( H_2 \\)</span> 合并到 <span class="math">\\( H_1 \\)</span> ，首先需要检查 <span class="math">\\( H_1 \\)</span> 的左侧是否有元素；如果有，那么可以立即插入左侧位置，无需额外调整；否则，将右侧的节点递归地与 <span class="math">\\( H_2 \\)</span> 合并，然后根据节点的 <span class="math">\\( Npl \\)</span> 判断左式堆的性质是否发生了改变，适当做一些调整。</p>

<p>合并的实际代码实现如下：</p>

<div class="vscode-block"><div><span token="keyword">static</span> <span token="type">leftheap</span> <span style="color: #82aaff;">_LeftHeap_Merge</span>(<span token="type">leftheap</span> <span style="color: #d7dbe0;">heap_A</span>, <span token="type">leftheap</span> <span style="color: #d7dbe0;">heap_B</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">heap_A</span>-&gt;<span style="color: #7fdbca;">left</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">heap_A</span>-&gt;<span style="color: #7fdbca;">left</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">heap_B</span>;</div><div>&nbsp; &nbsp; <span token="keyword">else</span> {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">heap_A</span>-&gt;<span style="color: #7fdbca;">right</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">LeftHeap_Merge</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">heap_A</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">right</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">heap_B</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">heap_A</span>-&gt;<span style="color: #7fdbca;">left</span>-&gt;<span style="color: #7fdbca;">Npl</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">heap_A</span>-&gt;<span style="color: #7fdbca;">right</span>-&gt;<span style="color: #7fdbca;">Npl</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">LeftHeap_SwapChildren</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">heap_A</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">heap_A</span>-&gt;<span style="color: #7fdbca;">Npl</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">heap_A</span>-&gt;<span style="color: #7fdbca;">right</span>-&gt;<span style="color: #7fdbca;">Npl</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">heap_A</span>;</div><div>}</div></div>

<p>注意，两个函数间相互调用，由此形式一种递归的关系。</p>

<p>之所以合并时需要朝着右侧节点的方向进行，是因为左式堆具有向左生长的特性，因此右侧节点的长度不会超过节点的期望深度 <span class="math">\\( \log N \\)</span> ，因此合并的时间复杂度也为 <span class="math">\\( O(\log N) \\)</span> ，这也就是左式堆的思想。</p>

<p>既然左式堆往往被用作优先队列，那么它需要具备优先队列的操作：插入和删除最小值。之所以先介绍左式堆的合并操作，是因为插入和删除最小值都可以使用合并来描述。</p>

<p>例如，插入可以视为一棵只有树根的树与一个左式堆合并：</p>

<div class="vscode-block"><div><span token="type">leftheap</span> <span style="color: #82aaff;">LeftHeap_Insert</span>(<span token="type">leftheap</span> <span style="color: #d7dbe0;">heap</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&nbsp; &nbsp; <span token="type">leftheap_node</span><span style="color: #7fdbca;">*</span> <span token="variable">node</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">leftheap_node</span><span style="color: #82aaff;">))</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">node</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #82aaff;">NULL</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of space</span></div><div>&nbsp; &nbsp; <span token="variable">node</span>-&gt;<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">elem</span>;</div><div>&nbsp; &nbsp; <span token="variable">node</span>-&gt;<span style="color: #7fdbca;">left</span> <span style="color: #c792ea;">=</span> <span token="variable">node</span>-&gt;<span style="color: #7fdbca;">right</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">NULL</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #82aaff;">LeftHeap_Merge</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">heap</span><span style="color: #82aaff;">, </span><span token="variable">node</span><span style="color: #82aaff;">)</span>;</div><div>}</div></div>

<p>那么插入的时间复杂度也为 <span class="math">\\( O(\log N) \\)</span> 。这也是左式堆的一个弊端：为了实现较快的合并，它不得不牺牲插入的速度。</p>

<p>左式堆的删除可以通过去除树根元素后，将其左右子节点合并成一个新堆实现：</p>

<div class="vscode-block"><div><span token="type">leftheap</span> <span style="color: #82aaff;">LeftHeap_RemoveMin</span>(<span token="type">leftheap</span> <span style="color: #d7dbe0;">heap</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #82aaff;">LeftHeap_IsEmpty</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">heap</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">heap</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> empty heap</span></div><div>&nbsp; &nbsp; <span token="type">leftheap</span> <span token="variable">left</span> &nbsp;<span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">left</span>;</div><div>&nbsp; &nbsp; <span token="type">leftheap</span> <span token="variable">right</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">heap</span>-&gt;<span style="color: #7fdbca;">right</span>;</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">free</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">heap</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #82aaff;">LeftHeap_Merge</span><span style="color: #82aaff;">(</span><span token="variable">left</span><span style="color: #82aaff;">, </span><span token="variable">right</span><span style="color: #82aaff;">)</span>;</div><div>}</div></div>

<p>此过程的时间复杂度也为 <span class="math">\\( O(\log N) \\)</span> 。</p>

<p>优先队列作为一种比较实用的数据类型，在许多队列的改进应用场景都能看到。本节介绍优先队列，主要是为下一节介绍排序算法做基础，堆与一种特别的排序算法“堆排序”密切相关。</p>
<p><a rel="nofollow" href="/archives/717">数据结构06-优先队列(堆)</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/717/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>数据结构05-散列</title>
		<link>/archives/653</link>
					<comments>/archives/653#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 10 Aug 2022 02:50:08 +0000</pubDate>
				<category><![CDATA[数据结构与算法]]></category>
		<category><![CDATA[数据结构]]></category>
		<guid isPermaLink="false">/?p=653</guid>

					<description><![CDATA[<p>散列的概念 散列简介 前文介绍的树或链表都是一种链式&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/653">数据结构05-散列</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>散列的概念</h2>

<h3>散列简介</h3>

<p>前文介绍的树或链表都是一种链式存储结构，在获取某个位置的节点时都需要沿着路径依次查找下一个节点的位置，而不能直接定位。</p>

<p>数组（或者说顺序存储的线性表）则支持直接定址，如果知道一个元素在数组中的位置，则可以直接通过地址偏移得到，该过程可以以常数级且非常快的时间运行。例如，假设将某班学生的信息按学号排序放在数组中，那么只需要知道学生学号，就可以立即访问数组的对应位置，从而获取学生信息。</p>

<p><strong>散列表</strong>(hash table)就是根据该原理实现的。散列表也叫哈希表，可以为不同值（这个值可以是任意类型的，包括浮点数、字符串等）在散列表中分配一个地址，但这个值不能直接得到，而是要经由一定计算从而转换为整数。该映射关系由<strong>散列函数</strong>计算。</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/08-hashtable-module.png" alt="" width="300">
</figure>

<p>理想的情况下每个元素的映射关系易于计算，且每个元素都能被分配到唯一的地址。例如假设机器中拥有一个很长的结构数组，索引值位置存放身份证号对应的个人信息，那么可以根据一定规律计算得到身份证号，再根据身份证号就可以直接找到存放个人信息的单元。然而这是不可能的，因为单元的数目总是有限的，但是要存储的元素可能是无法穷举的。</p>

<h3>散列函数</h3>

<p>散列函数需要谨慎编写，一个好的散列函数应该能尽可能给不同的值分配不同的地址，同时又可以避免地址被浪费。除此之外，如果两个关键字计算出的地址一致，发生<strong>冲突</strong>(collision)，散列函数应当额外采取一些动作来确保散列表都能容纳它们。</p>

<p>考虑要为一些英文单词计算分配散列表中的地址。字符串无法直接转换为整数，需要采取一个算法。</p>

<p>一种简单的实现是使用字符串的 ASCII 累计值作为散列值，这样做实现简单且计算很快。不过英文字符的 ASCII 累计值一般低于 2000（只考虑小写英文字符）；而实用的英文词汇至少也得几万个，平均下来每个位置都有十多个词汇发生冲突。这显然不是一种有效的散列函数。</p>

<p>那么可以给每位字符的 ASCII 值乘上一个权重，且越靠后的字符权重越高。例如，可以使用多项式函数：</p>

<div class="math">
\\[
    h_k = k_1 + 27 k_2 + 27^2 k_3 \,\dots
\\]
</div>

<p>这样可以就可以增加字符间联系的作用。相应的代码实现如下：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="keyword">unsigned</span> <span token="keyword">int</span> <span token="type">index</span>;</div><br><div><span token="type">index</span> <span style="color: #82aaff;">HashWord</span>(<span token="keyword">const</span> <span token="keyword">char</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">key</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">table_size</span>) {</div><div>&#160; &#160; <span token="keyword">unsigned</span> <span token="keyword">long</span> <span token="variable">val</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&#160; &#160; <span token="keyword">while</span> (<span style="color: #7fdbca;">*</span><span style="color: #d7dbe0;">key</span> <span style="color: #c792ea;">!=</span> <span style="color: #d9f5dd;">'</span><span token="number">\0</span><span style="color: #d9f5dd;">'</span>)</div><div>&#160; &#160; &#160; &#160; <span token="variable">val</span> <span style="color: #c792ea;">=</span> (<span token="variable">val</span> <span style="color: #c792ea;">&lt;&lt;</span> <span token="number">5</span>) <span style="color: #7fdbca;">+</span> <span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">key</span><span style="color: #c792ea;">++</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span token="variable">val</span> <span style="color: #7fdbca;">%</span> <span style="color: #d7dbe0;">table_size</span>;</div><div>}</div></div>

<p>程序使用如下变式计算多项式的和：</p>

<div class="math">
\\[
    h_k = (( \dots k_3) \times 27 + k_2 ) \times 27 + k_1 
\\]
</div>

<p>使用 32 代替 27 的原因是可以通过移位加速运算。使用取模可以减少表长度，同时提升表的利用率。使用该算法时，部分计算出的对应关系如下：</p>

<div class="codeblock code-template">
    "hello"->28423<br>
    "world"->34135<br>
    "algorithm"->36119
</div>

<p>当然，该算法还是存在许多问题，不过今天的重点不是散列算法，而是需要提出一种合适的数据结构，使得发生冲突时能有相应的解决方案。接下来就介绍两种常用的方法。</p>

<h2>碰撞解决方法</h2>

<h3>分离链接法</h3>

<p><strong>分离链接法</strong>(separator chaining)将散列到同一个值的所有元素保留到一个表中。下图展示了使用<a href="/archives/592">链表模型</a>下的分离链接法：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/08-separator-chain.png" alt="" width="240">
</figure>

<p>除了使用链表，还可以使用其余任意的表、二叉树，甚至是另一个散列表来保存冲突的元素。</p>

<p>为了执行查找，散列函数指出应该使用哪一个表。如果表的个数较多且散列结果较平均，遍历表并不需要检查多少元素，总体效率还是不错的。</p>

<p>为了执行插入，同样需要遍历表以确认元素是否已经在表中；如果还未存在，则可以插入表的任意位置，取决于使用场景。</p>

<p>分离链接散列表的类型声明如下：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="type">linkedlist</span> <span token="type">hashsep_node</span>;</div><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">hashsep_table</span> {</div><div>&#160; &#160; <span token="keyword">int</span> <span style="color: #7fdbca;">size</span>;</div><div>&#160; &#160; <span token="type">hashsep_node</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">list</span>;</div><div>} <span style="color: #7fdbca;">*</span> <span token="type">hashsep_table</span>;</div></div>

<p>以上定义有些混乱，可以结合上面图示理解：<code>hashsep_table</code> 指针指向一个分离链接散列表；<code>list</code> 域指向表的主体部分，注意，它是一个指向指针的二重指针；<code>hashsep_node</code> 是一个链表，指向具体节点。下图有助于理解它们的关系：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/08-separator-chain-structure.png" alt="" width="420">
</figure>

<p>因此，分离链接散列表的创建过程为：</p>

<div class="vscode-block"><div><span token="type">hashsep_table</span> <span style="color: #82aaff;">HashSepTable_New</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">size</span>) {</div><div>&#160; &#160; <span token="type">hashsep_table</span> <span token="variable">table</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span token="keyword">struct</span><span style="color: #82aaff;"> </span><span style="color: #82aaff;text-decoration: underline;">hashsep_table</span><span style="color: #82aaff;">))</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span token="variable">table</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span style="color: #82aaff;">NULL</span>;<span style="color: #637777;"> &#160; &#160; &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of memory</span></div><div>&#160; &#160; <span token="variable">table</span>-&gt;<span style="color: #7fdbca;">size</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">size</span>;</div><div>&#160; &#160; <span token="variable">table</span>-&gt;<span style="color: #7fdbca;">list</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">hashsep_node</span><span style="color: #82aaff;">) </span><span style="color: #7fdbca;">*</span><span style="color: #82aaff;"> </span><span token="variable">table</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">size</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span token="variable">table</span>-&gt;<span style="color: #7fdbca;">list</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span style="color: #82aaff;">NULL</span>;<span style="color: #637777;"> &#160; &#160; &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of memory</span></div><div>&#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span token="variable">table</span>-&gt;<span style="color: #7fdbca;">size</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>) {</div><div>&#160; &#160; &#160; &#160; <span token="variable">table</span>-&gt;<span style="color: #7fdbca;">list</span>[<span token="variable">i</span>] <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">linkedlist_node</span><span style="color: #82aaff;">))</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="variable">table</span>-&gt;<span style="color: #7fdbca;">list</span>[<span token="variable">i</span>] <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">return</span> <span style="color: #82aaff;">NULL</span>;<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of memory</span></div><div>&#160; &#160; &#160; &#160; <span token="variable">table</span>-&gt;<span style="color: #7fdbca;">list</span>[<span token="variable">i</span>]-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">NULL</span>;</div><div>&#160; &#160; } &#160; &#160;</div><div>&#160; &#160; <span token="keyword">return</span> <span token="variable">table</span>;</div><div>}</div></div>

<p>程序中需要为散列表、散列表链表组、散列表链表组每个链表的首个节点都分配内存。定义时链表使用了表头，因此对每个链表都需要单独调整表头。</p>

<p>查找操作将返回一个包含元素的链表单元。在通过散列函数取得合适的链表后，接下来的查找等同于链表的查找：</p>

<div class="vscode-block"><div><span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span style="color: #82aaff;">HashSepTable_Find</span>(<span token="type">hashsep_table</span> <span style="color: #d7dbe0;">table</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">key</span>) {</div><div>&#160; &#160; <span token="type">linkedlist</span> <span token="variable">list</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">table</span>-&gt;<span style="color: #7fdbca;">list</span>[<span style="color: #82aaff;">Hash</span>(<span style="color: #d7dbe0;">key</span>, table_size)];</div><div>&#160; &#160; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">node</span> <span style="color: #c792ea;">=</span> <span token="variable">list</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&#160; &#160; <span token="keyword">while</span> (<span token="variable">node</span> <span style="color: #c792ea;">!=</span> <span style="color: #82aaff;">NULL</span> <span style="color: #c792ea;">&amp;&amp;</span> <span style="color: #c792ea;">!</span><span style="color: #82aaff;">Equals</span><span style="color: #82aaff;">(</span><span token="variable">node</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">elem</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">key</span><span style="color: #82aaff;">)</span>)</div><div>&#160; &#160; &#160; &#160; <span token="variable">node</span> <span style="color: #c792ea;">=</span> <span token="variable">node</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span token="variable">node</span>;</div><div>}</div></div>

<p>注意，由于使用散列时元素的值未必可以直接比较，因此这里抽象为 <code>Equals()</code> 函数，字符串的具体实现可以使用 <code>strcmp()</code> 。</p>

<p>接下来是插入，如果插入的项已经存在，则什么都不用做；否则，将其插入链表的前端：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">HashSepTable_Insert</span>(<span token="type">hashsep_table</span> <span style="color: #d7dbe0;">table</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">key</span>) {</div><div>&#160; &#160; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">node</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">HashSepTable_Find</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">table</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">key</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span token="variable">node</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>) {<span style="color: #637777;"> &#160; </span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> key not found</span></div><div>&#160; &#160; &#160; &#160; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">new_node</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">linkedlist_node</span><span style="color: #82aaff;">))</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="variable">new_node</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="number">2</span>;<span style="color: #637777;"> &#160; &#160; </span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of memory</span></div><div>&#160; &#160; &#160; &#160; <span token="type">linkedlist</span> <span token="variable">list</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">table</span>-&gt;<span style="color: #7fdbca;">list</span>[<span style="color: #82aaff;">Hash</span>(<span style="color: #d7dbe0;">key</span>, table_size)];</div><div>&#160; &#160; &#160; &#160; <span token="variable">new_node</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span token="variable">list</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">Assign</span><span style="color: #82aaff;">(</span><span token="variable">new_node</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">elem</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">key</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span token="variable">list</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span token="variable">new_node</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="number">0</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span token="keyword">return</span> <span token="number">1</span>;</div><div>}</div></div>

<p>插入链表前端的实现是最方便且高效的，并且有时候最新插入的元素可能最先被访问。不过该函数在查找和插入时两次调用了散列函数，如果将其合并可能会更快一些。</p>

<p>删除操作和链表的删除一致。很多时候散列表都没必要删除，那么不使用表头操作还会更简单一些。</p>

<p>如果定义散列表的<strong>装填因子</strong>(load factor) <span class="math">\\( \lambda \\)</span> 为散列表中元素个数与表大小的比值。表的平均长度为 <span class="math">\\( \lambda \\)</span> ，执行一次查找需要的时间为计算散列值以及遍历表所用的时间：如果不存在该元素，则遍历的链接数平均为 <span class="math">\\( \lambda \\)</span>（不包括 <code>NULL</code> 链接）；存在该元素时，需要遍历 <span class="math">\\( 1 + \lambda / 2 \\)</span> 个链接。</p>

<p>装填因子直接影响查找的效率。在以上链表实现的分离链接散列表中，要求 <span class="math">\\( \lambda \sim 1 \\)</span> ，如果比 1 大，说明元素较多，不可避免地会加长链表；如果比 1 小的多，那么表的大小不能充分利用。</p>

<p>除此之外，使用素数作为表的长度也能使元素更分散一些，比如不会使相同比例的数值分到同一个模。<a href="https://stackoverflow.com/questions/1145217/why-should-hash-functions-use-a-prime-number-modulus">stackoverflow 有一个问题</a>就是关于它的，有兴趣可以看一看里面的回答。</p>

<h3>开放定址法</h3>

<p>分离链接法的缺点是需要指针，且新单元分配内存需要时间。<strong>开放定址散列法</strong>(open addressing hashing)是另外一种用链表解决冲突的方法。该方法在遇到冲突时，尝试选择另外的单元，直到找到可用的空单元。因此所有元素都需要直接放入表中，开放定址散列法所需要的表更大，且装填因子也不能过大。</p>

<p>开放定址法的查找也是如此，当发现对应位置不是该元素时，它沿着相同的选择路径继续，直到发现空的位置，就说明该元素根本没有被插入过。</p>

<p>更一般地，当散列函数计算出结果 <span class="math">\\( h_0(X) \\)</span> 但发现该位置被占用时，它就重新计算出 <span class="math">\\( h_1(X), h_2(X) \\)</span> 等，其中：</p>

<div class="math">
\\[
    h_i(X) = (\text{hash}(X) + F(i))\mod size
\\]
</div>

<p>函数 <span class="math">\\( F \\)</span> 用于解决冲突。下面介绍几个典型的函数选择。</p>

<ul>
    <li><strong>线性探测法</strong></li>
</ul>

<p>线性探测法中，函数 <span class="math">\\( F \\)</span> 是线性函数。下图展示了这一原理：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/08-open-addressing-linear.png" alt="" width="220">
</figure>

<p>这样做的缺点是碰撞时单元会形成一些区块，导致一次<strong>聚集</strong>(primary clustering)。下一次散列到该聚集区块的值往往又需要多次线性探测，且会加重聚集区块。</p>

<p>计算结果表明线性探测的预期探测次数对插入和不成功的查找而言大约为 <span class="math">\\( 0.5(1 + 1 / (1- \lambda)^2) \\)</span> ，对成功的查找为 <span class="math">\\( 0.5(1 + 1 / (1 - \lambda)) \\)</span> 。因此线性探测法要求 <span class="math">\\( \lambda < 0.5 \\)</span> ，否则当表快满时线性探测要往下找很多个节点才能找到一个空余的，浪费较多时间。</p>

<ul>
    <li><strong>平方探测法</strong></li>
</ul>

<p>平方探测可以解决线性探测的聚集问题。平方探测就是将冲突函数改为二次函数，下图说明了为何此过程不会聚集：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/08-open-addressing-quadratic.png" alt="" width="260">
</figure>

<p>可以证明，如果使用平方探测，且表的大小是<em>素数</em>，那么当表至少有一半是空的时候，总是能插入一个元素。</p>

<blockquote>
    <p>该结论的证明需要通过一定数学公式推导。这里可以简单这么理解：当表长是素数时，在任何位置插入元素后，在不断绕回寻找可用节点时至少会有半个表被遍历到，因此只要表有一半是空的，总能找到一个合适的位置。</p>
</blockquote>

<p>不过平方探测的缺点是当表被填满超过一半时，有时甚至会出现一个合适的位置都找不到的情况。这就要求其装填因子应该低于 0.5 。</p>

<p>以平方探测法为例，开放定址法的散列表结构声明为：</p>

<div class="vscode-block"><div><span token="keyword">enum</span> <span token="type">hashquad_status</span> { </div><div>&#160; &#160; <span token="variable">HASHQUAD_USED</span>, <span token="variable">HASHQUAD_EMPTY</span>, <span token="variable">HASHQUAD_DELETED</span> };</div><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">hashquad_node</span> {</div><div>&#160; &#160; <span token="type">elemtype</span> <span style="color: #7fdbca;">elem</span>;</div><div>&#160; &#160; <span token="keyword">enum</span> <span token="type">hashquad_status</span> <span style="color: #7fdbca;">status</span>;</div><div>} <span token="type">hashquad_node</span>;</div><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">hashquad_table</span> {</div><div>&#160; &#160; <span token="keyword">int</span> <span style="color: #7fdbca;">size</span>;</div><div>&#160; &#160; <span token="type">hashquad_node</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">list</span>;</div><div>} <span style="color: #7fdbca;">*</span> <span token="type">hashquad_table</span>;</div></div>

<p>在开放定址散列表中，不能直接删除元素，否则会使定址关系断裂；如果要删除，需要使用懒惰删除策略，在定义中也增加了对懒惰删除的支持。</p>

<p>初始化开放定址散列表和初始化分离链接散列表的过程类似。由于不使用链表，因此这部分内容会简化一些：</p>

<div class="vscode-block"><div><span token="type">hashquad_table</span> <span style="color: #82aaff;">HashQuadTable_New</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">size</span>) {</div><div>&#160; &#160; <span token="type">hashquad_table</span> <span token="variable">table</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span token="keyword">struct</span><span style="color: #82aaff;"> </span><span style="color: #82aaff;text-decoration: underline;">hashquad_table</span><span style="color: #82aaff;">))</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span token="variable">table</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span style="color: #82aaff;">NULL</span>;<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of memory</span></div><div>&#160; &#160; <span token="variable">table</span>-&gt;<span style="color: #7fdbca;">size</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">size</span>;</div><div>&#160; &#160; <span token="variable">table</span>-&gt;<span style="color: #7fdbca;">list</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">hashquad_node</span><span style="color: #82aaff;">) </span><span style="color: #7fdbca;">*</span><span style="color: #82aaff;"> </span><span token="variable">table</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">size</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span token="variable">table</span>-&gt;<span style="color: #7fdbca;">list</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span style="color: #82aaff;">NULL</span>;<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of memory</span></div><div>&#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span token="variable">table</span>-&gt;<span style="color: #7fdbca;">size</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>)</div><div>&#160; &#160; &#160; &#160; <span token="variable">table</span>-&gt;<span style="color: #7fdbca;">list</span>[<span token="variable">i</span>].<span style="color: #7fdbca;">status</span> <span style="color: #c792ea;">=</span> <span token="variable">HASHQUAD_EMPTY</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span token="variable">table</span>;</div><div>}</div></div>

<p>为了执行查找操作，在查找到对应对应的表单元时，会沿着平方路径继续查找，直到找到对应的单元或发现已经到路径的结尾。结尾的标志为遇到一个 <code>EMPTY</code> 的项：</p>

<div class="vscode-block"><div><span token="type">index</span> <span style="color: #82aaff;">HashQuadTable_Find</span>(<span token="type">hashquad_table</span> <span style="color: #d7dbe0;">table</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">key</span>) {</div><div>&#160; &#160; <span token="type">index</span> <span token="variable">pos</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Hash</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">key</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">table</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">size</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span token="keyword">int</span> <span token="variable">collision</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&#160; &#160; <span token="keyword">while</span> (<span style="color: #d7dbe0;">table</span>-&gt;<span style="color: #7fdbca;">list</span>[<span token="variable">pos</span>].<span style="color: #7fdbca;">status</span> <span style="color: #c792ea;">!=</span> <span token="variable">HASHQUAD_EMPTY</span> <span style="color: #c792ea;">&amp;&amp;</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160;<span style="color: #c792ea;">!</span><span style="color: #82aaff;">Equals</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">table</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">list</span><span style="color: #82aaff;">[</span><span token="variable">pos</span><span style="color: #82aaff;">].</span><span style="color: #7fdbca;">elem</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">key</span><span style="color: #82aaff;">)</span>) {</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="variable">pos</span> <span style="color: #c792ea;">+=</span> <span token="number">2</span> <span style="color: #7fdbca;">*</span> <span style="color: #c792ea;">++</span><span token="variable">collision</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>;</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="variable">pos</span> <span style="color: #c792ea;">&gt;=</span> <span style="color: #d7dbe0;">table</span>-&gt;<span style="color: #7fdbca;">size</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="variable">pos</span> <span style="color: #c792ea;">-=</span> <span style="color: #d7dbe0;">table</span>-&gt;<span style="color: #7fdbca;">size</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span token="keyword">return</span> <span token="variable">pos</span>;</div><div>}</div></div>

<p>两个判断条件不能写反，否则当发现元素匹配时，判断短路会忽视了该位置应该不可用的事实。程序中使用平方间的关系 <span class="math">\\( (i+1)^2 = (i)^2 + 2i - 1 \\)</span> 来加速运算，并在必要的时候执行绕回。</p>

<p>查找发现不存在时，函数会返回路径上的最后一个位置，插入例程可在返回值的基础上做插入：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">HashQuadTable_Insert</span>(<span token="type">hashquad_table</span> <span style="color: #d7dbe0;">table</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">key</span>) {</div><div>&#160; &#160; <span token="type">index</span> <span token="variable">pos</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">HashQuadTable_Find</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">table</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">key</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">table</span>-&gt;<span style="color: #7fdbca;">list</span>[<span token="variable">pos</span>].<span style="color: #7fdbca;">status</span> <span style="color: #c792ea;">!=</span> <span token="variable">HASHQUAD_USED</span>) {</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">table</span>-&gt;<span style="color: #7fdbca;">list</span>[<span token="variable">pos</span>].<span style="color: #7fdbca;">status</span> <span style="color: #c792ea;">=</span> <span token="variable">HASHQUAD_USED</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">Assign</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">&amp;</span><span style="color: #d7dbe0;">table</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">list</span><span style="color: #82aaff;">[</span><span token="variable">pos</span><span style="color: #82aaff;">].</span><span style="color: #7fdbca;">elem</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">key</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="number">0</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span token="keyword">return</span> <span token="number">1</span>;</div><div>}</div></div>

<p>如果元素已经存在，那么就什么都不做。</p>

<ul>
    <li><strong>双散列</strong></li>
</ul>

<p>平方探测排除了一次聚集，但缺点是散列到同一位置上的元素将继续寻找同样的备选单元，形成<strong>二次聚集</strong>(secondary clustering)，还是会拖慢查找速度。</p>

<p>另一种解决冲突的方法是使用<strong>双散列</strong>(double hashing)，使用第二个散列函数往下寻找新的备选单元。这样做的优点是散列到同一位置的元素会再次散列到不同位置。</p>

<p>使用双散列需要谨慎选取第二个散列函数，并且会额外花费一些计算时间。</p>

<h3>再散列</h3>

<p>开放定址散列法要求装填因子不应超过 0.5 ，否则某些操作运行的时间将很长，甚至可能出现失败。如果当装填因子快达到该值，为了能将其降低，需要扩充表长。但不能直接对原表做扩容，否则绕回操作将会变化而导致单元间的联系断裂。</p>

<p>因此，需要新建一个更大的表，使用相关的新散列函数扫描原始散列表，计算每个存在的元素的新散列值并将其插入新表中。这一过程称为<strong>再散列</strong>(rehashing)，它需要耗费 <span class="math">\\( O(N) \\)</span> 的时间，因此该操作只应该在必要的时候进行，例如当装填因子到达某一个特定值。</p>

<p>再散列的实现比较简单，只需要创建一个更大（例如两倍大）的表，然后将原表内的所有元素重新插入新表内即可：</p>

<div class="vscode-block"><div><span token="type">hashquad_table</span> <span style="color: #82aaff;">HashQuadTable_Rehash</span>(<span token="type">hashquad_table</span> <span style="color: #d7dbe0;">table</span>) {</div><div>&#160; &#160; <span token="keyword">int</span> <span token="variable">old_size</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">table</span>-&gt;<span style="color: #7fdbca;">size</span>;</div><div>&#160; &#160; <span token="type">hashquad_node</span><span style="color: #7fdbca;">*</span> <span token="variable">old_list</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">table</span>-&gt;<span style="color: #7fdbca;">list</span>;</div><div>&#160; &#160; <span style="color: #d7dbe0;">table</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">HashQuadTable_New</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;">NextPrime</span><span style="color: #82aaff;">(</span><span token="variable">old_size</span><span style="color: #82aaff;"> </span><span style="color: #7fdbca;">*</span><span style="color: #82aaff;"> </span><span token="number">2</span><span style="color: #82aaff;">))</span>;</div><div>&#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span token="variable">old_size</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="variable">old_list</span>[<span token="variable">i</span>].<span style="color: #7fdbca;">status</span> <span style="color: #c792ea;">!=</span> <span token="variable">HASHQUAD_USED</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #82aaff;">HashQuadTable_Insert</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">table</span><span style="color: #82aaff;">, </span><span token="variable">old_list</span><span style="color: #82aaff;">[</span><span token="variable">i</span><span style="color: #82aaff;">].</span><span style="color: #7fdbca;">elem</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span style="color: #82aaff;">free</span><span style="color: #82aaff;">(</span><span token="variable">old_list</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span style="color: #d7dbe0;">table</span>;</div><div>}</div></div>

<p>总的来说，散列可以以常数级（或几乎是常数级）的时间执行查找或插入，但这要求散列表需要控制其装填因子。散列表可以支持非整数元素例如复数和字符串，这也是二叉查找树无法做到的一个优势。</p>

<p>散列的应用场景非常广泛，许多编程语言都提供了 Map 或 Dictionary 键值对类型，根据一个元素能获取另一个元素，许多实现用的就是散列表，可以用于配置、缓存、变量跟踪等各种场景中。</p>
<p><a rel="nofollow" href="/archives/653">数据结构05-散列</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/653/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>数据结构04-树与二叉树</title>
		<link>/archives/622</link>
					<comments>/archives/622#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sat, 06 Aug 2022 18:33:00 +0000</pubDate>
				<category><![CDATA[数据结构与算法]]></category>
		<category><![CDATA[数据结构]]></category>
		<guid isPermaLink="false">/?p=622</guid>

					<description><![CDATA[<p>树的概念 树的结构 树(tree)是一种典型的一对多&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/622">数据结构04-树与二叉树</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>树的概念</h2>

<h3>树的结构</h3>

<p><strong>树</strong>(tree)是一种典型的一对多关系，下图展示了一棵具体的树：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-tree-concrete.png" width="272">
</figure>

<p>将上图倒过来看就是生活中常见的树。树从一个主干开始，随着一对多指数级分裂，向上逐渐变茂盛。</p>

<p>可以用多种方式定义树。常见的定义方式是递归：一棵树是一些节点的集合：若集合非空，则一棵树由<strong>根</strong>(root)节点 <span class="math">\\( r \\)</span> 以及 0 个或多个非空子树 <span class="math">\\( T_1,T_2,\dots,T_k \\)</span> 组成。每棵子树的根都被来自根 <span class="math">\\( r \\)</span> 的一条有向的<strong>边</strong>(edge)所连接。</p>

<p>下图表示这种树的思想：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-tree-model.png" alt="" width="255">
</figure>

<p>每一棵子树的根称为根 <span class="math">\\( r \\)</span> 的<strong>子</strong>(child)节点，而 <span class="math">\\( r \\)</span> 是每一棵子树根的<strong>父</strong>(parent)节点。</p>

<p>子树 <span class="math">\\( T_1,T_2,\dots,T_k \\)</span> 也采用同样的方式定义，因此说这种定义是递归的。这种定义下，一棵树是 <span class="math">\\( N \\)</span> 个节点和 <span class="math">\\( N-1 \\)</span> 条边的集合（根节点 <span class="math">\\( r \\)</span> 没有对应的边）。</p>

<p>以上展示的具体的树中，根为节点 A ，每一个节点可以有任意多个子节点，包括 0 个。没有子节点的节点称为<strong>叶</strong>(leaf)，具有相同父节点的节点称为<strong>兄弟</strong>(sibling)。类似地可以定义<strong>祖父</strong>(grandparent)节点和<strong>子孙</strong>(grandchild)节点关系。</p>

<p>从节点 <span class="math">\\( n_1 \\)</span> 到节点 <span class="math">\\( n_k \\)</span> 的<strong>路径</strong>(path)定义为节点 <span class="math">\\( n_1,n_2,\dots,n_k \\)</span> 的一个序列，使得对于 <span class="math">\\( 1 \leq i < k \\)</span> ，节点 <span class="math">\\( n_i \\)</span> 是 <span class="math">\\( n_{i+1} \\)</span> 的父节点。这个路径的<strong>长</strong>(length)为该路径上边的条数，即 <span class="math">\\( n-1 \\)</span> 。从每一个节点到它自己有一条长为 0 的路径，从根到每一个节点存在且仅存在一条路径。</p>

<p>任意节点 <span class="math">\\( n_i \\)</span> 的<strong>深度</strong>(depth)为从根到该节点的唯一路径的长，根的深度为 0 ；<strong>高</strong>(height)是从 <span class="math">\\( n_i \\)</span> 到一片树叶的最长路径的长，因此所有树叶的高度都是 0 。</p>

<p>一棵树的高等于它根的高；深度等于它最深树叶的深度，且等于树的高。</p>

<p>如果存在从 <span class="math">\\( n_1 \\)</span> 到 <span class="math">\\( n_2 \\)</span> 的一条路径，称 <span class="math">\\( n_1 \\)</span> 为 <span class="math">\\( n_2 \\)</span> 的<strong>祖先</strong>(ancestor)节点，而 <span class="math">\\( n_2 \\)</span> 是 <span class="math">\\( n_1 \\)</span> 的<strong>后裔</strong>(descendant)节点。如果同时 <span class="math">\\( n_1 \neq n_2 \\)</span> ，那么 <span class="math">\\( n_1 \\)</span> 是 <span class="math">\\( n_2 \\)</span> 的一位真祖先(proper ancestor)，而 <span class="math">\\( n_2 \\)</span> 是 <span class="math">\\( n_1 \\)</span> 的一个真后裔(proper descendant)。</p>

<p>以上定义看似多余且非常不直观，但它对于分析树的性能是有帮助的。后续会介绍多种不同类型的树，它们是树的实现子集，并在某些场景上可以提升效率。</p>

<h3>树的简单实现</h3>

<p>树的应用非常广泛，其中之一就是操作系统的文件结构。在操作系统中，一个目录可能包含几个子目录或文件，子目录中又可能包含子目录或文件，这种一对多且递归的关系就可以使用树来表示。在 Windows 系统中，在命令行中显示当前目录的体系结构使用的命令就为 <code>tree</code> ：</p>

<div class="codeblock code-console"><span class="codetoken prompt">D:\sources\data-science></span> <span class="codetoken command">tree</span>
Folder PATH listing for volume Data
Volume serial number is C61A-4BF3
D:.
└───data-science
    ├───articles
    │   ├───chapter01
    │   ├───chapter02
    │   ├───chapter03
    │   ├───chapter04
    │   └───chapter05
    ├───assets
    └───images
</div>

<p>以上就是一个典型的树状结构。</p>

<p>树的节点在逻辑上存在对应关系，那么就可以借用链表的思想，在节点中使用一些指针指向它包含的每一个子节点。只需要增加节点中指针的个数就可以从一对一连接变成一对多连接，符合树的定义。</p>

<p>然而实际情况下，子节点的数量不定且可能变化，因此不能直接建立对应到每个子节点的指针。既然使用链表的思想，那么可以再重新安排一下树的结构，变成如下模型：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-tree-concrete-linkedlist.png" alt="" width="267">
</figure>

<p>该模型下，每个结点都需要两个固定的指针：一个指针指向子树，一个指针指向兄弟节点。这样就可以以确定的方式串联起整棵树的节点了，且可以很方便地管理所有的子节点。</p>

<p>不过这种树的实现不具备研究价值。下面介绍一种树的子集：二叉查找树，它是一种特定的树的实现，主要优化了查找的方式，效率比表快得多。</p>

<h2>二叉查找树</h2>

<h3>二叉树的概念</h3>

<p><strong>二叉树</strong>(binary tree)是一棵树，符合树的通用定义，但它要求其中每个节点都不能有多于两个的子节点。</p>

<p>下图展示了一个二叉树的模型，其中 <span class="math">\\( T_L \\)</span> 和 <span class="math">\\( T_R \\)</span> 均可能为空：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-tree-binary-model.png" alt="" width="226">
</figure>

<p>二叉树的重要性质是二叉树的平均深度为 <span class="math">\\( O(\sqrt{N}) \\)</span> （二叉树节点不总是左右都有节点，因此二叉树的节点一般会随着深度线性增长），不过最坏情况（都只有一边有子节点）下深度可以达到 <span class="math">\\( N-1 \\)</span> 。</p>

<p>由于该性质，二叉树在查找中很有用。</p>

<h3>二叉查找树</h3>

<p><strong>二叉查找树</strong>(binary search tree)又是一种特殊的二叉树，它满足二叉树的所有要求，但同时规定：对于树中的每个节点 <span class="math">\\( X \\)</span> ，它的左子树中的所有值小于 <span class="math">\\( X \\)</span> 中的值，而它的右子树中的所有值大于 <span class="math">\\( X \\)</span> 的值。</p>

<p>这意味着该树可以用某种统一的方式排序。在<a href="/archives/586">第一节</a>就介绍了二分查找法，并指出二分查找法有远低于线性查找的时间开销。然而二分查找必须要求结构是有序的，而对线性表的排序会涉及表项的移动，移动表项总是要消耗线性的时间，因此线性表不适合直接使用二分查找。</p>

<p>然而二叉查找树天然是有序的，它具有链表一样的常数级插入删除开销。理想的二叉查找树左右子节点都能尽可能利用，使得节点可以随着深度指数级增长，从而使平均深度达到 <span class="math">\\( O(\log N) \\)</span> 。</p>

<p>有了以上对二叉树模型的描述，二叉树的节点定义为：</p>

<div class="vscode-block"><div><span token="operator">typedef</span> <span token="keyword">struct</span> <span token="type">bsearchtree_node</span> {</div><div>&#160; &#160; <span token="type">elemtype</span> <span token="property">elem</span>;</div><div>&#160; &#160; <span token="keyword">struct</span> <span token="type">bsearchtree_node</span><span token="property">*</span> <span token="property">left</span>;</div><div>&#160; &#160; <span token="keyword">struct</span> <span token="type">bsearchtree_node</span><span token="property">*</span> <span token="property">right</span>;</div><div>} <span token="type">bsearchtree_node</span>, <span token="property">*</span> <span token="type">bsearchtree</span>;</div></div>

<p>由于二叉树最多只有两个子节点，因此不需要使用链表的方式管理子节点，可以在指针域中直接定位子节点。</p>

<p>树是一种一对多的关系，因此树的很多操作都需要沿着多个方向分裂执行。这种特点使树的操作比较复杂，并可能无法及时停止。</p>

<p>前面介绍的树是使用递归的方式定义的，那么也可以使用递归的方式操作树。这样做虽然不够直观，但可以完美贴合树的定义。</p>

<p>例如清空一棵树的操作，为了清空一棵树需要清空它的所有节点，但为了使树不发生断裂，需要逐层清空叶节点。如果采用循环的方式不能很好地执行回退操作，此时可以考虑使用递归。递归的实现非常简单：</p>

<div class="vscode-block"><div><span token="type">bsearchtree</span> <span token="func">BinSearchTree_Clear</span>(<span token="type">bsearchtree</span> <span style="color: #d7dbe0;">tree</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span token="operator">!=</span> <span token="func">NULL</span>) {</div><div>&#160; &#160; &#160; &#160; <span token="func">BinSearchTree_Clear</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">)</span>;</div><div>&#160; &#160; &#160; &#160; <span token="func">BinSearchTree_Clear</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">)</span>;</div><div>&#160; &#160; &#160; &#160; <span token="func">free</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">)</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span token="keyword">return</span> <span token="func">NULL</span>;</div><div>}</div></div>

<p>在删除一棵树时，需要先删除它的左右子节点：如果存在左右子节点，就说明有子树，那么就进入左右子树递归删除；否则就说明该节点已经是树叶了，被删除也没有影响。在确保子树都被删除了以后，再删除节点自身。考虑到这里使用了双递归，还不是尾递归，因此无法很轻松地改写为循环。</p>

<p>递归实现下，终止条件非常重要。在清空例程中，递归的终止条件为不存在子节点，那么就停止递归，返回上一步。由于二叉搜索树的平均深度为 <span class="math">\\( O(\log N) \\)</span> ，递归消耗的空间资源增长率也与其类似，不易发送空间不够的情况。</p>

<p>根据这种思想，可以实现查找。查找操作一般需要返回指向树中含有对应值的节点的指针（而不是一个索引）。如果这样的节点不存在，则返回空指针。</p>

<p>根据二叉查找树的定义，如果查找的值比当前节点的值小，那么可能的值存在于它的左子树中，就去它左子树中查找；如果值比当前节点的值大，那么就去它右子树中查找，这也很适合用递归的方式实现：</p>

<div class="vscode-block"><div><span token="type">bsearchtree_node</span><span token="property">*</span> <span token="func">BinSearchTree_Find</span>(<span token="type">bsearchtree</span> <span style="color: #d7dbe0;">tree</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span token="operator">==</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="func">NULL</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">value</span> <span token="operator">&lt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="func">BinSearchTree_Find</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">, </span><span style="color: #d7dbe0;">value</span><span token="func">)</span>;</div><div>&#160; &#160; <span token="keyword">else</span> <span token="keyword">if</span> (<span style="color: #d7dbe0;">value</span> <span token="operator">&gt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="func">BinSearchTree_Find</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">, </span><span style="color: #d7dbe0;">value</span><span token="func">)</span>;</div><div>&#160; &#160; <span token="keyword">else</span></div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span style="color: #d7dbe0;">tree</span>;</div><div>}</div></div>

<p>注意测试的顺序，关键问题是需要首先测试当前位置是否为空树，否则后续的查找会出现问题。同时还需要将最不可能的情况，也就是正好找到的情况放在最后一步执行。</p>

<p>这里同样遵循树的递归定义，并且使用的是单个的尾递归，因此可以方便地使用 <code>while</code> 循环实现。</p>

<p>可以使用类似的方法查找树的最值。由于如果存在左子树，左子树上的值总是比当前节点的值小的，因此如果要找到最小值，可以不断递归遍历左子树，直到达到最大深度为止。最大值可也用类似的方式找出。</p>

<p>下面给出了分别用递归和循环实现的查找最值：</p>

<div class="vscode-block"><div><span token="type">bsearchtree_node</span><span token="property">*</span> <span token="func">BinSearchTree_FindMin</span>(<span token="type">bsearchtree</span> <span style="color: #d7dbe0;">tree</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span token="operator">==</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="func">NULL</span>;</div><div>&#160; &#160; <span token="keyword">else</span> <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span> <span token="operator">==</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span style="color: #d7dbe0;">tree</span>;</div><div>&#160; &#160; <span token="keyword">else</span></div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="func">BinSearchTree_FindMin</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">)</span>;</div><div>}</div><div><span token="type">bsearchtree_node</span><span token="property">*</span> <span token="func">BinSearchTree_FindMax</span>(<span token="type">bsearchtree</span> <span style="color: #d7dbe0;">tree</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span token="operator">!=</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">while</span> (<span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span> <span token="operator">!=</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span> <span token="operator">=</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span style="color: #d7dbe0;">tree</span>;</div><div>}</div></div>

<p>查找最值的要点与普通查找类似，都要注意终止条件是树已经到达最深的位置了。除此之外，最好判断一下一开始传入的树是否为空树。</p>

<h3>插入与删除操作</h3>

<p>二叉查找树的插入和删除比较复杂。二叉查找树为了维持有序结构，插入和删除都不像链表那么简单，而是要将待插入的内容插入到正确的位置，这个位置一般是确定的。</p>

<p>插入稍微简单一些。不过需要注意的是，之前在介绍二叉查找树时都假定树中的元素都有着不同的值，如果待插入的值与某个节点的值相同，那么就要根据实际情况安排它：要么将其丢弃，要么用别的方式记录它。</p>

<p>插入的实现如下，一个插入例程可以在查找的基础上编写：如果找到与待插入元素相同的节点，那么就什么也不用做；否则沿着应有的路径继续向下查找，并将其插入到查找路径的最后一点上。</p>

<p>下图展示了这种插入思路：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-tree-insert.png" alt="" width="180">
</figure>

<p>为了插入元素 5 ，尝试沿着路径搜索 5 ：6(向左找)→2(向右找)→4(向右找)→找到底了，那么这个位置满足二叉查找树的要求，就将其插入这个位置上。</p>

<p>可见插入都是在叶节点上完成，既然使用查找的方式寻找合适的插入位置，那么下一次查找、插入时也可以顺利找到该节点，且不会使树存在重复的元素。</p>

<p>如果经常发生重复插入的情况，或者需要允许元素重复，可以在节点中附加一个记录频率的字段来保存该信息。这样做的优点是在删除时可以直接将频率字段减 1 ，而不需要真正移除节点，降低了实现的难度。</p>

<p>根据该原理，以下是插入的例程，注意还是用递归的方式实现的：</p>

<div class="vscode-block"><div><span token="type">bsearchtree</span> <span token="func">BinSearchTree_Insert</span>(<span token="type">bsearchtree</span> <span style="color: #d7dbe0;">tree</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span token="operator">==</span> <span token="func">NULL</span>) {<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> empty tree, should create first</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span> <span token="operator">=</span> <span token="func">malloc</span><span token="func">(</span><span token="property">sizeof</span><span token="func">(</span><span style="color: #82aaff;text-decoration: underline;">bsearchtree_node</span><span token="func">))</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span token="operator">==</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="func">NULL</span>;<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> fail to allocate memory</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span> <span token="operator">=</span> <span style="color: #d7dbe0;">value</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span> <span token="operator">=</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span> <span token="operator">=</span> <span token="func">NULL</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span token="keyword">else</span> <span token="keyword">if</span> (<span style="color: #d7dbe0;">value</span> <span token="operator">&lt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span> <span token="operator">=</span> <span token="func">BinSearchTree_Insert</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">, </span><span style="color: #d7dbe0;">value</span><span token="func">)</span>;</div><div>&#160; &#160; <span token="keyword">else</span> <span token="keyword">if</span> (<span style="color: #d7dbe0;">value</span> <span token="operator">&gt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span> <span token="operator">=</span> <span token="func">BinSearchTree_Insert</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">, </span><span style="color: #d7dbe0;">value</span><span token="func">)</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span style="color: #d7dbe0;">tree</span>;<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> value is in the tree already</span></div><div>}</div></div>

<p>每一次递归时，都尝试到子树中执行插入；真正的插入发送在子树为空的情况（到达边缘位置了），那么就在原地创建一个新的节点并容纳插入值。为了让新的节点成为树的一部分，将该函数写成返回一个指向新根节点的指针，并在递归回退时重新建立路径上的所有指针。</p>

<p>删除显然是最困难的过程，为了确保删除时维持树的稳定，要考虑多种不同的情况：</p>

<ul>
    <li>待删除的节点是一片树叶：这种情况下删除并不会影响树的其余部分，可以立即删除</li>
    <li>待删除的节点只有一个子节点：这种删除类似链表删除，只需要调整父节点的指针绕过该节点，指向子节点即可</li>
</ul>

<p>下图展示了删除的节点只有一个子节点的情况：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-single-delete.png" width="200" alt="">
</figure>

<p>删除前后，整个树的结构仍然符合二叉查找树的定义。</p>

<ul>
    <li>待删除的节点有两个子节点：这是真正复杂的一种情况，因为不但要删除对应节点，还需要安排它的两个子节点到合适的位置</li>
</ul>

<p>这种情况下，一般的删除方法是用其右子树中最小的数据代替该结点的数据，然后再递归去除右子树中该最小数据。由于右子树中最小的数据也比左子树中的任意节点大，因此这样的操作既能去除该节点，同时符合二叉查找树的定义。</p>

<p>下图展示了从一棵较为复杂的树中删除值 4 的情况：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-tree-delete-complex.png" alt="" width="450">
</figure>

<p>该删除分几步：首先找到节点 4 ，并用右子树中最小数据 6 代替；然后还需要删除右子树中重复数据 6 ，那么继续沿着该路径查找 6 ，找到后以相同的方式删除 6 。这里右子树中的 6 只有一个子节点，因此只需要像链表一样删除即可。</p>

<p>删除完成之后，总体看下来，仍然符合二叉查找树的定义。</p>

<p>二叉查找树删除的原理其实不算太复杂，但难点在于如何实现。每一步不仅需要分析子节点个数，总体还需要满足递归的要求。</p>

<p>二叉查找树删除的例程如下：</p>

<div class="vscode-block"><div><span token="type">bsearchtree_node</span><span token="property">*</span> <span token="func">BinSearchTree_Remove</span>(<span token="type">bsearchtree</span> <span style="color: #d7dbe0;">tree</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span token="operator">==</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="func">NULL</span>;<span style="color: #637777;"> &#160; &#160; &#160; &#160; &#160; &#160; &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> element not found</span></div><div>&#160; &#160; <span token="type">bsearchtree_node</span><span token="property">*</span> <span token="variable">temp</span>;</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">value</span> <span token="operator">&lt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span>)<span style="color: #637777;"> &#160; &#160; &#160; </span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> go left</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span> <span token="operator">=</span> <span token="func">BinSearchTree_Remove</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">, </span><span style="color: #d7dbe0;">value</span><span token="func">)</span>;</div><div>&#160; &#160; <span token="keyword">else</span> <span token="keyword">if</span> (<span style="color: #d7dbe0;">value</span> <span token="operator">&gt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span>)<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> go right</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span> <span token="operator">=</span> <span token="func">BinSearchTree_Remove</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">, </span><span style="color: #d7dbe0;">value</span><span token="func">)</span>;</div><div>&#160; &#160; <span token="keyword">else</span> <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span> <span token="operator">&amp;&amp;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span>) {<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> element found with 2 children</span></div><div><span style="color: #a8a8a8;">&#160; &#160; &#160; &#160; /* replace by min value in right subtree */</span></div><div>&#160; &#160; &#160; &#160; <span token="variable">temp</span> <span token="operator">=</span> <span token="func">BinSearchTree_FindMin</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">)</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span> <span token="operator">=</span> <span token="variable">temp</span>-&gt;<span token="property">elem</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span> <span token="operator">=</span> <span token="func">BinSearchTree_Remove</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">, </span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">elem</span><span token="func">)</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span token="keyword">else</span> {<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> element found with 0 or 1 children</span></div><div>&#160; &#160; &#160; &#160; <span token="variable">temp</span> <span token="operator">=</span> <span style="color: #d7dbe0;">tree</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span> <span token="operator">==</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span> <span token="operator">=</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">else</span> <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span> <span token="operator">==</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span> <span token="operator">=</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span>;</div><div>&#160; &#160; &#160; &#160; <span token="func">free</span><span token="func">(</span><span token="variable">temp</span><span token="func">)</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span token="keyword">return</span> <span style="color: #d7dbe0;">tree</span>;</div><div>}</div></div>

<p>以上函数可以分为几个部分：最前面用于递归查找待删除元素，如果找到了判断子节点个数：如果有两个子节点，查找右侧最小值替换该位置，并再次递归地查找、删除该最小值；如果有 0 个或 1 个子节点，那么就按正常的方式删除。</p>

<p>可以预见的是，删除过程会越来越向深的方向进行，并总会遇到边缘位置（不全有两个子节点），这也就是递归终止的条件。</p>

<p>以上程序中，每次删除时还需要先查找出最小值替换节点，然后还要查找删除该最小值。这两步有些重复了，可以将其结合以提高运行效率，不过程序可能还会复杂一些。</p>

<h3>效率分析</h3>

<p>直观上看，除了清空操作外，对二叉查找树的搜索、插入、删除（插入与删除都基于查找实现）都花费 <span class="math">\\( O(\log N) \\)</span> 的时间。因为每次用常数时间在树中降低一层时，就会排除剩余的一半节点。</p>

<p>严格来说，二叉查找树的时间花费与深度相关，如果 <span class="math">\\( d \\)</span> 是包含访问值的节点深度，那么操作将花费 <span class="math">\\( O(d) \\)</span> 时间。然而，实际情况下看，二叉查找树的深度并没有达到理想的平均情况。其原因出在删除操作，该操作总是用右子树中的一个节点代替原有节点，这就会造成：</p>

<ul>
    <li>右子树少了一个节点，并且随着递归删除，删除节点的位置越来越往右下</li>
    <li>原先节点的值变大，下一次插入的位置可能会变到左边</li>
</ul>

<p>因此，该删除操作有助于使左子树变深，右子树变浅。在足够多的随机插入和删除操作下，一棵树会不可避免地左沉：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-tree-left-lean.png" alt="" width="460">
</figure>

<p>左沉使右侧节点的利用率变低，不能很好地利用两个子节点位置。一种极端的情况是每个节点的右节点都没有值，那么二叉树将会退化为有序的链表，使得深度变为 <span class="math">\\( N-1 \\)</span> 。可以证明，如果随机交替插入和删除 <span class="math">\\( N^2 \\)</span> 次，那么树的期望深度为 <span class="math">\\( \sqrt{N} \\)</span> 。</p>

<p>如果能对左沉的树重新编排节点的位置，那么有助于缓解这一情况。例如，对以上删除示例中使用到的左沉的树重新排列节点后，树的深度从 6 减少为了 4 ：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-tree-left-lean-example.png" alt="" width="530">
</figure>

<p>如果在删除时随机选择右子树的最小元素或左子树的最大元素来代替它，确实有助于缓解倾斜问题。不过在条件不好的情况下，还是可能发现倾斜。这就要求树必须要能够有简单的方式做调整，使得后面操作效率更高。</p>

<p>下面介绍一种二叉查找树的改进版本，它优化了对自调整的支持，</p>

<!-- finished:2022-08-03 -->

<h2>AVL树</h2>

<h3>AVL树的概念</h3>

<p><strong>AVL</strong>(Adelson-Velskii and Landis)树是带有平衡条件的二叉查找树。平衡意味着每个节点子树的高度要相近（完全等高太严格也难以实现），使整棵树不会明显倾斜，拥有接近 <span class="math">\\( \log N \\)</span> 的高度。</p>

<p>一棵 AVL 树每个节点的左子树和右子树的高度最多差 1（空树的高度定义为 -1 ），并在每一个节点中保留高度信息。</p>

<p>调整树会消耗一定时间，这就要求不能太过频繁地调整，或一次只调整树的一部分。插入操作一定会破坏 AVL 树的完整性，因此可以在插入后对周围的节点做一定的调整，使其恢复 AVL 树的性质。对 AVL 树的修正可以使用<strong>旋转</strong>(rotation)来完成。</p>

<p>下图是一棵平衡的 AVL（子）树，因为左右子树的高度只差 1 。然而，对左侧子树的插入会破坏该平衡。插入有两种情况：一种是发生在“外侧”的插入，另一种是发生在“内侧”的插入。对右子树的插入实质上的对称的，虽然需要使用不同的代码处理。</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-avltree-unbalance.png" alt="" width="250">
</figure>

<p>发生在“外侧”的插入可以通过对树的一次<strong>单旋转</strong>(single rotation)调整，发生在“内侧”的插入可以通过对树的一次<strong>双旋转</strong>(single rotation)调整。本节介绍旋转的基本原理，并给出简单的代码实现。</p>

<p>首先，采用以下代码实现 AVL 树并计算节点的高度：</p>

<div class="vscode-block"><div><span token="operator">typedef</span> <span token="keyword">struct</span> <span token="type">avltree_node</span> {</div><div>&#160; &#160; <span token="type">elemtype</span> <span token="property">elem</span>;</div><div>&#160; &#160; <span token="keyword">struct</span> <span token="type">avltree_node</span><span token="property">*</span> <span token="property">left</span>;</div><div>&#160; &#160; <span token="keyword">struct</span> <span token="type">avltree_node</span><span token="property">*</span> <span token="property">right</span>;</div><div>&#160; &#160; <span token="keyword">int</span> <span token="property">height</span>;</div><div>} <span token="type">avltree_node</span>, <span token="property">*</span> <span token="type">avltree</span>;</div><br><div><span token="keyword">static</span> <span token="keyword">int</span> <span token="func">AvlTree_Height</span>(<span token="keyword">const</span> <span token="type">avltree_node</span><span token="property">*</span> <span style="color: #d7dbe0;">node</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">node</span> <span token="operator">==</span> <span token="func">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="property">-</span><span token="number">1</span>;<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> empty tree</span></div><div>&#160; &#160; <span token="keyword">return</span> <span style="color: #d7dbe0;">node</span>-&gt;<span token="property">height</span>;</div><div>}</div></div>

<p>接下来介绍旋转操作。</p>

<h3>AVL树的旋转</h3>

<p>AVL 树的旋转分为单旋转和双旋转两种，分别调整不同的不平衡情况。</p>

<ul>
    <li><strong>单旋转</strong></li>
</ul>

<p>下图展示了一个不平衡树的抽象模型，对 <span class="math">\\( X \\)</span> 节点的插入使 <span class="math">\\( Z \\)</span> 明显不平衡：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-avltree-single-rotate.png" alt="" width="370">
</figure>

<p>为了恢复树的平衡，需要调整两者的位置。但是为了满足二叉查找树的定义，不能直接交换它们，而是需要调整节点间的指向关系，使水平位置满足 <span class="math">\\( [X, k_1, k_2, Z] \\)</span> 的顺序。</p>

<p>可以将单旋转看成一个不平衡的杠杆，为了使其恢复平衡，需要将支点的位置移到更靠近重心处。</p>

<p>以下给出了单旋转的代码实现：</p>

<div class="vscode-block"><div><span token="keyword">static</span> <span token="type">avltree_node</span><span token="property">*</span> <span token="func">AvlTree_LeftSingleRotate</span>(<span token="type">avltree_node</span><span token="property">*</span> <span style="color: #d7dbe0;">k2</span>) {</div><div>&#160; &#160; <span token="type">avltree_node</span><span token="property">*</span> <span style="color: #c5e478;">k1</span> <span token="operator">=</span> <span style="color: #d7dbe0;">k2</span>-&gt;<span token="property">left</span>;</div><div>&#160; &#160; <span style="color: #d7dbe0;">k2</span>-&gt;<span token="property">left</span> <span token="operator">=</span> <span style="color: #c5e478;">k1</span>-&gt;<span token="property">right</span>;</div><div>&#160; &#160; <span style="color: #c5e478;">k1</span>-&gt;<span token="property">right</span> <span token="operator">=</span> <span style="color: #d7dbe0;">k2</span>;</div><div>&#160; &#160; <span style="color: #d7dbe0;">k2</span>-&gt;<span token="property">height</span> <span token="operator">=</span> <span token="func">max</span><span token="func">(</span><span token="func">AvlTree_Height</span><span token="func">(</span><span style="color: #d7dbe0;">k2</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">), </span><span token="func">AvlTree_Height</span><span token="func">(</span><span style="color: #d7dbe0;">k2</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">))</span> <span token="property">+</span> <span token="number">1</span>;</div><div>&#160; &#160; <span style="color: #c5e478;">k1</span>-&gt;<span token="property">height</span> <span token="operator">=</span> <span token="func">max</span><span token="func">(</span><span token="func">AvlTree_Height</span><span token="func">(</span><span style="color: #c5e478;">k1</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">), </span><span style="color: #d7dbe0;">k2</span><span token="func">-&gt;</span><span token="property">height</span><span token="func">)</span> <span token="property">+</span> <span token="number">1</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span style="color: #c5e478;">k1</span>;<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> new root</span></div><div>}</div></div>

<p>对指针指向的修改可以参照旋转模型实现。在修改后还要调整节点高度，为子节点最大高度多一层。</p>

<p>以上介绍的是左侧插入的单旋转，另一侧的单旋转可以通过镜像操作实现。</p>

<ul>
    <li><strong>双旋转</strong></li>
</ul>

<p>单旋转对“内侧”的插入无效，下面通过实际情况展示了这样失败的原因：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-avltree-single-rotate-failure.png" alt="" width="350">
</figure>

<p>“内侧”插入模型可以看作一个天平，不平衡之处发生在中心，因此不能通过调整两端节点达到平衡。</p>

<p>以下模型展示了使用双旋转修复 AVL 树的方法：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-avltree-double-rotate.png" alt="" width="400">
</figure>

<p>插入可能发生在 <span class="math">\\( B \\)</span> 或 <span class="math">\\( C \\)</span> 位置。为了重新平衡，必须让靠“中间”的节点，即 <span class="math">\\( k_2 \\)</span> 作为新的根。</p>

<p>双旋转操作下，不管插入的位置发生在 <span class="math">\\( B \\)</span> 还是 <span class="math">\\( C \\)</span> ，旋转之后树总是平衡的。</p>

<p>双旋转操作可以以一种简洁的形式完成。下图展示的树由于插入了节点 3 ，而使 10 的两个子节点高度差 2 变得不平衡。但如果对 10 的左节点做一次右单旋转：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-avltree-double-rotate-example-1.png" alt="" width="400">
</figure>

<p>尽管还是没有平衡，但是这次的不平衡好像插入变到了“外侧”去了，那么只需要再对 10 做一次单旋转即可维持平衡：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-avltree-double-rotate-example-2.png" alt="" width="440">
</figure>

<p>因此，代码可以以一种很简单的形式实现：</p>

<div class="vscode-block"><div><span token="keyword">static</span> <span token="type">avltree_node</span><span token="property">*</span> <span token="func">AvlTree_LeftDoubleRotate</span>(<span token="type">avltree_node</span><span token="property">*</span> <span style="color: #d7dbe0;">k3</span>) {</div><div>&#160; &#160; <span style="color: #d7dbe0;">k3</span>-&gt;<span token="property">left</span> <span token="operator">=</span> <span token="func">AvlTree_RightSingleRotate(</span><span style="color: #d7dbe0;">k3</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">)</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span token="func">AvlTree_LeftSingleRotate</span><span token="func">(</span><span style="color: #d7dbe0;">k3</span><span token="func">)</span>;</div><div>}</div></div>

<p>所有的旋转都只需要调整几个指针和高度，都是常数级的。</p>

<p>有了旋转的操作之后，就可以对 AVL 树做插入。插入毫无疑问非常复杂，因为它是在二叉查找树的插入基础上完善的。为了将 <span class="math">\\( X \\)</span> 节点插入到一棵 AVL 树 <span class="math">\\( T \\)</span> 中，需要递归地将其插入 <span class="math">\\( T \\)</span> 的子树 <span class="math">\\( T_{LR} \\)</span> 中。如果 <span class="math">\\( T_{LR} \\)</span> 的高度不变，那么插入完成；否则出现高度不平衡的情况，要适当做旋转。</p>

<p>下面展示了插入的代码实现：</p>

<div class="vscode-block"><div><span token="type">avltree</span> <span token="func">AvlTree_Insert</span>(<span token="type">avltree</span> <span style="color: #d7dbe0;">tree</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span token="operator">==</span> <span token="func">NULL</span>) {<span style="color: #637777;"> &#160; &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> create and return a one-node tree</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span> <span token="operator">=</span> <span token="func">malloc(</span><span token="property">sizeof</span><span token="func">(</span><span style="color: #82aaff;text-decoration: underline;">avltree_node</span><span token="func">))</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span token="operator">==</span> <span token="func">NULL</span>)<span style="color: #637777;"> &#160;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> out of memory</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">return</span> <span token="func">NULL</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span> <span token="operator">=</span> <span style="color: #d7dbe0;">elem</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">height</span> <span token="operator">=</span> <span token="number">0</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span> <span token="operator">=</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span> <span token="operator">=</span> <span token="func">NULL</span>;</div><div>&#160; &#160; }</div><div>&#160; &#160; <span token="keyword">else</span> <span token="keyword">if</span> (<span style="color: #d7dbe0;">elem</span> <span token="operator">&lt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span>) {</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span> <span token="operator">=</span> <span token="func">AvlTree_Insert</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">, </span><span style="color: #d7dbe0;">elem</span><span token="func">)</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="func">AvlTree_Height</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">)</span> <span token="property">-</span> <span token="func">AvlTree_Height</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">)</span> <span token="operator">==</span> <span token="number">2</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">elem</span> <span token="operator">&lt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">left</span>-&gt;<span token="property">elem</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span> <span token="operator">=</span> <span token="func">AvlTree_LeftSingleRotate</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">)</span>;</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">else</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span> <span token="operator">=</span> <span token="func">AvlTree_LeftDoubleRotate</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">)</span>;</div><div>&#160; &#160; } &#160; &#160;</div><div>&#160; &#160; <span token="keyword">else</span> <span token="keyword">if</span> (<span style="color: #d7dbe0;">elem</span> <span token="operator">&gt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">elem</span>) {</div><div>&#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span> <span token="operator">=</span> <span token="func">AvlTree_Insert</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">, </span><span style="color: #d7dbe0;">elem</span><span token="func">)</span>;</div><div>&#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span token="func">AvlTree_Height</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">)</span> <span token="property">-</span> <span token="func">AvlTree_Height</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">)</span> <span token="operator">==</span> <span token="number">2</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">elem</span> <span token="operator">&gt;</span> <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">right</span>-&gt;<span token="property">elem</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span> <span token="operator">=</span> <span token="func">AvlTree_RightSingleRotate(</span><span style="color: #d7dbe0;">tree</span><span token="func">)</span>;</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="keyword">else</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #d7dbe0;">tree</span> <span token="operator">=</span> <span token="func">AvlTree_RightDoubleRotate</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">)</span>;</div><div>&#160; &#160; }</div><div><span style="color: #a8a8a8;">&#160; &#160; /* elem is in the tree already */</span></div><div>&#160; &#160; <span style="color: #d7dbe0;">tree</span>-&gt;<span token="property">height</span> <span token="operator">=</span> <span token="func">max</span><span token="func">(</span><span token="func">AvlTree_Height</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">left</span><span token="func">), </span><span token="func">AvlTree_Height</span><span token="func">(</span><span style="color: #d7dbe0;">tree</span><span token="func">-&gt;</span><span token="property">right</span><span token="func">))</span> <span token="property">+</span> <span token="number">1</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span style="color: #d7dbe0;">tree</span>;</div><div>}</div></div>

<p>以上使用递归实现，代码是在二叉查找树的基础上扩充实现的，主要增加了高度的计算和旋转的操作，旋转发生的条件可以参考模型。</p>

<p>对 AVL 树删除的实现很复杂，因此这里不再介绍。如果删除不频繁的情况下，一般采取<strong>懒惰删除</strong>(lazy deletion)的方式，即在节点中附加一个额外的域，当删除时在该域中做标记或使频次减 1 。</p>

<h3>树的遍历</h3>

<p>由于前文介绍了树的清空操作，它就是一种遍历。因此遍历打印树可以通过类似的方式完成。</p>

<p>下面给出了一种至少能看的打印操作：</p>

<div class="vscode-block"><div><span token="keyword">static</span> <span token="keyword">void</span> <span style="color: #82aaff;">AvlTree_PrintNode</span>(<span token="type">avltree_node</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">node</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">depth</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">node</span> <span style="color: #c792ea;">&amp;&amp;</span> <span style="color: #d7dbe0;">node</span>-&gt;<span style="color: #7fdbca;">height</span> <span style="color: #c792ea;">&gt;</span> <span token="number">0</span>) {</div><div>&#160; &#160; &#160; &#160; <span token="keyword">for</span> (<span token="keyword">int</span> <span style="color: #c5e478;">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span style="color: #c5e478;">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">depth</span>; <span style="color: #c5e478;">i</span><span style="color: #c792ea;">++</span>)</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #82aaff;">printf(</span><span style="color: #d9f5dd;">"</span><span style="color: #ecc48d;">—</span><span style="color: #d9f5dd;">"</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">printf(</span><span style="color: #d9f5dd;">"</span> <span style="color: #82aaff;">%d</span><span token="number">\n</span><span style="color: #d9f5dd;">"</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">node</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">elem</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; }</div><div>}</div><div><span token="keyword">void</span> <span style="color: #82aaff;">AvlTree_Print</span>(<span token="type">avltree</span> <span style="color: #d7dbe0;">tree</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">depth</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span>) {</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">AvlTree_Print</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">tree</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">left</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">depth</span><span style="color: #82aaff;"> </span><span style="color: #7fdbca;">+</span><span style="color: #82aaff;"> </span><span token="number">1</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">AvlTree_PrintNode</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">tree</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">depth</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; &#160; &#160; <span style="color: #82aaff;">AvlTree_Print</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">tree</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">right</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">depth</span><span style="color: #82aaff;"> </span><span style="color: #7fdbca;">+</span><span style="color: #82aaff;"> </span><span token="number">1</span><span style="color: #82aaff;">)</span>;</div><div>&#160; &#160; }</div><div>}</div><div><span style="color: #c792ea;">#</span><span token="keyword">define</span> <span style="color: #82aaff;">avltree_print</span><span style="color: #d9f5dd;">(</span><span style="color: #d7dbe0;">avl</span><span style="color: #d9f5dd;">)</span> <span style="color: #82aaff;">AvlTree_Print</span>(avl, <span token="number">0</span>)</div></div>

<p>将相邻层顶点之间用线连接，即可看到一棵抽象的二叉查找树：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/07-avltree-print.png" alt="" height="360">
</figure>

<p>打印结果从上到下是有序的，说明二叉查找树也是有序的，因此可以换来大量数据时很快的查找效率。并且不管节点间深度有什么关系，值小的节点一定排在值大的节点的左边（图中表示为上面），因此对二叉查找树的修改一定也要维持这种规律。</p>

<p>打印的遍历是先处理左边节点，然后处理自身再处理右边节点，这种遍历称为<strong>中序遍历</strong>(inorder traversal)，其特点是元素可以按顺序处理；而清空的遍历需要处理完两个子树后再处理自身，这种遍历称为<strong>后序遍历</strong>(postorder traversal)，特点是从下向上逐层遍历。</p>

<p>第三种常用的遍历方式是<strong>先序遍历</strong>(preorder traversal)，当前节点在子节点前优先处理，可以用来利用节点深度标志标志每一个节点：</p>

<div class="vscode-block"><div><span token="keyword">int</span> <span style="color: #82aaff;">AvlTree_Height</span>(<span token="type">avltree</span> <span style="color: #d7dbe0;">tree</span>) {</div><div>&#160; &#160; <span token="keyword">if</span> (<span style="color: #d7dbe0;">tree</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&#160; &#160; &#160; &#160; <span token="keyword">return</span> <span style="color: #7fdbca;">-</span><span token="number">1</span>;</div><div>&#160; &#160; <span token="keyword">return</span> <span token="number">1</span> <span style="color: #7fdbca;">+</span> <span style="color: #82aaff;">max</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;">AvlTree_Height</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">tree</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">left</span><span style="color: #82aaff;">), </span><span style="color: #82aaff;">AvlTree_Height</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">tree</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">right</span><span style="color: #82aaff;">))</span>;</div><div>}</div></div>

<p>总的来说，二叉查找树是一种比较经典的数据结构，它提出了一种较为高效的查找解决方案。二叉查找树并不是唯一的查找树，还有许多类似的、甚至更高效的查找树实现。不过对树的介绍暂时告一段落，接下来研究散列表，它实现了一种更快速的、常数级的查找，不过其限制也更大。</p>
<p><a rel="nofollow" href="/archives/622">数据结构04-树与二叉树</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/622/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>数据结构03-栈和队列</title>
		<link>/archives/609</link>
					<comments>/archives/609#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 04 Aug 2022 02:00:38 +0000</pubDate>
				<category><![CDATA[数据结构与算法]]></category>
		<category><![CDATA[数据结构]]></category>
		<guid isPermaLink="false">/?p=609</guid>

					<description><![CDATA[<p>很多时候都需要将表作为某个暂时存储的容器，此时就需要&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/609">数据结构03-栈和队列</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>很多时候都需要将表作为某个暂时存储的容器，此时就需要频繁地添加或删除表中的元素。</p>

<p>然而，线性表的插入或删除需要线性时间，显然不适合频繁修改。链表的修改虽然需要只需要常数级时间，但是涉及内存的动态分配、指针的调整等，操作还是有些复杂。</p>

<p>本节介绍栈和队列的概念，栈和队列可以看作特殊的线性表，它们主要简化了插入或删除的操作，使得这一过程非常高效，很适合用于密集的调整操作。</p>

<h2 id="stack">栈</h2>

<h3>栈的概念</h3>

<p><strong>栈</strong>(stack)是限制插入和删除都只能在一个位置上进行的表，该位置是表的末端，又称为<strong>栈顶</strong>(top)。下图列出了栈的概念：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/05-stack-concept.png" alt="" width="220">
</figure>

<p>对栈的基本操作有<strong>入栈</strong>(push)和<strong>出栈</strong>(pop)，前者向栈内添加一个元素，后者向栈内移除一个元素。从图中可以看出，栈的特点是后添加的元素必须先被移除后，才能处理前面添加的元素，因此栈有时又被称为<strong>后进先出</strong>(last in first out, LIFO)表。</p>

<p>栈需要有一个<strong>栈顶指针</strong>实时指示栈顶的位置，对栈元素的访问及修改等操作都通过栈顶指针来实现。当元素入栈或出栈时，栈顶指针也相应被改变。一般来说，栈顶指针不能轻易被改变，因此栈顶指针指向的元素是唯一的可见元素。</p>

<p>栈可以使用许多形式实现，首先来看最简单的数组实现方式。</p>

<h3>栈的数组实现</h3>

<p>数组实现避免了直接使用指针，是更加简单且应用广泛的解决方案。这种方式的唯一缺点是需要提前声明一个数组的大小。</p>

<p>用数组实现下，每一个栈结构需要有一个成员 <code>topptr</code> ，用于指示栈顶在数组中的哪一个位置。对于空栈而言，它的值一般是是 -1 或 0 。下图展示了栈的数组实现模型：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/05-stack-model.png" alt="" width="108">
</figure>

<p>根据以上介绍，栈的数组实现的结构定义为：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">size</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">topptr</span>;</div><div>&nbsp; &nbsp; <span token="type">elemtype</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">body</span>;</div><div>} <span token="type">stack</span>;</div><br><div><span style="color: #c792ea;">#</span><span token="keyword">define</span> <span style="color: #82aaff;">STACK_NULLTOP</span> (<span token="number">0</span>)</div></div>

<p>数组实现下，栈的入栈和出栈操作分别如下：</p>

<p>为了将某个元素压入栈中，需要将栈顶位置上移一层，然后置栈的栈顶位置为入栈元素。相应的实现为：</p>

<div class="vscode-block"><div><span style="color: #82aaff;">bool</span> <span style="color: #82aaff;">Stack_IsFull</span>(<span token="type">stack</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">topptr</span> <span style="color: #c792ea;">&gt;=</span> <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">size</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>;</div><div>}</div><div><span token="type">status</span> <span style="color: #82aaff;">Stack_Push</span>(<span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>, <span token="type">stack</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #82aaff;">Stack_IsFull</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">s</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> stack full</span></div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">body</span>[<span style="color: #c792ea;">++</span><span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">topptr</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">value</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>}</div></div>

<p>由于数组的容量总是有限的，因此需要先判断栈是否已满。如果在栈已满的情况下继续入栈，将不可避免地发生<strong>栈顶越界</strong>，可能会与其余部分的数据发生冲突。因此对栈应该小心操作。</p>

<p>为了弹出栈元素，直接让栈顶位置下移一层即可：</p>

<div class="vscode-block"><div><span style="color: #82aaff;">bool</span> <span style="color: #82aaff;">Stack_IsEmpty</span>(<span token="type">stack</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">topptr</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">STACK_NULLTOP</span>;</div><div>}</div><div><span token="type">status</span> <span style="color: #82aaff;">Stack_Pop</span>(<span token="type">stack</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #82aaff;">Stack_IsEmpty</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">s</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> stack empty</span></div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">topptr</span><span style="color: #7fdbca;">--</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>}</div></div>

<p>同样，为了防止栈顶越界，需要提前判断栈是否为空。</p>

<p>入栈和出栈不仅以常数级别的时间实现，而且以非常快的时间运行。大部分机器上都支持寄存器的自增和自减寻址功能，因此栈顶位置移动一层只需要一条机器指令就能实现，入栈也只需要额外执行一次数组的索引赋值即可。</p>

<p>栈舍弃了查找与遍历等操作，实现了非常高效的修改操作。因此，栈是计算机中一种非常基本的数据结构。在大部分机器上甚至内存就是一个栈，可以使用寄存器对内存做入栈和出栈操作，执行效率非常高。</p>

<p>一个影响栈运行效率的因素在于错误检测。对空栈的出栈和对满栈的入栈都会引起数组越界从而导致程序出错。由于这个原因，在某些外部条件确保不会发生溢出的情况下，或在栈的底层实现中，经常会省略处理条件检测。</p>

<p>出栈是一种很有意思的操作，因为它不涉及数据的改变，只需要调整栈顶指针即可。下一次入栈操作时，该元素就会被覆盖，达到删除效果。因此，清空栈只需要将栈顶指针重新置于栈底即可：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">Stack_Clear</span>(<span token="type">stack</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">topptr</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">STACK_NULLTOP</span>;</div><div>}</div></div>

<p>该操作不需要改动任何元素，可以以常数级，并且是非常快的常数级时间完成。</p>

<p>返回栈顶元素可以通过读取栈在栈顶指针位置的元素实现。出栈操作有时也需要读取弹出的元素，其实现就是读取栈顶和出栈的叠加：</p>

<div class="vscode-block"><div><span token="type">elemtype</span> <span style="color: #82aaff;">Stack_PopTop</span>(<span token="type">stack</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span style="color: #82aaff;">Stack_IsEmpty</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">s</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">body</span>[<span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">topptr</span><span style="color: #7fdbca;">--</span>];</div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; /* stack empty */</span></div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> return value to avoid warning</span></div><div>}</div></div>

<p>此过程中可能出现栈空的情况，但无法通过返回值提示栈已空，只能通过控制台提示或强制中断代码的执行。</p>

<h3>栈的链表实现</h3>

<p>由于栈是一个表，因此任何实现表的方式都能实现栈，链表也不例外。如果不能分配一个合理的数组空间，那么更好的方法还是使用链表来实现栈。</p>

<p>这种栈的实现下，测试栈是否是空栈的方式与测试链表是否为空的实现相同，并且栈几乎没有长度限制，无需判断栈是否已满：</p>

<div class="vscode-block"><div><span token="keyword">bool</span> <span style="color: #82aaff;">Stack_IsEmpty</span>(<span token="type">stack</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>;</div><div>}</div></div>

<p>入栈和出栈在栈的链表实现下的具体操作分别为：</p>

<p>入栈通过向链表开始端添加新的节点实现：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">Stack_Push</span>(<span token="type">stack</span> <span style="color: #d7dbe0;">s</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&nbsp; &nbsp; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">cell</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">linkedlist_node</span><span style="color: #82aaff;">))</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">cell</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> stack (memory) full</span></div><div>&nbsp; &nbsp; <span token="variable">cell</span>-&gt;<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">value</span>;</div><div>&nbsp; &nbsp; <span token="variable">cell</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span token="variable">cell</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>}</div></div>

<p>出栈通过移除链表开始端的首个节点实现：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">Stack_Pop</span>(<span token="type">stack</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span token="type">stack</span> <span token="variable">first</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #82aaff;">Stack_IsEmpty</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">s</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; <span token="variable">first</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">next</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; <span style="color: #82aaff;">free</span><span style="color: #82aaff;">(</span><span token="variable">first</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>}</div></div>

<p>链表实现下，入栈和出栈的操作依赖于内存的重新分配，不仅速度较慢，在许多机器上需要依赖操作系统的行为，因此链表实现的栈并不能作为计算机的基本数据结构。</p>

<p>链表实现栈的特点是首节点本身不动，且代表栈顶。下图展示了这一思想：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/05-stack-linked.png" alt="" width="130">
</figure>

<p>因此，返回栈顶元素通过检查链表的首节点的值实现：</p>

<div class="vscode-block"><div><span token="type">elemtype</span> <span style="color: #82aaff;">Stack_Top</span>(<span token="type">stack</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span style="color: #82aaff;">Stack_IsEmpty</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">s</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">s</span>-&gt;<span style="color: #7fdbca;">next</span>-&gt;<span style="color: #7fdbca;">elem</span>;</div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; /* empty stack */</span></div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> return to avoid warning</span></div><div>}</div></div>

<p>链表实现下，出栈后栈的位置无法被重新利用，因此需要显式回收。清空链表的操作需要通过不断执行出栈操作实现，而不能直接修改栈顶指针：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">Stack_Clear</span>(<span token="type">stack</span> <span style="color: #d7dbe0;">s</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">s</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> not created</span></div><div>&nbsp; &nbsp; <span token="keyword">else</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">while</span> (<span style="color: #c792ea;">!</span><span style="color: #82aaff;">Stack_IsEmpty</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">s</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">Stack_Pop</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">s</span><span style="color: #82aaff;">)</span>;</div><div>}</div></div>

<p>该操作需要消耗线性时间。考虑到链表的操作更加复杂，因此使用链表实现栈并不是一种很实用的做法。</p>

<h2 id="queue">队列</h2>

<h3>队列的概念</h3>

<p>栈具有后入先出的特性，这意味着先入栈的元素往往得不到优先处理。该特性在一些倒序处理时很实用，然而在顺序处理元素时却无能为力。</p>

<p>通过对栈原理的思考，可以做一些修改而得到队列的概念。类似于栈，<strong>队列</strong>(queue)也是一个表。然而，队列的插入操作在一端进行，而删除操作在另一端进行。因此队列是先入先出(first in first out, FIFO)的，在保持栈的优点下可以顺序处理元素。</p>

<p>队列的基本操作是<strong>入队</strong>(enqueue)和<strong>出队</strong>(dequeue)。入队是在表的末端，即<strong>队尾</strong>(rear)处插入一个元素；而出队则删除表的第一个元素，即<strong>队首</strong>(front)处的元素。</p>

<p>下图展示了一个队列的模型：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/06-queue-concept.png" alt="" width="280">
</figure>

<p>同样地，队列可以由数组或链表实现。不过数组的实现较为常用，因此这里只介绍队列的数组模型。</p>

<h3>队列的实现</h3>

<p>下图展示了数组模型下，处于中间状态的一个队列：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/06-queue-model.png" alt="" width="217">
</figure>

<p>队列两端的元素有着不确定的值。特别地，队列前面的元素曾经属于该队列。</p>

<p>采用以下结构定义实现队列：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">queue</span> {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">size</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">front</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">rear</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">length</span>;</div><div>&nbsp; &nbsp; <span token="type">elemtype</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">body</span>;</div><div>} <span style="color: #7fdbca;">*</span> <span token="type">queue</span>;</div></div>

<p>这里需要一个成员 <code>length</code> 来记录实际存在队列中的元素个数。</p>

<p>通过队列的类型声明，测试一个队列为空或已满的方法是很容易的：</p>

<div class="vscode-block"><div><span style="color: #82aaff;">bool</span> <span style="color: #82aaff;">Queue_IsEmpty</span>(<span token="type">queue</span> <span style="color: #d7dbe0;">q</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #c792ea;">==</span> <span token="number">0</span>;</div><div>}</div><div><span style="color: #82aaff;">bool</span> <span style="color: #82aaff;">Queue_IsFull</span>(<span token="type">queue</span> <span style="color: #d7dbe0;">q</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #c792ea;">==</span> <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">size</span>;</div><div>}</div></div>

<p>队列的操作细节和栈比较相似。为了使一个元素入队，让队尾后移，并将元素放入队尾后更新队列长度。</p>

<p>为了使一个元素出队，置队首元素为返回值，然后让队首后移并更新长度。</p>

<p>这种实现的问题在于入队和出队时队列会不断后移（而不是像栈一样栈顶在上上下下的过程中达到平衡），造成队列空间一直向后压缩。当多次入队后，队尾到达的数组的边界，那么下一次入队就会发生队列溢出。</p>

<p>一种简单的解决方法可以参考循环链表的思想，即只要队首或队尾到达数组尾端，它就绕回数组开头，形成循环结构。其实现为：</p>

<div class="vscode-block"><div><span token="keyword">static</span> <span token="keyword">int</span> <span style="color: #82aaff;">Queue_Succ</span>(<span token="type">queue</span> <span style="color: #d7dbe0;">q</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">pos</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">++</span><span style="color: #d7dbe0;">pos</span> <span style="color: #c792ea;">==</span> <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">size</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">pos</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">pos</span>;</div><div>}</div></div>

<p>如果 <code>front</code> 或 <code>rear</code> 增 1 使得超越了数组，那么其值重置为数组的第一个位置，否则可以放心增 1 。实现绕回并不需要多少附加代码，不过它会使开销变大。如果能保证入队的次数不会大于队列长度，那么没必要使用回绕。</p>

<p>关于队列的循环实现，还需要注意：</p>

<ul>
    <li>检测队列为空或为满非常重要，因为在循环实现下虽然不会发生数组溢出，但是当队首和队尾相邻时，队列自身可能发生交叉，致使自身被自身覆盖</li>
    <li>队首和队尾可能有多种表示方法，例如当队列为空时，队首和队尾可能在同一个单元，也可能在相邻单元，这两种情况下队列的长度计算方式不同</li>
</ul>

<p>这里采用后一种实现，即队首和队尾在相邻单元。和栈一样，为了清空队列，只需要将位置 <code>front</code> 和 <code>rear</code> 修改到合适的位置，并将队列大小置 0 即可，并不需要对队列中的元素作任何改动：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">Queue_Clear</span>(<span token="type">queue</span> <span style="color: #d7dbe0;">q</span>) {</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">front</span> <span style="color: #c792ea;">=</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">rear</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>}</div></div>

<p>该操作也可用于初始化队列。</p>

<p>根据以上对队列操作的介绍，入队和出队的操作分为为：</p>

<p>入队：让队尾在逻辑上后移，并将元素放入队尾后更新队列长度，代码实现为：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">Queue_Enqueue</span>(<span token="type">queue</span> <span style="color: #d7dbe0;">q</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #82aaff;">Queue_IsFull</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">q</span><span style="color: #82aaff;">)</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> queue full</span></div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">length</span><span style="color: #c792ea;">++</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">rear</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Queue_Succ</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">q</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">q</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">rear</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">body</span>[<span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">rear</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">value</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>}</div></div>

<p>这里的后移是一种逻辑上的后移，因为队列底层是由循环数组支持的，其位置的改变由相应的函数决定。</p>

<p>出队的操作为，置队首元素为返回值，然后让队首后移并更新长度。一般情况下都需要对出队元素做一定处理，否则栈就够用了：</p>

<div class="vscode-block"><div><span token="type">elemtype</span> <span style="color: #82aaff;">Queue_Dequeue</span>(<span token="type">queue</span> <span style="color: #d7dbe0;">q</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">elem</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #82aaff;">Queue_IsEmpty</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">q</span><span style="color: #82aaff;">)</span>) {</div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; &nbsp; &nbsp; /* queue empty */</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> return to avoid warning</span></div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">length</span><span style="color: #7fdbca;">--</span>;</div><div>&nbsp; &nbsp; <span token="variable">elem</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">body</span>[<span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">front</span>];</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">q</span>-&gt;<span style="color: #7fdbca;">front</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">Queue_Succ</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">q</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">q</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">front</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">elem</span>;</div><div>}</div></div>

<p>循环实现下，队列可以在无需移动元素的基础上，不断操作队列两端的元素，使得插入和删除都有着常数级且很快的效率。但也正因如此，队列的维护不像栈那么简单，无法得到计算机底层的直接支持。</p>

<p>队列相比栈，更适合用于处理生活问题。因为在生活情景下，许多问题都需要优先处理先到达的项，并且在处理时随时可能有新的项到达。</p>
<p><a rel="nofollow" href="/archives/609">数据结构03-栈和队列</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/609/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>数据结构02-链表</title>
		<link>/archives/592</link>
					<comments>/archives/592#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 01 Aug 2022 09:27:05 +0000</pubDate>
				<category><![CDATA[数据结构与算法]]></category>
		<category><![CDATA[数据结构]]></category>
		<guid isPermaLink="false">/?p=592</guid>

					<description><![CDATA[<p>单链表 链表的概念 上一节介绍了线性表的概念，同时使&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/592">数据结构02-链表</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>单链表</h2>

<h3>链表的概念</h3>

<p><a href="/archives/586">上一节</a>介绍了线性表的概念，同时使用数组实现顺序存储方式的线性表。使用顺序存储方式的线性表的特点是逻辑关系上相邻的两个元素在物理位置上也相邻，因此元素的存储与访问都比较简单，各种操作也很直观。</p>

<p>然而，顺序存储结构也存在一定缺点，例如：</p>

<ul>
    <li>在表的中间插入或删除时，后面的元素会被频繁地移来移去，产生线性开销，浪费大量时间；</li>
    <li>表的尺寸是有限值的，当达到尺寸限值时若还需要插入元素，需要重新申请内存空间并移动所有元素</li>
</ul>

<p>为了避免以上缺点，这就要求插入元素时元素的位置可以任意存放，这样就无需移动元素，也无需在尺寸不够时需要重新申请一大块内存并移动所有元素。</p>

<p>然而，为了能够将表项关联为一个整体，需要有一种方法能找到表的每项元素的位置。这里提出了<strong>链表</strong>(linked list)的概念。链表的实现是一种非连续的存储，在每项元素中都指出下一项元素的位置。</p>

<p>下图表达了链表的思想：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/02-linklist-structure.png" alt="linked list" width="430">
</figure>

<p>从上图可以看到，链表的每一个结构都由两部分组成：</p>

<ol>
    <li><strong>数据域</strong>：数据元素本身</li>
    <li><strong>指针域</strong>：指针 <code>next</code> 指向该元素的后继元素结构</li>
</ol>

<p>特别地，最后一个单元的 <code>next</code> 指针指向 <code>NULL</code> ，代表链表的结束。</p>

<p>因此，链表节点结构的定义如下：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">linkedlist_node</span> {</div><div>&nbsp; &nbsp; <span token="type">elemtype</span> <span style="color: #7fdbca;">elem</span>;</div><div>&nbsp; &nbsp; <span token="keyword">struct</span> <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">next</span>;</div><div>} <span token="type">linkedlist_node</span>, <span style="color: #7fdbca;">*</span> <span token="type">linkedlist</span>;</div></div>

<p>为了执行打印表或查找等遍历操作，只需要用一个指针记录该表的第一个元素，然后不断用 <code>next</code> 指针获取后继元素即可访问链表的每一项。</p>

<p>链表在插入和删除时表的整体或部分无需全部移动，避免了线性开销。删除命令只需要通过修改一个指针实现：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/02-linklist-delete.png" alt="" width="430">
</figure>

<p>在遍历表时，<span class="math">\\( A_3 \\)</span> 元素由于没有指针指向它，不会被访问到，便会直接忽略，达到删除的效果。</p>

<p>插入命令只需要通过一次 <code>malloc()</code> 调用从系统中获得一个新节点结构，并调整周围的指针：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/02-linklist-insert.png" alt="" width="460">
</figure>

<p>仔细研究上图可以发现，以上实现仍然存在一些问题，主要涉及首节点元素：它的插入和删除方式都比较特殊，因为不涉及修改调整前指针。</p>

<p>为了方便起见，需要留出一个标志节点元素，称为表头节点。通过表头可以很容易地管理表元素：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/02-linklist-header.png" alt="" width="520">
</figure>

<p>接下来演示链表的具体操作。</p>

<h3>链表的具体操作</h3>

<p>根据链表的定义，测试一个链表是否是空链表是很容易的：</p>

<div class="vscode-block"><div><span style="color: #82aaff;">bool</span> <span style="color: #82aaff;">LinkedList_IsEmpty</span>(<span token="type">linkedlist</span> <span style="color: #d7dbe0;">list</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>;</div><div>}</div></div>

<p>该函数也可以用于测试一个节点位置是否已经位于链表的末尾。线性表作为一个整体拥有表示长度的成员信息，但链表没有。在遍历时为了防止越界，必须不断判断是否遍历到链表的末尾。</p>

<p>线性表在查找元素时必须一个个元素挨个判断过去，链表也不例外。只需要从表头或任意链表位置开始，不断向后查询节点，直到找到所需要的元素即可。链表的查找操作如下：</p>

<div class="vscode-block"><div><span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span style="color: #82aaff;">LinkedList_GetNode</span>(<span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">node</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&nbsp; &nbsp; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">nxt</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">node</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; <span token="keyword">while</span> (<span token="variable">nxt</span> <span style="color: #c792ea;">!=</span> <span style="color: #82aaff;">NULL</span> <span style="color: #c792ea;">&amp;&amp;</span> <span token="variable">nxt</span>-&gt;<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">!=</span> <span style="color: #d7dbe0;">value</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">nxt</span> <span style="color: #c792ea;">=</span> <span token="variable">nxt</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">nxt</span>;</div><div>}</div></div>

<p><code>while</code> 判断条件利用了 <code>&amp;&amp;</code> 运算符的短路原理，一旦发现到达结尾，就不再判断值的存在性。</p>

<p>上面介绍过链表的删除和插入原理，接下来尝试使用代码实现。删除节点的操作相对容易实现，只需要找到节点的前驱节点 <code>previous</code> ，再通过调整一个指针指向：</p>

<div class="codeblock code-template">
    previous-&gt;next=previous-&gt;next-&gt;next;
</div>

<p>即可完成删除。不过该操作的难点在于节点只保存下一个节点的位置，因此无法通过一个现有节点简单获取前一个节点的位置。为了找到前驱元素，需要额外编写一个函数来寻找它：</p>

<div class="vscode-block"><div><span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span style="color: #82aaff;">LinkedList_GetPrevNode</span>(<span token="type">linkedlist</span> <span style="color: #d7dbe0;">list</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&nbsp; &nbsp; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">prev</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">list</span>;</div><div>&nbsp; &nbsp; <span token="keyword">while</span> (<span token="variable">prev</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">!=</span> <span style="color: #82aaff;">NULL</span> <span style="color: #c792ea;">&amp;&amp;</span> <span token="variable">prev</span>-&gt;<span style="color: #7fdbca;">next</span>-&gt;<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">!=</span> <span style="color: #d7dbe0;">value</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">prev</span> <span style="color: #c792ea;">=</span> <span token="variable">prev</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">prev</span>;</div><div>}</div></div>

<p>两种查找整体实现类似，只不过它直接跨节点查找，以确保不丢失上一个节点的信息。</p>

<p>配合该例程以及上文的介绍，可以很容易编写出删除链表元素的函数：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">LinkedList_Remove</span>(<span token="type">linkedlist</span> <span style="color: #d7dbe0;">list</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&nbsp; &nbsp; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">prev</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">LinkedList_GetPrevNode</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">list</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">value</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span style="color: #82aaff;">LinkedList_IsLast</span><span style="color: #82aaff;">(</span><span token="variable">prev</span><span style="color: #82aaff;">)</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span token="variable">prev</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">prev</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span token="variable">temp</span>-&gt;<span style="color: #7fdbca;">next</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> bypass deleted cell</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">free</span><span style="color: #82aaff;">(</span><span token="variable">temp</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;</div><div>}</div></div>

<p>在查找前驱节点时，可能发生找不到的情况，此时返回的是最后一个节点，要对这种情况加以判断。</p>

<p>插入比删除略复杂。观察以上插入图示可以看出，为了保证链表在任何时候不断裂，插入的步骤需要按以下顺序进行：</p>

<ol>
    <li>将新节点的 <code>next</code> 指针顺着旧节点指向下一个元素</li>
    <li>断开旧节点的 <code>next</code> 指针，指向新节点</li>
</ol>

<p>这两个步骤不能反过来，否则后续节点的位置信息就丢失了。相应的C语言实现如下：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">LinkedList_InsertAfter</span>(<span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">prev</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&nbsp; &nbsp; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">linkedlist_node</span><span style="color: #82aaff;">))</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">temp</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>) {</div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; &nbsp; &nbsp; /* fail to allocate memory for node */</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="variable">temp</span>-&gt;<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">value</span>;</div><div>&nbsp; &nbsp; <span token="variable">temp</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">prev</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">prev</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span token="variable">temp</span>;</div><div>}</div></div>

<p>从以上代码可以看出，链表在增删时需要不断调用 <code>malloc()</code> 和 <code>free()</code> 来管理内存，因此链表是动态的，它无需一次性分配一大段内存，可以在需要的时候再申请一小部分。</p>

<p>除去查找外，链表的插入和删除的时间复杂度是常数级 <span class="math">\\( O(1) \\)</span> 的。不过链表的缺点只记录下<em>一个</em>元素的信息，因此如果只是访问特定位置的元素时，顺序存储结构可以直接偏移地址，但链表需要一个个按线索找出后续元素，因此链表的随机访问具有线性时间消耗。</p>

<p>尽管链表之间是单向连接的，不过可以使用一种很简单的算法反转单向链表：顺序遍历该链表，并将每个元素依次插入反转表的开头。这样的反转算法只需要消耗线性时间，并且无需额外的存储空间：</p>

<div class="vscode-block"><div><span token="type">linkedlist</span> <span style="color: #82aaff;">LinkedList_Reverse</span>(<span token="type">linkedlist</span> <span style="color: #d7dbe0;">list</span>) {</div><div>&nbsp; &nbsp; <span token="type">linkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">header</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">linkedlist_node</span><span style="color: #82aaff;">))</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span token="variable">header</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #82aaff;">NULL</span>;</div><div>&nbsp; &nbsp; <span token="variable">header</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">NULL</span>;</div><div>&nbsp; &nbsp; <span token="keyword">while</span> (<span style="color: #d7dbe0;">list</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">next</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">LinkedList_InsertAfter</span><span style="color: #82aaff;">(</span><span token="variable">header</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">list</span><span style="color: #82aaff;">-&gt;</span><span style="color: #7fdbca;">elem</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">header</span>;</div><div>}</div></div>

<h2>静态链表(游标实现)</h2>

<h3>静态链表的概念</h3>

<p>并不是所有语言都支持指针。如果想不使用指针或引用实现链表，就需要使用静态链表。这种链表是通过游标访问元素的。</p>

<p>链表的指针实现中有两个必须实现的特性：</p>

<ol>
    <li>每个节点都是一个结构，一个结构包含数据以及指向下一个结构体的指针</li>
    <li>一个新的节点可以调用 <code>malloc()</code> 从内存中得到，并可以通过 <code>free()</code> 释放</li>
</ol>

<p>游标方法必须能够模仿这两条特性。</p>

<p>下图展示了游标方法实现静态链表的原理：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/03-cursorlist-structure.png" alt="" width="128">
</figure>

<p>满足条件 1 的逻辑方式是要有一个全局的结构体数组，对于该数组中的单元，其数组下标可以用来代表一个地址，从而模拟指针。</p>

<p>下面给出了静态链表的游标实现的声明：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> <span token="type">slinkedlist_node</span> {</div><div>&nbsp; &nbsp; <span token="type">elemtype</span> <span style="color: #7fdbca;">elem</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">cursor</span>;</div><div>} <span token="type">slinkedlist_node</span>;</div><br><div><span style="color: #c792ea;">#</span><span token="keyword">define</span> &nbsp;<span style="color: #82aaff;">SLINKEDLIST_SIZE</span> <span token="number">1024</span></div><div><span token="type">slinkedlist_node</span> <span token="variable">linkedspace</span>[<span style="color: #82aaff;">SLINKEDLIST_SIZE</span>];</div></div>

<p>模拟条件 2 的方法是，除了数据本身通过游标组成的链表外，在静态链表空间中还需要有一条连接各个空闲位置的链表，称为<strong>备用链表</strong>。</p>

<p>备用链表 <code>freedspace</code> 数组中的闲置单元可以执行 <code>malloc()</code> 和 <code>free()</code> 。对于 <code>cursor</code> 游标，0 的值等价于 <code>NULL</code> 指针。</p>

<ul>
    <li>为了执行 <code>malloc()</code> 功能，将表头后面的第一个元素从 <code>freedspace</code> 表中删除</li>
    <li>为了执行 <code>free()</code> 功能，将该单元放在 <code>freedspace</code> 表的前段</li>
</ul>

<p>通常将 <code>linkedspace[0]</code> 作为备用链表的表头使用，<code>linkedspace[1]</code> 作为数据链表的表头使用。这样，对应的C语言代码为：</p>

<div class="vscode-block"><div><span token="keyword">int</span> <span style="color: #82aaff;">SLinkedList_Alloc</span>(<span token="keyword">void</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">pos</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span token="number">0</span>].<span token="variable">cursor</span>;</div><div>&nbsp; &nbsp; <span token="variable">linkedspace</span>[<span token="number">0</span>].<span style="color: #7fdbca;">cursor</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span token="variable">pos</span>].<span style="color: #7fdbca;">cursor</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">pos</span>;</div><div>}</div><div><span token="keyword">void</span> <span style="color: #82aaff;">SLinkedList_Free</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">pos</span>) {</div><div>&nbsp; &nbsp; <span token="variable">linkedspace</span>[pos].<span token="variable">cursor</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span token="number">0</span>].<span token="variable">cursor</span>;</div><div>&nbsp; &nbsp; <span token="variable">linkedspace</span>[<span token="number">0</span>].<span token="variable">cursor</span> <span style="color: #c792ea;">=</span> pos;</div><div>}</div></div>

<p>注意，如果没有可分配的空间，它会正确返回位置 0 以供判断。下图展示了某一时刻的静态链表：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/03-cursorlist-concept.png" alt="" width="340">
</figure>

<p>由于静态链表的游标充当后向指针，判断一个静态链表是否为空，或一个节点是否位于静态链表末尾和普通链表相似：</p>

<div class="vscode-block"><div><span style="color: #82aaff;">bool</span> <span style="color: #82aaff;">SLinkedList_IsEmpty</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">list</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">linkedspace</span>[<span style="color: #d7dbe0;">list</span>].<span style="color: #7fdbca;">cursor</span> <span style="color: #c792ea;">==</span> <span token="number">0</span>;</div><div>}</div><div><span style="color: #82aaff;">bool</span> <span style="color: #82aaff;">SLinkedList_IsLast</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">pos</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">linkedspace</span>[<span style="color: #d7dbe0;">pos</span>].<span style="color: #7fdbca;">cursor</span> <span style="color: #c792ea;">==</span> <span token="number">0</span>;</div><div>}</div></div>

<h3>静态链表的操作</h3>

<p>静态链表的操作和普通链表具有相似性。例如查找例程，它通过从数据链表的表头逐个遍历 <code>cursor</code> 指向的静态链表空间位置来访问下一个元素：</p>

<div class="vscode-block"><div><span token="keyword">int</span> <span style="color: #82aaff;">SLinkedList_Find</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">list</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">pos</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span style="color: #d7dbe0;">list</span>].<span style="color: #7fdbca;">cursor</span>;</div><div>&nbsp; &nbsp; <span token="keyword">while</span> (<span token="variable">pos</span> <span style="color: #c792ea;">&amp;&amp;</span> <span token="variable">linkedspace</span>[<span token="variable">pos</span>].<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">!=</span> <span style="color: #d7dbe0;">elem</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">pos</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span token="variable">pos</span>].<span style="color: #7fdbca;">cursor</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">pos</span>;</div><div>}</div></div>

<p>删除的原理和指针链表一致，即找出前驱元素的位置 <code>prev</code> ，通过跨越节点：</p>

<div class="codeblock code-template">
    linkedspace[prev].cursor = linkedspace[linkedspace[prev].cursor].cursor
</div>

<p>即可完成删除。删除后还需要释放节点占用的空间。</p>

<p>查询前驱元素节点的函数实现为：</p>

<div class="vscode-block"><div><span token="keyword">int</span> <span style="color: #82aaff;">SLinkedList_FindPrevPos</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">list</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">prev</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span style="color: #d7dbe0;">list</span>].<span style="color: #7fdbca;">cursor</span>;</div><div>&nbsp; &nbsp; <span token="keyword">while</span> (<span token="variable">prev</span> <span style="color: #c792ea;">&amp;&amp;</span> <span token="variable">linkedspace</span>[<span token="variable">linkedspace</span>[<span token="variable">prev</span>].<span style="color: #7fdbca;">cursor</span>].<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">!=</span> <span style="color: #d7dbe0;">elem</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">prev</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span token="variable">prev</span>].<span style="color: #7fdbca;">cursor</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">prev</span>;</div><div>}</div></div>

<p>那么删除的程序实现为：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">SLinkedList_Remove</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">list</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">temp</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">pos</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">SLinkedList_FindPrevPos</span><span style="color: #82aaff;">(</span><span style="color: #d7dbe0;">list</span><span style="color: #82aaff;">, </span><span style="color: #d7dbe0;">elem</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #c792ea;">!</span><span style="color: #82aaff;">SLinkedList_IsLast</span><span style="color: #82aaff;">(</span><span token="variable">pos</span><span style="color: #82aaff;">)</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span token="variable">pos</span>].<span style="color: #7fdbca;">cursor</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">linkedspace</span>[<span token="variable">pos</span>].<span style="color: #7fdbca;">cursor</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span token="variable">temp</span>].<span style="color: #7fdbca;">cursor</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">SLinkedList_Free</span><span style="color: #82aaff;">(</span><span token="variable">temp</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;</div><div>}</div></div>

<p>注意比较与指针链表的异同点。指针链表的 <code>this-&gt;next</code> 等价于静态链表的 <code>linkedspace[this].cursor</code> 。</p>

<p>因此，类比一下指针链表的插入，静态链表的插入实现为：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">SLinkedList_InsertAfter</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">prev</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">SLinkedList_Alloc</span><span style="color: #82aaff;">()</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">temp</span> <span style="color: #c792ea;">==</span> <span token="number">0</span>) {</div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; &nbsp; &nbsp; /* fail to allocate memory */</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="variable">linkedspace</span>[<span token="variable">temp</span>].<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">=</span> elem;</div><div>&nbsp; &nbsp; <span token="variable">linkedspace</span>[<span token="variable">temp</span>].<span style="color: #7fdbca;">cursor</span> <span style="color: #c792ea;">=</span> <span token="variable">linkedspace</span>[<span style="color: #d7dbe0;">prev</span>].<span style="color: #7fdbca;">cursor</span>;</div><div>&nbsp; &nbsp; <span token="variable">linkedspace</span>[<span style="color: #d7dbe0;">prev</span>].<span style="color: #7fdbca;">cursor</span> <span style="color: #c792ea;">=</span> <span token="variable">temp</span>;</div><div>}</div></div>

<p>指针链表的核心是 <code>node*</code> 指针，用来在内存中找出下一个节点所在的位置。静态链表的核心是 <code>int</code> 值，用来在 <code>linkedspace</code> 中找出下一个节点所在的位置。因此可以认为静态链表在程序中维护了自己的一段“内存”，进而自行制造了指针这一概念。理解了这一点，便不难理解指针链表与静态链表的关系了。</p>

<h2>更多链表模型</h2>

<p>链表是一种非常经典的数据结构，它提供了一种非顺序的关联结构，借由一个指针可以指向其关联的任意元素。从链表开始，数据结构的两个项之间的关系开始变得语义化。</p>

<p>通过增加节点指针的个数，可以使节点之间拥有一对多的关系。</p>

<p>链表有几种典型的扩展，使链表可以适应更多场景。接下来简要介绍。</p>

<h3>双链表</h3>

<p>有时需要倒序扫描链表或局部倒序后退节点，但是普通链表的实现却非常复杂。这里提出<strong>双链表</strong>(doubly linked list)的概念，本质上就是在链表的基础上增加了一个前向指针 <code>prev</code> ，使链表节点间可以双向连接。</p>

<p>下图展示了双链表的原理：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/04-doubly-linklist-structure.png" alt="" width="550">
</figure>

<p>双链表可以使向前检索变得更便利，但代价是一个附加的链，增加了空间的需求，同时也增加了插入和删除的开销，因为有更多指针需要调整。</p>

<p>首先看双链表的插入。如果需要向双链表中插入元素，需要完成以下几个工作：</p>

<ul>
    <li>调整前一节点的 <code>next</code> 指针和后一节点的 <code>prev</code> 指针</li>
    <li>为当前节点的 <code>next</code> 和 <code>prev</code> 指针建立连接</li>
</ul>

操作的图示为：

<p>双链表的插入只需要给出前面或后面的节点作为定位即可。这里以给出前面的节点为例编写代码：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">DuLinkedList_InsertAfter</span>(<span token="type">dulinkedlist_node</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">previous</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&nbsp; &nbsp; <span token="type">dulinkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">next</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">previous</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; <span token="type">dulinkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">dulinkedlist_node</span><span style="color: #82aaff;">))</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">temp</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; <span token="variable">temp</span>-&gt;<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">value</span>;</div><div>&nbsp; &nbsp; <span token="variable">temp</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span token="variable">next</span>;<span style="color: #637777;"> &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> adjusting between this and next</span></div><div>&nbsp; &nbsp; <span token="variable">next</span>-&gt;<span style="color: #7fdbca;">prev</span> <span style="color: #c792ea;">=</span> <span token="variable">temp</span>;</div><div>&nbsp; &nbsp; <span token="variable">temp</span>-&gt;<span style="color: #7fdbca;">prev</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">previous</span>;<span style="color: #637777;"> &nbsp; </span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> adjusting between this and prev</span></div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">previous</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span token="variable">temp</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>}</div></div>

<p>双链表在删除时，需要调整的指针个数比单链表更多。但是双链表的删除操作比单链表简单，因为前驱元素的信息是现成的。</p>

下图展示了双链表的删除操作：

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/04-doubly-linklist-delete.png" alt="" width="510">
</figure>

<p>可以正序扫描双链表以找出所需元素，也可以倒序扫描。以下示例使用倒序扫描删除链表的最后一个找出的节点。为了判断倒序扫描结束，需要不断判断当前位置是否为表头：</p>

<div class="vscode-block"><div><span style="color: #82aaff;">bool</span> <span style="color: #82aaff;">DuLinkedList_IsHeader</span>(<span token="type">dulinkedlist_node</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">node</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #d7dbe0;">node</span>-&gt;<span style="color: #7fdbca;">prev</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>;</div><div>}</div><div><span token="keyword">void</span> <span style="color: #82aaff;">DuLinkedList_DeleteLast</span>(<span token="type">dulinkedlist_node</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">last</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">value</span>) {</div><div>&nbsp; &nbsp; <span token="type">dulinkedlist_node</span><span style="color: #7fdbca;">*</span> <span token="variable">tmp</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">last</span>;</div><div>&nbsp; &nbsp; <span token="keyword">while</span> (<span token="variable">tmp</span> <span style="color: #c792ea;">&amp;&amp;</span> <span token="variable">tmp</span>-&gt;<span style="color: #7fdbca;">elem</span> <span style="color: #c792ea;">!=</span> <span style="color: #d7dbe0;">value</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">tmp</span> <span style="color: #c792ea;">=</span> <span token="variable">tmp</span>-&gt;<span style="color: #7fdbca;">prev</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">tmp</span> <span style="color: #c792ea;">&amp;&amp;</span> <span style="color: #c792ea;">!</span><span style="color: #82aaff;">DuLinkedList_IsHeader</span><span style="color: #82aaff;">(</span><span token="variable">tmp</span><span style="color: #82aaff;">)</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">tmp</span>-&gt;<span style="color: #7fdbca;">prev</span>-&gt;<span style="color: #7fdbca;">next</span> <span style="color: #c792ea;">=</span> <span token="variable">tmp</span>-&gt;<span style="color: #7fdbca;">next</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">tmp</span>-&gt;<span style="color: #7fdbca;">next</span>-&gt;<span style="color: #7fdbca;">prev</span> <span style="color: #c792ea;">=</span> <span token="variable">tmp</span>-&gt;<span style="color: #7fdbca;">prev</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #82aaff;">free</span><span style="color: #82aaff;">(</span><span token="variable">tmp</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; }</div><div>}</div></div>

<p>双链表是一种特殊的链表，除了原生支持倒序查找外，其余的操作例如查找或遍历，都与普通的单链表并没有太大区别。</p>

<h3>循环链表</h3>

<p>链表的后继指针可以指向任何符合语义的节点元素，这也就意味着一个修改后的链表可以不是线性的，而是拥有各种不同的形态。</p>

<p>例如，可以让链表的最后一个元素指向第一个元素或表头，由此整个链表会发生闭合，形成<strong>循环链表</strong>(circular linked list)。下图展示了一个有表头的单链循环链表：</p>

<figure><img decoding="async" src="/wordpress/wp-content/uploads/2022/08/04-circle-linklist-structure.png" alt="" width="435"></figure>

<p>循环链表的操作和普通链表一致，差别仅在于判断遍历终止的条件为是否回到表头或首元素而不是遇到 <code>NULL</code> 。</p>

<p>循环链表也可以和双链表组合在一起，形成双向循环链表。下图展示了一个没有表头的双链循环链表：</p>

<figure><img decoding="async" src="/wordpress/wp-content/uploads/2022/08/04-circle-doubly-linklist-structure.png" alt="" width="430"></figure>

<p>由此可见，链表只需要对节点做一些调整，就能适应多种多样的场景。有些时候需要经常获取链表的长度，但遍历链表显然是个低效的做法，此时可以为表头提供一个特殊的节点定义，它包含链表的长度信息，并在增加或删除结点时实时更新长度。</p>

<p>又或是有时需要频繁地在链表的结尾位置增加或删除数据，由于链表不能直接通过地址偏移找到末尾节点的位置，那么可以在表头添加一个指向尾部节点的指针域，通过该域可以快速访问链表的末尾位置。</p>

<p>下图展示了修改后的链表模型：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/08/04-linkedlist-final.png" alt="" width="520">
</figure>

<p>这样并没有为单次操作增加多少工作量，却可以很好地避免某些操作产生的线性开销。后续介绍的许多数据结构，例如树和图，都与链表的思想密不可分。</p>
<p><a rel="nofollow" href="/archives/592">数据结构02-链表</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/592/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>数据结构01-基本概念与线性表</title>
		<link>/archives/586</link>
					<comments>/archives/586#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sat, 30 Jul 2022 14:26:30 +0000</pubDate>
				<category><![CDATA[数据结构与算法]]></category>
		<category><![CDATA[数据结构]]></category>
		<category><![CDATA[算法]]></category>
		<guid isPermaLink="false">/?p=586</guid>

					<description><![CDATA[<p>什么是数据结构 在编程程序时，往往会遇到数据的存储问&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/586">数据结构01-基本概念与线性表</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>什么是数据结构</h2>

<p>在编程程序时，往往会遇到数据的存储问题。在一般情况下，都会使用数组存储一系列数据，然而仅仅使用数组并不能有效地组织复杂的数据。考虑以下几个典型的应用场景：</p>

<p>在以分类表示数据时，一个类别可能包括众多子类别。如果仅以数组存储数据，那么类别之间就很难建立联系，如果需要按类别筛选数据，不便于查找子类别中的数据。</p>

<p>在地图中存储各个地点的信息时，地点间存在空间上的关联，而数组难以体现这种关联，不方便规划路径。</p>

<p>这些时候，就需要使用<strong>数据结构</strong>(data structure)。当数据量较小的时候，使用数据结构的优势并不明星；但当数据量开始变大时，数据结构的优势便体现出来。一个合适的数据结构可以在数据量很大时，将数据以规则的形式组织起来，使数据的管理更加方便高效。</p>

<p><strong>抽象数据类型</strong>(Abstract Data Type, ADT)是在一个模型定义下的操作集合，操作效果只取决于特性，而与具体的数据类型无关。例如，对于数组 ADT ，它所具有的操作有获取索引值位置元素、修改索引值位置元素等，这个数组可以是整型数组、字符数组、结构数组或更复杂的嵌套数组等，但只要它是数组，就拥有这些操作或特性。</p>

<p>在后续研究的数据结构都属于 ADT ，因为往往需要使用不同的数据类型来适应不同的场合。例如在使用数组时，如果要处理一系列实验数据，可以使用浮点数数组，如果要处理一段文本，可以使用字符数组，只需要研究数组本身的特性，就可以将其应用到不同的场合中。</p>

<p>在第一节中，暂时只研究数组这种比较熟悉的数据结构，并分析其优缺点。这里研究的数组指的不仅仅是C语言中的数组，而是更广义的线性存储结构，一般称为线性表。</p>

<h2>线性表</h2>

<h3>线性表的概念</h3>

<p><strong>线性表</strong>(linear list)是一组数据组成的有限序列，其中每个数据项含义相似。本节研究顺序存储结构的线性表，它常在内存中以一块地址连续的存储单元依次存储，非常类似C语言中数组的特征，因此可以使用C语言中的数组来表示线性表。</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/07/01-linearlist-concept.png" alt="" width="230">
</figure>

<p>采用以下定义实现线性表：</p>

<div class="vscode-block"><div><span style="color: #c792ea;">typedef</span> <span token="keyword">int</span> <span token="type">elemtype</span>;</div><br><div><span style="color: #c792ea;">typedef</span> <span token="keyword">struct</span> {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">length</span>;</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span style="color: #7fdbca;">size</span>;<span style="color: #637777;"> &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #637777;"> actual allocated size</span></div><div>&nbsp; &nbsp; <span token="type">elemtype</span><span style="color: #7fdbca;">*</span> <span style="color: #7fdbca;">body</span>;</div><div>} <span token="type">linearlist</span>;</div></div>

<p>在第一行中定义了 <code>elemtype</code> 类型，由于这里仅研究线性表 ADT ，因此不关心实际的数据项类型，它可以是任意有效的类型。C语言没有泛型，因此这里只能通过 <code>typedef</code> 用整型暂时模拟通用数据项类型。</p>

<p>由于C语言中数组的功能偏弱，因此除了使用数组存储数据外，为了方便后期处理表中的数据，线性表还需要实时记录以下 2 项信息：</p>

<ul>
    <li>线性表申请的<strong>存储容量</strong></li>
    <li>线性表的<strong>长度</strong>，也就是表中存储数据元素的个数</li>
</ul>

<p>为了确保拥有合适的空间存储数据，线性表申请的存储容量应大于期望存储的数据长度。当达到最大存储容量时，应该不能再对线性表添加新元素。</p>

<p>这里采用结构的形式描述线性表，这是因为在程序中可能同时存在许多不同的线性表，使用结构易于批量生产线性表。</p>

<p>在结构内存储实际数据的字段 <code>body</code> 字段是一个指针。它的用途是：通过 <code>malloc()</code> 函数动态申请到足够的存储空间，然后将其作为一个数组使用。</p>

<p>因此，新创建一个顺序表的步骤为：</p>

<ul>
    <li>给 <code>body</code> 指针申请足够的内存空间</li>
    <li>给 <code>length</code> 和 <code>size</code> 字段赋一个合适的初始值</li>
</ul>

<p>相应的C语言实现如下：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">Linearlist_Init</span>(<span token="type">linearlist</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">l</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">size</span>) {</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">l</span>-&gt;<span style="color: #7fdbca;">body</span> <span style="color: #c792ea;">=</span> (<span token="type">elemtype</span><span style="color: #7fdbca;">*</span>) <span style="color: #82aaff;">malloc</span><span style="color: #82aaff;">(</span><span style="color: #7fdbca;">sizeof</span><span style="color: #82aaff;">(</span><span style="color: #82aaff;text-decoration: underline;">elemtype</span><span style="color: #82aaff;">) </span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">size</span><span style="color: #82aaff;">)</span>;</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">l</span>-&gt;<span style="color: #7fdbca;">body</span> <span style="color: #c792ea;">==</span> <span style="color: #82aaff;">NULL</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">l</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">l</span>-&gt;<span style="color: #7fdbca;">size</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">size</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>}</div></div>

<h3>线性表项操作</h3>

<p>得到一个线性表后，就可以对线性表做一些操作。对线性表的操作主要是对线性表内的元素做一些改动。</p>

<p>首先是插入。线性表可以向任意位置插入元素，不过如果向中间位置插入元素，需要将线性表的后续元素整体后移，为插入的元素空出位置。下图展示了这种情况：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/07/01-linearlist-insert.png" alt="" width="510">
</figure>

<p>因此，线性表插入数据元素的代码实现如下：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">Linearlist_InsertAt</span>(<span token="type">linearlist</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">list</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">elem</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">index</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">index</span> <span style="color: #c792ea;">&gt;</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span> <span style="color: #c792ea;">||</span> <span style="color: #d7dbe0;">index</span> <span style="color: #c792ea;">&lt;</span> <span token="number">1</span>) {</div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; &nbsp; &nbsp; /* inappropriate inserting position */</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #c792ea;">==</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">size</span>) {</div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; &nbsp; &nbsp; /* have no extra storage space for element */</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">2</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>; <span token="variable">i</span> <span style="color: #c792ea;">&gt;=</span> <span style="color: #d7dbe0;">index</span>; <span token="variable">i</span><span style="color: #7fdbca;">--</span>) </div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span>];</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">body</span>[<span style="color: #d7dbe0;">index</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">elem</span>;</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">length</span><span style="color: #c792ea;">++</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>}</div></div>

<p>在插入前，需要做两次判断：插入数据的位置是否合适，以及是否还有多余的空间让数据插入。</p>

<p>具体插入的方式为从最后一个元素开始，从后向前逐个将元素后移，直到将待插入位置的元素也后移了为止，这样便可以空出一个位置让数据插入。</p>

<p>与插入相反的操作是删除。删除某个位置的元素只需要将目标元素的后续元素整体前移即可，待删除元素便会被直接覆盖：</p>

<div class="vscode-block"><div><span token="type">status</span> <span style="color: #82aaff;">Linearlist_RemoveAt</span>(<span token="type">linearlist</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">list</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">index</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">index</span> <span style="color: #c792ea;">&gt;</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">length</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span> <span style="color: #c792ea;">||</span> <span style="color: #d7dbe0;">index</span> <span style="color: #c792ea;">&lt;</span> <span token="number">1</span>) {</div><div><span style="color: #a8a8a8;">&nbsp; &nbsp; &nbsp; &nbsp; /* inappropriate position */</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">index</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">length</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span>];</div><div>&nbsp; &nbsp; <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">length</span><span style="color: #7fdbca;">--</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span token="number">0</span>;</div><div>}</div></div>

查找也是线性表常用的一种操作。查找元素可以用多种算法实现，这里仅仅使用最基本的顺序查找算法，即遍历线性表的每个元素，直到找到需要的值为止。代码实现为：

<div class="vscode-block"><div><span style="color: #c792ea;font-weight: bold;">int</span> <span style="color: #82aaff;">Linearlist_Find</span>(<span style="color: #d6deeb;text-decoration: underline;">linearlist</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">list</span>, <span style="color: #d6deeb;text-decoration: underline;">elemtype</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&nbsp; &nbsp; <span style="color: #c792ea;font-weight: bold;">for</span> (<span style="color: #c792ea;font-weight: bold;">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">length</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #c792ea;font-weight: bold;">if</span> (<span style="color: #d7dbe0;">elem</span> <span style="color: #c792ea;">==</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #c792ea;font-weight: bold;">return</span> <span token="variable">i</span>;</div><div>&nbsp; &nbsp; <span style="color: #c792ea;font-weight: bold;">return</span> <span style="color: #7fdbca;">-</span><span token="number">1</span>;</div><div>}</div></div>

<p>如果找到了相应的元素，它会返回该元素的索引值；如果没有找到相应的元素，则返回 <code>-1</code> 。</p>

<p>如果能成功查找到一个元素，凭借返回的索引值，就能轻松修改该元素的值。</p>

<h2>算法分析</h2>

<p><strong>算法</strong>(algorithm)是对求解特定问题所做的一些步骤的描述。如果能够确认该步骤是有效的，那么就需要分析该算法的效率如何。例如，如果需要求解一个等差数列连续若干项的和，一种算法是逐个计算每项的值再累加，得到的结果也是正确的；也可以采取累加公式，直接由所给定的基本信息代入公式即可一步计算出结果，更加省时省力。</p>

<p>因此，对一个算法最主要的评估标准就是执行的时间资源和存储中间结果的额外空间资源。</p>

<h3>算法的复杂度</h3>

<p>一般来说，使用某种数据结构处理某个实际问题时，随着数据项的个数变多，算法的执行时间和占用的额外空间往往也会受到变化。例如，从一个简单的记事本中查找一段文本，和从一篇很长的小说中查找一段文本，两者消耗的时间也是不同的。如果搜索的文本重复率较高，那么需要的空间资源也会更多。</p>

<p>虽然不可能精确得知算法执行消耗的时间，也比较难计算占用内存的实际大小，但是可以从算法的某些特征中估算出算法的性能：当数据项个数变多时，算法消耗的资源呈什么增长率变化。</p>

<p>例如，如果需要查找线性表内的某个元素，由于它可能出现在线性表内的任意位置，需要遍历线性表。重新展示代码如下：</p>

<div class="vscode-block"><div><span token="keyword">int</span> <span style="color: #82aaff;">Linearlist_Find</span>(<span token="type">linearlist</span><span style="color: #7fdbca;">*</span> <span style="color: #d7dbe0;">list</span>, <span token="type">elemtype</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">length</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">elem</span> <span style="color: #c792ea;">==</span> <span style="color: #d7dbe0;">list</span>-&gt;<span style="color: #7fdbca;">body</span>[<span token="variable">i</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> <span token="variable">i</span>;</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #7fdbca;">-</span><span token="number">1</span>;</div><div>}</div></div>

<p>如果线性表内有 <span class="math">\\( n \\)</span> 个元素，那么在最坏的情况下，算法需要做 <span class="math">\\( n \\)</span> 次判断，然后才返回一个值。如果使用数学函数表示算法的性能，参数 <span class="math">\\( n \\)</span> 表示数据结构内包含的元素个数，计算结果为每个基本操作执行的次数，那么随着数据结构内包含的元素个数增多，在最久的情况下，需要执行的操作次数为：</p>

<div class="math">
\\[
    T(n) = 2n+1
\\]
</div>

<p>每增加一项数据，就需要判断其值是否满足要求，还需要 <code>for</code> 多循环一次。如果假定每个操作执行的时间差不多，那么只需要知道该函数对应关系，就可以估算出一定数据量下，算法执行的大致时间。</p>

<p>不过一般来说无需计算得这么详细，只需要知道算法执行时间的增长变化趋势即可，或者说算法中基本操作重复执行的次数与数据规模 <span class="math">\\( n \\)</span> 呈什么函数关系变化。算法的时间度量记作：</p>

<div class="math">
\\[
    T(n)=O(f(n))
\\]
</div>

<p>大写字母 O 表示随数据规模 <span class="math">\\( n \\)</span> 增大，算法执行时间的增长率主要由 <span class="math">\\( f(n) \\)</span> 的增长率主导，称为算法的<strong>渐进时间复杂度</strong>(asymptotic time complexity)，简称<strong>时间复杂度</strong>。</p>

<p>在以上查找算法中，随着数据规模增大，查找所消耗的时间也普遍呈线性规模增长，因此查找时间复杂度为：</p>

<div class="math">
\\[
    T(n) = O(n)
\\]
</div>

<p>只需关心函数是线性变化的，至于线性系数和低项都可以省略。</p>

<p>之所以时间复杂度只关心最高项，主要是为了对比各算法的执行效率。当 <span class="math">\\( n \\)</span> 足够大的时候，消耗恒定时间的返回语句对算法的时间影响可以不计，而线性系数对时间的影响远不如更换算法对时间的影响大。</p>

<p>例如，以下是二分查找(binary search)算法的代码实现。二分查找算法的原理是如果数组是有序的，那么为了查找某一个值是否在数组内，只需将其与数组中间位置的元素做比较：如果数组中间位置的元素比待查找的值大，那么由于数组是有序的，数组后半部分的元素都比该值大，待查找的值不可能出现在这半部分中，那么只需再用这种方法在前半部分查找即可：</p>

<div class="vscode-block"><div><span token="keyword">int</span> <span style="color: #82aaff;">binary_search</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">len</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">elem</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> left <span style="color: #c792ea;">=</span> <span token="number">0</span>; </div><div>&nbsp; &nbsp; <span token="keyword">int</span> right <span style="color: #c792ea;">=</span> len <span style="color: #7fdbca;">-</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; <span token="keyword">while</span> (left <span style="color: #c792ea;">&lt;=</span> right) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">int</span> mid <span style="color: #c792ea;">=</span> (right <span style="color: #7fdbca;">+</span> left) <span style="color: #7fdbca;">/</span> <span token="number">2</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span token="variable">arr</span>[mid] <span style="color: #c792ea;">==</span> elem)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">return</span> mid; </div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">else</span> <span token="keyword">if</span> (<span token="variable">arr</span>[mid] <span style="color: #c792ea;">&lt;</span> elem)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left <span style="color: #c792ea;">=</span> mid <span style="color: #7fdbca;">+</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">else</span> <span token="keyword">if</span> (<span token="variable">arr</span>[mid] <span style="color: #c792ea;">&gt;</span> elem)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right <span style="color: #c792ea;">=</span> mid <span style="color: #7fdbca;">-</span> <span token="number">1</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; <span token="keyword">return</span> <span style="color: #7fdbca;">-</span><span token="number">1</span>;</div><div>}</div></div>

<p>这种查找算法每一次判断都可以剔除剩余的一半查找范围，使待查找的范围呈指数级递减。运气最差的情况下，当查找 <span class="math">\\( log_2 n \\)</span> 次左右便可以将搜索范围缩减到零，此时就可以判断值是否出现在数组中了。因此，该算法的时间复杂度为：</p>

<div class="math">
\\[
    T(n) = O(\log\, n)
\\]
</div>

<p>当 <span class="math">\\( n \\)</span> 足够大时，根据极限的等价无穷小概念可知，该算法的执行时间是明显优于普通的查找算法的。可以通过绘制时间复杂度的函数图像比较两个算法的运行时间：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/07/01-time-complexity.png" alt="" width="300">
</figure>

<p>不过为了能够实现快速查找，二分搜索法要求数组必须是有序的。</p>

<p>接下来再看一个示例，选择排序(selection sort)是一种简单的排序算法，用于使数组内的每个元素从小到大排列。该算法的基本原理为：先找出数组的最小元素并移动到数组的起始位置，然后每次都从剩余未排序元素中查找最小元素并放到已排序序列的末尾，直到没有待排序元素为止。</p>

<p>选择排序的算法实现如下：</p>

<div class="vscode-block"><div><span token="keyword">void</span> <span style="color: #82aaff;">selection_sort</span>(<span token="keyword">int</span> <span style="color: #d7dbe0;">arr</span><span token="keyword">[]</span>, <span token="keyword">int</span> <span style="color: #d7dbe0;">len</span>) {</div><div>&nbsp; &nbsp; <span token="keyword">int</span> <span token="variable">min</span>, <span token="variable">temp</span>;</div><div>&nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">i</span> <span style="color: #c792ea;">=</span> <span token="number">0</span>; <span token="variable">i</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">len</span> <span style="color: #7fdbca;">-</span> <span token="number">1</span>; <span token="variable">i</span><span style="color: #c792ea;">++</span>) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">min</span> <span style="color: #c792ea;">=</span> <span token="variable">i</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">for</span> (<span token="keyword">int</span> <span token="variable">j</span> <span style="color: #c792ea;">=</span> <span token="variable">i</span> <span style="color: #7fdbca;">+</span> <span token="number">1</span>; <span token="variable">j</span> <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">len</span>; <span token="variable">j</span><span style="color: #c792ea;">++</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="keyword">if</span> (<span style="color: #d7dbe0;">arr</span>[<span token="variable">j</span>] <span style="color: #c792ea;">&lt;</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">min</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">min</span> <span style="color: #c792ea;">=</span> <span token="variable">j</span>;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span token="variable">temp</span> <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">min</span>];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">arr</span>[<span token="variable">min</span>] <span style="color: #c792ea;">=</span> <span style="color: #d7dbe0;">arr</span>[<span token="variable">i</span>];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #d7dbe0;">arr</span>[<span token="variable">i</span>] <span style="color: #c792ea;">=</span> <span token="variable">temp</span>;</div><div>&nbsp; &nbsp; }</div><div>}</div></div>

<p>在这个算法中，<code>for</code> 循环内又嵌套了一层 <code>for</code> 循环。如果数据规模为 <span class="math">\\( n \\)</span> ，那么外层循环一共执行 <span class="math">\\( n-1 \\)</span> 次，内层循环的额执行次数也与 <span class="math">\\( n \\)</span> 有关，总的执行时间是两者的乘积，即时间复杂度为：</p>

<div class="math">
\\[
    T(n) = O(n^2)
\\]
</div>

<p>显然，当 <span class="math">\\( n \\)</span> 足够大的时候，它消耗的时间远比线性的时间复杂度多。因此选择排序效率较低，一般不用于排序很大的数据。选择排序的时间复杂度比普通的查找大，因此没有必要为了二分查找法的速度优势而特地为数组排序。</p>

<p>排序是算法的一个重要话题，后续会专门花费一节介绍排序算法，许多精彩的思想都可以有效降低排序的时间复杂度。</p>

<p>空间复杂度与时间复杂度类似，也可以使用类似的方法估计并对比算法花费的空间资源。不过只要不是太过夸张，一般对空间的需求并没有时间那么首要，并且大多数情况下空间复杂度都易于分析，因此较少研究算法的空间复杂度。</p>

<h3>线性表的复杂度分析</h3>

<p>使用顺序存储结构的线性表在其中某个位置插入或删除一个数据元素时，为了保证线性表的连续性，必须要移动表中的一系列元素。</p>

<p>如果插入或删除开头位置的元素，则整个线性表的元素都要发生移动；如果删除末尾位置的元素，则可以不用移动元素。假设插入和删除的位置是随机的，那么每次操作平均会移动约一半元素，也就是说操作的时间复杂度为 <span class="math">\\( O(n) \\)</span> 。</p>

<p>使用顺序存储结构的线性表时，其优势在于获取表的长度和取确定位置的元素时间复杂度都为 <span class="math">\\( O(1) \\)</span> ，也就是说不管线性表多长，要取哪一个位置的元素，都只需要常数级的时间。如果需要频繁地访问元素的话，使用线性表是不错的选择。</p>

<p>由于顺序存储结构的线性表在应对大量数据的增加或修改时表现并不是很好，表的一部分需要经常移来移去。下一节介绍链表，链表是一种非连续的存储，在插入和删除时表的整体或部分无需全部移动。</p>
<p><a rel="nofollow" href="/archives/586">数据结构01-基本概念与线性表</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/586/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
