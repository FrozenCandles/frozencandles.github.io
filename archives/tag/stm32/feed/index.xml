<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>STM32归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/stm32/feed?simply_static_page=3750" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Mon, 12 Dec 2022 12:10:44 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>STM32归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>STM32与物联网02-网络数据收发</title>
		<link>/archives/519</link>
					<comments>/archives/519#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 15 Jul 2022 02:13:17 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[ESP8266]]></category>
		<category><![CDATA[STM32]]></category>
		<category><![CDATA[物联网]]></category>
		<guid isPermaLink="false">/?p=519</guid>

					<description><![CDATA[<p>在上一节中，介绍了 ESP8266 的使用方法。不过&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/519">STM32与物联网02-网络数据收发</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>在<a href="/archives/496">上一节</a>中，介绍了 ESP8266 的使用方法。不过上一节中都是通过串口调试工具手动发送信息的方式来操作 ESP8266 ，这肯定不能用于实际开发。因此，本节介绍如何编写合适的程序来和 ESP8266 交互，从而收发并解析网络数据。</p>
<h2>TCP服务器</h2>
<p>在 TCP 服务器下，可以使用移动设备主动连接 ESP8266 提供的 WiFi 。如果编写正确的程序，那么可以使用移动设备控制 ESP8266 。</p>
<h3>建立TCP服务器</h3>
<p>从上一节的介绍可以了解到，程序和 ESP8266 的交互主要是通过发送 AT 指令完成的，因此程序中首要的任务就是编写合适的程序向 ESP8266 发送指令。</p>
<p>不过在发送指令后，可能还需要判断指令是否被成功接收。一般来说，ESP8266 执行失败时可能返回各种信息，但在成功执行指令后都会返回 OK 。发送指令可以通过以下函数完成：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">ESP8266_SendCmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* cmd, <span class="hljs-keyword">uint8_t</span> timeout)</span> </span>{
    ESP8266_Buffer.Length = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(ESP8266_Buffer.Body, <span class="hljs-number">0</span>, USART_RX_BUF_SIZE);
    <span class="hljs-built_in">USART_printf</span>(USART3, <span class="hljs-string">"%s\r\n"</span>, cmd);
    <span class="hljs-keyword">while</span> (timeout--) {
        <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">100</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"OK"</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</pre></div>
<p>由于不同指令处理的时间也不一致，因此在程序中引入了一个倒计时器，在倒计时结束前不断检查接收到的信息中是否包含 <code>"OK"</code> ，如果是则结束当前倒计时，这样可以确保在指令执行完后就可以立即退出延时，提高程序执行效率。</p>
<p>程序中与 ESP8266 交互基本是都采用这种方式。例如，在程序下载后若希望使 ESP8266 也重启，则可以通过拉低 RST 引脚复位 ESP8266 ，复位后会接到 <code>"ready"</code> 信息，则可以编写以下函数：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">ESP8266_Reset</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> timeout)</span> </span>{
    <span class="hljs-built_in">ESP8266_RST</span>(RESET);
    <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">500</span>);
    <span class="hljs-built_in">ESP8266_RST</span>(SET);
    <span class="hljs-keyword">while</span> (timeout--) {
        <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">100</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"ready"</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</pre></div>
<p>如果某条指令有其余回复的情况，只需要参照以上略做修改即可。</p>
<p>有了以上函数后，就可以编写代码，逐条发送指令了。这里将 ESP8266 设置为 AP 模式，使其变成一个 WiFi 热点，使计算机可以直接连接上 ESP8266 并收发信息，因此首先需要发送 <code>AT+CWMODE=2</code> 指令：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_Reset</span>(<span class="hljs-number">50</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_SendCmd</span>(<span class="hljs-string">"AT+CWMODE=2"</span>, <span class="hljs-number">50</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
</pre></div>
<p>然后可以使用 <code>AT+CWSAP="&lt;ssid&gt;","&lt;password&gt;",&lt;chl&gt;,&lt;enc&gt;</code> 设置 WiFi 参数，一般来说通道号和加密类型都设置为 4 即可：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">char</span> cmd[<span class="hljs-number">64</span>];
<span class="hljs-built_in">sprintf</span>(cmd, <span class="hljs-string">"AT+CWSAP=\"%s\",\"%s\",%d,%d\r\n"</span>, SSID, PASSWORD, <span class="hljs-number">4</span>, WPA_WPA2_PSK);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_SendCmd</span>(cmd, <span class="hljs-number">50</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
</pre></div>
<p>可以将这些参数设置为宏定义以方便修改。接下来的许多设置都和以上代码类似，可以以此为模板替换为其它命令，因此不再展示代码，仅介绍主要命令。</p>
<p>如果要设置固定的局域网 IP ，可以通过 <code>AT+CIPAP="&lt;ip&gt;"</code> 完成。</p>
<p>接下来可以通过指令 <code>AT+CIPMODE=&lt;mode&gt;</code> 设置 ESP8266 的传输模式。该命令可以设置 ESP8266 的两种传输模式：</p>
<ol start="0">
<li>普通传输模式(Normal Transmission Mode)，该模式下，用户可以通过 AT 指令发送 TCP 数据，同时 ESP8266 也会将接收到的数据以 +IPD 等指令的形式返回</li>
<li>透传接收模式(Passthrough Receiving Mode)：该模式下，ESP8266 无法发送 TCP 数据，同时 ESP8266 会将接收到的数据以原始的形式返回给 STM32</li>
</ol>
<p>透传接收模式一般用于开启透传模式。关于透传模式会在后续介绍。</p>
<p>ESP8266 支持多路连接，即一个 TCP 端口可以建立多个连接。通过 <code>AT+CIPMUX=1</code> 可以启用多连接，每个连接到端口上的客户端通过 <code>&lt;id&gt;</code> 标识，连接的数量最后为 5 个，因此 <code>&lt;id&gt;</code> 的取值范围为 0~4 。</p>
<p>多连接必须在所有连接都断开且服务器也关闭时才可以设置，并且只有普通传输模式下才能设置为多连接。</p>
<p>接下来，可以通过 <code>AT+CIPSERVER=1,8266</code> 开启一个位于端口 8266 上的 TCP 服务器。根据以上步骤，TCP 服务器便建立完成，可以准备接收客户端发来的数据了。</p>
<h3>数据获取与解析</h3>
<p>在建立了 TCP 服务器后，ESP8266 便会等待客户端的连接。</p>
<p>TCP 客户端在接到客户端的数据时，会以 <code>+IPD,&lt;id&gt;,&lt;len&gt;:&lt;data&gt;</code> 的指令形式转交数据给 STM32 。由于以上开启了多路连接，因此接收的数据中多了一个字段 <code>&lt;id&gt;</code> 。</p>
<p>因此判断是否有数据收到也很简单，只需要判断接收缓冲区内是否有子串 <code>"+IPD"</code> 即可：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ESP8266_HasData</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body,<span class="hljs-string">"+IPD"</span>) 
        &amp;&amp; <span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body,<span class="hljs-string">":"</span>);
}
</pre></div>
<p>以上同时查找子串 <code>":"</code> 确保数据有效性。根据以上格式，拆解该字符串并截取有效数据如下：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">ESP8266_MuxGetData</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* data, <span class="hljs-keyword">uint16_t</span>* len)</span> </span>{
    <span class="hljs-keyword">uint8_t</span> id;
    <span class="hljs-keyword">char</span>* data_ptr = <span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"+IPD"</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(data_ptr,<span class="hljs-string">"+IPD,%d,%d"</span>, &amp;id, len) == <span class="hljs-number">2</span>) {
        <span class="hljs-built_in">memcpy</span>(data, <span class="hljs-built_in">strstr</span>(data_ptr, <span class="hljs-string">":"</span>) + <span class="hljs-number">1</span>, *len);
        data[*len] = <span class="hljs-string">'\0'</span>;
        ESP8266_Buffer.Length = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(ESP8266_Buffer.Body, <span class="hljs-number">0</span>, USART_RX_BUF_SIZE);
        <span class="hljs-keyword">return</span> id;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</pre></div>
<p>以上函数略显复杂。之所以要这么复杂，主要有以下两个方面的原因：<code>scanf()</code> 类函数使用字符串转换说明时，它在读入数据时如果遇到一个空格或回车符，会丢弃后面的所有数据，这显然不能用于截取用户数据。</p>
<p>另外上一节说过工程中接收串口传来的不定长数据的方式是使用串口空闲中断，然而空闲中断接收的一包数据并不都是符合期望的一包数据：在接收到 TCP 连接时，ESP8266 会发送 <code>&lt;id&gt;,CONNECT</code> 表示连接已建立，如果此时建立的连接接收到任何数据，ESP8266 也会立即转发该数据。因此如果连接建立后马上收到数据，那么两次发送的数据时间相隔过短，可能会没有引起空闲中断而被 STM32 认为是同一包数据。在连接取消时，也有同样的问题。</p>
<p>不过发送数据的函数可能更加复杂：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">ESP8266_MuxSendData</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* data, <span class="hljs-keyword">uint16_t</span> length, <span class="hljs-keyword">uint8_t</span> id, <span class="hljs-keyword">uint8_t</span> timeout)</span> </span>{
    <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
    <span class="hljs-built_in">USART_printf</span>(USART3, <span class="hljs-string">"AT+CIPSEND=%d,%d\r\n"</span>, id, length);
    <span class="hljs-keyword">while</span> (timeout--) {
        <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">10</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"&gt;"</span>))
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">if</span> (timeout &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
        <span class="hljs-built_in">USART_SendBytes</span>(USART3, data, length);
        <span class="hljs-keyword">while</span> (timeout--) {
            <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">10</span>);
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"SEND OK"</span>)) {
                <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"link is not valid"</span>)) {
                <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
    }
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</pre></div>
<p>上一节介绍了发送数据主要使用 <code>AT+CIPSEND</code> 指令完成（多连接下需要一个额外的字段指示发送给的 <code>&lt;id&gt;</code> ），如果可以发送 ESP8266 会返回 <code>"&gt; "</code> 作提示。如果发送成功，ESP8266 会返回 <code>"SEND OK"</code> ，通过返回提示就可以知道发送状态。</p>
<p>有了以上函数以后，就可以着手编写主程序了。主程序的处理逻辑非常简单，在建立 TCP 服务器后，便不断判断是否有数据到达，如果有那么便读取数据并回复信息：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">char</span> ipd_data[<span class="hljs-number">512</span>];
<span class="hljs-keyword">int8_t</span> ipd_id;
<span class="hljs-keyword">uint16_t</span> ipd_len;
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">ESP8266_CreateTcpServer</span>())
    <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">200</span>);
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_HasData</span>()) {
        ipd_id = <span class="hljs-built_in">ESP8266_MuxGetData</span>(ipd_data, &amp;ipd_len);
        <span class="hljs-built_in">ESP8266_MuxSendData</span>(<span class="hljs-string">"Acknowledge"</span>, <span class="hljs-number">12</span>, ipd_id, <span class="hljs-number">30</span>);
    }
    <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">500</span>);
}
</pre></div>
<p>可以将得到的数据显示在串口中。在计算机客户端，编写如下套接字程序：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">import</span> socket, time
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((<span class="hljs-string">'192.168.10.1'</span>, <span class="hljs-number">8266</span>))
client.send(time.ctime().encode())
message = client.recv(<span class="hljs-number">1024</span>)
<span class="hljs-built_in">print</span>(message.decode())
client.close()
</pre></div>
<p>将计算机连接到 ESP8266 创建的 WiFi 上并运行该套接字程序，即可观察到实验现象。如果为程序编写合适的用户界面并在 STM32 上进一步解析数据，那么便可以实现手机端控制 STM32 了。</p>
<h2>TCP客户端与HTTP请求</h2>
<p>TCP 客户端的建立与 TCP 服务器类似，这里先使 ESP8266 连接到路由器，借助路由器访问公网上的服务器。</p>
<p>前几步操作与 TCP 客户端类似：在复位 ESP8266 后，首先通过指令 <code>AT+CWMODE=1</code> 设置 Sta 模式，然后通过 <code>AT+CWJAP="&lt;ssid&gt;","&lt;password&gt;"</code> 连接到路由器中。由于客户端无需多个连接，可以使用 <code>AT+CIPMUX=0</code> 关闭多连接。</p>
<p>本次采用透传模式(Passthrough Mode)来收发数据。透传模式是一种特殊的收发数据模式，在透传模式下，用户不能发送 AT 指令，发送的任何数据都会作为原始的数据发送到传输对端；从传输对端收到的数据也会不经由任何 <code>+IPD</code> 封装而原封不动地返回给 STM32 。</p>
<p>使用 <code>AT+CIPMODE=1</code> 可以设置传输模式为透传模式。通过 <code>AT+CIPSTART</code> 连接上服务器后，直接执行 <code>AT+CIPSEND</code> ，待 ESP8266 返回 <code>"&gt;"</code> 后就进入了透传模式。透传模式下，每包数据以 20ms 间隔区分，每包最大 2048 字节，发送和接收数据都不需要封装成指令，方便处理。</p>
<p>正常退出透传模式的唯一方式就是单独发送一包发送指令 <code>+++</code> 。</p>
<p>根据以上原理，可以使用 STM32 发送相应指令，连接到服务器后进入透传模式，并准备发送相应的数据。其代码和上文服务端类似，例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_Reset</span>(<span class="hljs-number">50</span>))
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_SendCmd</span>(<span class="hljs-string">"AT+CWMODE=1"</span>, <span class="hljs-number">20</span>))
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_SendCmd</span>(<span class="hljs-string">"AT+CWJAP=\"TP_LINK\",\"abc123456\""</span>, <span class="hljs-number">100</span>))
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
<span class="hljs-comment">// ... and so on</span>
</pre></div>
<p>当然，考虑到一些指令执行成功时不总是返回 <code>OK</code> ，并且为了使程序逻辑更清晰，可以将一些指令封装成函数。例如，以下函数根据地址（可以是 IP 地址或域名，DNS 解析将自动完成）和端口号，连接到特定的 TCP 服务器中并进入透传模式：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">ESP8266_ConnectServer</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* address, <span class="hljs-keyword">uint16_t</span> port, <span class="hljs-keyword">uint8_t</span> timeout)</span> </span>{
    <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
    <span class="hljs-built_in">USART_printf</span>(USART3, <span class="hljs-string">"AT+CIPSTART=\"TCP\",\"%s\",%d\r\n"</span>, address, port);
    <span class="hljs-keyword">while</span> (timeout--) {
        <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">100</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"CONNECT"</span>)) {
            <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
            <span class="hljs-built_in">USART_printf</span>(USART3, <span class="hljs-string">"AT+CIPSEND\r\n"</span>);
            <span class="hljs-keyword">while</span> (timeout--) {
                <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">100</span>);
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"\r\nOK\r\n\r\n&gt;"</span>))
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"CLOSED"</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"ALREADY CONNECTED"</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
}
</pre></div>
<p>可以仿照该函数将其它指令封装成具有抽象功能的对应函数。</p>
<p>在本示例中，在使用 TCP 连接到远程服务器的 80 端口的基础上，手动构造合适的 HTTP 请求并发送：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
    <span class="hljs-built_in">USART_SendString</span>(USART3, <span class="hljs-string">"GET /api/temperature?time=now HTTP/1.1\r\n"</span>
                            <span class="hljs-string">"Connection: keep-alive\r\n"</span>
                            <span class="hljs-string">"Host: 192.168.1.105:80\r\n\r\n"</span>);
    <span class="hljs-built_in">delay_s</span>(<span class="hljs-number">5</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, ESP8266_Buffer.Body);
}
</pre></div>
<p>这里 5 秒钟便查询一次数据。如果间隔过长，连接可能断开，那么可以先主动断开连接，等需要查询时再发起 TCP 连接。</p>
<p>通过 HTTP 服务器提供的合适接口，ESP8266 便可以从互联网中获取到非常广泛的数据。在测试用的服务器中，该接口返回一个 json 响应并被转发到 STM32 中，串口调试工具中显示的原始数据如下：</p>

<div class="codeblock code-console">HTTP/1.1 200 OK
Date: Wed, 13 Jul 2022 10:57:48 GMT
Server: WSGIServer/0.2 CPython/3.9.1
Content-Type: application/json
X-Frame-Options: DENY
Content-Length: 93
X-Content-Type-Options: nosniff
Referrer-Policy: same-origin

{"temperature": {"high": 37.6, "low": 28.1, "now": 36.7}, "humidity": "50%", "wind": "11mph"}
</div>
<p>通过解析请求头 <code>Content-Length</code> 就可以获取数据的长度，然后查找子串 <code>"{"</code> 的位置便可以提取出接口返回的 json 数据，并可以使用 cJSON 等第三方库解析其中的数据。互联网中存在许多类似的接口，只需要构造合适的请求头，便可以抓取很多有用的信息，不过这需要有一定的抓包或爬虫的基础。</p>
<p>通过路由器可以接入互联网，在 TCP 服务的基础上，构造出合适的 HTTP 等应用层协议的封装，便可以采集互联网中的各种数据，或者向服务器报告自身传感器的数据，由此真正实现物联网的基础。</p>
<p>例如，可以向 HTTP 服务器提供的接口发送 POST 请求，将传感器数据作为参数发送给服务器，服务器解析 POST 请求并更新数据库，然后便可以显示在前端上，这样便可以在任何地点查看 STM32 的状态了。不过由于其实现涉及到的知识点过于广泛，无论是环境的配置还是程序的编写都不是一篇文章能完整介绍的，这里便不再涉及。</p>
<p>一个比较有趣的实现是利用 SMTP 发送电子邮件，可以阅读<a href="/archives/403#email">这篇文章</a>了解 SMTP 应用层协议的原理与基本报文格式，文章中附带了 Python 套接字程序实现，它和 AT 指令的思路具有一定相似性，移植到 STM32 的主要难点是使用 base64 编码完成身份验证，有兴趣的读者可以尝试自行实现。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.espressif.com/projects/esp-at/en/release-v2.2.0.0_esp8266/AT_Command_Set/TCP-IP_AT_Commands.html">https://docs.espressif.com/projects/esp-at/en/release-v2.2.0.0_esp8266/AT_Command_Set/TCP-IP_AT_Commands.html</a><br>TCP/IP 相关 AT 指令集的官方文档。<!-- 讲道理使用 AT 指令真的该读读文档，我 google 时发现很多关于 ESP8266 使用的介绍都是错误的。 --></p>
<p><a rel="nofollow" href="/archives/519">STM32与物联网02-网络数据收发</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/519/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>STM32与物联网01-ESP8266基本操作</title>
		<link>/archives/496</link>
					<comments>/archives/496#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 11 Jul 2022 13:47:08 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[ESP8266]]></category>
		<category><![CDATA[STM32]]></category>
		<category><![CDATA[物联网]]></category>
		<guid isPermaLink="false">/?p=496</guid>

					<description><![CDATA[<p>ESP8266物联网简介 ESP8266简介 ESP&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/496">STM32与物联网01-ESP8266基本操作</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>ESP8266物联网简介</h2>

<h3>ESP8266简介</h3>

<p>ESP8266 是上海乐鑫公司开发的一款具有 WiFi 功能的控制芯片，它带有完整的 TCP/IP 协议栈，因此可以用作物联网开发。</p>

<p>ESP8266 本身也是一个性能不错的 32 位微控制器，完全可以作为普通的 MCU 使用。然而，考虑到 ESP8266 作为 MCU 时需要一整套开发环境，且 ESP8266 的外设并不算丰富，因此这里仅将其作为一个普通外围器件使用，通过 STM32 等 MCU 控制它并接收 ESP8266 收到的网络数据。</p>

<p>在作为外围模块使用时，ESP8266 主要通过串口收发命令和数据，因此任意可以使用串口并设置波特率的 MCU 理论上都可以操作 ESP8266 实现物联网功能，包括但不限于 51 单片机、AVR 、STM32 和树莓派。</p>

<p>这里选用 ESP-01 作为 WiFi 模块，其外观为：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/07/esp8266-appearance.png" alt="" width="220">
    <figcaption>ESP-01S模块</figcaption>
</figure>

<p>它具有的优点为：</p>

<ol>
    <li>价格非常低廉，仅需个位数</li>
    <li>尺寸很小，大约为 25mm x 15mm</li>
    <li>功能完善，它本身也是一个微型开发板，具有 8 个引脚，可以实现程序下载、串口收发等功能</li>
    <li>市面上大多数 ESP-01 模块在售卖时已经内置了串口控制程序，上电后便可以正常工作。如果没有也不要紧，只需再花个位数价格就可以再买一个 ESP8266 固件下载器，结合商家给出的资料就可以重新烧入固件</li>
</ol>

<p>在详细介绍 ESP8266 的使用方法之前，最好先了解以下背景知识：</p>

<p>ESP8266 所使用的 WiFi 是工作频率在 2.4GHz 波段的局域网无线通信。有些笔记本电脑或路由器默认使用的是 5GHz 的网络频段，如果不修改将会无法与 ESP8266 连接上。</p>

<p>ESP8266 支持两种 WiFi 通信模式：AP 和 Sta 。AP 表示接入点(access point)，可以创建一个 WiFi 热点让其余设备连接，一般作为局域网服务器使用；Sta 表示连接设备，该模式下 ESP8266 可以主动连接其它 WiFi 信号，一般作为局域网客户端使用。不过 ESP8266 支持 Sta 和 AP 两模式共存，可以在连接 WiFi 的同时被其余设备连接。</p>

<p>在 ESP-01 模块中，具有 8 个引脚，各个引脚的作用为：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/07/esp8266-pins.png" alt="" width="170">
</figure>

<table>
    <tr>
        <th>序号</th>
        <th>名称</th>
        <th>功能</th>
    </tr>
    <tr>
        <td>1</td>
        <td><code>GND</code></td>
        <td>接地</td>
    </tr>
    <tr>
        <td>2</td>
        <td><code>GPIO 2</code></td>
        <td>通用输入输出（内部已上拉）</td>
    </tr>
    <tr>
        <td>3</td>
        <td><code>GPIO 0</code></td>
        <td>选择模式：低电平为下载模式，未连接或高电平为正常工作模式</td>
    </tr>
    <tr>
        <td>4</td>
        <td><code>RXD</code></td>
        <td>串口 0 数据接收，也可用作普通 GPIO</td>
    </tr>
    <tr>
        <td>5</td>
        <td><code>VCC</code></td>
        <td>3.3V 供电</td>
    </tr>
    <tr>
        <td>6</td>
        <td><code>RST</code></td>
        <td>复位线，若通过外部置为低电平则复位</td>
    </tr>
    <tr>
        <td>7</td>
        <td><code>CH_PD</code></td>
        <td>高电平使能芯片，低电平失能芯片</td>
    </tr>
    <tr>
        <td>8</td>
        <td><code>TXD</code></td>
        <td>串口 0 数据发送，也可用作普通 GPIO</td>
    </tr>
</table>

<p>接下来的程序使用基于 STM32 的标准库编写，并可以比较容易地修改为 HAL 库的代码，或使用其余类似的单片机编写作用相似的代码。</p>

<h3>串口接收不定长数据方法</h3>

<p>在正式介绍 ESP8266 操作方法之前，首先介绍一个基本的要点：如何使用串口接收 ESP8266 可能发来的不定长数据并解析。</p>

<p>不定长数据的接收方法有很多，例如可以通过空字符确定结尾。这里使用串口的空闲中断实现该方法，空闲中断的的产生是由于在两次数据发送间隔，串口没有检测到数据输入而产生的，从而可以判断数据接收完毕，停止接收数据。</p>

<p>首先，为了保存接收数据，需要定义一个缓冲区。这里通过一个结构体的形式确定缓冲区所需成员：</p>

<div class="vscode-block"><div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span> <span style="color: #4876d6;">USART_RX_BUF_SIZE</span> <span style="color: #aa0982;">1024</span></div><div><span style="color: #994cc3;">typedef</span> <span style="color: #994cc3;font-weight: bold;">struct</span><span style="color: #403f53;"> {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">char</span> <span style="color: #0c969b;">Body</span><span style="color: #403f53;">[</span><span style="color: #4876d6;">USART_RX_BUF_SIZE</span><span style="color: #403f53;">];</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;font-weight: bold;">uint16_t</span> <span style="color: #0c969b;">Length</span><span style="color: #403f53;"> &#160; &#160; :</span><span style="color: #aa0982;">15</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;font-weight: bold;">uint16_t</span> <span style="color: #0c969b;">FinishFlag</span><span style="color: #403f53;"> :</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">} </span><span style="color: #4876d6;">USART_Buffer</span><span style="color: #403f53;">;</span></div></div>

<p>注意，由于不总是在中断函数内处理接收数据，因此需要一个比特的字段用于判断数据是否接收完毕。</p>

<p>为了接收串口空闲中断，需要先在初始化函数内使能它：</p>

<div class="vscode-block"><div><span style="color: #994cc3;font-weight: bold;">void</span> <span style="color: #4876d6;">USART_Config</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> ...</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">USART_ITConfig(</span><span style="color: #4876d6;">USART3</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">USART_IT_IDLE</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">ENABLE</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">}</span></div></div>

<p>对应的串口中断函数的实现如下：</p>

<div class="vscode-block"><div><span style="color: #4876d6;">USART_Buffer</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">;</span></div><div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">USART3_IRQHandler</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">USART_GetITStatus(</span><span style="color: #4876d6;">USART3</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">USART_IT_RXNE</span><span style="color: #4876d6;">)</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">!=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">RESET</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Length</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">&lt;</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">USART_RX_BUF_SIZE</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">-</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">))</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Body</span><span style="color: #403f53;">[</span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Length</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">] </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> (</span><span style="color: #994cc3;font-weight: bold;">char</span><span style="color: #403f53;">)</span><span style="color: #4876d6;">USART_ReceiveData(</span><span style="color: #4876d6;">USART3</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; }</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">USART_GetITStatus(</span><span style="color: #4876d6;">USART3</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">USART_IT_IDLE</span><span style="color: #4876d6;">)</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">!=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">RESET</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">FinishFlag</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Body</span><span style="color: #403f53;">[</span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Length</span><span style="color: #403f53;">] </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #111111;">'</span><span style="color: #aa0982;">\0</span><span style="color: #111111;">'</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">volatile</span><span style="color: #403f53;"> </span><span style="color: #4876d6;font-weight: bold;">uint16_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">temp</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">temp</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">USART3</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">SR</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">temp</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">USART3</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">DR</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">ESP8266_FrameFinish_CallBack()</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; }</span></div><div><span style="color: #403f53;">}</span></div></div>

<p>在串口中断函数中，对以下两个中断类型响应：<code>USART_IT_RXNE</code> 表示数据接收寄存器收到内容，那么将接收到的内容作为一个字符放入缓冲区中；<code>USART_IT_IDLE</code> 表示数据包接收完毕，在缓冲器结尾添加上一个空字符使其变为字符串，并将结束标志位置 1 。</p>

<p>注意在不接收中断时，串口空闲中断会一直产生，从而干扰程序运行；清除串口空闲中断标志位需要由软件完成，具体做法是通过程序先读取 <var type="register">USART_SR</var> 寄存器，再读取 <var type="register">USART_DR</var> 寄存器。</p>

<p>在程序的最后使用一个回调函数来处理本次接收的数据包，它可以根据当前项目的使用情况自行编写或替换为相应的语句。</p>

<h2>ESP8266基本使用</h2>

<h3>设备连接与初始化</h3>

<p>根据上文的介绍，单片机最少需要 4 个 I/O 口与 ESP8266 相连：这里选用 USART3 作为与 ESP8266 通信的串口，则 <var type="pin">PB10</var> 与 ESP8266 的 RXD 相连，<var type="pin">PB11</var> 与 TXD 相连；<var type="pin">PA4</var> 与 RST 相连，<var type="pin">PA5</var> 与 CH_PD 相连：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/07/esp8266-pin-connect.png" alt="" width="230">
</figure>

<p>这里主要通过以下两个宏操作引脚：</p>

<div class="vscode-block"><div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_RST</span><span style="color: #111111;">(</span><span style="color: #403f53;">state</span><span style="color: #111111;">)</span><span style="color: #403f53;"> &#160; </span><span style="color: #4876d6;">GPIO_WriteBit</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">GPIOA</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">GPIO_Pin_4</span><span style="color: #403f53;">, (</span><span style="color: #4876d6;">BitAction</span><span style="color: #403f53;">)state)</span></div><div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_CH_PD</span><span style="color: #111111;">(</span><span style="color: #403f53;">state</span><span style="color: #111111;">)</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">GPIO_WriteBit</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">GPIOA</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">GPIO_Pin_5</span><span style="color: #403f53;">, (</span><span style="color: #4876d6;">BitAction</span><span style="color: #403f53;">)state)</span></div></div>

<p>本节先介绍一个最简单的、手动操作 ESP8266 的方式演示操作的整个过程：通过计算机的串口调试工具将命令发送给 STM32 ，STM32 接收后转发给 ESP8266 ，并将接收到的数据再转发给串口调试工具：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/07/esp8266-connect-debug.png" alt="" width="480">
</figure>

<p>因此，在初始化 ESP8266 时需要初始化相应的 GPIO 及两个 USART 外设，并将 RST 和 CH_PD 都置高电平：</p>

<div class="vscode-block"><div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_Init</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_GPIO_Config()</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_USART_Config()</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_RST</span><span style="color: #4876d6;">(</span><span style="color: #4876d6;">SET</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_CH_PD</span><span style="color: #4876d6;">(</span><span style="color: #4876d6;">SET</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">}</span></div></div>

<p>注意，初始化 STM32 连接到 ESP8266 的串口时，需要将波特率设置为 115200 ，否则数据无法被正常接收。当连接上 ESP8266 后，可以通过后续发送指令修改 ESP8266 的串口波特率。</p>

<p>除此之外，还有一些其它的外设如定时器、调试用串口等，其使用情况可以根据项目需要自行管理，对应的初始化过程不再介绍。</p>

<p>在串口 3 中断中，将接收到的 ESP8266 数据转发回串口调试工具：</p>

<div class="vscode-block"><div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_FrameFinish_CallBack</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">printf(</span><span style="color: #111111;">"</span><span style="color: #4876d6;">%s</span><span style="color: #111111;">"</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #4876d6;">.</span><span style="color: #0c969b;">Body</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">FinishFlag</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Length</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">}</span></div></div>

<p>串口 1 的中断处理过程与以上类似，这里不再重复。</p>

<h3>AT指令简介</h3>

<p>既然是使用串口通信的方式操作 ESP8266 ，那么收、发数据都需要遵循一定格式。ESP8266 的固件内置了 AT 指令，可以通过串口发送 AT 指令控制 ESP8266 。</p>

<p>所谓 AT 指令，是一种字符串形式的数据，但开头都是 <code>AT</code> 两个字符，后续跟上具体的选项。AT 指令有以下 4 种主要的表现形式：</p>

<table>
    <tr>
        <th>指令类型</th>
        <th>指令格式</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>测试指令</td>
        <td>AT+&lt;x&gt;=?</td>
        <td>用于查询设置命令或内部程序设置的参数以及其取值范围</td>
    </tr>
    <tr>
        <td>查询指令</td>
        <td>AT+&lt;x&gt;?</td>
        <td>用于查询参数当前设置的值</td>
    </tr>
    <tr>
        <td>设置命令</td>
        <td>AT+&lt;x&gt;=&lt;...&gt;</td>
        <td>用于设置用户自定义的参数值</td>
    </tr>
    <tr>
        <td>执行指令</td>
        <td>AT+&lt;x&gt;</td>
        <td>用于执行受模块内部程序控制的变参数不可变的功能</td>
    </tr>
</table>

<p>每一个 AT 指令以换行符 CRLF <code>\r\n</code> 作为结尾的标志，在串口调试工具中需要另起一行。</p>

<p>AT 指令很多，但是并不是每一个都会用得到。这里仅介绍需要的 AT 指令，完整的 AT 指令可以从文档中查看。</p>

<blockquote>
    <p>注意，某些厂商在生产开发板时，可能会对 AT 固件做一些裁剪，去除一些用处不大的指令，因此在使用时请阅读商家提供的说明文档。</p>
</blockquote>

<p>最简单的 AT 指令就是单个 <code>AT</code> ，用于测试 AT 固件是否能用。如果能用，ESP8266 会返回 <code>OK</code> ：</p>

<div class="codeblock code-console"><span class="codetoken command">AT</span>
AT


OK</div>

<p>上面发送了一个指令 <code>AT</code> ，而 ESP8266 则先回复了指令内容 <code>AT</code> ，再回复一个 <code>OK</code> ，这种先复述指令内容再发送有效数据的方式称为回显。回显会在一定程度上影响数据解析，并且在设计时 STM32 在接到串口调试工具发送的消息时已经执行了一次回显操作，因此可以使用 <code>ATE0</code> 指令关闭回显：</p>

<div class="codeblock code-console"><span class="codetoken command">ATE0</span>
ATE0


OK
<span class="codetoken command">AT</span>

OK</div>

<p>这样后续发送指令时只会回复有效数据了。在后续的操作中全部关闭回显，命令都是通过 STM32 收到后立即转发回来的。</p>

<p>可以使用 <code>AT+GMR</code> 查看当前固件的版本信息：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+GMR</span>

AT version:0.22.0.0(Mar 20 2015 10:04:26)
SDK version:1.0.0
compile time:Mar 20 2015 11:00:32

OK</div>

<p>如果固件版本过旧，可能也会缺少一些命令。可以使用专用的固件烧入模块通过 USB 为 ESP8266 更新固件。</p>

<p>上文曾经提到 ESP8266 有两种主要的工作模式：Sta 和 AP 。可以使用 <code>AT+CWMODE=&lt;mode&gt;</code> 设置 ESP8266 的通信模式：参数 <code>&lt;mode&gt;</code> 为 <code>1</code> 代表 ESP8266 设置为 Sta 模式；<code>2</code> 代表设置为 AP 模式；参数 <code>3</code> 则是 Sta 模式和 AP 模式共存。</p>

<p>这里将其设置为 Sta 模式，主动连接路由器或笔记本提供的 WiFi ：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CWMODE=1</span>


OK</div>

<p>在 Sta 模式下，可以使用执行命令 <code>AT+CWLAP</code> 列出(List)当前环境下可用的 WiFi 接入点：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CWLAP</span>

+CWLAP:(4,"Laptop",-54,"ac:4e:aa:b2:1f:f2",1)
+CWLAP:(4,"TP-LINK",-28,"51:38:39:a8:d5:e0",1)
+CWLAP:(4,"Mobile",-86,"a8:79:4b:22:42:e6",11)

OK</div>

<p>返回的结果中，每项数据都占一行，有 5 个元素，第一个元素 <code>&lt;ecn&gt;</code> 列出了 WiFi 所使用的加密类型，值 <code>4</code> 代表加密类型为 WPA_WPA2_PSK ；第二个元素 <code>&lt;ssid&gt;</code> 代表 WiFi 名，第三个元素 <code>&lt;rssi&gt;</code> 代表 WiFi 强度，绝对值越小强度越高；第四个元素 <code>&lt;mac&gt;</code> 是设备的 MAC 地址；最后一个元素 <code>&lt;channel&gt;</code> 代表频道。</p>

<blockquote>
    <p>注意，ESP8266 返回的数据都是 UTF-8 编码的，需要将串口调试工具的编码也设置为 UTF-8 ，否则可能出现中文乱码。</p>
</blockquote>

<p>连接(Join) WiFi 可以通过以下命令执行：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CWJAP="TP-LINK","abc123456"</span>


OK</div>

<p>WiFi 名和密码都要以字符串的形式放在双引号内，两者间使用逗号隔开。</p>

<p>连接到 WiFi 后，可以使用 <code>AT+CIFSR</code> 命令查看当前设备的 IP 地址：</p>

<div class="codeblock code-console">AT+CIFSR

+CIFSR:STAIP,"192.168.137.129"
+CIFSR:STAMAC,"65:e8:db:a5:9b:84"

OK</div>

<p>更多的 AT 指令及其用法可以参考官方文档。接下来介绍 ESP8266 从连接 WiFi 到接收网络数据的常用过程。</p>

<h3>WiFi连接与数据收发测试</h3>

<p>以下测试也全部在串口调试工具中发送命令与接收数据。</p>

<p>首先提前设置好 WiFi 名和密码，然后让 ESP8266 主动连接 WiFi ：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CWMODE=1</span>


OK
<span class="codetoken command">AT+CWJAP="TP-LINK","abc123456"</span>


OK</div>

<p>这里将计算机和 ESP8266 都主动连接到路由器提供的 WiFi 中，两者处于同一个局域网内，这样便可以比较方便地互发数据。</p>

<p>连接后，需要在计算机中查看本机在局域网内的地址：(IPv4 Address)</p>

<div class="codeblock code-console"><span class="codetoken prompt">C:\Users\Hello></span> <span class="codetoken command">ipconfig</span>

Windows IP Configuration

Wireless LAN adapter WLAN:

    Connection-specific DNS Suffix  . :
    IPv4 Address. . . . . . . . . . . : 192.168.1.105
    Subnet Mask . . . . . . . . . . . : 255.255.255.0
    Default Gateway . . . . . . . . . : 192.168.1.1
</div>

<p>以下通过 ESP8266 主动向计算机发起连接，并发送查询当前时间的命令；计算机接到命令后，向 ESP8266 返回当前的时间。在计算机的客户端，使用 Python 编写如下套接字程序：</p>

<div class="vscode-block"><div><span style="color: #994cc3;font-weight: bold;">import</span><span style="color: #403f53;"> socket, time</span></div><div><span style="color: #403f53;">server </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> socket.</span><span style="color: #0c969b;">socket</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">socket.AF_INET</span><span style="color: #111111;">,</span><span style="color: #4876d6;"> socket.SOCK_STREAM</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">server.</span><span style="color: #0c969b;">bind</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">(</span><span style="color: #111111;">''</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">12000</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">server.</span><span style="color: #0c969b;">listen</span><span style="color: #403f53;">(</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">)</span></div><div><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> </span><span style="color: #bc5454;">True</span><span style="color: #403f53;">:</span></div><div><span style="color: #403f53;">&#160; &#160; connect, address </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> server.</span><span style="color: #0c969b;">accept</span><span style="color: #403f53;">()</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">print</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">address</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">&#160; &#160; message </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> connect.</span><span style="color: #0c969b;">recv</span><span style="color: #403f53;">(</span><span style="color: #aa0982;">1024</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">print</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">message</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> message.</span><span style="color: #0c969b;">decode</span><span style="color: #403f53;">() </span><span style="color: #994cc3;">==</span><span style="color: #403f53;"> </span><span style="color: #111111;">'</span><span style="color: #c96765;">time</span><span style="color: #111111;">'</span><span style="color: #403f53;">:</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; connect.</span><span style="color: #0c969b;">send</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">time.</span><span style="color: #0c969b;">ctime</span><span style="color: #403f53;">()</span><span style="color: #4876d6;">.</span><span style="color: #0c969b;">encode</span><span style="color: #403f53;">())</span></div><div><span style="color: #403f53;">&#160; &#160; connect.</span><span style="color: #0c969b;">close</span><span style="color: #403f53;">()</span></div></div>

<p>使用 Python 编写套接字程序的方法可以参考<a href="/archives/403">这篇文章</a>。运行该程序后，在单片机端通过设置指令 <code>AT+CIPSTART</code> 向该局域网 IP 地址与端口号发起 TCP 连接：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CIPSTART="TCP","192.168.1.105",12000</span>

CONNECT

OK</div>

<p>连接完成以后，可以通过设置指令 <code>AT+CIPSEND</code> 发送数据，参数 <code>&lt;length&gt;</code> 为数据的长度：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CIPSEND=4</span>


OK
> <span class="codetoken command">time</span>
SEND OK

+IPD,24:Mon Jul 11 14:58:48 2022CLOSED</div>

<p>当收到此命令后，会换行返回 <code>> </code> 符号，表示接下来可以继续接收待发送的数据；后续通过串口发送的数据可以不用以新行结尾，当数据长度达到 <code>&lt;length&gt;</code> 时，ESP8266 才会将数据发送出去并返回 OK 。</p>

<p>在收到网络数据时，ESP8266 会以 <code>+IPD</code> 的指令形式返回，第一个逗号后面代表数据的长度，冒号后面跟随的是实际的数据。最后的 <code>CLOSE</code> 代表连接中断，它和数据是是分两次接收的。通过解析数组 <code>ESP8266_Buffer.Body</code> 中保存的数据，单片机就可以通过网络获取当前的实时时间，并用于校正当前的 RTC 时钟等。</p>

<p>当然，在实际使用时不会通过串口转发这么麻烦的方式，可以在程序中直接操作串口按指定的形式收发数据，下一节将会介绍相应程序的编写方法。</p>

<h2>参考资料/延伸阅读</h2>

<p><a href="https://docs.espressif.com/projects/esp-at/en/release-v2.2.0.0_esp8266/Get_Started/index.html">https://docs.espressif.com/projects/esp-at/en/release-v2.2.0.0_esp8266/Get_Started/index.html</a></p>

<p>ESP-AT 指令文档。不过很少有商家的固件会有这么新的版本。</p>
<p><a rel="nofollow" href="/archives/496">STM32与物联网01-ESP8266基本操作</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/496/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程01-移植到STM32</title>
		<link>/archives/307</link>
					<comments>/archives/307#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 13 Jun 2022 02:55:21 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<category><![CDATA[STM32]]></category>
		<guid isPermaLink="false">/?p=307</guid>

					<description><![CDATA[<p>LVGL库简介 LVGL(Light and Ver&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/307">LVGL库入门教程01-移植到STM32</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>LVGL库简介</h2>
<p>LVGL(Light and Versatile Graphics Library)是一个免费、开源的嵌入式图形库，可以创建丰富、美观的界面，具有许多可以自定义样式的控件，支持按键或触摸响应，支持中文字符，并且内存占用较低。可以在 <a href="https://lvgl.io/demos">https://lvgl.io/demos</a> 使用网页端体验 LVGL 的动态效果，再决定是否需要使用 LVGL 。</p>
<p>LVGL 使用 C 语言编写，可以用在树莓派、ESP32 、STM32 等单片机上，并支持各种中大型屏幕（只需要提供屏幕的绘图 API 即可）。LVGL 的官网地址为：<a href="https://lvgl.io/">https://lvgl.io/</a> ，GitHub 地址为：<a href="https://github.com/lvgl/lvgl">https://github.com/lvgl/lvgl</a> 。</p>
<p>LVGL 提供了许多示例程序，还提供了 PC 端的模拟器，这都加快了 LVGL 的开发效率。</p>
<h2>移植LVGL</h2>
<p>LVGL 并没有只针对哪一个单片机和哪一个屏幕，事实上它甚至在 PC 机也能运行的起来。完整的 LVGL 的移植可以参考官方文档的介绍 <a href="https://docs.lvgl.io/master/porting/index.html">https://docs.lvgl.io/master/porting/index.html</a> 。在移植前，请自行了解单片机及屏幕的使用方法并提供接口程序。</p>
<h3>建立工程</h3>
<p>接下来以 STM32 系列单片机为例介绍 LVGL 的移植，不同单片机的移植过程也可以参考以下步骤。下表给出了 LVGL 所需的配置，在使用 LVGL 前请确保单片机性能满足要求：</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Minimal</strong></th>
<th><strong>Recommended</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Architecture</strong></td>
<td>16, 32 or 64 bit microcontroller or processor</td>
<td></td>
</tr>
<tr>
<td><strong>Clock</strong></td>
<td>&gt; 16 MHz</td>
<td>&gt; 48 MHz</td>
</tr>
<tr>
<td><strong>Flash/ROM</strong></td>
<td>&gt; 64 kB</td>
<td>&gt; 180 kB</td>
</tr>
<tr>
<td><strong>Static RAM</strong></td>
<td>&gt; 16 kB</td>
<td>&gt; 48 kB</td>
</tr>
<tr>
<td><strong>Draw buffer</strong></td>
<td>&gt; 1 ×<em>hor. res.</em> pixels</td>
<td>&gt; 1/10 screen size</td>
</tr>
<tr>
<td><strong>Compiler</strong></td>
<td>C99 or newer</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote><p>注意：使用 Keil5 请开启“C99 Mode”，否则会编译不通过。还在使用 Keil4 的请升级或更换编译器。</p></blockquote>
<p>首先，在 <a href="https://github.com/lvgl/lvgl">https://github.com/lvgl/lvgl</a> 下载或克隆整个工程。LVGL 的最新版本是 LVGL 8.2 ，注意 LVGL 7 已经不再更新，LVGL 7 和 8 之间库结构发生较大改变，编写出的代码并不很兼容，并且 LVGL 7 的示例代码和模拟器似乎已经在 GitHub 上下架了。本教程以 LVGL 8 为例，移植 LVGL 7 的话可以参考，但一些细节需要注意调整。建议使用最新版本，否则无法得到完整的工具链支持。</p>
<blockquote><p>使用 Keil 的开发者请注意，LVGL 8 似乎不能在 ARM CC v5 下编译成功，请更新编译器版本为 ARM CC v6 。</p>
<p>使用 STM32 的开发者还需要注意，STM32 标准库无法使用 ARM CC v6 编译，请使用 HAL 库或更换编译工具链（如 LLVM-clang 或 GCC-none-eabi ）</p></blockquote>
<p>接下来自行准备一个单片机工程，在 <code>User</code> 或其它等效的目录中，然后新建目录 <code>lvgl</code> 并进入，从克隆得到的 LVGL 工程中复制以下文件或目录到其中：</p>
<div class="codeblock code-template">
	examples<br />
src<br />
lvgl.h<br />
lv_conf_template.h</div>
<p>如果不需要使用官方提供的示例代码，可以不复制 <code>demos</code> 目录。</p>
<p>接下来，将 <code>lv_conf_template.h</code> 重命名为 <code>lv_conf.h</code> ，并移动到上一级目录中。</p>
<blockquote><p>注意：LVGL 库的目录比较复杂，头文件引用相对混乱，在没有充分明白正在做什么之前，请不要随意修改文件夹名或变更文件位置。</p></blockquote>
<p>回到上一级目录，打开 <code>lv_conf.h</code> ，将开头的 <code>#if 0</code> 条件编译取消，启用文件包含的配置：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/* clang-format off */</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;"> </span><span style="color: #a8a8a8;">/*Set it to "1" to enable content*/</span></div>
</div>
<p>该配置文件还有几处需要调整的地方，首先最前面（第 27 行）的一个宏定义表示显示屏的颜色深度，需要根据不同的显示屏做调整：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/*Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888)*/</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_COLOR_DEPTH</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">16</span></div>
</div>
<p>如果屏幕的颜色深度不一致，一定要修改该宏。LVGL 会根据该宏创建合适的颜色定义，如果与实际不一致会造成显示时颜色错乱。</p>
<blockquote><p>如果设置为 8 ，代表使用 8 位的颜色，其中 RBG 色值各占 3 、3 、2 位；如果设置为 16 ，则 RBG 色值各占 5 、6 、5 位，这是许多 TFT 屏采用的颜色格式；32 则是大多数 PC 机和移动设备都使用的带透明度的 32bit 位图，RGB 色值和透明度各占一个字节。</p></blockquote>
<p>第 52 行中还有一处表示最大占用内存量的宏，可以根据实际单片机的情况自行修改，只要保证大于注释中写的 2kB 就行。</p>
<div class="vscode-block">
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/*Size of the memory available for `lv_mem_alloc()` in bytes (&gt;= 2kB)*/</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_MEM_SIZE</span><span style="color: #403f53;"> (</span><span style="color: #aa0982;">32U</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1024U</span><span style="color: #403f53;">) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">/*[bytes]*/</span></div>
</div>
<p>除此之外，在第 273 和 280 行还有这么两个宏定义，如果将它们设置为 <code>1</code> ，那么可以在屏幕的左下角和右下角显示当前内存占用和帧率，非常适合性能分析：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_USE_PERF_MONITOR</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_USE_MEM_MONITOR</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span></div>
</div>
<p>其它设置可以对照注释和文档修改。</p>
<p>接下来开始导入工程文件，这一步需要将 <code>lvgl/src</code> 中除了 <code>draw</code> 目录中的所有文件全部导入，而 <code>draw</code> 目录中除了根目录的 <code>.c</code> 文件外，只导入 <code>sw</code> 目录中的源文件。LVGL 8 的目录深度较大，请耐心添加，细心检查，不要遗漏文件。</p>
<p>使用 STM32 单片机的话还需要注意在启动文件中修改堆、栈大小，至少各设置 8kB 空间：</p>
<div class="vscode-block">
<div><span style="color: #403f53;">Stack_Size &nbsp; &nbsp; &nbsp;</span><span style="color: #994cc3;font-weight: bold;">EQU</span><span style="color: #403f53;"> &nbsp; &nbsp; 0x00002000</span></div>
<div><span style="color: #403f53;">Heap_Size &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">EQU</span><span style="color: #403f53;"> &nbsp; &nbsp; 0x00002000</span></div>
</div>
<p>全部添加完成之后，尝试编译整个工程，应该是可以零 error 通过了。</p>
<blockquote><p>使用 ARM CC v6 可能会发生 <code>__aeabi_assert</code> 符号未定义的问题，可以在整个项目管理中提前定义宏 <code>NDEBUG</code> 禁用该符号。</p></blockquote>
<h3>显示设备的API对接</h3>
<p>LVGL 只提供了绘图的算法，其它内容需要自行编写。LVGL 提供的接口在 <code>lvgl/examples/porting</code> 目录中，该目录有如下文件：</p>
<ul>
<li><code>lv_port_disp</code> ：显示设备接口</li>
<li><code>lv_port_indev</code> ：输入设备接口</li>
<li><code>lv_port_fs</code> ：文件系统接口</li>
</ul>
<p>将各个文件名结尾的 <code>template</code> 去除。接下来先编写显示设备的接口，至少确保能显示一些东西来。</p>
<hr>
<p>在 <code>lv_port_disp.c</code> 及其头文件中，首先需要去除条件编译，启用这部分内容：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/*Copy this file as "lv_port_disp.h" and set this value to "1" to enable content*/</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span></div>
</div>
<p>由于之前重命名过头文件，因此在源文件中也需要修改对应的名称：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">include</span><span style="color: #403f53;"> </span><span style="color: #111111;">"</span><span style="color: #c96765;">lv_port_disp.h</span><span style="color: #111111;">"</span></div>
</div>
<p>源文件在宏定义区域中有两个宏定义，需要修改为实际的显示屏尺寸。改过了之后记得把 <code>#warning</code> 预处理语句去除了：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">ifndef</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">MY_DISP_HOR_RES</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;">#warning Please define or replace the macro MY_DISP_HOR_RES with the actual screen width, default value 320 is used for now.</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">MY_DISP_HOR_RES</span><span style="color: #403f53;"> &nbsp; &nbsp;</span><span style="color: #aa0982;">320</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">endif</span></div>
<div><span style="color: #a8a8a8;">/* ... same as above ... */</span></div>
</div>
<p><code>lv_port_disp_init()</code> 是一个最顶层的初始化显示设备的函数，在主函数中需要调用它一次性初始化显示设备的功能。该函数的修改方式注释里已经写的较为清楚了，接下来提供一个修改示例。</p>
<p>首先将 91~102 行的两个提供显示缓存的语句全部注释或删除，只保留 <code>/* Example for 1) */</code> 。然后修改 114~115 行的两个数值为实际的屏幕清晰度。</p>
<div class="vscode-block">
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* Example for 1) */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_disp_draw_buf_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">draw_buf_dsc_1</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_color_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">buf_1</span><span style="color: #403f53;">[MY_DISP_HOR_RES </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">];</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_disp_draw_buf_init</span><span style="color: #403f53;">(</span><span style="color: #0c969b;">&amp;</span><span style="color: #403f53;">draw_buf_dsc_1, </span><span style="color: #4876d6;">buf_1</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">NULL</span><span style="color: #403f53;">, MY_DISP_HOR_RES </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/*Set the resolution of the display*/</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">disp_drv</span><span style="color: #403f53;">.hor_res </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">320</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">disp_drv</span><span style="color: #403f53;">.ver_res </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">240</span><span style="color: #403f53;">;</span></div>
</div>
<p>该文件内还有两个函数 <code>disp_init()</code> 和 <code>disp_flush()</code> ，需要提供实际显示设备的接口。</p>
<p><code>disp_init()</code> 中，需要提供屏幕的初始化代码，如果已经在外部初始化过可以忽略。</p>
<p><code>disp_flush()</code> 中，需要在注释的位置根据提供的参数绘制一个像素点，。这一过程也可以使用填充函数获得更快的速度，甚至可以使用 GPU 等加速等方式完成，具体如何编写代码可以参考注释。例如，测试用的屏幕是这样逐个绘制像素点，从而填充一块区域的：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/* ... */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">for</span><span style="color: #403f53;">(y </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> area</span><span style="color: #0c969b;">-</span><span style="color: #994cc3;">&gt;</span><span style="color: #403f53;">y1; y </span><span style="color: #994cc3;">&lt;=</span><span style="color: #403f53;"> area</span><span style="color: #0c969b;">-</span><span style="color: #994cc3;">&gt;</span><span style="color: #403f53;">y2; y</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">for</span><span style="color: #403f53;">(x </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">area</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">x1</span><span style="color: #403f53;">; x </span><span style="color: #994cc3;">&lt;=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">area</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">x2</span><span style="color: #403f53;">; x</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">ILI9341_SetFrontColor(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">ili9341, color_p-&gt;full)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">ILI9341_DrawPixel(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">ili9341, x, y)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; color_p</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #a8a8a8;">/* ... */</span></div>
</div>
<p>至此，API 移植便结束了。接下来可以编写程序测试 LVGL 的效果了。</p>
<h3>LVGL的初始化</h3>
<p>在使用 LVGL 前，需要调用以下两个函数完成 LVGL 库的初始化以及 LVGL 显示设备接口的初始化：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">lv_init</span><span style="color: #403f53;">();</span></div>
<div><span style="color: #4876d6;">lv_port_disp_init</span><span style="color: #403f53;">();</span></div>
</div>
<p>然后就可以绘制图形了。这里提供了一段简单的代码，可以绘制一个按钮：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> btn </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_btn_create</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">lv_scr_act</span><span style="color: #403f53;">()); </span></div>
<div><span style="color: #4876d6;">lv_obj_set_pos</span><span style="color: #403f53;">(btn, </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">lv_obj_set_size</span><span style="color: #403f53;">(btn, </span><span style="color: #aa0982;">120</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">50</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> label </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_label_create</span><span style="color: #403f53;">(btn);</span></div>
<div><span style="color: #4876d6;">lv_label_set_text</span><span style="color: #403f53;">(label, </span><span style="color: #111111;">"</span><span style="color: #c96765;">Button</span><span style="color: #111111;">"</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">lv_obj_center</span><span style="color: #403f53;">(label);</span></div>
</div>
<p>绘制完之后，还需要在主循环中调用 <code>lv_task_handler()</code> 函数，这样绘制的内容才能实时更新到屏幕上：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> (</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* ... */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_task_handler()</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>然后将编译得到的结果下载到单片机内，就可以在屏幕上看到一个按钮了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-01-disp-test.jpg" alt="-" width="360"></figure>
<h2>LVGL输入设备移植</h2>
<p>上文介绍了如何移植显示设备。但是 LVGL 是一个用户界面库，光有显示设备，不能做一些用户交互的功能还是不太够，因此就需要使用输入设备。</p>
<p>LVGL 支持 5 种类型的输入设备：</p>
<ul>
<li>Touchpad ：触摸屏</li>
<li>Mouse ：鼠标</li>
<li>Keypad ：键盘</li>
<li>Encoder ：编码器</li>
<li>Button ：按键</li>
</ul>
<p>在移植时，不要搞错了输入设备的类型，否则 LVGL 无法对输入作出响应。</p>
<p>LVGL 对输入设备的接口全部存放在 <code>lv_port_indev.c</code> 及其头文件中。接下来以触摸屏为例介绍输入设备的移植，不同设备的 API 有一定区别，在移植时请以官方文档为主。</p>
<p>首先，需要去掉两个文件中的 <code>#if 0</code> 条件编译，启用两个文件。</p>
<p>在 <code>lv_port_indev.c</code> 中，包含了 5 种设备的 API ，但它们不可能都用到，因此需要裁剪无用的函数和定义。尤其是在初始化函数 <code>lv_port_indev_init()</code> 中，如果不去除无用设备的初始化语句，那么在调用时可能会出现问题。</p>
<p>源码在注释中已经着重强调了不同 API 的分区，只需要根据分区保留需要的代码即可。</p>
<p>根据代码的思路（精简后的源码不长，而且抽象程度较高，完全可以读懂），接下来实现三个函数的功能。</p>
<p>首先是 <code>touchpad_init()</code> ，在这里需要对输入设备做初始化，就像上文对触摸屏做初始化一样。</p>
<p>在 <code>touchpad_is_pressed()</code> 中，需要提供一个显示屏触摸函数，判断是否发生了触摸事件：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">bool</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">touchpad_is_pressed</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">XPT2046_TouchDetect()</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">==</span><span style="color: #403f53;"> TOUCH_PRESSED)</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">true</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">false</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>如果发生了触摸事件，那么会进入 <code>touchpad_get_xy()</code> 函数中，获取触摸点坐标：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">touchpad_get_xy</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">lv_coord_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">lv_coord_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> XPT2046_Coordinate </span><span style="color: #4876d6;">coord</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> { </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">, </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">, </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">, </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;"> };</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">XPT2046_Get_TouchedPoint(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">xpt2046, </span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">coord</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; (</span><span style="color: #0c969b;">*</span><span style="color: #403f53;">x</span><span style="color: #403f53;">) </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">coord</span><span style="color: #403f53;">.</span><span style="color: #4876d6;">x</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; (</span><span style="color: #0c969b;">*</span><span style="color: #403f53;">y</span><span style="color: #403f53;">) </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">coord</span><span style="color: #403f53;">.</span><span style="color: #4876d6;">y</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>如果这几个函数都编写正确，那么理论上已经可以实现输入功能了。不过在此之前，还有一个关键的步骤：LVGL 使用一个 tick 系统管理全局事件，它就像 LVGL 的心跳一样，如果没有这个心跳就无法检测事件。</p>
<p>为了给 LVGL 提供心跳，需要不断调用 <code>lv_tick_inc()</code> 函数，该函数的参数为每次心跳的毫秒间隔：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> (</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_tick_inc(</span><span style="color: #aa0982;">1</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_task_handler()</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">delay_ms(</span><span style="color: #aa0982;">1</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>使用单片机时更推荐使用定时器完成该函数的调用，设置定时器溢出时间为 1 毫秒后在定时器中断函数内调用它。</p>
<hr>
<p>接下来提供一个示例，可以检测输入设备是否能正常使用。首先在 <code>main</code> 函数的开头执行输入设备的初始化：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">lv_port_indev_init</span><span style="color: #403f53;">();</span></div>
</div>
<p>然后编写如下函数：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">btn_event_cb</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">lv_event_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> e) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_event_code_t</span><span style="color: #403f53;"> code </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_event_get_code(e)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> btn </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_event_get_target(e)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (code </span><span style="color: #994cc3;">==</span><span style="color: #403f53;"> LV_EVENT_CLICKED) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> cnt </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; cnt</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> label </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_obj_get_child(btn, </span><span style="color: #aa0982;">0</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">lv_label_set_text_fmt(label, </span><span style="color: #111111;">"</span><span style="color: #c96765;">Button: </span><span style="color: #4876d6;">%d</span><span style="color: #111111;">"</span><span style="color: #4876d6;">, cnt)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">}</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_example</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> btn </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_btn_create(lv_scr_act())</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_set_pos(btn, </span><span style="color: #aa0982;">10</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">10</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_set_size(btn, </span><span style="color: #aa0982;">120</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">50</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_add_event_cb(btn, btn_event_cb, LV_EVENT_ALL, NULL)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> label </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_label_create(btn)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_label_set_text(label, </span><span style="color: #111111;">"</span><span style="color: #c96765;">Button</span><span style="color: #111111;">"</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_center(label)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>在主函数中调用 <code>lv_example()</code> ，编译后下载到单片机内，可以得到一个和上一个示例相同的按钮，但是每次点击之后，按钮的文本都会发生变化：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-01-indev-test.jpg" alt="-" width="360"></figure>
<h2>使用LVGL模拟器</h2>
<p>LVGL 是一个图形库，那么在绘制图形时就免不了需要对绘制结果做一些微调。那么每次微调都需要将程序下载到单片机去显然是麻烦的选择，不过幸好 LVGL 提供了模拟器，可以在 PC 端上直接生成可交互的界面，无需下载即可查看绘制效果。</p>
<p>LVGL 可以在各个平台上模拟，完整的模拟器使用指南可以参照 <a href="https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html">https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html</a> 。接下来以 Windows 平台基于 Visual Studio 的模拟为例介绍通用的使用方法。</p>
<p>首先，在 <a href="https://github.com/lvgl/lv_port_win_visual_studio">https://github.com/lvgl/lv_port_win_visual_studio</a> 中下载 Visual Studio 工程源码。注意，在 <code>LVGL.Simulator</code> 目录中包含 3 个外部的仓库，需要将它们一并下载并放在正确的位置。</p>
<p>然后，使用 Visual Studio 打开 <code>LVGL.Simulator.sln</code> 工程，点击编译即可得到 GUI 可执行文件。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-01-simulation-test.jpg" alt="-" width="770"></figure>
<p>LVGL 模拟器的屏幕大小可能与实际屏幕大小不符，需要在主函数最前部分 <code>lv_win32_init</code> 初始化时做一些调整。</p>
<p>需要注意的是，Visual Studio 提供的模拟器是使用 C++ 编写的，如果需要自定义函数，需要在头文件中使用</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">ifdef</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">__cplusplus</span></div>
<div><span style="color: #994cc3;font-weight: bold;">extern</span><span style="color: #403f53;"> </span><span style="color: #111111;">"</span><span style="color: #c96765;">C</span><span style="color: #111111;">"</span><span style="color: #403f53;"> {</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">endif</span></div>
<div><span style="color: #a8a8a8;">/* ... function prototypes ... */</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">ifdef</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">__cplusplus</span></div>
<div><span style="color: #403f53;">}</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">endif</span></div>
</div>
<p>将函数原型包围起来，否则在使用 C 语言符号时会出错。</p>
<p><a rel="nofollow" href="/archives/307">LVGL库入门教程01-移植到STM32</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/307/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>U8g2图形库与STM32移植</title>
		<link>/archives/301</link>
					<comments>/archives/301#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 09 Jun 2022 02:43:19 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[OLED]]></category>
		<category><![CDATA[STM32]]></category>
		<category><![CDATA[u8g2]]></category>
		<guid isPermaLink="false">/?p=301</guid>

					<description><![CDATA[<p>简介 U8g2 是一个用于嵌入式设备的简易图形库，可&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/301">U8g2图形库与STM32移植</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>简介</h2>
<p>U8g2 是一个用于嵌入式设备的简易图形库，可以在多种 OLED 和 LCD 屏幕上，支持包括 SSD1306 等多种类型的底层驱动，并可以很方便地移植到 Arduino 、树莓派、NodeMCU 和 ARM 上。</p>
<p>U8g2 库同时包含了 U8x8 绘图库，两者的区别为：</p>
<ul>
<li>U8g2 包含各种简单及复杂图形的绘制，并支持各种形式的字体，但需要占用一定单片机的内存作为绘图缓存</li>
<li>U8x8 只包含简单的显示文本功能，且只支持简单、定宽的字体。它直接绘制图形，没有缓存功能</li>
</ul>
<p>U8g2 库的 GitHub 地址为：<a href="https://github.com/olikraus/u8g2">https://github.com/olikraus/u8g2</a> ，可以从中获取到源码与文档帮助。</p>
<h2>移植</h2>
<p>本次以将 U8g2 移植到 STM32 单片机与 SSD1306 通过 I2C 驱动的 128x64 OLED 为例，介绍移植的方法。不同单片机和驱动的移植可以参考这一过程，也可以参考 U8g2 的官方移植教程 <a href="https://github.com/olikraus/u8g2/wiki/Porting-to-new-MCU-platform">https://github.com/olikraus/u8g2/wiki/Porting-to-new-MCU-platform</a> 。</p>
<p>首先下载或克隆 U8g2 的源码，这里主要是使用 C 语言编写，所以只需要用到 <code>csrc</code> 目录下的文件。</p>
<p>下载完成后，将 <code>csrc</code> 目录拷贝或移动到工程目录里，并重命名为合适的目录名例如 <code>u8g2lib</code> 。</p>
<p>接下来，需要删除一些无用的代码，并添加底层驱动的代码。</p>
<h3>删除无用内容</h3>
<p>U8g2 的源码为了支持多种设备驱动，包含了许多兼容性的代码。首先，类似 <code>u8x8_d_xxx.c</code> 命名的文件中包含 U8x8 的驱动兼容，文件名包括驱动的型号和屏幕分辨率，因此需要删除无用的驱动文件，只保留当前设备的驱动。例如，本次使用的是 128x64 的 SSD1306 屏幕，那么只需要保留 <code>u8x8_d_ssd1306_128x64_noname.c</code> 文件，删除其它类似的文件即可。U8g2 支持的所有屏幕驱动可以在 <a href="https://github.com/olikraus/u8g2/wiki/u8g2setupc">https://github.com/olikraus/u8g2/wiki/u8g2setupc</a> 找到。</p>
<p>同时还需要精简 <code>u8g2_d_setup.c</code> 和 <code>u8g2_d_memory.c</code> 中 U8g2 提供的驱动兼容。</p>
<p>在 <code>u8g2_d_setup.c</code> 中，只需要保留 <code>u8g2_Setup_ssd1306_i2c_128x64_noname_f()</code> 这一个函数即可。注意，该文件内有几个命名类似的函数：命名中无 <code>i2c</code> 的是 SPI 接口驱动的函数，需要根据接口选择；以 1 结尾的函数代表使用的缓存空间为 128 字节，以 2 结尾的函数代表使用的缓存为 256字节，类似以 f 结尾的函数代表使用的缓存为 1024 字节。</p>
<p><code>u8g2_d_memory.c</code> 文件也是同理，它需要根据 <code>u8g2_d_setup.c</code> 中的调用情况决定用到哪些函数。由于 <code>u8g2_Setup_ssd1306_i2c_128x64_noname_f()</code> 函数只用到 <code>u8g2_m_16_8_f()</code> 这一个函数，因此只需要保留它，其余函数全部删除即可。</p>
<p>还有一处必要的精简是字体文件 <code>u8x8_fonts.c</code> 和 <code>u8g2_fonts.c</code> ，尤其是 <code>u8g2_fonts.c</code> ，该文件提供了包括汉字在内的几万个文字的多种字体，仅源文件就有 30MB ，编译后占据的内存非常大。</p>
<p>字体类型的变量非常多，建议先复制一个备份后将所有变量删除，之后视情况再添加字体。字体变量的命名大致遵循以下规则：</p>
<div class="codeblock code-template">
    &lt;prefix&gt; '_' &lt;name&gt; '_' &lt;purpose&gt; &lt;charset&gt;</div>
<p>其中：</p>
<ul>
<li><code>&lt;prefix&gt;</code> 前缀基本上以 u8g2 开头；</li>
<li><code>&lt;name&gt;</code> 字体名，其中可能包含字符大小</li>
<li>各种 <code>&lt;purpose&gt;</code> 含义如下表所示：</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>t</td>
<td>透明字体形式</td>
</tr>
<tr>
<td>h</td>
<td>所有字符等高</td>
</tr>
<tr>
<td>m</td>
<td>monospace 字体（等宽字体）</td>
</tr>
<tr>
<td>8</td>
<td>每一个字符都是 8x8 大小的</td>
</tr>
</tbody>
</table>
<ul>
<li><code>&lt;charset&gt;</code> 是字体支持的字符集，如下表所示：</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>f</td>
<td>只包含单字节字符</td>
</tr>
<tr>
<td>r</td>
<td>只包含 ASCII 范围为 32~127 的字符</td>
</tr>
<tr>
<td>u</td>
<td>只包含 ASCII 范围为 32~95 的字符，即不包括小写英文</td>
</tr>
<tr>
<td>n</td>
<td>只包含数字及一些特殊用途字符</td>
</tr>
<tr>
<td>...</td>
<td>还包括许多自定义的字符集，例如有一些结尾带 gb2312 或 Chinese 的字体名就包括中文</td>
</tr>
</tbody>
</table>
<p>一般建议只保留需要的字体即可。</p>
<h3>添加回调函数</h3>
<p>U8g2 已经包含了 SSD1306 的驱动，只需要添加一个函数 <code>u8x8_gpio_and_delay()</code> 用于模拟时序即可。官方文件给出了一个函数的编写模板为：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8x8_gpio_and_delay</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8x8_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">msg</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">arg_int</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">arg_ptr</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">switch</span><span style="color: #403f53;"> (</span><span style="color: #403f53;">msg</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_AND_DELAY_INIT</span><span style="color: #403f53;">: &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> called once during init phase of u8g2/u8x8</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> can be used to setup pins</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_NANO</span><span style="color: #403f53;">: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> delay arg_int * 1 nano second</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">; &nbsp;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_100NANO</span><span style="color: #403f53;">: &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> delay arg_int * 100 nano seconds</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* and many other cases */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_MENU_HOME</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #a8a8a8;">/* get menu home pin state */</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">default</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">); &nbsp; &nbsp; </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> default return value</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>以下是一个写法示例：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8x8_gpio_and_delay</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8x8_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">msg</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">arg_int</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">arg_ptr</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">switch</span><span style="color: #403f53;"> (</span><span style="color: #403f53;">msg</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_100NANO</span><span style="color: #403f53;">: </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> delay arg_int * 100 nano seconds</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">__NOP</span><span style="color: #403f53;">();</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_10MICRO</span><span style="color: #403f53;">: </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> delay arg_int * 10 micro seconds</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">for</span><span style="color: #403f53;"> (</span><span style="color: #994cc3;font-weight: bold;">uint16_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">n</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">; </span><span style="color: #4876d6;">n</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">&lt;</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">320</span><span style="color: #403f53;">; </span><span style="color: #4876d6;">n</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">)</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">__NOP</span><span style="color: #403f53;">();</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_MILLI</span><span style="color: #403f53;">: &nbsp; </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> delay arg_int * 1 milli second</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">delay_ms</span><span style="color: #403f53;">(</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_I2C</span><span style="color: #403f53;">: &nbsp; &nbsp; </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int is the I2C speed in 100KHz, e.g. 4 = 400 KHz</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">delay_us</span><span style="color: #403f53;">(</span><span style="color: #aa0982;">5</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=1: delay by 5us, arg_int = 4: delay by 1.25us</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_I2C_CLOCK</span><span style="color: #403f53;">: </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=0: Output low at I2C clock pin</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #403f53;">arg_int</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">?</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">GPIO_SetBits</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">GPIO_B</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">GPIO_Pin_6</span><span style="color: #403f53;">) </span><span style="color: #994cc3;">:</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">GPIO_ResetBits</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">GPIO_B</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">GPIO_Pin_6</span><span style="color: #403f53;">); &nbsp;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=1: Input dir with pullup high for I2C clock pin</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_I2C_DATA</span><span style="color: #403f53;">: &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=0: Output low at I2C data pin</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #403f53;">arg_int</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">?</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">GPIO_SetBits</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">GPIO_B</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">GPIO_Pin_7</span><span style="color: #403f53;">) </span><span style="color: #994cc3;">:</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">GPIO_ResetBits</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">GPIO_B</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">GPIO_Pin_7</span><span style="color: #403f53;">); &nbsp;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=1: Input dir with pullup high for I2C data pin</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_MENU_SELECT</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #a8a8a8;">/* get menu select pin state */</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_MENU_NEXT</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #a8a8a8;">/* get menu next pin state */</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_MENU_PREV</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #a8a8a8;">/* get menu prev pin state */</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_MENU_HOME</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #a8a8a8;">/* get menu home pin state */</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">default</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">); </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> default return value</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>如果使用的引脚不是 PB6 和 PB7 ，注意在对应的位置修改；如果是使用硬件 I2C 的方式，那么可以不需要模拟时序，但是需要编写硬件驱动函数。在结尾处，会给出一个基于标准库的硬件移植方法。</p>
<p>最后，不要忘记了初始化 I2C 对应的 GPIO 引脚。</p>
<h2>U8g2简单使用</h2>
<p>U8g2 的初始化可以参考如下步骤：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_Init</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_Setup_ssd1306_i2c_128x64_noname_f(</span><span style="color: #403f53;">u8g2</span><span style="color: #4876d6;">, U8G2_R0, u8x8_byte_sw_i2c, u8x8_gpio_and_delay)</span><span style="color: #403f53;">; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> 初始化 u8g2 结构体</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_InitDisplay(</span><span style="color: #403f53;">u8g2</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> 根据所选的芯片进行初始化工作，初始化完成后，显示器处于关闭状态</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_SetPowerSave(</span><span style="color: #403f53;">u8g2</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">0</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> 打开显示器</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_ClearBuffer(</span><span style="color: #403f53;">u8g2</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>这里需要调用之前保留的 <code>u8g2_Setup_ssd1306_128x64_noname_f()</code> 函数，该函数的4个参数，其含义为：</p>
<ul>
<li><code>u8g2</code> ：需要配置的 U8g2 结构体</li>
<li><code>rotation</code> ：配置屏幕是否要旋转，默认使用 <code>U8G2_R0</code> 即可</li>
<li><code>byte_cb</code> ：传输字节的方式，这里使用软件 I2C 驱动，因此使用 U8g2 源码提供的 <code>u8x8_byte_sw_i2c()</code> 函数。如果是硬件 I2C 的话，可以参照编写自己的函数</li>
<li><code>gpio_and_delay_cb</code> ：提供给软件模拟 I2C 的 GPIO 输出和延时，使用之前编写的配置函数 <code>u8x8_gpio_and_delay()</code></li>
</ul>
<p>如果需要显示字符串，需要提前调用以下函数设置字体：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_SetFont</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">const</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">font</span><span style="color: #403f53;">);</span></div>
</div>
<hr>
<p>U8g2 的绘制方式有 2 种，每种都有不同的特点。</p>
<p>首先是全屏缓存模式(Full screen buffer mode)，它的特点是绘制速度快，并且所有的绘制方法都可以使用。但是这种模式需要大量的 RAM 空间，因此使用需要用到缓存为 1024 字节的初始化函数（函数名以 f 结尾）。</p>
<p>这种绘图的方式首先需要清除缓冲区，调用绘图 API 后绘制的内容会保留在缓存内，需要手动发送缓存的内容到屏幕上：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #4876d6;">u8g2_ClearBuffer(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #a8a8a8;">/* Draw Something */</span></div>
<div><span style="color: #4876d6;">u8g2_SendBuffer(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
</div>
<p>第二种是分页模式(Page mode)，它同样可以使用所有的绘制方法，但绘制速度较慢，不过占用的 RAM 空间也少，可以使用 128 或 256 字节的缓存（函数名以 1 和 2 结尾）。</p>
<p>这种绘图的方式首先创建第一页，然后在一个 <code>do...while</code> 循环内部绘制图形，不断判断是否到达下一页，如果到达了就自动刷新缓存：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">u8g2_FirstPage(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #994cc3;font-weight: bold;">do</span><span style="color: #403f53;"> {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* Draw Something */</span></div>
<div><span style="color: #403f53;">} </span><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">u8g2_NextPage(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2)</span><span style="color: #403f53;">);</span></div>
</div>
<p>可以认为分页模式是一块一块绘制的，只绘制需要的区域。</p>
<p>还可以使用 U8x8 的绘图模式，这种情况下需要使用 U8x8 提供的结构体以及一系列函数，这里不再说明。</p>
<h2>绘图API</h2>
<p>完整的 API 参考可以参见官方文档 <a href="https://github.com/olikraus/u8g2/wiki/u8g2reference/">https://github.com/olikraus/u8g2/wiki/u8g2reference/</a> ，里面不仅有 API 的介绍，还有绘制效果的图片演示。</p>
<p>U8g2 的坐标系和绝大多数 GUI 库一样，原点在左上角，(x, y) 往右下递增，坐标的单位为像素。</p>
<h3>简单图形绘制</h3>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawPixel</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawHLine</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">len</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawVLine</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">len</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawLine</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x1</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y1</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y2</span><span style="color: #403f53;">);</span></div>
</div>
<p>分别用于绘制像素点、根据左上角顶点 (<code>x</code>, <code>y</code>) 与长度 <code>len</code> 绘制水平线与垂直线，以及绘制两点之间的线段。</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawFrame</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">w</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">h</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawBox</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">w</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">h</span><span style="color: #403f53;">);</span></div>
</div>
<p>根据左上角的 (<code>x</code>, <code>y</code>) 坐标与宽 <code>w</code> 高 <code>h</code> 绘制空心与实心矩形。</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawRBox</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> x, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> y, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> w, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> h, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> r);</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawRFrame</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> x, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> y, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> w, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> h, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> r);</span></div>
</div>
<p>绘制实行与空心圆角矩形，多了一个参数圆角半径 <code>r</code> 。</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawCircle</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x0</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y0</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">rad</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">option</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawDisc</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x0</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y0</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">rad</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">option</span><span style="color: #403f53;">);</span></div>
</div>
<p>根据圆心 (<code>x0</code>, <code>y0</code>) 绘制直径为 <code>rad</code> ×2+1 的空心圆和实心圆。</p>
<p><code>option</code> 为圆的部分选项，此参数可控制绘制圆弧或扇形：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>U8G_DRAW_ALL</code></td>
<td>整个圆弧</td>
</tr>
<tr>
<td><code>U8G2_DRAW_UPPER_RIGHT</code></td>
<td>右上部分的圆弧</td>
</tr>
<tr>
<td><code>U8G2_DRAW_UPPER_LEFT</code></td>
<td>左上部分的圆弧</td>
</tr>
<tr>
<td><code>U8G2_DRAW_LOWER_LEFT</code></td>
<td>左下部分的圆弧</td>
</tr>
<tr>
<td><code>U8G2_DRAW_LOWER_RIGHT</code></td>
<td>右下部分的圆弧</td>
</tr>
</tbody>
</table>
<p>还可以使用按位或运算符 <code>|</code> 连接几个部分。</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawEllipse</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> x0, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> y0, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> rx, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> ry, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> option);</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawFilledEllipse</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> x0, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> y0, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> rx, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> ry, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> option);</span></div>
</div>
<p>根据圆心 (<code>x0</code>, <code>y0</code>) 和水平半径 <code>rx</code> 、竖直半径 <code>ry</code> 绘制空心和实心椭圆。</p>
<p>void u8g2_DrawTriangle(u8g2_t *u8g2, int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2);</p>
<p>根据三个点绘制实心三角形（空心三角形可以使用直线达到类似效果）。</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawXBM</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> x, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> y, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> w, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> h, </span><span style="color: #994cc3;font-weight: bold;">const</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">bitmap);</span></div>
</div>
<p>在图形左上角 (<code>x</code>, <code>y</code>) 根据宽 <code>w</code> 高 <code>h</code> 绘制 XBM 格式的位图。可以使用 <a href="https://tools.clz.me/image-to-bitmap-array">https://tools.clz.me/image-to-bitmap-array</a> 工具将一般图片转换为位图代码。</p>
<p>和 Bitmap 有关的函数还有一个：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_SetBitmapMode</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> is_transparent);</span></div>
</div>
<p>该函数用于设置 Bitmap 是否透明。</p>
<h3>字符显示</h3>
<p>为了显示字符串，首先要设置字体。调用以下函数可以提前设置字体：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_SetFont</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #994cc3;font-weight: bold;">const</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">font);</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_SetFontMode</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> is_transparent);</span></div>
</div>
<p>字体是一种特殊的位图，因此也可以设置是否透明。所有的字体保存在 <code>u8g2_fonts.c</code> 源文件中，注意在移植 U8g2 库时曾经裁剪过该文件。</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawStr</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">const</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">char</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">str</span><span style="color: #403f53;">);</span></div>
</div>
<p>在左下角 (<code>x</code>, <code>y</code>) 处显示字符串。注意，这个方法只能绘制 ASCII 字符。如有需要显示 Unicode 字符，需要使用以下函数：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawGlyph</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">uint16_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">encoding</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_DrawUTF8</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">const</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">char</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">str</span><span style="color: #403f53;">);</span></div>
</div>
<p>绘制 Unicode 字符和字符串。U8g2 支持 16 位的 Unicode 字符集，因此 <code>encoding</code> 的范围被限制在 65535 。该函数绘制 Unicode 字符串时还需要对应的字体也支持 Unicode 字符。</p>
<p>注意这几个函数都有返回值，它们返回绘制成功的字符个数。</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_GetAscent</span><span style="color: #111111;">(</span><span style="color: #403f53;">u8g2</span><span style="color: #111111;">)</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_GetDescent</span><span style="color: #111111;">(</span><span style="color: #403f53;">u8g2</span><span style="color: #111111;">)</span></div>
</div>
<p>这两个宏定义用于获取字体基线以上和基线以下的高度。上文提到的显示字符串的函数实际上参数 <code>y</code> 指的是基线高度。此外注意基线以下的高度返回的是负值。</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_GetStrWidth</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #994cc3;font-weight: bold;">const</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">char</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">s);</span></div>
<div><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_GetUTF8Width</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #994cc3;font-weight: bold;">const</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">char</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">str);</span></div>
</div>
<p>获取当前字体下，字符串和 UTF-8 字符串的宽度，单位为像素。</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_SetFontDirection</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> dir);</span></div>
</div>
<p>设置文字朝向，根据参数不同分别设置为正常朝向的顺时针旋转 <code>dir</code> ×90° 。</p>
<h3>其它绘图相关API</h3>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_SetClipWindow</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">clip_x0</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">clip_y0</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">clip_x1</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">u8g2_uint_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">clip_y1</span><span style="color: #403f53;">);</span></div>
</div>
<p>设置采集窗口大小，设置后绘制的图形只在该窗口范围内显示。设置后可以使用 <code>u8g2_SetMaxClipWindow()</code> 函数去掉该限制。</p>
<h2>示例代码</h2>
<p>以下官方示例代码可以在 OLED 上显示该库的 logo ：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #4876d6;">u8g2_FirstPage</span><span style="color: #403f53;">(</span><span style="color: #0c969b;">&amp;</span><span style="color: #403f53;">u8g2);</span></div>
<div><span style="color: #994cc3;font-weight: bold;">do</span><span style="color: #403f53;"> {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_SetFontMode(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">1</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_SetFontDirection(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">0</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_SetFont(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, u8g2_font_inb24_mf)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_DrawStr(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">0</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">20</span><span style="color: #4876d6;">, </span><span style="color: #111111;">"</span><span style="color: #c96765;">U</span><span style="color: #111111;">"</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_SetFontDirection(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">1</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_SetFont(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, u8g2_font_inb30_mn)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_DrawStr(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">21</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">8</span><span style="color: #4876d6;">, </span><span style="color: #111111;">"</span><span style="color: #c96765;">8</span><span style="color: #111111;">"</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_SetFontDirection(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">0</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_SetFont(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, u8g2_font_inb24_mf)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_DrawStr(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">51</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">30</span><span style="color: #4876d6;">, </span><span style="color: #111111;">"</span><span style="color: #c96765;">g</span><span style="color: #111111;">"</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_DrawStr(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">67</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">30</span><span style="color: #4876d6;">, </span><span style="color: #111111;">"</span><span style="color: #aa0982;">\xb2</span><span style="color: #111111;">"</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_DrawHLine(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">2</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">35</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">47</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_DrawHLine(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">3</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">36</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">47</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_DrawVLine(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">45</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">32</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">12</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_DrawVLine(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">46</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">33</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">12</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_SetFont(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, u8g2_font_4x6_tr)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">u8g2_DrawStr(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">u8g2, </span><span style="color: #aa0982;">1</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">54</span><span style="color: #4876d6;">, </span><span style="color: #111111;">"</span><span style="color: #c96765;">github.com/olikraus/u8g2</span><span style="color: #111111;">"</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">} </span><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">u8g2_NextPage</span><span style="color: #403f53;">(</span><span style="color: #0c969b;">&amp;</span><span style="color: #403f53;">u8g2));</span></div>
</div>
<h2>附录：使用硬件I2C移植U8g2</h2>
<p>硬件 I2C 效率上比软件 I2C 快了非常多，因此特别适合 U8g2 这种大型 UI 框架。下面基于标准库介绍硬件 I2C 的移植方式。</p>
<p>如果使用硬件 I2C ，需要在调用该函数（或类似函数）时，使用自己的硬件读写函数：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_Setup_ssd1306_i2c_128x64_noname_f</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8g2_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">const</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8g2_cb_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">rotation</span><span style="color: #403f53;">, u8x8_msg_cb </span><span style="color: #403f53;">byte_cb</span><span style="color: #403f53;">, u8x8_msg_cb </span><span style="color: #403f53;">gpio_and_delay_cb</span><span style="color: #403f53;">);</span></div>
</div>
<p>首先还是需要编写一个 <code>gpio_and_delay()</code> 回调函数。不过由于这里是使用硬件 I2C ，因此不再需要提供 GPIO 和时序操作的支持，只需要提供一个毫秒级的延时即可：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8x8_gpio_and_delay_hw</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8x8_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">msg</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #403f53;">arg_int</span><span style="color: #403f53;">, </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">arg_ptr</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">switch</span><span style="color: #403f53;"> (</span><span style="color: #403f53;">msg</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_100NANO</span><span style="color: #403f53;">: </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> delay arg_int * 100 nano seconds</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_10MICRO</span><span style="color: #403f53;">: </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> delay arg_int * 10 micro seconds</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_MILLI</span><span style="color: #403f53;">: </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> delay arg_int * 1 milli second</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">Delay_ms</span><span style="color: #403f53;">(</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_DELAY_I2C</span><span style="color: #403f53;">: </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int is the I2C speed in 100KHz, e.g. 4 = 400 KHz</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=1: delay by 5us, arg_int = 4: delay by 1.25us</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_I2C_CLOCK</span><span style="color: #403f53;">: </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=0: Output low at I2C clock pin</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=1: Input dir with pullup high for I2C clock pin</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_I2C_DATA</span><span style="color: #403f53;">: &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=0: Output low at I2C data pin</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> arg_int=1: Input dir with pullup high for I2C data pin</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_MENU_SELECT</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #a8a8a8;">/* get menu select pin state */</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_MENU_NEXT</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #a8a8a8;">/* get menu next pin state */</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_MENU_PREV</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #a8a8a8;">/* get menu prev pin state */</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_GPIO_MENU_HOME</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #a8a8a8;">/* get menu home pin state */</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">default</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">u8x8_SetGPIOResult</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8x8</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">); </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> default return value</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>如果是使用硬件 I2C ，那么需要自行编写硬件驱动函数，向 OLED 写入字节。这个函数的编写可以参考官方提供的软件驱动函数 <code>u8x8_byte_sw_i2c()</code> ，一个编写示例为：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">uint8_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">u8x8_byte_hw_i2c</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">u8x8_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">u8x8, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> msg, </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> arg_int, </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;">arg_ptr) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> data </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> (</span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;">) arg_ptr;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">switch</span><span style="color: #403f53;">(msg) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_BYTE_SEND</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;">( arg_int</span><span style="color: #0c969b;">--</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">&gt;</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;"> ) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">I2C_SendData(I2C1, </span><span style="color: #0c969b;">*</span><span style="color: #4876d6;">data</span><span style="color: #994cc3;">++</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> (</span><span style="color: #994cc3;">!</span><span style="color: #4876d6;">I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)</span><span style="color: #403f53;">) </span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">continue</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_BYTE_INIT</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* add your custom code to init i2c subsystem */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">RCC_APB1PeriphClockCmd</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">RCC_APB1Periph_I2C1</span><span style="color: #403f53;">, ENABLE);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; I2C_InitTypeDef I2C_InitStructure </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .I2C_Mode </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> I2C_Mode_I2C,</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .I2C_DutyCycle </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> I2C_DutyCycle_2,</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .I2C_OwnAddress1 </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0x10</span><span style="color: #403f53;">,</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .I2C_Ack </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> I2C_Ack_Enable,</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .I2C_AcknowledgedAddress </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> I2C_AcknowledgedAddress_7bit,</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .I2C_ClockSpeed </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">400000</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">I2C_Init</span><span style="color: #403f53;">(I2C1, </span><span style="color: #0c969b;">&amp;</span><span style="color: #403f53;">I2C_InitStructure);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">I2C_Cmd</span><span style="color: #403f53;">(</span><span style="color: #403f53;">I2C1</span><span style="color: #403f53;">, </span><span style="color: #403f53;">ENABLE</span><span style="color: #403f53;">); &nbsp;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_BYTE_SET_DC</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* ignored for i2c */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_BYTE_START_TRANSFER</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">I2C_GetFlagStatus</span><span style="color: #403f53;">(I2C1, I2C_FLAG_BUSY));</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">I2C_GenerateSTART</span><span style="color: #403f53;">(</span><span style="color: #403f53;">I2C1</span><span style="color: #403f53;">, </span><span style="color: #403f53;">ENABLE</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;">(</span><span style="color: #994cc3;">!</span><span style="color: #4876d6;">I2C_CheckEvent</span><span style="color: #403f53;">(I2C1, I2C_EVENT_MASTER_MODE_SELECT))</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">continue</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">I2C_Send7bitAddress</span><span style="color: #403f53;">(</span><span style="color: #403f53;">I2C1</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">0x78</span><span style="color: #403f53;">, </span><span style="color: #403f53;">I2C_Direction_Transmitter</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;">(</span><span style="color: #994cc3;">!</span><span style="color: #4876d6;">I2C_CheckEvent</span><span style="color: #403f53;">(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">continue</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">case</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">U8X8_MSG_BYTE_END_TRANSFER</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">I2C_GenerateSTOP</span><span style="color: #403f53;">(I2C1, ENABLE);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">break</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">default</span><span style="color: #403f53;">:</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>从各个 <code>case</code> 标签可以很明白地看出一个 I2C 的读写过程：<code>U8X8_MSG_BYTE_INIT</code> 标签下需要初始化 I2C 外设，<code>U8X8_MSG_BYTE_START_TRANSFER</code> 标签产生起始信号并发出目标地址，<code>U8X8_MSG_BYTE_SEND</code> 标签开始发送字节，并且发送的字节存储在 <code>*arg_ptr</code> 参数中，<code>arg_int</code> 是字节的总长度（ U8g2 库似乎一次不会传输多余 32 字节的信息）。最后，<code>U8X8_MSG_BYTE_END_TRANSFER</code> 标签处产生停止信号。</p>
<blockquote><p>注意在使用硬件 I2C 时，GPIO 需要设置为复用开漏输出模式 <code>GPIO_Mode_AF_OD</code> 。</p></blockquote>
<p>最后一步，用以上编写的硬件函数初始化 U8g2 驱动：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">u8g2_Setup_ssd1306_i2c_128x64_noname_f</span><span style="color: #403f53;">(</span><span style="color: #403f53;">u8g2</span><span style="color: #403f53;">, </span><span style="color: #403f53;">U8G2_R0</span><span style="color: #403f53;">, </span><span style="color: #403f53;">u8x8_byte_hw_i2c</span><span style="color: #403f53;">, </span><span style="color: #403f53;">u8x8_gpio_and_delay_hw</span><span style="color: #403f53;">);</span></div>
</div>
<p>硬件移植过程完毕。</p>
<p><a rel="nofollow" href="/archives/301">U8g2图形库与STM32移植</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/301/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
