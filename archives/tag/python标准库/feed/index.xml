<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Python标准库归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/python%E6%A0%87%E5%87%86%E5%BA%93/feed?simply_static_page=3746" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Mon, 12 Dec 2022 12:23:27 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>Python标准库归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Python函数式编程10 functools模块：高阶函数工具</title>
		<link>/archives/296</link>
					<comments>/archives/296#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Tue, 07 Jun 2022 05:53:18 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Python标准库]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=296</guid>

					<description><![CDATA[<p>functools 库包含许多实用的函数操作工具，并&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/296">Python函数式编程10 functools模块：高阶函数工具</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p><code>functools</code> 库包含许多实用的函数操作工具，并且它们都是高阶函数。</p>
<h2>常用函数</h2>
<h3>lru_cache：缓存结果</h3>
<p><code>@lru_cache(maxsize)</code> 装饰器能保存已有计算结果，从而加快函数运行，其中 LRU 指最近使用的(least recent used) 。该装饰器会将最近得到的计算结果保留在缓存中，并在必要时清除不常用的计算结果。</p>
<p>例如，以下是使用缓存改进后的递归形式的斐波那契数列函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">lru_cache</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">maxsize</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">1024</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">fibonacci_cached</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> n &lt; </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> n</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> fibonacci_cached(n - </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">) + fibonacci_cached(n - </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">)</span></div>
</div>
<p>接下来在 IPython 环境中对有无缓存的情况测试执行效率，结果为：</p>
<div class="codeblock code-console"><span class="codetoken ipython-in">In [1]:</span> def fibonacci_without_cache():<br />
...:     return fibonacci(34)<br />
...: def fibonacci_with_cache():<br />
...:     fibonacci_cached.cache_clear()<br />
...:     return fibonacci_cached(34)<br />
<span class="codetoken ipython-in">In [2]:</span> %timeit fibonacci_without_cache<br />
2.12 s ± 7.21 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)<br />
<span class="codetoken ipython-in">In [3]:</span> %timeit fibonacci_with_cache<br />
12.6 µs ± 67.8 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</div>
<p>注意，不能直接使用 <code>%timeit</code> 命令测试函数，因为它会多次执行取平均时间，而第一次执行后由于缓存的存在使后续结果直接从缓存中获取，干扰测试效果。因此，每次测试后都通过装饰器的 <code>.cache_clear()</code> 方法清空缓存。</p>
<p>从测试结果中可以看出，缓存的存在极大提升了递归函数的执行效率。</p>
<h3>partial：冻结参数</h3>
<p><code>partial(<em>func</em>, /, *<em>args</em>, **<em>kwargs</em>)</code> 可以将函数的部分参数固定，得到一个新的函数。</p>
<p>例如，如果想要设置打开一个文件时，永远是以 UTF-8 编码的形式打开，那么可以使用 <code>partial</code> 将 <code>open()</code> 函数的 <code><em>encoding</em></code> 参数固定，形成一个新的函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">uopen = partial(</span><span style="color: #8b56bf;">open</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">encoding</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">utf8</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
</div>
<p>这样每次确保都是以 UTF-8 编码对文件操作的：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> uopen(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">demo.txt</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">w</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> f:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; f.write(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f641.png" alt="🙁" class="wp-smiley" style="height: 1em; max-height: 1em;" />✯<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/26c8.png" alt="⛈" class="wp-smiley" style="height: 1em; max-height: 1em;" />⚝<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2602.png" alt="☂" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2601.png" alt="☁" class="wp-smiley" style="height: 1em; max-height: 1em;" />︎<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f636.png" alt="😶" class="wp-smiley" style="height: 1em; max-height: 1em;" /></span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
</div>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/10-unicode-txt.jpg" alt="" width="150"></figure>
<p><code>partial()</code> 非常适用于冻结高阶函数的函数参数，这种情况下，可以提前写好一个函数，从而让一个比较泛化的高阶函数具有更具体的功能，例如：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> operator </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> add, mul</span></div>
<div><span style="color: #8b56bf;">sum</span><span style="color: #405c79;"> = partial(reduce, add) </span></div>
<div><span style="color: #405c79;">prod = partial(reduce, mul) </span></div>
</div>
<p>该装饰器的本质就是给一部分参数提前赋值，也可以使用匿名函数实现类似的效果。</p>
<h3>singledispatch：单分派</h3>
<p><code>@singledispatch</code> 装饰器可以根据参数的类型指定不同的函数，可以在一定程度上使用泛型。</p>
<p>例如，假设要实现一个函数 <code>scale(<em>data</em>, <em>scalar</em>)</code> ，将数据缩放。但是传入的数据可能是一个数值，也可能是一个数组。那么就需要在函数内判断传入数据的类型。</p>
<p><code>@singledispatch</code> 装饰器则可以简化判断的流程，它可以根据参数类型的不同，指定调用不同的函数。为了实现这一点，需要先将目标函数装饰起来：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">singledispatch</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
</div>
<p>然后调用目标函数的 <code>@.register(<em>type</em>)</code> 方法作为装饰器，将不同类型的参数导向不同的函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">float</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">_scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">float</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> data * scalar</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">list</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">_scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x * scalar, data))</span></div>
</div>
<p>此时，如果传入的参数类型不同，那么就会被不同的函数调用了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; scale(0.7, 2)<br />
1.4<br />
&gt;&gt;&gt; scale(list(range(10)), 0.3)<br />
[0.0, 0.3, 0.6, 0.8999999999999999, 1.2, 1.5, 1.7999999999999998, 2.1, 2.4, 2.6999999999999997]</div>
<p>如果对一个分派函数同时使用多个装饰器，那么这些类型的参数都会汇合到这个函数中：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">tuple</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">list</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">_scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
</div>
<p>Python3.7 对该函数做了一些改进，如果已经提供了类型注解，那么可以直接使用方法对象作为装饰器，即 <code>@scale.register</code> 这种不调用的形式。</p>
<p>这种单分派函数可以在一定程度上实现函数签名效果，但可惜的是它只支持一个参数。</p>
<p>除此之外，functools 还包含一系列其它的高阶函数，例如<a href="/archives/239">第 4 节</a>中介绍到的 <code>reduce()</code> 函数、在介绍面向对象编程时装饰类的 <code>@total_ordering</code> 装饰器、Python3.9 新增的 <code>@cache</code> 装饰器，以及以上提到的装饰器都有用于方法的改版。更多标准库的介绍可以参阅 Python 标准库官方文档。</p>
<h2>参考资料</h2>
<p><a href="https://docs.python.org/3/library/functools.html">https://docs.python.org/3/library/functools.html</a></p>
<p>Python3 标准库 <code>functools</code> 官方文档</p>
<p><!-- finished(all):2022-06-02 --></p>
<p><a rel="nofollow" href="/archives/296">Python函数式编程10 functools模块：高阶函数工具</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/296/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程08 itertools模块：更多迭代器</title>
		<link>/archives/270</link>
					<comments>/archives/270#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 01 Jun 2022 04:46:00 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Python标准库]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=270</guid>

					<description><![CDATA[<p>itertools 模块中包含大量迭代器函数，是处理&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/270">Python函数式编程08 itertools模块：更多迭代器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p><code>itertools</code> 模块中包含大量迭代器函数，是处理数据的非常好用的工具。</p>
<blockquote><p>生成器是迭代器的一个部分，迭代器和生成器的用途是一致的，只是迭代器并不都是使用 <code>yield</code> 这种关键字的方式定义。可以用生成器的概念来理解它。</p></blockquote>
<h2>无限迭代器</h2>
<p>以下迭代器如果在迭代时不使用 <code>break</code> 终止或遇到错误，那么它会一直执行下去。</p>
<h3>count：计数迭代器</h3>
<p>内置的 <code>range()</code> 函数需要定义范围的上界，而下限和步长值可选。count(start=0, step=1) 函数与之相反，需要给出可选的起始值和步长，无须定义上界。在停止之前，该生成器会一直执行下去。</p>
<p><code>count()</code> 函数的参数可以是浮点数，但是由于进制带来的舍入误差会随着程序的运行逐渐累积，因此尽量在较大的计数过程中慎用浮点数计数，或者使用整型计数再转换为浮点数的方式。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">count(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 10 11 12 13 14 ...</span></div>
<div><span style="color: #405c79;">count(</span><span style="color: #bf8b56;">2.5</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0.5</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 2.5 3.0 3.5 ...</span></div>
</div>
<h3>cycle：循环迭代器</h3>
<p><code>cycle()</code> 函数重复循环一组值，可用它循环数据集标识符对数据集进行分组。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">cycle(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; A B C A B C A B C ...</span></div>
</div>
<h3>repeat：重复迭代器</h3>
<p><code>repeat(<em>elem</em>, <em>n</em>=None)</code> 用于重复单个值，不过也可以通过第二个参数将其限制为有限的迭代器。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">repeat(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 10 10 10</span></div>
</div>
<h2>有限迭代器</h2>
<p>有限迭代器更多，也更常用。它们具体的长度一般取决于给定序列的长度或特征。</p>
<h3>accumulate：归约迭代器</h3>
<p><code>accumulate()</code> 函数基于给定的函数返回一个可迭代对象，将一系列归约值汇总在一起，遍历迭代器得出当前汇总值。以下给出了一个这样的示例：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">accumulate([</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 1 3 6 10 15</span></div>
</div>
<p><code>accumulate()</code> 函数的第二个参数 <code>func</code> 的默认行为是加法，也可以改成其它的归约函数。</p>
<h3>chain：组合迭代器</h3>
<p><code>chain()</code> 函数将多个迭代器组合为单个迭代器，可以用于一次处理多个集合。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">chain(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">), </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">20</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">)) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 0 1 2 3 4 10 12 14 16 18</span></div>
</div>
<p>如果多个迭代器被放在一个可迭代对象内，那么还可以使用 chain.from_iterable() 类方法取代以上这种可变参数的形式。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">chain.from_iterable([</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">DEF</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; A B C D E F</span></div>
</div>
<h3>groupby：分组迭代器</h3>
<p><code>groupby(<em>iterable</em>, <em>key</em>=None)</code> 通过对每个元素应用 <code><em>key</em></code> 函数求值，并根据求值结果将一个迭代器切分为多个小迭代器，具体的规则为：如果后一个元素的 key 返回值等于前一个元素的 key 返回值，会将这两个元素放在同一个分组中；如果与前一个元素的 key 值不同，则当前分组结束，将当前元素放到新的分组中。</p>
<p>该生成器每一次迭代的结果都是一个 <code>(key, group)</code> 形式的元组，其中第二个元素是生成器。</p>
<p>以下是一个简单的示例，将一个排序好的列表按十位分组：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> random </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> randint</span></div>
<div><span style="color: #405c79;">target = </span><span style="color: #8b56bf;">filter</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">_</span><span style="color: #405c79;">: randint(</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">), </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">50</span><span style="color: #405c79;">))</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in groupby(target, </span><span style="color: #bf8b56;">key</span><span style="color: #405c79;">=</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x // </span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(i[</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">], </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">(i[</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]))</span></div>
</div>
<p>结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
0 [2, 4, 6]<br />
1 [10, 11, 13, 16, 19]<br />
2 [23, 26, 27, 29]<br />
3 [30, 31, 32, 35, 37, 38]<br />
4 [40, 41, 46, 47, 48]</div>
<p>因此，<code>groupby()</code> 函数的输入列表必须是排序好的，以确保分在一组中的元素是相邻的。</p>
<h3>compress：选择迭代器</h3>
<p>内置的 <code>filter()</code> 根据函数求值结果为真或假决定是否保留元素，而 <code>compress(<em>data</em>, <em>selectors</em>)</code> 则根据 <code><em>selectors</em></code> 可迭代对象给出的布尔值决定是否保留同一位置处的元素。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">compress(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCDEF</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; A C E</span></div>
</div>
<h3>islice：切片迭代器</h3>
<p><code>islice(<em>iterable</em>, <em>start</em>=0, <em>stop</em>, <em>step</em>=1)</code> 函数可以对迭代器实现切片操作，就像 <code>slice</code> 类对序列实现切片操作一样。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">islice(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCDEFG</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># =&gt; C D E F G</span></div>
<div><span style="color: #405c79;">islice(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCDEFG</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">None</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; B D F</span></div>
</div>
<h3>dropwhile和takewhile：过滤状态迭代器</h3>
<p><code>dropwhile(<em>predicate</em>, <em>iterable</em>)</code> 和 <code>takewhile(<em>predicate</em>, <em>iterable</em>)</code> 都是过滤函数，其用法是：从 <code><em>predicate</em></code> 函数给定的一种布尔模式开始，当布尔状态变换后，则函数的过滤规则也发生变化。<code>dropwhile()</code> 函数开始采用拒绝模式，当谓词函数变为 <code>False</code> 时切换并一直保持为通过模式。<code>takewhile()</code> 则从通过模式开始，当谓词函数变为 <code>False</code> 时切换并一直保持为拒绝模式。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">dropwhile(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x &lt; </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 6 4 1</span></div>
<div><span style="color: #405c79;">takewhile(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x &lt; </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 1 4</span></div>
</div>
<p>这两个函数的一种常见用法是过滤掉文件的头部和尾部的一些无用信息。例如，假设有如下附加了额外头部信息的 CSV 文件：</p>
<div class="vscode-block">
<div><span style="color: #24292e;">Author: Hello</span></div>
<div><span style="color: #24292e;">Date: 2022-05-31</span></div>
<div><span style="color: #24292e;">sepal_length,</span><span style="color: #d73a49;">sepal_width,</span><span style="color: #6f42c1;">petal_length,</span><span style="color: #a8a8a8;">petal_width,</span><span style="color: #032f62;">species</span></div>
<div><span style="color: #24292e;">5.1,</span><span style="color: #d73a49;">3.5,</span><span style="color: #6f42c1;">1.4,</span><span style="color: #a8a8a8;">0.2,</span><span style="color: #032f62;">Iris-setosa</span></div>
<div><span style="color: #24292e;">4.9,</span><span style="color: #d73a49;">3.0,</span><span style="color: #6f42c1;">1.4,</span><span style="color: #a8a8a8;">0.2,</span><span style="color: #032f62;">Iris-setosa</span></div>
<div><span style="color: #24292e;">6.4,</span><span style="color: #d73a49;">3.2,</span><span style="color: #6f42c1;">4.5,</span><span style="color: #a8a8a8;">1.5,</span><span style="color: #032f62;">Iris-versicolor</span></div>
<div><span style="color: #24292e;">6.9,</span><span style="color: #d73a49;">3.1,</span><span style="color: #6f42c1;">4.9,</span><span style="color: #a8a8a8;">1.5,</span><span style="color: #032f62;">Iris-versicolor</span></div>
</div>
<p>那么可以使用如下方式处理它：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">open</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">header.csv</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">r</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> f:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; data = dropwhile(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">row</span><span style="color: #405c79;">: </span><span style="color: #bf568b;font-weight: bold;">not</span><span style="color: #405c79;"> row[</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">].isdigit(), f)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">row</span><span style="color: #405c79;">: row.replace(</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\n</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">''</span><span style="color: #405c79;">).split(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">,</span><span style="color: #405c79;">'</span><span style="color: #405c79;">), data):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(i)</span></div>
</div>
<p>该程序检查 CSV 文件的每一行（注意文件对象也是可迭代对象，每次迭代结果为文件中的一行），判断每一行的首字符是不是数字，并将头部非数字开头的行丢弃。其结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
['5.1', '3.5', '1.4', '0.2', 'Iris-setosa']<br />
['4.9', '3.0', '1.4', '0.2', 'Iris-setosa']<br />
['6.4', '3.2', '4.5', '1.5', 'Iris-versicolor']<br />
['6.9', '3.1', '4.9', '1.5', 'Iris-versicolor']</div>
<h2>改进的迭代器</h2>
<p>以下迭代器是对内置迭代器的补充或改进。</p>
<h3>zip_longest：不截短的zip</h3>
<p>在<a href="/archives/239">第 4 节</a>介绍了 <code>zip()</code> 迭代器，它接收多个序列，返回结果的长度是其中最短序列的长度。而 <code>zip_longest(*<em>iterables</em>, <em>fillvalue</em>=None)</code> 则为较短的序列填充 <code><em>fillvalue</em></code> 参数提供的默认值，直到遍历完最长的序列。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">zip_longest(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCD</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">xy</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">fillvalue</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">*</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; Ax By C* D*</span></div>
</div>
<h3>filterfalse：filter的反相过滤</h3>
<p>内置的 <code>filter()</code> 迭代器会保留所有求值结果为 <code>True</code> 的数据；而 <code>filterfalse()</code> 则与之相反，它会保留所有求值结果为 <code>False</code> 的数据。</p>
<div class="vscode-block">
<div><span style="color: #8b56bf;">filter</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x % </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">)) &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># =&gt; 1 3 5 7 9</span></div>
<div><span style="color: #405c79;">filterfalse(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x % </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">)) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 0 2 4 6 8</span></div>
</div>
<p>通过组合这两个迭代器，可以方便地将输入数据分为“保留”和“舍弃”两组。</p>
<h3>starmap：平铺的map</h3>
<p>内置的 <code>map()</code> 迭代器可以接收多个可迭代对象，它将每一个可迭代对象中的元素组合为所需的参数；而 <code>starmap()</code> 迭代器只接收一个可迭代对象，它将其中元素展开后变成所需的参数。以下给出了一个这样的示例：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">starmap(</span><span style="color: #8b56bf;">pow</span><span style="color: #405c79;">, [(</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">,</span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">), (</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">,</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">), (</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">,</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">)]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 32 9 1000</span></div>
</div>
<p>因此，使用 <code>zip()</code> 迭代器可以非常简单地将 <code>map()</code> 变成 <code>starmap()</code> ：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">starmap</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">function</span><span style="color: #405c79;">, *</span><span style="color: #bf8b56;">iterables</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(function, </span><span style="color: #8b56bf;">zip</span><span style="color: #405c79;">(iterables))</span></div>
</div>
<h3>tee：克隆迭代器</h3>
<p><code>tee(<em>iterable</em>, <em>n</em>=2)</code> 函数可以突破<mark>迭代器只能使用一次</mark>的限制，将可迭代对象拷贝 <code><em>n</em></code> 份，并将拷贝结果以元组的形式返回。</p>
<p>不过该函数在使用时有一些限制：它的实现实际上有将迭代器转化为序列的过程，因此在处理大型数据集且拷贝次数较少时的效果往往不佳。</p>
<h2>组合迭代器</h2>
<p>接下来的迭代器与排列组合有关，因此它们往往需要输入多个序列。</p>
<h3>product：笛卡儿积</h3>
<p><code>product(*<em>iterables</em>, <em>repeat</em>=1)</code> 用于得到笛卡儿积，即基于一组集合生成所有可能的元素组合。<code><em>repeat</em></code> 参数可以将提供的集合重复若干次参与组合。例如：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">product(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">), </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">)) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 00 01 02 10 11 12 20 21 22</span></div>
<div><span style="color: #405c79;">product(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">AB</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">repeat</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AA AB BA BB</span></div>
</div>
<p>该函数的作用结果类似嵌套的 <code>for</code> 循环。以下再次给出了一个示例：</p>
<div class="codeblock code-console">&gt;&gt;&gt; from random import choice<br />
&gt;&gt;&gt; cards = list(product(range(1, 14), '<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" />'))<br />
&gt;&gt;&gt; choice(cards)<br />
(2, '<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />')<br />
&gt;&gt;&gt; choice(cards)<br />
(9, '<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />')</div>
<h3>排列组合相关迭代器</h3>
<p><code>permutations(<em>iterable</em>, <em>r</em>=None)</code> 函数会排列集合中所有元素；如果给出参数 <code><em>r</em></code> ，则它会限制参与排列元素的个数，例如：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">permutations(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">)) &nbsp; </span><span style="color: #a8a8a8;"># =&gt; 012 021 102 120 201 210</span></div>
<div><span style="color: #405c79;">permutations(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCD</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AB AC AD BA BC BD CA CB CD DA DB DC</span></div>
</div>
<p>由于 <span class="math">\\( n \\)</span> 个元素的排列结果有 <span class="math">\\( P_n^r = \frac{n!}{(n-r)!} \\)</span> 个，因此随着元素个数的上升，排列结果的长度急剧上升。</p>
<p>与之类似的函数是 <code>combinations(<em>iterable</em>, <em>r</em>)</code> ，它会以忽略顺序的形式组合集合中所有元素。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">combinations(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCD</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AB AC AD BC BD CD</span></div>
<div><span style="color: #405c79;">combinations(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">), </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 012 013 023 123</span></div>
</div>
<p>还有一个类似的迭代器 <code>combinations_with_replacement(<em>iterable</em>, <em>r</em>)</code> ，其区别是该迭代器在组合时允许元素重复：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">combinations(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># =&gt; AB AC BC</span></div>
<div><span style="color: #405c79;">combinations_with_replacement(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AA AB AC BB BC CC</span></div>
</div>
<p>这些迭代器通常用于处理排列组合相关的数学问题中。</p>
<p>使用这些迭代器可以代替许多算法中出现的简单循环，并使执行过程更高效。<code>itertools</code> 模块中还给出了更多范例，将基本的迭代器组合成更高级、有用的迭代器，可以高效地处理复杂的数据，参见 <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes">https://docs.python.org/3/library/itertools.html#itertools-recipes</a> 。</p>
<h2>参考资料</h2>
<p><a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a></p>
<p><code>itertools</code> 模块的官方文档。本文中的许多示例代码都来自该文档中。</p>
<p>文章中使用到的 CSV 数据来自 kaggle 。</p>
<p><!-- finished(all):2022-05-31 --></p>
<p><a rel="nofollow" href="/archives/270">Python函数式编程08 itertools模块：更多迭代器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/270/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python标准库time：处理时间</title>
		<link>/archives/168</link>
					<comments>/archives/168#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 23 Mar 2022 05:06:00 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Python标准库]]></category>
		<category><![CDATA[日期时间]]></category>
		<guid isPermaLink="false">/?p=168</guid>

					<description><![CDATA[<p>time，顾名思义，是用来处理时间的一个标准库。该库&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/168">Python标准库time：处理时间</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p><code class="traditional">time</code>，顾名思义，是用来处理时间的一个标准库。该库主要由C语言的标准库 <code class="traditional">time.h</code>&nbsp;封装而成，因此部分函数的命名可读性一般，整体设计思路也不够面向对象。</p>



<p>此外，Python与时间、日期相关的标准库有若干个，它们的功能可能有一定交集，但是侧重点不同：</p>



<ul><li><code class="traditional">time</code>库：主要用于处理时间相关的事务，但是功能比较基础</li><li><code class="traditional">datetime</code>库：是 <code class="traditional">time</code> 库的封装版本，具有更现代化的处理方式</li><li><code class="traditional">calendar</code>库：主要用于得到日历</li><li><code class="traditional">zoneinfo</code>库：主要用于处理时区</li></ul>



<p>时间并不只是日历，为了明白该库的一些用法，不仅需要对地理概念上的时间有所了解，还需要对计算机概念中的时间有所认识。</p>



<p>以下简单介绍一些关于时间的概念：</p>



<ul><li>格林尼治平均时间(Greenwich Mean Time, GMT)</li></ul>



<p>由于全地球每个地方的时间都并不相同，某地处于“早上8时”时，大洋彼岸却并不是“早上8时”，这可能会在交流时引起一定混乱。因此全地球需要一个标准，当人们需要表达明确的时间时，将当地的时间翻译成标准时间以供参照。</p>



<p>这个标准就是<span style="text-decoration: underline;">格林尼治平均时间</span> GMT 。它以位于英国伦敦的格林尼治天文台所处的以太阳参照的时间为标准，所谓“平均”指的是消除由于公转引起的太阳升降的差别，而造成每天长度都不完全一致的影响。</p>



<ul><li>协调世界时(Coordinated Universal Time, UTC)</li></ul>



<p>协调世界时由格林尼治平均时间发展而来，是最主要的世界时间标准。它与格林尼治平均时间的区别在于使用原子钟确定精确的秒数，这样报时更准确，因此被许多标准用作标准时间。</p>



<p>其缩写UTC并不完全对应原英文，原因是法文缩写和英文缩写都包含U、T、C三个字母，最后标准采用中庸的方式，决定都不按照这两种语言的缩写排列。</p>



<ul><li>Unix计时元年(Unix Epoch)</li></ul>



<p>Unix计时元年是目前大多数计算机和编程语言确定时间原点的一种方式。由于Unix操作系统诞生自1970年，因此该操作系统将时间的原点确定在 1970-01-01 00:00:00(UTC)。目前计算机要处理的大部分时间都发生在这之后，因此可以将该时间点作为坐标原点，以时间的流逝方向作为正向，确定一个计算时间的坐标轴。</p>



<ul><li>Unix时间(Unix Time)，或Unix时间戳(Unix Timestamp)</li></ul>



<p>这是计算机表示当前时间的一种方式，它表示从Unix计时元年到现在所经过的秒数。例如，在编写这篇文章时，当前的Unix时间戳是 1646380540 。时间戳可以非常方便地标识某一个具体的时间，并对比两个时间点的先后顺序。</p>



<p><code class="traditional">gmtime()</code>&nbsp;是一个转换计算机时间戳到标准UTC时间的函数。例如，可以通过 <code class="traditional">gmtime(0)</code>&nbsp;来检查当前计算机的时间原点：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> time</span></div><div><span style="color: #405c79;">&gt;&gt;&gt; time.gmtime(</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">)</span></div><div><span style="color: #405c79;">time.struct_time(</span><span style="color: #bf8b56;">tm_year</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">1970</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_mon</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_mday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_hour</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_min</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_sec</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_wday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_yday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_isdst</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">)</span></div></div>



<p>结果表示，当前计算机使用Unix时间来表示时间。</p>



<h2 class="wp-block-heading" id="结构化时间对象">结构化时间对象</h2>



<p>以上函数得到的结果是一个表示时间的结构化对象，它的用法和 <code class="traditional">namedtuple</code>&nbsp;类似，该类包含以下属性：</p>



<figure class="wp-block-table"><table><tbody><tr><td>索引</td><td>属性名</td><td>描述</td><td>索引</td><td>属性名</td><td>描述</td></tr><tr><td>0</td><td><code class="traditional">tm_year</code></td><td>对应的四位数年</td><td>5</td><td><code class="traditional">tm_sec</code></td><td>对应的秒钟</td></tr><tr><td>1</td><td><code class="traditional">tm_mon</code></td><td>对应的月</td><td>6</td><td><code class="traditional">tm_wday</code></td><td>对应的星期，星期一记为0</td></tr><tr><td>2</td><td><code class="traditional">tm_mday</code></td><td>对应的日</td><td>7</td><td><code class="traditional">tm_yday</code></td><td>这是一年中的第几天</td></tr><tr><td>3</td><td><code class="traditional">tm_hour</code></td><td>对应的小时，从0到23</td><td>8</td><td><code class="traditional">tm_isdst</code></td><td>是否使用夏令时，0是1否-1不确定</td></tr><tr><td>4</td><td><code class="traditional">tm_min</code></td><td>对应的分钟</td><td></td><td></td><td></td></tr></tbody></table></figure>



<blockquote class="wp-block-quote"><p>关于夏令时</p><cite>所谓夏令时，也称<span style="text-decoration: underline;">日光节约时间</span>(daylight saving time)，是一种在夏季将时间调快一小时，以符合人们作息规律的一种时间。目前仅有部分地区采用这种报时方式。</cite></blockquote>



<p>可以通过访问以上结构的某些成员，来获取其中的信息：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; epoch = time.gmtime(</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">)</span></div><div><span style="color: #405c79;">&gt;&gt;&gt; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'Unix timestamp since </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">epoch.tm_year</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">-</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">epoch.tm_mon</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">-</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">epoch.tm_mday</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">epoch.tm_hour</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">:</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">epoch.tm_min</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">:</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">epoch.tm_sec</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> UTC'</span><span style="color: #405c79;">)</span></div><div><span style="color: #405c79;">Unix timestamp since </span><span style="color: #bf8b56;">1970</span><span style="color: #405c79;">-</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">-</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">:</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">:</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">UTC</span></div></div>



<p>这样就可以创建需要的日期格式。</p>



<hr class="wp-block-separator"/>



<p>注意，由于 <code class="traditional">struct_time</code>&nbsp;是一种类似元组的类型，因此它的每个元素都是只读的。在作为参数时，也可以使用包含 9&nbsp;个元素的元组代替&nbsp;<code class="traditional">struct_time</code>&nbsp;类型。</p>



<p>如果省略参数，那么 <code class="traditional">gmtime()</code>&nbsp;会返回当前的&nbsp;UTC&nbsp;时间。也可以使用 <code class="traditional">localtime()</code> ，该函数的用法和&nbsp;<code class="traditional">gmtime()</code>&nbsp;类似，不过得到的是表示本地时区时间的结构化时间对象：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.gmtime()</span></div><div><span style="color: #405c79;">time.struct_time(</span><span style="color: #bf8b56;">tm_year</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">2022</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_mon</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_mday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">22</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_hour</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_min</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">39</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_sec</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">32</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_wday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_yday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">81</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_isdst</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">)</span></div><div><span style="color: #405c79;">&gt;&gt;&gt; time.localtime()</span></div><div><span style="color: #405c79;">time.struct_time(</span><span style="color: #bf8b56;">tm_year</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">2022</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_mon</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_mday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">22</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_hour</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">13</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_min</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">39</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_sec</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">34</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_wday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_yday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">81</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_isdst</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">)</span></div></div>



<p><code class="traditional">localtime()</code>&nbsp;函数，为获取本地时间提供了一个合适的方式。</p>



<p>如果认为 <code class="traditional">localtime()</code>&nbsp;得到的结构化时间对象不够易读，可以使用 <code class="traditional">asctime()</code>&nbsp;函数将其转换为一个简单的表示时间的字符串描述：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.asctime(time.localtime())</span></div><div><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Tue Mar 22 13:53:59 2022</span><span style="color: #405c79;">'</span></div></div>



<p>实际上，<code class="traditional">asctime()</code>&nbsp;函数在省略参数的情况下默认得到的就是对当前的本地时间描述：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.asctime(time.localtime()) == time.asctime()</span></div><div><span style="color: #bf8b56;">True</span></div></div>



<h2 class="wp-block-heading" id="时间戳的用法">时间戳的用法</h2>



<p><code class="traditional">time()</code>&nbsp;是一个基本的函数，它用来获取当前（或者说语句执行时）的时间戳：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.time()</span></div><div><span style="color: #bf8b56;">1646384946.4768329</span></div></div>



<p>这种方式得到的时间戳可以比秒更精确。</p>



<p>结构化时间对象可以使用&nbsp;<code class="traditional">asctime()</code>&nbsp;来获取字符串描述，而时间戳也有类似功能。<code class="traditional">ctime()</code>&nbsp;函数用于将时间戳转化为字符串描述：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.ctime(time.time())</span></div><div><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Tue Mar 22 14:07:57 2022</span><span style="color: #405c79;">'</span></div></div>



<p><code class="traditional">ctime()</code>&nbsp;函数也可以省略参数，同样默认得到对当前的本地时间描述：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.ctime() == time.ctime(time.time())</span></div><div><span style="color: #bf8b56;">True</span></div><div><span style="color: #405c79;">&gt;&gt;&gt; time.ctime() == time.asctime()</span></div><div><span style="color: #bf8b56;">True</span></div></div>



<hr class="wp-block-separator"/>



<p>既然有了结构化时间对象，为何要使用时间戳？首先，时间戳的优点在于，只需要对时间戳使用数值上的运算，就可以间接得到日期上的运算。</p>



<p>例如，可以通过加减运算来获取一定间隔前后的日期信息：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; day = </span><span style="color: #bf8b56;">3600</span><span style="color: #405c79;"> * </span><span style="color: #bf8b56;">24</span></div><div><span style="color: #405c79;">&gt;&gt;&gt; time.ctime(time.time() + </span><span style="color: #bf8b56;">30</span><span style="color: #405c79;"> * day) &nbsp;</span><span style="color: #a8a8a8;"># 30 days later</span></div><div><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Wed Apr 20 23:33:12 2022</span><span style="color: #405c79;">'</span></div></div>



<p>给当前时间戳加上 30&nbsp;天对应的秒数，就表示 30&nbsp;天后的时刻，然后便可以调用 <code class="traditional">ctime()</code>&nbsp;获取这一时刻的信息。</p>



<p>其次，时间戳可以方便地标识具体的时刻。基于此，只需要通过比较数值大小就可以得出两个时间的先后。</p>



<p>一种常见的需求是计算两个时间的差值，这种情况下只需要对两个时间戳相减即可。例如，以下实现了这样的一个装饰器，可以计算某个函数运行的时间：</p>



<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> time</span></div><br><div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">timeit</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">wrapper</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">args</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">kwargs</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; start = time.time()</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; func(*args, **kwargs)</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> time.time() - start</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> wrapper</span></div></div>



<p>通过以下函数测试它的效果：</p>



<div class="vscode-block"><div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">timeit</span></div><div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">test</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">start</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">length</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">10000</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; product = </span><span style="color: #bf8b56;">1</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(start, start + length):</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; product = product * start</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> product</span></div><br><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(test(</span><span style="color: #bf8b56;">start</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">30000</span><span style="color: #405c79;">))</span></div></div>



<p>结果为：</p>



<div class="code-console">
0.07980942726135254
</div>



<p>可以看到计时结果还是比较精确的。</p>



<hr class="wp-block-separator"/>



<p>时间戳和结构化时间对象是两种基本的时间表示方法。之前说过，可以使用 <code class="traditional">gmtime()</code>&nbsp;或&nbsp;<code class="traditional">localtime()</code>&nbsp;来将时间戳转换为结构化时间对象。<code class="traditional">mktime()</code>&nbsp;是 <code class="traditional">localtime()</code>&nbsp;的逆过程，它可以用一个表示本地时间的结构化时间对象生成时间戳：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.mktime((</span><span style="color: #bf8b56;">2022</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">22</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">14</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">57</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">40</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">81</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">))</span></div><div><span style="color: #bf8b56;">1647932260.0</span></div><div><span style="color: #405c79;">&gt;&gt;&gt; time.mktime(time.localtime())</span></div><div><span style="color: #bf8b56;">1647932333.0</span></div></div>



<p>以上使用元组的形式来表示结构化时间对象。</p>



<h2 class="wp-block-heading" id="处理时间格式">处理时间格式</h2>



<p><code class="traditional">asctime()</code>&nbsp;和 <code class="traditional">ctime()</code>&nbsp;得到的时间格式可能无法符合需求。此时，一个改善思路就是重新借用 <code class="traditional">localtime()</code>&nbsp;返回的结构化时间对象，重新编写一个函数利用它提供的信息得到格式化的字符串。</p>



<p><code class="traditional">time</code>&nbsp;库就提供了这样的一个函数 <code class="traditional">strftime(<em>format</em>, <em>t</em>=localtime())</code> 。它利用 <code class="traditional"><em>format</em></code> 参数提供的格式字符串，将一个结构化时间对象提供的信息填入其中。</p>



<p><code class="traditional"><em>format</em></code> 参数使用类似 Python2&nbsp;的百分号形式的格式化字符串。即，以一个百分号紧跟一个字符作为格式化的转换说明。这也是C语言标准的字符串格式方法。</p>



<p>以下给出了一个示例，将当前的时间格式化为另一种阅读习惯的方式：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.ctime()</span></div><div><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Tue Mar 22 15:15:26 2022</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">&gt;&gt;&gt; time.strftime(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">%Y </span><span style="color: #bf8b56;">%b</span><span style="color: #56bf8b;"> </span><span style="color: #bf8b56;">%d</span><span style="color: #56bf8b;"> </span><span style="color: #bf8b56;">%a</span><span style="color: #56bf8b;"> %H:%M:</span><span style="color: #bf8b56;">%d</span><span style="color: #405c79;">"</span><span style="color: #405c79;">)</span></div><div><span style="color: #405c79;">'</span><span style="color: #56bf8b;">2022 Mar 22 Tue 15:16:22</span><span style="color: #405c79;">'</span></div></div>



<p>下表列出了完整的转换说明符：</p>



<figure class="wp-block-table"><table><tbody><tr><td>符号</td><td>含义</td><td>符号</td><td>含义</td></tr><tr><td><code class="traditional">%a</code></td><td>星期几，英文缩写</td><td><code class="traditional">%p</code></td><td>现在是上午(AM)还是下午(PM)，使用本地化表述</td></tr><tr><td><code class="traditional">%A</code></td><td>星期几，英文全称</td><td><code class="traditional">%S</code></td><td>秒钟，取值为 [00, 61]</td></tr><tr><td><code class="traditional">%b</code></td><td>月份名，英文缩写</td><td><code class="traditional">%U</code></td><td>一年的第几周，取值为 [00, 53]</td></tr><tr><td><code class="traditional">%B</code></td><td>月份名，英文全称</td><td><code class="traditional">%w</code></td><td>星期几，序号表示，取值为 [0, 6] 。0 表示星期天</td></tr><tr><td><code class="traditional">%c</code></td><td>ctime() 等使用的本地化日期时间完整表示格式</td><td><code class="traditional">%W</code></td><td>类似 %U ，不过使用星期天而不是星期一来界定第0周的结束</td></tr><tr><td><code class="traditional">%d</code></td><td>日期，取值为 [01, 31]</td><td><code class="traditional">%x</code></td><td>本地化日期表示格式</td></tr><tr><td><code class="traditional">%H</code></td><td>24进制小时，取值为 [00, 23] </td><td><code class="traditional">%X</code></td><td>本地化时间表示格式</td></tr><tr><td><code class="traditional">%I</code></td><td>12进制小时，取值为 [01, 12]</td><td><code class="traditional">%y</code></td><td>两位数年份，取值为 [00, 99]</td></tr><tr><td><code class="traditional">%j</code></td><td>一年的第几天，取值为 [001, 366]</td><td><code class="traditional">%Y</code></td><td>四位数年份</td></tr><tr><td><code class="traditional">%m</code></td><td>月份，取值为 [01, 12]</td><td><code class="traditional">%z</code></td><td>本地时区与UTC的时间差，取值为 [-23:59, +23:59]</td></tr><tr><td><code class="traditional">%M</code></td><td>分钟，取值为 [00, 59]</td><td><code class="traditional">%%</code></td><td>表示一个百分号 %</td></tr></tbody></table></figure>



<p>利用转换说明，就可以自定义时间表示的格式。以下再次给出一个示例：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.strftime(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">Tomorrow is </span><span style="color: #bf8b56;">%m</span><span style="color: #56bf8b;">-</span><span style="color: #bf8b56;">%d</span><span style="color: #405c79;">"</span><span style="color: #405c79;">, time.localtime(time.time() + day))</span></div><div><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Tomorrow is 03-23</span><span style="color: #405c79;">'</span></div></div>



<p><code class="traditional">strptime(<em>string</em>, <em>format</em>="%a %b %d %H:%M:%S %Y")</code>&nbsp;与&nbsp;<code class="traditional">strftime()</code>&nbsp;函数的作用相反，它用于将一个已经格式化后的字符串，通过提供的格式反推得到结构化时间对象。例如：</p>



<div class="vscode-block"><div><span style="color: #405c79;">&gt;&gt;&gt; time.strptime(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">2020-03-22</span><span style="color: #405c79;">"</span><span style="color: #405c79;">, </span><span style="color: #405c79;">"</span><span style="color: #bf8b56;">%Y</span><span style="color: #56bf8b;">-</span><span style="color: #bf8b56;">%m</span><span style="color: #56bf8b;">-</span><span style="color: #bf8b56;">%d</span><span style="color: #405c79;">"</span><span style="color: #405c79;">)</span></div><div><span style="color: #405c79;">time.struct_time(</span><span style="color: #bf8b56;">tm_year</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">2020</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_mon</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_mday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">22</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_hour</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_min</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_sec</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_wday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_yday</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">82</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">tm_isdst</span><span style="color: #405c79;">=-</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">)</span></div></div>



<p>如果提供的信息不足，那么结构化时间对象里的元素将使用默认值。如果提供的字符串与格式字符串不匹配，那么会引发 <code class="error">ValueError</code>&nbsp;错误。</p>



<h2 class="wp-block-heading" id="其余内容">其余内容</h2>



<p>除了日期和时间相关的格式化外，<code class="traditional">time</code>&nbsp;库还提供了几个常用的与时间相关的功能。</p>



<p><code class="traditional">sleep(<em>secs</em>: float)</code>&nbsp;是一个常用的函数，它的功能是暂停当前的程序一段时间。它的效果就相当于进入一个空循环，直到达到了设定的时间为止。</p>



<div class="vscode-block"><div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">timeit</span></div><div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">delay</span><span style="color: #405c79;">():</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; time.sleep(</span><span style="color: #bf8b56;">3.14</span><span style="color: #405c79;">)</span></div><br><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(delay())</span></div></div>



<p>结果为：</p>



<div class="code-console">
3.1410584449768066
</div>



<p>当然暂停的时间不会那么精确。暂停过程可以被&nbsp;<code class="error">KeyboardInterrupt</code>&nbsp;中断。</p>



<hr class="wp-block-separator"/>



<p><code class="traditional">perf_counter()</code>&nbsp;是一个用于精确计时的函数。它并没有确定的计时零点，但是它确定的时间差值却非常精确。因此，上文编写的 <code class="traditional">timeit()</code>&nbsp;函数可以使用 <code class="traditional">perf_counter()</code>&nbsp;函数用于计时以获取更精确的结果。</p>



<p>下面给出了这样一个示例，使用 <code class="traditional">time()</code>&nbsp;函数无法捕捉到如此小的时间差：</p>



<div class="vscode-block"><div><span style="color: #405c79;">start = time.time()</span></div><div><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">1000</span><span style="color: #405c79;">))</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(time.time() - start)</span></div><br><div><span style="color: #405c79;">start = time.perf_counter()</span></div><div><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">1000</span><span style="color: #405c79;">))</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(time.perf_counter() - start)</span></div></div>



<p>结果为：</p>



<div class="code-console">
0.0<br>
4.190000000001137e-05
</div>



<p>除此之外，<code class="traditional">time</code> 库还包括一些其余的函数，包括获取纳秒级别的时间信息、操作Unix的系统时钟等。不过这些都不够常用，具体可以参阅Python官方文档。</p>



<p>最后，用一张图总结 <code class="traditional">time</code>&nbsp;库的内容：</p>



<figure class="wp-block-image size-full is-resized"><img decoding="async" src="/wp-content/uploads/2022/03/python-time.png" alt="" class="wp-image-176" width="417" height="249" srcset="/wp-content/uploads/2022/03/python-time.png 498w, /wp-content/uploads/2022/03/python-time-300x179.png 300w" sizes="(max-width: 417px) 100vw, 417px" /></figure>



<h2 class="wp-block-heading" id="参考资料">参考资料</h2>



<p><a href="https://en.wikipedia.org/wiki/Greenwich_Mean_Time">https://en.wikipedia.org/wiki/Greenwich_Mean_Time</a></p>



<p><a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">https://en.wikipedia.org/wiki/Coordinated_Universal_Time</a></p>



<p><a href="https://en.wikipedia.org/wiki/Leap_second">https://en.wikipedia.org/wiki/Leap_second</a></p>



<p><a href="https://en.wikipedia.org/wiki/Unix_time">https://en.wikipedia.org/wiki/Unix_time</a></p>



<p><a href="https://en.wikipedia.org/wiki/Daylight_saving_time">https://en.wikipedia.org/wiki/Daylight_saving_time</a></p>



<p>维基百科对一些概念的解释</p>



<p><a href="https://docs.python.org/3/library/time.html">https://docs.python.org/3/library/time.html</a></p>



<p>Python3文档——标准库 <code class="traditional">time</code></p>
<p><a rel="nofollow" href="/archives/168">Python标准库time：处理时间</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/168/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python标准库re：使用正则表达式</title>
		<link>/archives/144</link>
					<comments>/archives/144#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 21 Mar 2022 09:59:22 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Python标准库]]></category>
		<category><![CDATA[正则表达式]]></category>
		<guid isPermaLink="false">/?p=144</guid>

					<description><![CDATA[<p>关于正则表达式的预备知识，可以参见：正则表达式简单入&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/144">Python标准库re：使用正则表达式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>关于正则表达式的预备知识，可以参见：<a href="/archives/124" target="_blank" rel="noreferrer noopener">正则表达式简单入门</a></p>



<p>本文介绍正则表达式在Python中的应用，主要通过标准库 <code class="traditional">re</code> 提供的函数实现。</p>



<h2 class="wp-block-heading" id="使用-re-库的预备知识">使用 re 库的预备知识</h2>



<h3 class="wp-block-heading" id="字符转义问题">字符转义问题</h3>



<p>由于正则表达式使用反斜杠 <code class="traditional">\</code> 来转义字符，而 Python 也使用 <code class="traditional">\</code> 来转义字符。而在这种情况下，两者的转义可能发生冲突：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">expr01 = </span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\b</span><span style="color: #56bf8b;">on</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">expr02 = </span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\\</span><span style="color: #56bf8b;">bon</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">target_string = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">turn on</span><span style="color: #405c79;">'</span></div></div>



<p>由于 Python 会先将正则表达式编译成一个字符串，再利用 <code class="traditional">re</code> 库的正则表达式语法去匹配一个字符串如 <code class="traditional">target_string</code> ，所以 Python 的转义级别要高于正则表达式的。因此在本例中：</p>



<ol><li>Python 会先将表达式 <code class="traditional">expr01</code> 中的 <code class="traditional">"\b"</code> 转义成一个退格符，再将 <code class="traditional">"退格符on"</code> 作为一个正则表达式去匹配目标字符串，因此得到的结果是什么也匹配不到。</li><li>Python 会先将表达式 <code class="traditional">expr02</code> 中的 <code class="traditional">"\\"</code> 转义成反斜杠 <code class="traditional">"\"</code> ，再将 <code class="traditional">"\bon"</code> 作为一个正则表达式，而正则表达式又将 <code class="traditional">"\b"</code> 转义成单词的边界，即完整的表达式为 <code class="traditional">"单词的边界on"</code> 去匹配目标字符串，因此匹配的结果是 <code class="traditional">"on"</code></li></ol>



<p>在上例可以看出，Python 和正则表达式的转义混合会引起混乱。为了避免这种情况发生，强烈建议使用 Python 的原始字符串，它通过在字符串字面量加上 <code class="traditional">r</code> 前缀来表明原始字符， 该前缀会忽略 Python 的转义，从而可以准确地表达一个正则表达式。因此，上例可以写成：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">raw_expr = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\b</span><span style="color: #56bf8b;">on</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">target_string = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">turn on</span><span style="color: #405c79;">'</span></div></div>



<h3 class="wp-block-heading" id="常用参数">常用参数</h3>



<p>要用上正则表达式，应该要提供一个正则表达式和待匹配的文本。<code class="traditional">re</code> 库的函数通常都有以下三个常用的参数：<code class="traditional">pattern</code> 、<code class="traditional">string</code> 和 <code class="traditional">flag</code> ：</p>



<ul><li><code class="traditional">pattern</code> ：一个代表正则表达式的字符串，建议使用 r 不转义。</li><li><code class="traditional">string</code> ：需要匹配的字符串，如果字符串过长（如 HTML 源码），一般使用变量指向该字符串。</li><li><code class="traditional">flags</code> ：匹配模式。常见 <code class="traditional">flags</code> 的取值及含义如下：</li></ul>



<figure class="wp-block-table"><table><tbody><tr><td><code class="traditional">re.I<br>re.IGNORECAS</code></td><td>忽略大小写模式</td></tr><tr><td><code class="traditional">re.M<br>re.MULTILINE</code></td><td>多行模式，使 <code class="traditional">^</code> 和 <code class="traditional">$</code> 能够作用于每行的开始和结尾。该模式下便有了 <code class="traditional">^</code><code class="traditional"></code> 和 <code class="traditional">\A</code> 以及 <code class="traditional">$</code> 和 <code class="traditional">\Z</code> 的区别。</td></tr><tr><td><code class="traditional">re.S<br>re.DOTALL</code></td><td>单行模式，使 <code class="traditional">.</code> 所匹配的任意字符包含换行符</td></tr><tr><td><code class="traditional">re.X<br>re.VERBOSE</code></td><td>冗长模式，忽略空格，并允许用 <code class="traditional">#</code> 号添加注释</td></tr><tr><td><code class="traditional">re.A<br>re.ACSII</code></td><td>使用 ASCII 字符集中定义的 <code class="traditional">\w</code> 、<code class="traditional">\W</code> 、<code class="traditional">\b</code> 、<code class="traditional">\B</code> 、<code class="traditional">\s</code> 、<code class="traditional">\S</code> ，而不是默认的 Unicode 字符集。</td></tr><tr><td><code class="traditional">re.L<br>re.LOCALE</code></td><td>本地化模式，使用当前本地化语言字符集中定义的 <code class="traditional">\w</code> 、<code class="traditional">\W</code> 、<code class="traditional">\b</code> 、<code class="traditional">\B</code> 、<code class="traditional">\s</code> 、<code class="traditional">\S</code>（用于多语言操作系统）</td></tr><tr><td><code class="traditional">re.U<br>re.UNICODE</code></td><td>使用 Unicode 字符集中定义的 <code class="traditional">\w</code> 、<code class="traditional">\W</code> 、<code class="traditional">\b</code> 、<code class="traditional">\B</code> 、<code class="traditional">\s</code> 、<code class="traditional">\S</code> ，默认的情况</td></tr></tbody></table></figure>



<p>如果要同时设置多个匹配模式，使用按位或运算符 <code class="traditional">|</code> 号将其隔开。例如 <code class="traditional">flags=re.M|re.X</code> 。</p>



<h2 class="wp-block-heading" id="基本用法-匹配和搜索">基本用法：匹配和搜索</h2>



<h3 class="wp-block-heading" id="匹配">匹配</h3>



<p><code class="traditional">match(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数使用 <code class="traditional"><em>pattern</em></code> 传入的正则表达式按 <code class="traditional"><em>flags</em></code> 匹配模式，从字符串的起始位置逐一匹配字符串 <code class="traditional"><em>string</em></code> 。若匹配成功，返回一个 <code class="traditional">Match</code> 对象；若匹配不成功，返回一个空值 <code class="traditional">None</code> 。例如：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> re</span></div><br><div><span style="color: #405c79;">target01 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">010-123456</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">target02 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">010 123456</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">regex01 = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\d</span><span style="color: #405c79;">{3}</span><span style="color: #568bbf;">-\d</span><span style="color: #405c79;">{3,6}'</span></div><br><div><span style="color: #405c79;">result01 = re.match(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=regex01, </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target01)</span></div><div><span style="color: #405c79;">result02 = re.match(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=regex01, </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target02)</span></div><br><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result01)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result02)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
&lt;re.Match object; span=(0, 10), match='010-123456'&gt;<br>
None
</div>



<p>由于 Python 默认一个对象在条件判断时代表布尔值 <code class="traditional">True</code> ，而空值代表布尔值 <code class="traditional">False</code> ，为了防止匹配失败造成的影响，可以使用 <code class="traditional">if</code> 语句来判断 <code class="traditional">match()</code> 函数的匹配是否成功。</p>



<p>如果 <code class="traditional">match()</code> 函数匹配成功，它将返回一个 <code class="traditional">Match</code> 对象。对于这个 <code class="traditional">Match</code> 对象，可以使用一些方法来获取正则表达式匹配的信息。</p>



<p>当匹配的表达式中有用到圆括号 <code class="traditional">( )</code> 或 <code class="traditional">(?P&lt;name&gt;)</code> 进行分组时，可以使用  方法用来获取各组匹配到的字符串。括号内传入的参数为代表组序号的整数，或代表组名称的字符串（只需要名称就够了，不需要别的修饰符）。如果不传入参数或传入 <code class="traditional">0</code> ，则代表获取整个匹配结果。如果传入的值没有对应的组，会发生 <code class="error">IndexError</code> 错误。例如：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">target03 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">e is the base of the Natural Logarithms.</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">regex02 = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'(</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">*)</span><span style="color: #568bbf;"> is the </span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">?P&lt;what&gt;</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">*)</span><span style="color: #568bbf;">\.$</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">result03 = re.match(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=regex02,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target03)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result03.group())</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result03.group(</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">))</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result03.group(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">what</span><span style="color: #405c79;">'</span><span style="color: #405c79;">))</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
e is the base of the Natural Logarithms.<br>
e<br>
base of the Natural Logarithms<br>
</div>



<p>类似地，还可以使用 <code class="traditional">.groups()</code> 方法得到分组匹配到的字符串元组，或者通过 <code class="traditional">.groupdict()</code> 方法得到一个以自定义名称作为键、匹配结果作为值的字典。如果匹配的表达式中没有自定义名称的分组，后者返回一个空字典。</p>



<p>以下给出了这样一个示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">target04 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">www.python.org</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">regex03 = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'(</span><span style="color: #568bbf;">www</span><span style="color: #405c79;">)</span><span style="color: #568bbf;">\.</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">?P&lt;name&gt;</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">+)</span><span style="color: #568bbf;">\.</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">?P&lt;domain&gt;</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">+)'</span></div><div><span style="color: #405c79;">result04 = re.match(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=regex03,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target04)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result04.groups())</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result04.groupdict())</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
('www', 'python', 'org')<br>
{'name': 'python', 'domain': 'org'}
</div>



<p>该对象还有以下常用的方法：</p>



<ul><li><code class="traditional">.start(<em>group</em>)</code> ：返回对应组开始的匹配位置，整个字符串的开头位置为 0 向后类推。忽略 <em><code class="traditional">group</code> </em>参数相当于返回整个匹配结果的表达式的开头位置。由于 <code class="traditional">match()</code> 函数会从整个字符串的开头匹配，所以不带参数或者带参数 0 时会返回 0 。</li><li><code class="traditional">.end(<em>group</em>)</code> ：返回对应组结尾的匹配位置，整个字符串的开头位置为 0 向后类推。忽略 <em><code class="traditional">group</code> </em>参数相当于返回整个匹配结果的表达式的结尾位置。</li><li><code class="traditional">.span(<em>group</em>)</code> ：以元组的形式返回对应组的开头和结尾的匹配位置，相当于 <code class="traditional">(.start(<em>group</em>), .stop(<em>group</em>))</code></li></ul>



<p>它的一些属性可以反过来查找匹配时用到的信息：</p>



<ul><li><code class="traditional">re</code> ：匹配时使用的正则表达式对象</li><li><code class="traditional">string</code> ：待匹配的文本</li><li><code class="traditional">pos</code> ：正则表达式搜索文本的开始位置</li><li><code class="traditional">endpos</code> ：正则表达式搜索文本的结束位置</li><li><code class="traditional">lastindex</code> ：正则表达式最后的组序号</li><li><code class="traditional">lastgroup</code> ：正则表达式最后的组名</li></ul>



<hr class="wp-block-separator"/>



<p><code class="traditional">fullmatch(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数和 <code class="traditional">match()</code> 函数相似，只不过 <code class="traditional">fullmatch()</code> 函数用来检查正则表达式和目标字符串是否完全匹配，而不是部分匹配。</p>



<p>如果完全匹配，则 <code class="traditional">fullmatch()</code> 函数返回一个 <code class="traditional">Match</code> 对象，否则便返回空值。</p>



<p>其参数、<code class="traditional">Match</code> 对象的属性等都和 <code class="traditional">match()</code> 函数几乎一致。</p>



<p>但是有一个例外：在懒惰匹配模式下，如果其完整的匹配结果是原字符串，则 <code class="traditional">fullmatch()</code> 也能够成功匹配。这是由于懒惰匹配必须要先匹配完整的字符串，再回溯选取最少的结果。以下给出了一个简单的演示：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> re</span></div><div><span style="color: #405c79;">target05 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Python is ...</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">result05 = re.fullmatch(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">+'</span><span style="color: #405c79;">,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target05)</span></div><div><span style="color: #405c79;">result06 = re.fullmatch(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">{3,}?'</span><span style="color: #405c79;">,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target05)</span></div><div><span style="color: #405c79;">result07 = re.fullmatch(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">{3,6}'</span><span style="color: #405c79;">,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target05)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result05)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result06)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result07)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
&lt;_sre.SRE_Match object; span=(0, 13), match='Python is ...'&gt;<br>
&lt;_sre.SRE_Match object; span=(0, 13), match='Python is ...'&gt;<br>
None
</div>



<h3 class="wp-block-heading" id="搜索">搜索</h3>



<p>相比与匹配，搜索可能应用更多一些。<code class="traditional">search(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数也和 <code class="traditional">match()</code> 函数相似，该函数会检索整个字符串来寻找目标表达式的匹配对象。</p>



<p><code class="traditional">search()</code> 函数和 <code class="traditional">match()</code> 函数的区别在于配对位置。<code class="traditional">match()</code> 函数只会匹配字符串的开始，如果字符串的开始不符合正则表达式，便匹配失败。而 <code class="traditional">search()</code> 函数会检索整个字符串来判断里面是否有结果满足正则表达式，如果字符串的某一部分符合正则表达式，便匹配成功。</p>



<p>该函数也会得到一个 <code class="traditional">Match</code> 对象。</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">regex04 = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\b</span><span style="color: #405c79;">(?:</span><span style="color: #bf8b56;">[01]</span><span style="color: #568bbf;">\d</span><span style="color: #405c79;">|</span><span style="color: #568bbf;">2</span><span style="color: #bf8b56;">[0-3]</span><span style="color: #405c79;">)</span><span style="color: #568bbf;">:</span><span style="color: #bf8b56;">[0-5]</span><span style="color: #568bbf;">\d:</span><span style="color: #bf8b56;">[0-5]</span><span style="color: #568bbf;">\d\b</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">target06 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Now it</span><span style="color: #568bbf;">\'</span><span style="color: #56bf8b;">s 22:32:15.</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">result08 = re.search(regex04, target06)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result08)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
<_sre.SRE_Match object; span=(9, 17), match='22:32:15'>
</div>



<p>可以看到，得到的结果可以通过 <code class="traditional">.span()</code> 方法来得到匹配字符串的位置，或者通过 <code class="traditional">.group()</code> 方法得到完整的匹配字符串。</p>



<p>注意：<code class="traditional">search()</code> 函数虽然可以搜索整个字符串，但是它只会返回第一个匹配成功的结果，例如：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">result09 = re.search(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">ca.</span><span style="color: #405c79;">+?</span><span style="color: #568bbf;">\b</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">A cat catches a cap.</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result09)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
<_sre.SRE_Match object; span=(2, 5), match='cat'>
</div>



<p>尽管上例按照正则表达式的匹配方式来说，<code class="traditional">"cat"</code>、<code class="traditional">"catches"</code>、<code class="traditional">"cab"</code> 都可以成功匹配。</p>



<hr class="wp-block-separator"/>



<p>如果想到获取所有的匹配结果，可以使用 <code class="traditional">findall(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数。该函数可以在字符串中找到正则表达式所匹配的所有子串，并返回一个包含所有结果的列表。如果没有找到匹配的结果，则返回空列表；若 <code class="traditional"><em>pattern</em></code> 中包含组，则返回各组匹配结果的列表。</p>



<p>以下给出了这样一个示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">target07 = </span><span style="color: #405c79;">'''</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;link rel="stylesheet" href="/static/style.css"&gt;</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;link rel="stylesheet" href="/static/font.css"&gt;</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;script src="/static/jquery.js"&gt;&lt;/script&gt;</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;script src="/static/doctools.js"&gt;&lt;/script&gt;</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;script src="/static/locale.js"&gt;&lt;/script&gt;</span><span style="color: #405c79;">'''</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(re.findall(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">/static/</span><span style="color: #405c79;">(</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">+</span><span style="color: #568bbf;">\.js</span><span style="color: #405c79;">)'</span><span style="color: #405c79;">, target07))</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
['jquery.js', 'doctools.js', 'locale.js']
</div>



<p>对于以上这种每个正则表达式只包含一个分组时的情况，<code class="traditional">findall()</code> 返回的列表中的每个元素都是该唯一分组匹配到的字符串。如果包含两个或以上分组，那么每个分组匹配到的字符串就以元组的形式排开了。</p>



<p><code class="traditional">finditer(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数的作用与 <code class="traditional">f</code>findall() 函数类似。只不过当被匹配的对象很长（如一个大型网站的 HTML 源码），可能会匹配出非常多的结果。这个时候不希望直接返回一个很长的列表，便需要用到 <code class="traditional">finditer()</code> 函数返回一个生成器来存储匹配结果，其中每个迭代元素都是 <code class="traditional">Match</code> 对象。</p>



<p>以下给出了一个这样的示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> requests</span></div><div><span style="color: #405c79;">html = requests.get(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">https://www.python.org/</span><span style="color: #405c79;">'</span><span style="color: #405c79;">).text</span></div><div><span style="color: #405c79;">result = re.finditer(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">https://</span><span style="color: #bf8b56;">[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]</span><span style="color: #405c79;">+</span><span style="color: #bf8b56;">[-A-Za-z0-9+&amp;@#/%=~_|]</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, html)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">next</span><span style="color: #405c79;">(result))</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">next</span><span style="color: #405c79;">(result))</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
&lt;callable_iterator object at 0x018690D0&gt;<br>
&lt;re.Match object; span=(1303, 1368), match='https://media.ethicalads.io/media/client/v1.4.0/e&gt;<br>
&lt;re.Match object; span=(3759, 3815), match='https://www.python.org/static/opengraph-icon-200x&gt;
</div>



<h2 class="wp-block-heading" id="替换与分隔">替换与分隔</h2>



<h3 class="wp-block-heading" id="替换">替换</h3>



<p>正则表达式可以用来替换字符串中不符合要求的部分。使用 <code class="traditional">sub(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count</em>=0, <em>flags</em>=0)</code> 函数可以实现该效果。以下是该函数的参数说明：</p>



<ul><li><code class="traditional">pattern</code> ：一个符合正则表达式的要替换字符串</li><li><code class="traditional">repl</code> ：用来替换的字符串，也可为一个函数</li><li><code class="traditional">string</code> ：被查找并替换的原始字符串</li><li><code class="traditional">count</code> ：模式匹配后从前向后替换的最大次数，默认为 0 ，表示替换所有的匹配</li><li><code class="traditional">flags</code> ：编译时用的匹配模式</li></ul>



<p>该函数返回替换后的结果。以下给出了这样一个示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">code_segment = </span><span style="color: #405c79;">'''</span><span style="color: #56bf8b;">/* hello world application */</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; int main(/* command line arguments */int argc, char* argv[]) {</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &nbsp; &nbsp; printf("Hello, world!"); /* print function */</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; } </span><span style="color: #405c79;">'''</span></div><div><span style="color: #405c79;">result = re.sub(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">/\*.</span><span style="color: #405c79;">*?</span><span style="color: #568bbf;">\*/</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">''</span><span style="color: #405c79;">, code_segment)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
 &nbsp; &nbsp;int main(int argc, char* argv[]) {<br>
 &nbsp; &nbsp; &nbsp; &nbsp;printf("Hello, world!");<br>
 &nbsp; &nbsp;}
</div>



<p>一种常见的需求就是对捕获到的结果做一些小改动，而不是完全替换为一个毫不相干的结果。这可以通过引用组实现。<code class="traditional"><em>repl</em></code> 参数内，可以通过 <code class="traditional">\g&lt;group&gt;</code> 的形式引用一个分组的匹配结果。</p>



<p>以下给出了这样的一个示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">name_list = </span><span style="color: #405c79;">'''</span><span style="color: #56bf8b;"> name: John ... name: Smith ....</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; name: Peter .. name: James ...</span><span style="color: #405c79;">'''</span></div><div><span style="color: #405c79;">result = re.sub(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">name: </span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">?P&lt;name&gt;</span><span style="color: #568bbf;">\w</span><span style="color: #405c79;">+)'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">\g&lt;name&gt;@example.mail</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, name_list)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
 John@example.com ... Smith@example.com ....<br>
 &nbsp; &nbsp;Peter@example.com .. James@example.com ...
</div>



<p><code class="traditional"><em>repl</em></code> 参数有一种特殊情况就是它为一个函数对象。这时这个函数需要有且仅有这样一个参数，代表匹配结果的 <code class="traditional">Match</code> 对象。因此可以将需要将要替换的字符分组，再用 <code class="traditional">Match</code> 对象的 <code class="traditional">.group()</code> 方法取出需要替换的字符串的组，并在函数内部进行运算。例如：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> random </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> choice</span></div><div><span style="color: #405c79;">cards = [a + b </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> a in </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" /></span><span style="color: #405c79;">'</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> b in </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">A23456789JQK</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]</span></div><div><span style="color: #405c79;">this_round = </span><span style="color: #405c79;">'''</span><span style="color: #56bf8b;">... got <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" />6 . <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />4 and <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" />K ... <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />9 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />5 .. <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />A <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" />4</span><span style="color: #405c79;">'''</span></div><div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">get_random_card</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">before</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; after = choice(cards)</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> after != before.group():</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> after</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> get_random_card(before)</span></div><div><span style="color: #405c79;">result = re.sub(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'(</span><span style="color: #bf8b56;">[<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />][A2-9JQK]</span><span style="color: #405c79;">)'</span><span style="color: #405c79;">, get_random_card, this_round)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
... got <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" />3 . <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />2 and <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />9 ... <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" />7 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" />5 .. <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />5 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" />6
</div>



<p>这种使用函数来处理如何完成替换的方式非常灵活。</p>



<hr class="wp-block-separator"/>



<p><code class="traditional">subn(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count</em>=0, <em>flags</em>=0)</code> 函数和 <code class="traditional">sub()</code> 函数功能类似，唯一不同的是 <code class="traditional">subn()</code> 函数的返回结果是一个包含 <code class="traditional">(result, count)</code> 的元组，即可以同时获取正则替换的完整结果与替换次数。</p>



<h3 class="wp-block-heading" id="分割">分割</h3>



<p>Python 内置了一个 <code class="traditional">.split()</code> 方法，可以用来分割字符串：</p>



<div class="code-console">
&gt;&gt;&gt; data = '0.2682, 0.1266, 0.0942, 0.5178, 0.9459'<br>
&gt;&gt;&gt; data.split(', ')<br>
['0.2682', '0.1266', '0.0942', '0.5178', '0.9459']
</div>



<p>但是该方法有一个缺点，那就是对于复杂情况下的分割效果不够理想：</p>



<div class="code-console">
&gt;&gt;&gt; row_data = '0.2682 0.1266   0.0942  0.5178    0.9459'<br>
&gt;&gt;&gt; row_data.split(' ')<br>
['0.2682', '0.1266', '', '', '0.0942', '', '0.5178', '', '', '', '0.9459']
</div>



<p>上例中，<code class="traditional"><code class="traditional">.split()</code></code> 方法无法识别出多个空格，导致多个空格的分割出现了未达到预期的效果。</p>



<p>这个时候，便可以使用 <code class="traditional">re</code> 库中的分割函数 <code class="traditional">split(<em>pattern</em>, <em>string</em>, <em>maxsplit</em>=0, <em>flags</em>=0)</code> ，该函数的效果是将 <code class="traditional"><em>pattern</em></code> 代表的正则表达式为分割标识，将 <code class="traditional"><em>string</em></code> 位于分割标识两侧的字符串拆分成列表。通俗地说，就是相比内置的 <code class="traditional">.split</code> 方法，该函数可以用正则表达式作为分割标识了。因此相比内置的 <code class="traditional">.split()</code> 方法，<code class="traditional">re</code> 库中的 <code class="traditional">split()</code> 函数分割更加的灵活。</p>



<p>例如，以上使用内置 <code class="traditional">.split()</code> 分割失败的情况，可以使用 <code class="traditional">split()</code> 函数这么处理：</p>



<div class="code-console">
&gt;&gt;&gt; from re import split<br>
&gt;&gt;&gt; split(r'\s+', row_data)<br>
['0.2682', '0.1266', '0.0942', '0.5178', '0.9459']
</div>



<p>可以看到正则表达式很完美地识别了多个空格并完成了拆分。</p>



<h2 class="wp-block-heading" id="其它内容">其它内容</h2>



<h3 class="wp-block-heading" id="正则表达式对象">正则表达式对象</h3>



<p>当在 Python 中使用正则表达式进行匹配时，<code class="traditional">re</code> 模块会执行两个步骤：</p>



<ol><li>将输入的正则表达式编译成一个正则表达式对象。如果正则表达式的字符串本身不合法，会产生 <code class="error">re.error</code> 错误。</li><li>用编译后的正则表达式去匹配字符串。</li></ol>



<p>因此当要进行匹配大量数据时，需要重复使用一个正则表达式几百上千次。此时，出于效率的考虑，可以先预编译该正则表达式为一个正则表达式对象，再利用正则表达式对象的方法去匹配字符串，这样便省略了步骤 1 ，很好地提升了效率。</p>



<p>使用 <code class="traditional">re.compile(pattern, flags=0)</code> 函数可以生成一个正则表达式对象：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> re</span></div><div><span style="color: #405c79;">pattern = re.compile(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">^\d</span><span style="color: #405c79;">{6}</span><span style="color: #568bbf;">$</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(pattern, </span><span style="color: #bf568b;">type</span><span style="color: #405c79;">(pattern))</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
re.compile('^\\d{6}$') &lt;class 're.Pattern'&gt;
</div>



<p>对于一个已经预编译完成的正则表达式对象，可以使用对象的一些方法来完成匹配。正则表达式对象方法有：</p>



<ul><li><code class="traditional">.match(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.fullmatch(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.search(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.finall(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.finditer(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.sub(<em>repl</em>, <em>string</em>, <em>count</em>)</code></li><li><code class="traditional">.subn(<em>repl</em>, <em>string</em>, <em>count</em>)</code></li><li><code class="traditional">.split(<em>string</em>, <em>maxsplit</em>)</code></li></ul>



<p>其中 <code class="traditional">pos</code> 和 <code class="traditional">endpos</code> 参数可以指定正则表达式的搜索位置。除此之外，这些方法与各自对应的函数的使用方法基本一致。</p>



<h2 class="wp-block-heading" id="附录">附录</h2>



<h3 class="wp-block-heading" id="参考资料">参考资料</h3>



<p><a href="https://docs.python.org/3/library/re.html">https://docs.python.org/3/library/re.html</a></p>



<p>Python3 re库官方文档</p>
<p><a rel="nofollow" href="/archives/144">Python标准库re：使用正则表达式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/144/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
