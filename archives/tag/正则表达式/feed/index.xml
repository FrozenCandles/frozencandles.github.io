<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>正则表达式归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/tag/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/feed?simply_static_page=3779" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Mon, 12 Dec 2022 12:23:27 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>正则表达式归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Python标准库re：使用正则表达式</title>
		<link>/archives/144</link>
					<comments>/archives/144#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 21 Mar 2022 09:59:22 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Python标准库]]></category>
		<category><![CDATA[正则表达式]]></category>
		<guid isPermaLink="false">/?p=144</guid>

					<description><![CDATA[<p>关于正则表达式的预备知识，可以参见：正则表达式简单入&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/144">Python标准库re：使用正则表达式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>关于正则表达式的预备知识，可以参见：<a href="/archives/124" target="_blank" rel="noreferrer noopener">正则表达式简单入门</a></p>



<p>本文介绍正则表达式在Python中的应用，主要通过标准库 <code class="traditional">re</code> 提供的函数实现。</p>



<h2 class="wp-block-heading" id="使用-re-库的预备知识">使用 re 库的预备知识</h2>



<h3 class="wp-block-heading" id="字符转义问题">字符转义问题</h3>



<p>由于正则表达式使用反斜杠 <code class="traditional">\</code> 来转义字符，而 Python 也使用 <code class="traditional">\</code> 来转义字符。而在这种情况下，两者的转义可能发生冲突：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">expr01 = </span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\b</span><span style="color: #56bf8b;">on</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">expr02 = </span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\\</span><span style="color: #56bf8b;">bon</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">target_string = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">turn on</span><span style="color: #405c79;">'</span></div></div>



<p>由于 Python 会先将正则表达式编译成一个字符串，再利用 <code class="traditional">re</code> 库的正则表达式语法去匹配一个字符串如 <code class="traditional">target_string</code> ，所以 Python 的转义级别要高于正则表达式的。因此在本例中：</p>



<ol><li>Python 会先将表达式 <code class="traditional">expr01</code> 中的 <code class="traditional">"\b"</code> 转义成一个退格符，再将 <code class="traditional">"退格符on"</code> 作为一个正则表达式去匹配目标字符串，因此得到的结果是什么也匹配不到。</li><li>Python 会先将表达式 <code class="traditional">expr02</code> 中的 <code class="traditional">"\\"</code> 转义成反斜杠 <code class="traditional">"\"</code> ，再将 <code class="traditional">"\bon"</code> 作为一个正则表达式，而正则表达式又将 <code class="traditional">"\b"</code> 转义成单词的边界，即完整的表达式为 <code class="traditional">"单词的边界on"</code> 去匹配目标字符串，因此匹配的结果是 <code class="traditional">"on"</code></li></ol>



<p>在上例可以看出，Python 和正则表达式的转义混合会引起混乱。为了避免这种情况发生，强烈建议使用 Python 的原始字符串，它通过在字符串字面量加上 <code class="traditional">r</code> 前缀来表明原始字符， 该前缀会忽略 Python 的转义，从而可以准确地表达一个正则表达式。因此，上例可以写成：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">raw_expr = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\b</span><span style="color: #56bf8b;">on</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">target_string = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">turn on</span><span style="color: #405c79;">'</span></div></div>



<h3 class="wp-block-heading" id="常用参数">常用参数</h3>



<p>要用上正则表达式，应该要提供一个正则表达式和待匹配的文本。<code class="traditional">re</code> 库的函数通常都有以下三个常用的参数：<code class="traditional">pattern</code> 、<code class="traditional">string</code> 和 <code class="traditional">flag</code> ：</p>



<ul><li><code class="traditional">pattern</code> ：一个代表正则表达式的字符串，建议使用 r 不转义。</li><li><code class="traditional">string</code> ：需要匹配的字符串，如果字符串过长（如 HTML 源码），一般使用变量指向该字符串。</li><li><code class="traditional">flags</code> ：匹配模式。常见 <code class="traditional">flags</code> 的取值及含义如下：</li></ul>



<figure class="wp-block-table"><table><tbody><tr><td><code class="traditional">re.I<br>re.IGNORECAS</code></td><td>忽略大小写模式</td></tr><tr><td><code class="traditional">re.M<br>re.MULTILINE</code></td><td>多行模式，使 <code class="traditional">^</code> 和 <code class="traditional">$</code> 能够作用于每行的开始和结尾。该模式下便有了 <code class="traditional">^</code><code class="traditional"></code> 和 <code class="traditional">\A</code> 以及 <code class="traditional">$</code> 和 <code class="traditional">\Z</code> 的区别。</td></tr><tr><td><code class="traditional">re.S<br>re.DOTALL</code></td><td>单行模式，使 <code class="traditional">.</code> 所匹配的任意字符包含换行符</td></tr><tr><td><code class="traditional">re.X<br>re.VERBOSE</code></td><td>冗长模式，忽略空格，并允许用 <code class="traditional">#</code> 号添加注释</td></tr><tr><td><code class="traditional">re.A<br>re.ACSII</code></td><td>使用 ASCII 字符集中定义的 <code class="traditional">\w</code> 、<code class="traditional">\W</code> 、<code class="traditional">\b</code> 、<code class="traditional">\B</code> 、<code class="traditional">\s</code> 、<code class="traditional">\S</code> ，而不是默认的 Unicode 字符集。</td></tr><tr><td><code class="traditional">re.L<br>re.LOCALE</code></td><td>本地化模式，使用当前本地化语言字符集中定义的 <code class="traditional">\w</code> 、<code class="traditional">\W</code> 、<code class="traditional">\b</code> 、<code class="traditional">\B</code> 、<code class="traditional">\s</code> 、<code class="traditional">\S</code>（用于多语言操作系统）</td></tr><tr><td><code class="traditional">re.U<br>re.UNICODE</code></td><td>使用 Unicode 字符集中定义的 <code class="traditional">\w</code> 、<code class="traditional">\W</code> 、<code class="traditional">\b</code> 、<code class="traditional">\B</code> 、<code class="traditional">\s</code> 、<code class="traditional">\S</code> ，默认的情况</td></tr></tbody></table></figure>



<p>如果要同时设置多个匹配模式，使用按位或运算符 <code class="traditional">|</code> 号将其隔开。例如 <code class="traditional">flags=re.M|re.X</code> 。</p>



<h2 class="wp-block-heading" id="基本用法-匹配和搜索">基本用法：匹配和搜索</h2>



<h3 class="wp-block-heading" id="匹配">匹配</h3>



<p><code class="traditional">match(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数使用 <code class="traditional"><em>pattern</em></code> 传入的正则表达式按 <code class="traditional"><em>flags</em></code> 匹配模式，从字符串的起始位置逐一匹配字符串 <code class="traditional"><em>string</em></code> 。若匹配成功，返回一个 <code class="traditional">Match</code> 对象；若匹配不成功，返回一个空值 <code class="traditional">None</code> 。例如：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> re</span></div><br><div><span style="color: #405c79;">target01 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">010-123456</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">target02 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">010 123456</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">regex01 = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\d</span><span style="color: #405c79;">{3}</span><span style="color: #568bbf;">-\d</span><span style="color: #405c79;">{3,6}'</span></div><br><div><span style="color: #405c79;">result01 = re.match(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=regex01, </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target01)</span></div><div><span style="color: #405c79;">result02 = re.match(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=regex01, </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target02)</span></div><br><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result01)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result02)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
&lt;re.Match object; span=(0, 10), match='010-123456'&gt;<br>
None
</div>



<p>由于 Python 默认一个对象在条件判断时代表布尔值 <code class="traditional">True</code> ，而空值代表布尔值 <code class="traditional">False</code> ，为了防止匹配失败造成的影响，可以使用 <code class="traditional">if</code> 语句来判断 <code class="traditional">match()</code> 函数的匹配是否成功。</p>



<p>如果 <code class="traditional">match()</code> 函数匹配成功，它将返回一个 <code class="traditional">Match</code> 对象。对于这个 <code class="traditional">Match</code> 对象，可以使用一些方法来获取正则表达式匹配的信息。</p>



<p>当匹配的表达式中有用到圆括号 <code class="traditional">( )</code> 或 <code class="traditional">(?P&lt;name&gt;)</code> 进行分组时，可以使用  方法用来获取各组匹配到的字符串。括号内传入的参数为代表组序号的整数，或代表组名称的字符串（只需要名称就够了，不需要别的修饰符）。如果不传入参数或传入 <code class="traditional">0</code> ，则代表获取整个匹配结果。如果传入的值没有对应的组，会发生 <code class="error">IndexError</code> 错误。例如：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">target03 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">e is the base of the Natural Logarithms.</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">regex02 = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'(</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">*)</span><span style="color: #568bbf;"> is the </span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">?P&lt;what&gt;</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">*)</span><span style="color: #568bbf;">\.$</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">result03 = re.match(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=regex02,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target03)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result03.group())</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result03.group(</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">))</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result03.group(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">what</span><span style="color: #405c79;">'</span><span style="color: #405c79;">))</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
e is the base of the Natural Logarithms.<br>
e<br>
base of the Natural Logarithms<br>
</div>



<p>类似地，还可以使用 <code class="traditional">.groups()</code> 方法得到分组匹配到的字符串元组，或者通过 <code class="traditional">.groupdict()</code> 方法得到一个以自定义名称作为键、匹配结果作为值的字典。如果匹配的表达式中没有自定义名称的分组，后者返回一个空字典。</p>



<p>以下给出了这样一个示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">target04 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">www.python.org</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">regex03 = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'(</span><span style="color: #568bbf;">www</span><span style="color: #405c79;">)</span><span style="color: #568bbf;">\.</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">?P&lt;name&gt;</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">+)</span><span style="color: #568bbf;">\.</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">?P&lt;domain&gt;</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">+)'</span></div><div><span style="color: #405c79;">result04 = re.match(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=regex03,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target04)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result04.groups())</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result04.groupdict())</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
('www', 'python', 'org')<br>
{'name': 'python', 'domain': 'org'}
</div>



<p>该对象还有以下常用的方法：</p>



<ul><li><code class="traditional">.start(<em>group</em>)</code> ：返回对应组开始的匹配位置，整个字符串的开头位置为 0 向后类推。忽略 <em><code class="traditional">group</code> </em>参数相当于返回整个匹配结果的表达式的开头位置。由于 <code class="traditional">match()</code> 函数会从整个字符串的开头匹配，所以不带参数或者带参数 0 时会返回 0 。</li><li><code class="traditional">.end(<em>group</em>)</code> ：返回对应组结尾的匹配位置，整个字符串的开头位置为 0 向后类推。忽略 <em><code class="traditional">group</code> </em>参数相当于返回整个匹配结果的表达式的结尾位置。</li><li><code class="traditional">.span(<em>group</em>)</code> ：以元组的形式返回对应组的开头和结尾的匹配位置，相当于 <code class="traditional">(.start(<em>group</em>), .stop(<em>group</em>))</code></li></ul>



<p>它的一些属性可以反过来查找匹配时用到的信息：</p>



<ul><li><code class="traditional">re</code> ：匹配时使用的正则表达式对象</li><li><code class="traditional">string</code> ：待匹配的文本</li><li><code class="traditional">pos</code> ：正则表达式搜索文本的开始位置</li><li><code class="traditional">endpos</code> ：正则表达式搜索文本的结束位置</li><li><code class="traditional">lastindex</code> ：正则表达式最后的组序号</li><li><code class="traditional">lastgroup</code> ：正则表达式最后的组名</li></ul>



<hr class="wp-block-separator"/>



<p><code class="traditional">fullmatch(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数和 <code class="traditional">match()</code> 函数相似，只不过 <code class="traditional">fullmatch()</code> 函数用来检查正则表达式和目标字符串是否完全匹配，而不是部分匹配。</p>



<p>如果完全匹配，则 <code class="traditional">fullmatch()</code> 函数返回一个 <code class="traditional">Match</code> 对象，否则便返回空值。</p>



<p>其参数、<code class="traditional">Match</code> 对象的属性等都和 <code class="traditional">match()</code> 函数几乎一致。</p>



<p>但是有一个例外：在懒惰匹配模式下，如果其完整的匹配结果是原字符串，则 <code class="traditional">fullmatch()</code> 也能够成功匹配。这是由于懒惰匹配必须要先匹配完整的字符串，再回溯选取最少的结果。以下给出了一个简单的演示：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> re</span></div><div><span style="color: #405c79;">target05 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Python is ...</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">result05 = re.fullmatch(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">+'</span><span style="color: #405c79;">,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target05)</span></div><div><span style="color: #405c79;">result06 = re.fullmatch(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">{3,}?'</span><span style="color: #405c79;">,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target05)</span></div><div><span style="color: #405c79;">result07 = re.fullmatch(</span><span style="color: #bf8b56;">pattern</span><span style="color: #405c79;">=</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">{3,6}'</span><span style="color: #405c79;">,</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">=target05)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result05)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result06)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result07)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
&lt;_sre.SRE_Match object; span=(0, 13), match='Python is ...'&gt;<br>
&lt;_sre.SRE_Match object; span=(0, 13), match='Python is ...'&gt;<br>
None
</div>



<h3 class="wp-block-heading" id="搜索">搜索</h3>



<p>相比与匹配，搜索可能应用更多一些。<code class="traditional">search(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数也和 <code class="traditional">match()</code> 函数相似，该函数会检索整个字符串来寻找目标表达式的匹配对象。</p>



<p><code class="traditional">search()</code> 函数和 <code class="traditional">match()</code> 函数的区别在于配对位置。<code class="traditional">match()</code> 函数只会匹配字符串的开始，如果字符串的开始不符合正则表达式，便匹配失败。而 <code class="traditional">search()</code> 函数会检索整个字符串来判断里面是否有结果满足正则表达式，如果字符串的某一部分符合正则表达式，便匹配成功。</p>



<p>该函数也会得到一个 <code class="traditional">Match</code> 对象。</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">regex04 = </span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\b</span><span style="color: #405c79;">(?:</span><span style="color: #bf8b56;">[01]</span><span style="color: #568bbf;">\d</span><span style="color: #405c79;">|</span><span style="color: #568bbf;">2</span><span style="color: #bf8b56;">[0-3]</span><span style="color: #405c79;">)</span><span style="color: #568bbf;">:</span><span style="color: #bf8b56;">[0-5]</span><span style="color: #568bbf;">\d:</span><span style="color: #bf8b56;">[0-5]</span><span style="color: #568bbf;">\d\b</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">target06 = </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">Now it</span><span style="color: #568bbf;">\'</span><span style="color: #56bf8b;">s 22:32:15.</span><span style="color: #405c79;">'</span></div><div><span style="color: #405c79;">result08 = re.search(regex04, target06)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result08)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
<_sre.SRE_Match object; span=(9, 17), match='22:32:15'>
</div>



<p>可以看到，得到的结果可以通过 <code class="traditional">.span()</code> 方法来得到匹配字符串的位置，或者通过 <code class="traditional">.group()</code> 方法得到完整的匹配字符串。</p>



<p>注意：<code class="traditional">search()</code> 函数虽然可以搜索整个字符串，但是它只会返回第一个匹配成功的结果，例如：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">result09 = re.search(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">ca.</span><span style="color: #405c79;">+?</span><span style="color: #568bbf;">\b</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">A cat catches a cap.</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result09)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
<_sre.SRE_Match object; span=(2, 5), match='cat'>
</div>



<p>尽管上例按照正则表达式的匹配方式来说，<code class="traditional">"cat"</code>、<code class="traditional">"catches"</code>、<code class="traditional">"cab"</code> 都可以成功匹配。</p>



<hr class="wp-block-separator"/>



<p>如果想到获取所有的匹配结果，可以使用 <code class="traditional">findall(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数。该函数可以在字符串中找到正则表达式所匹配的所有子串，并返回一个包含所有结果的列表。如果没有找到匹配的结果，则返回空列表；若 <code class="traditional"><em>pattern</em></code> 中包含组，则返回各组匹配结果的列表。</p>



<p>以下给出了这样一个示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">target07 = </span><span style="color: #405c79;">'''</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;link rel="stylesheet" href="/static/style.css"&gt;</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;link rel="stylesheet" href="/static/font.css"&gt;</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;script src="/static/jquery.js"&gt;&lt;/script&gt;</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;script src="/static/doctools.js"&gt;&lt;/script&gt;</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &lt;script src="/static/locale.js"&gt;&lt;/script&gt;</span><span style="color: #405c79;">'''</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(re.findall(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">/static/</span><span style="color: #405c79;">(</span><span style="color: #568bbf;">.</span><span style="color: #405c79;">+</span><span style="color: #568bbf;">\.js</span><span style="color: #405c79;">)'</span><span style="color: #405c79;">, target07))</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
['jquery.js', 'doctools.js', 'locale.js']
</div>



<p>对于以上这种每个正则表达式只包含一个分组时的情况，<code class="traditional">findall()</code> 返回的列表中的每个元素都是该唯一分组匹配到的字符串。如果包含两个或以上分组，那么每个分组匹配到的字符串就以元组的形式排开了。</p>



<p><code class="traditional">finditer(<em>pattern</em>, <em>string</em>, <em>flags</em>=0)</code> 函数的作用与 <code class="traditional">f</code>findall() 函数类似。只不过当被匹配的对象很长（如一个大型网站的 HTML 源码），可能会匹配出非常多的结果。这个时候不希望直接返回一个很长的列表，便需要用到 <code class="traditional">finditer()</code> 函数返回一个生成器来存储匹配结果，其中每个迭代元素都是 <code class="traditional">Match</code> 对象。</p>



<p>以下给出了一个这样的示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> requests</span></div><div><span style="color: #405c79;">html = requests.get(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">https://www.python.org/</span><span style="color: #405c79;">'</span><span style="color: #405c79;">).text</span></div><div><span style="color: #405c79;">result = re.finditer(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">https://</span><span style="color: #bf8b56;">[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]</span><span style="color: #405c79;">+</span><span style="color: #bf8b56;">[-A-Za-z0-9+&amp;@#/%=~_|]</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, html)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">next</span><span style="color: #405c79;">(result))</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">next</span><span style="color: #405c79;">(result))</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
&lt;callable_iterator object at 0x018690D0&gt;<br>
&lt;re.Match object; span=(1303, 1368), match='https://media.ethicalads.io/media/client/v1.4.0/e&gt;<br>
&lt;re.Match object; span=(3759, 3815), match='https://www.python.org/static/opengraph-icon-200x&gt;
</div>



<h2 class="wp-block-heading" id="替换与分隔">替换与分隔</h2>



<h3 class="wp-block-heading" id="替换">替换</h3>



<p>正则表达式可以用来替换字符串中不符合要求的部分。使用 <code class="traditional">sub(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count</em>=0, <em>flags</em>=0)</code> 函数可以实现该效果。以下是该函数的参数说明：</p>



<ul><li><code class="traditional">pattern</code> ：一个符合正则表达式的要替换字符串</li><li><code class="traditional">repl</code> ：用来替换的字符串，也可为一个函数</li><li><code class="traditional">string</code> ：被查找并替换的原始字符串</li><li><code class="traditional">count</code> ：模式匹配后从前向后替换的最大次数，默认为 0 ，表示替换所有的匹配</li><li><code class="traditional">flags</code> ：编译时用的匹配模式</li></ul>



<p>该函数返回替换后的结果。以下给出了这样一个示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">code_segment = </span><span style="color: #405c79;">'''</span><span style="color: #56bf8b;">/* hello world application */</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; int main(/* command line arguments */int argc, char* argv[]) {</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; &nbsp; &nbsp; printf("Hello, world!"); /* print function */</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; } </span><span style="color: #405c79;">'''</span></div><div><span style="color: #405c79;">result = re.sub(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">/\*.</span><span style="color: #405c79;">*?</span><span style="color: #568bbf;">\*/</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">''</span><span style="color: #405c79;">, code_segment)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
 &nbsp; &nbsp;int main(int argc, char* argv[]) {<br>
 &nbsp; &nbsp; &nbsp; &nbsp;printf("Hello, world!");<br>
 &nbsp; &nbsp;}
</div>



<p>一种常见的需求就是对捕获到的结果做一些小改动，而不是完全替换为一个毫不相干的结果。这可以通过引用组实现。<code class="traditional"><em>repl</em></code> 参数内，可以通过 <code class="traditional">\g&lt;group&gt;</code> 的形式引用一个分组的匹配结果。</p>



<p>以下给出了这样的一个示例：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #405c79;">name_list = </span><span style="color: #405c79;">'''</span><span style="color: #56bf8b;"> name: John ... name: Smith ....</span></div><div><span style="color: #56bf8b;">&nbsp; &nbsp; name: Peter .. name: James ...</span><span style="color: #405c79;">'''</span></div><div><span style="color: #405c79;">result = re.sub(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">name: </span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">?P&lt;name&gt;</span><span style="color: #568bbf;">\w</span><span style="color: #405c79;">+)'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">\g&lt;name&gt;@example.mail</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, name_list)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
 John@example.com ... Smith@example.com ....<br>
 &nbsp; &nbsp;Peter@example.com .. James@example.com ...
</div>



<p><code class="traditional"><em>repl</em></code> 参数有一种特殊情况就是它为一个函数对象。这时这个函数需要有且仅有这样一个参数，代表匹配结果的 <code class="traditional">Match</code> 对象。因此可以将需要将要替换的字符分组，再用 <code class="traditional">Match</code> 对象的 <code class="traditional">.group()</code> 方法取出需要替换的字符串的组，并在函数内部进行运算。例如：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> random </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> choice</span></div><div><span style="color: #405c79;">cards = [a + b </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> a in </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" /></span><span style="color: #405c79;">'</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> b in </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">A23456789JQK</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]</span></div><div><span style="color: #405c79;">this_round = </span><span style="color: #405c79;">'''</span><span style="color: #56bf8b;">... got <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" />6 . <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />4 and <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" />K ... <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />9 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />5 .. <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />A <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" />4</span><span style="color: #405c79;">'''</span></div><div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">get_random_card</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">before</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; after = choice(cards)</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> after != before.group():</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> after</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div><div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> get_random_card(before)</span></div><div><span style="color: #405c79;">result = re.sub(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'(</span><span style="color: #bf8b56;">[<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />][A2-9JQK]</span><span style="color: #405c79;">)'</span><span style="color: #405c79;">, get_random_card, this_round)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(result)</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
... got <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" />3 . <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />2 and <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />9 ... <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" />7 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" />5 .. <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />5 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" />6
</div>



<p>这种使用函数来处理如何完成替换的方式非常灵活。</p>



<hr class="wp-block-separator"/>



<p><code class="traditional">subn(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count</em>=0, <em>flags</em>=0)</code> 函数和 <code class="traditional">sub()</code> 函数功能类似，唯一不同的是 <code class="traditional">subn()</code> 函数的返回结果是一个包含 <code class="traditional">(result, count)</code> 的元组，即可以同时获取正则替换的完整结果与替换次数。</p>



<h3 class="wp-block-heading" id="分割">分割</h3>



<p>Python 内置了一个 <code class="traditional">.split()</code> 方法，可以用来分割字符串：</p>



<div class="code-console">
&gt;&gt;&gt; data = '0.2682, 0.1266, 0.0942, 0.5178, 0.9459'<br>
&gt;&gt;&gt; data.split(', ')<br>
['0.2682', '0.1266', '0.0942', '0.5178', '0.9459']
</div>



<p>但是该方法有一个缺点，那就是对于复杂情况下的分割效果不够理想：</p>



<div class="code-console">
&gt;&gt;&gt; row_data = '0.2682 0.1266   0.0942  0.5178    0.9459'<br>
&gt;&gt;&gt; row_data.split(' ')<br>
['0.2682', '0.1266', '', '', '0.0942', '', '0.5178', '', '', '', '0.9459']
</div>



<p>上例中，<code class="traditional"><code class="traditional">.split()</code></code> 方法无法识别出多个空格，导致多个空格的分割出现了未达到预期的效果。</p>



<p>这个时候，便可以使用 <code class="traditional">re</code> 库中的分割函数 <code class="traditional">split(<em>pattern</em>, <em>string</em>, <em>maxsplit</em>=0, <em>flags</em>=0)</code> ，该函数的效果是将 <code class="traditional"><em>pattern</em></code> 代表的正则表达式为分割标识，将 <code class="traditional"><em>string</em></code> 位于分割标识两侧的字符串拆分成列表。通俗地说，就是相比内置的 <code class="traditional">.split</code> 方法，该函数可以用正则表达式作为分割标识了。因此相比内置的 <code class="traditional">.split()</code> 方法，<code class="traditional">re</code> 库中的 <code class="traditional">split()</code> 函数分割更加的灵活。</p>



<p>例如，以上使用内置 <code class="traditional">.split()</code> 分割失败的情况，可以使用 <code class="traditional">split()</code> 函数这么处理：</p>



<div class="code-console">
&gt;&gt;&gt; from re import split<br>
&gt;&gt;&gt; split(r'\s+', row_data)<br>
['0.2682', '0.1266', '0.0942', '0.5178', '0.9459']
</div>



<p>可以看到正则表达式很完美地识别了多个空格并完成了拆分。</p>



<h2 class="wp-block-heading" id="其它内容">其它内容</h2>



<h3 class="wp-block-heading" id="正则表达式对象">正则表达式对象</h3>



<p>当在 Python 中使用正则表达式进行匹配时，<code class="traditional">re</code> 模块会执行两个步骤：</p>



<ol><li>将输入的正则表达式编译成一个正则表达式对象。如果正则表达式的字符串本身不合法，会产生 <code class="error">re.error</code> 错误。</li><li>用编译后的正则表达式去匹配字符串。</li></ol>



<p>因此当要进行匹配大量数据时，需要重复使用一个正则表达式几百上千次。此时，出于效率的考虑，可以先预编译该正则表达式为一个正则表达式对象，再利用正则表达式对象的方法去匹配字符串，这样便省略了步骤 1 ，很好地提升了效率。</p>



<p>使用 <code class="traditional">re.compile(pattern, flags=0)</code> 函数可以生成一个正则表达式对象：</p>



<div class="vscode-block" style="color: #405c79;background-color: #f7f9fb;"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> re</span></div><div><span style="color: #405c79;">pattern = re.compile(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">^\d</span><span style="color: #405c79;">{6}</span><span style="color: #568bbf;">$</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(pattern, </span><span style="color: #bf568b;">type</span><span style="color: #405c79;">(pattern))</span></div></div>



<p>结果为：</p>



<div class="code-console">
$ python -u regex.py<br>
re.compile('^\\d{6}$') &lt;class 're.Pattern'&gt;
</div>



<p>对于一个已经预编译完成的正则表达式对象，可以使用对象的一些方法来完成匹配。正则表达式对象方法有：</p>



<ul><li><code class="traditional">.match(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.fullmatch(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.search(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.finall(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.finditer(<em>string</em>, <em>pos</em>, <em>endpos</em>)</code></li><li><code class="traditional">.sub(<em>repl</em>, <em>string</em>, <em>count</em>)</code></li><li><code class="traditional">.subn(<em>repl</em>, <em>string</em>, <em>count</em>)</code></li><li><code class="traditional">.split(<em>string</em>, <em>maxsplit</em>)</code></li></ul>



<p>其中 <code class="traditional">pos</code> 和 <code class="traditional">endpos</code> 参数可以指定正则表达式的搜索位置。除此之外，这些方法与各自对应的函数的使用方法基本一致。</p>



<h2 class="wp-block-heading" id="附录">附录</h2>



<h3 class="wp-block-heading" id="参考资料">参考资料</h3>



<p><a href="https://docs.python.org/3/library/re.html">https://docs.python.org/3/library/re.html</a></p>



<p>Python3 re库官方文档</p>
<p><a rel="nofollow" href="/archives/144">Python标准库re：使用正则表达式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/144/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>正则表达式简单入门</title>
		<link>/archives/124</link>
					<comments>/archives/124#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 23 Feb 2022 15:10:05 +0000</pubDate>
				<category><![CDATA[编程语言]]></category>
		<category><![CDATA[正则表达式]]></category>
		<guid isPermaLink="false">/?p=124</guid>

					<description><![CDATA[<p>正则表达式(Regular Expression)，&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/124">正则表达式简单入门</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p><strong>正则表达式</strong>(Regular Expression)，是由一些特定字符及其组合所组成的字符串表达式，用来对目标字符串进行匹配、查找操作。</p>



<p>对于一些有规律的字符串匹配操作需求，例如特定网址、手机号码、生物信息等符合一定规律的字符串，无法用简单的判断表达式涵盖，而用正则表达式可以简洁、准确地表达其组成规律，从而高效地进行匹配操作。</p>



<h2 class="wp-block-heading" id="基本匹配语法">基本匹配语法</h2>



<p>在一个正则表达式中，一些普通文本用途就是代表实际需要匹配的字符。但不同于编程语言常见的字符串查找，正则表达式提供了特殊字符与结构，可以表达更抽象的字符串结构。</p>



<h3 class="wp-block-heading" id="基本特殊字符">基本特殊字符</h3>



<p>使用 <code class="modern">\d</code> 可以匹配一个数字：</p>



<p><code class="modern">"12<mark style="background-color: rgb(255, 220, 209);">\d</mark>"</code></p>



<ul><li>可以匹配 <code class="modern">"124"</code></li><li>不能匹配 <code class="modern">"12a" "12G" "12&gt;" "12我"</code></li></ul>



<p>使用 <code>\w</code> 可以匹配一个字母或数字，但不匹配符号和汉字：</p>



<p><code class="modern">"ca<mark style="background-color: rgb(255, 220, 209);">\w</mark>"</code></p>



<ul><li>可以匹配 <code class="modern">"cat" "ca4"</code></li><li>不能匹配 <code class="modern">"ca?" "ca字"</code></li></ul>



<p>使用点号 <code>.</code> 可以匹配除换行符外的任意一个字符（包括数字、符号、中文）：</p>



<p><code class="modern">"<mark style="background-color: rgb(255, 220, 209);">.</mark>txt"</code></p>



<ul><li>可以匹配 <code class="modern">".txt" "xtxt" "1txt" "&gt;txt" "这txt"</code></li><li>不能匹配单独的 <code class="modern">"txt"</code></li></ul>



<h3 class="wp-block-heading" id="限定匹配">限定匹配</h3>



<p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>



<p>使用星号 <code class="modern">*</code> 可以匹配前一个字符 0 次、1 次或多次：</p>



<p><code class="modern">"lon<mark style="background-color: rgb(255, 220, 209);">*</mark>g"</code></p>



<ul><li>可以匹配 <code class="modern">"log" "long" "lonng" "lonnnnnng"</code></li></ul>



<p>使用加号 <code class="modern">+</code> 可以匹配前一个字符 1 次或多次：</p>



<p><code class="modern">"hi<mark style="background-color: rgb(255, 220, 209);">+</mark>"</code></p>



<ul><li>可以匹配 <code class="modern">"hi" "hii" "hiiiiii"</code></li><li>不能匹配 <code class="modern">"h"</code></li></ul>



<p>使用问号 <code class="modern">?</code> 可以匹配前一个字符 0 次或 1 次：</p>



<p><code class="modern">"colou<mark style="background-color: rgb(255, 220, 209);">?</mark>r"</code></p>



<ul><li>可以匹配 <code class="modern">"color" "colour"</code></li><li>不能匹配 <code class="modern">"colouur"</code></li></ul>



<p>还可以进一步指定匹配的次数：</p>



<p>使用 <code class="modern">{<em>n</em>}</code> 可以将前一个字符匹配 <code class="modern"><em>n</em></code> 次：</p>



<p><code class="modern">"hel<mark style="background-color: rgb(255, 220, 209);">{2}</mark>o"</code></p>



<ul><li>只能匹配 <code class="modern">"hello"</code></li></ul>



<p>使用 <code class="modern">{<em>n</em>,}</code> 可以将前一个字符匹配 <code class="modern"><em>n</em></code> 次，或任意比 <code class="modern"><em>n</em></code> 多的次数：</p>



<p><code class="modern">"no<mark style="background-color: rgb(255, 220, 209);">{3,}</mark>"</code></p>



<ul><li>可以匹配 <code class="modern">"nooo" "noooo" "nooooo"</code> ，或 <code class="modern">n</code> 后面跟上更多的 <code class="modern">o</code></li><li>不能匹配 <code class="modern">"noo" "no"</code></li></ul>



<p>使用 <code class="modern">{<em>n</em>,<em>m</em>}</code> 可以将前一个字符匹配 <code class="modern"><em>n</em></code> ~ <code class="modern"><em>m</em></code> 次，包含 <code class="modern"><em>n</em></code> 和 <code class="modern"><em>m</em></code> ：<br><code class="modern">"o<mark style="background-color: rgb(255, 220, 209);">{2,6}</mark>h"</code></p>



<ul><li>可以匹配 <code class="modern">"ooh" "ooooh" "ooooooh"</code></li><li>不能匹配 <code class="modern">"oh"</code></li><li>当 o 数量超过6个时，只能匹配最后的 <code class="modern">"ooooooh"</code></li></ul>



<hr class="wp-block-separator"/>



<p>除了指定次数，还可以指定字符范围：</p>



<p>方括号对 <code class="modern">[]</code> 用来指定一个字符，方括号内为该字符的限定条件：</p>



<p>使用 <code class="modern">[…]</code> 表示字符范围，可以匹配方括号内的所有字符。一对方括号只能表示一个字符：</p>



<p><code class="modern">"b<mark style="background-color: rgb(255, 220, 209);">[</mark>aeiou<mark style="background-color: rgb(255, 220, 209);">]</mark>d"</code></p>



<ul><li>只能匹配 <code class="modern">"bad" "bed" "bid" "bod" "bud"</code></li></ul>



<p>使用 <code class="modern">[^…]</code> 表示字符范围，可以匹配除方括号内字符的其余字符。一对方括号只能表示一个字符：<br><code class="modern">"n<mark style="background-color: rgb(255, 220, 209);">[^</mark>ot<mark style="background-color: rgb(255, 220, 209);">]</mark>r"</code></p>



<ul><li>可以匹配 <code class="modern">"nnr" "nar" "n1r" "n我r" "n&lt;r"</code></li><li>只不能匹配 <code class="modern">"nr" "nor" "ntr"</code></li><li>如果要匹配 <code class="modern">"n^r"</code> ，请不要加上方括号，或将 <code class="modern">^</code> 号移到方括号的其它位置</li></ul>



<p>特别地，字符 <code class="modern">.</code> 在方括号对内只代表 <code class="modern">.</code> 字符，相当于 <code class="modern">\.</code> ，而非匹配任意字符。</p>



<p>类似 <code class="modern">[0-9]</code> 、<code class="modern">[a-z]</code> 、<code class="modern">[A-Z]</code> 表示字符范围，可以匹配某个区间的所有数字或字母，包含区间两端。</p>



<p>减号 <code class="modern">-</code> 两端必须同时是数字、小写字母或大写字母，并且是按从小到大或字母表顺序排列（小数字或靠前的字母在前，大数字或靠后的字母在后），否则它们不会匹配到任何结果。</p>



<p><code class="modern">"<mark style="background-color: rgb(255, 220, 209);">[</mark>U<mark style="background-color: rgb(255, 220, 209);">-</mark>Z<mark style="background-color: rgb(255, 220, 209);">][</mark>0<mark style="background-color: rgb(255, 220, 209);">-</mark>3<mark style="background-color: rgb(255, 220, 209);">][</mark>a<mark style="background-color: rgb(255, 220, 209);">-</mark>g<mark style="background-color: rgb(255, 220, 209);">]</mark>"</code></p>



<p>可以匹配 <code class="modern">"U3a" "Z2f" "Y0c"</code><br>不能匹配 <code class="modern">"A0c" "G3k" "u0g" "C9f"</code> 等</p>



<p>实际上 <code class="modern">\d</code> 等价于 <code class="modern">[0-9]</code> ，<code class="modern">\w</code> 等价于 <code class="modern">[a-zA-Z0-9_]</code> 。</p>



<h3 class="wp-block-heading" id="定位符号">定位符号</h3>



<p>某些符号可以用来限定位置，用于匹配特殊位置上的字符，而不能匹配一般位置上的同一字符。这样的符号一般称为<strong>定位符</strong>或<strong>锚点</strong>。</p>



<p>使用 <code class="modern">^</code> 号用在方括号对 <code class="modern">[]</code> 以外的其它地方，用来表示一行的开头位置，将匹配开头位置：</p>



<p><code class="modern">"<mark style="background-color: rgb(255, 220, 209);">^</mark>12"</code></p>



<ul><li>只能匹配开头位置的 <code class="modern">"12"</code></li><li>不能匹配其余位置的 <code class="modern">"12"</code></li></ul>



<p>注意：要匹配开头位置，<code class="modern">^</code> 号应该位于字符串最前面，否则自相矛盾。</p>



<p>特别地，如果还希望能匹配上一行的字符，请在 <code class="modern">^</code> 号前使用换行符 <code class="modern">\n</code> 。</p>



<p>其等价于转义字符 <code class="modern">\A</code> 。</p>



<br>



<p>使用 <code class="modern">$</code> 号用来表示行末位置，将匹配一行的末尾：</p>



<p><code class="modern">"that<mark style="background-color: rgb(255, 220, 209);">$</mark>"</code></p>



<ul><li>只能匹配行末位置的 <code class="modern">"that"</code></li><li>不能匹配其余位置的 <code class="modern">"that"</code></li></ul>



<p>该符号同样应该位于字符串末尾。如果还希望能匹配下一行的字符，请在 <code class="modern">$</code> 号后使用换行符 <code class="modern">\n</code> 。</p>



<p>其等价于转义字符 <code class="modern">\Z</code> 。</p>



<p><code class="modern">^</code> 和 <code class="modern">\A</code> 、<code class="modern">$</code><code class="modern"></code> 和 <code class="modern">\Z</code> 是有区别的，当它们在“多行模式”下的匹配方式不同。可以参考后续介绍的<mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-vivid-green-cyan-color">匹配模式</mark>。</p>



<p>使用 <code class="modern">\b</code> 匹配一个单词的边界。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项：</p>



<p><code class="modern">"<mark style="background-color: rgb(255, 220, 209);">\b</mark>as"</code></p>



<ul><li>可以匹配以 <code class="modern">as</code> 开始的单词，例如 <code class="modern">"assert"</code> 中的 <code class="modern">as</code></li><li>不能匹配在单词中或单词末尾的 <code class="modern">as</code> ，例如 <code class="modern">"Las Vegas"</code> 中的两个 <code class="modern">as</code></li></ul>



<p>所谓“单词的边界”与空白符有一定区别：单词的边界可能是一行的开始，即便它前面没有任何空白或换行符。单词的边界还可能是一篇文章的末尾，尽管它后面没有任何空白、换行符、换页符等。除此之外，单词的边界还可以是一个符号：</p>



<p><code class="modern">"<mark style="background-color: rgb(255, 220, 209);">\b</mark>emphasis<mark style="background-color: rgb(255, 220, 209);">\b</mark>"</code></p>



<ul><li>可以匹配 <code class="modern">"(emphasis)" "Warning:emphasis."</code> 中的 <code class="modern">emphasis</code></li><li>不能匹配 <code class="modern">"3emphasis"</code> 中的 <code class="modern">emphasis</code></li></ul>



<h3 class="wp-block-heading" id="捕获与引用">捕获与引用</h3>



<p>使用圆括号 <code class="modern">()</code> 可以指定一个子表达式，用来对表达式包含的内容进行区分。</p>



<p>使用单个竖线 <code class="modern">|</code> 代表“或”，代表该符号两侧的表达式都可以进行匹配：</p>



<p><code class="modern">"P<mark style="background-color: rgb(255, 220, 209);">(</mark>ython<mark style="background-color: rgb(255, 220, 209);">|</mark>HP<mark style="background-color: rgb(255, 220, 209);">)</mark>"</code></p>



<ul><li>只能匹配 <code class="modern">"Python" "PHP"</code></li></ul>



<p>在匹配过程中，为了不至于引起表意不清，请尽量使用圆括号 <code class="modern">(…)</code> 将子表达式括起来。</p>



<p>圆括号还有一个用途：默认情况下，圆括号会将表达式进行分组，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志（嵌套的表达式也是），第一个出现的分组的组号为 1 ，第二个为 2 ，以此类推。</p>



<p>特别地，第 0 组代表整个表达式捕获的内容本身。</p>



<hr class="wp-block-separator"/>



<p><strong>后向引用</strong>使用转义的数字用于重复搜索前面某个分组匹配的文本。例如，<code class="modern">\1</code> 代表分组 1 匹配的文本。</p>



<p><code class="modern">"\b<mark style="background-color: rgb(255, 220, 209);">(</mark>\w+<mark style="background-color: rgb(255, 220, 209);">)</mark>\b\s+<mark style="background-color: rgb(255, 220, 209);">\1</mark><mark style="background-color: rgb(255, 220, 209);">\b"</code></p>



<p>用来匹配重复的单词，其规则为：分组 1 必须要由至少一个字符组成，其组前和后必须为单词的边界（如空格、换行符等，或者什么也没有）；在经历了若干空格后，应该出现一个分组 1 对应的单词，并且该单词后应为单词的边界。换句话说，它匹配两个重复的单词。</p>



<ul><li>可以匹配 <code class="modern">"是 是" " go go"</code></li><li>不能匹配 <code class="modern">"age ago" "mere merely"</code></li></ul>



<p>如果使用 <code class="modern">\0</code> 则引用整个被匹配的正则表达式本身。</p>



<p>分组引用一般用于匹配对称、重复但不确定的字符串，如 HTML 的开始和结束标签。</p>



<p>注意：</p>



<ol><li>引用不能引用其自身，如 <code class="modern">"([a-z]<mark style="background-color: rgb(255, 220, 209);">\1</mark>)"</code> 是错误的，它匹配不到任何结果。同样，<code class="modern">\0</code> 代表正则表达式匹配本身，所以不能在正则表达式中引用，只能用于之后的其余操作中，如替换等。</li><li>引用不能用于方括号内的字符集内部，如 <code class="modern">"[<mark style="background-color: rgb(255, 220, 209);">\1</mark>b]"</code> 是不恰当的，其引用 <code class="modern">\1</code> 会被正则表达式解释为八进制转码。</li><li>由于圆括号匹配到的内容可能是不确定的，所以当圆括号没有匹配到任何内容时，其引用也无效，即引用的内容为空。</li><li>当对组使用重复操作符时，缓存里的引用内容会被不断刷新，只保留最近匹配的项目。例如 <code class="modern">"<mark style="background-color: rgb(255, 220, 209);">(</mark>[abc]+<mark style="background-color: rgb(255, 220, 209);">)</mark>=<mark style="background-color: rgb(255, 220, 209);">\1</mark>"</code> 可能匹配 <code class="modern">"cab=cab"</code> ，但是 <code class="modern">"<mark style="background-color: rgb(255, 220, 209);">(</mark>[abc]<mark style="background-color: rgb(255, 220, 209);"><code>)</code></mark>+=<mark style="background-color: rgb(255, 220, 209);">\1</mark>"</code> 则不匹配 <code class="modern">"cab=cab"</code> ，这是由于 <code class="modern">([abc])</code> 第一次匹配到 <code class="modern">"c"</code> 时，<code class="modern">"\1"</code> 代表 <code class="modern">"c"</code> ，然后 <code class="modern">([abc])</code> 会继续匹配 <code class="modern">"a"</code> 和 <code class="modern">"b"</code> ，最后缓存刷新的结果为 <code class="modern">"\1"</code> 代表 <code class="modern">"b"</code> ，所以它会匹配 <code class="modern">"cab=b"</code> 。</li></ol>



<p>也可以使用 <code class="modern">(?P&lt;<em>name</em>&gt;<em>exp</em>)</code> 自己指定子表达式的组名，这样就把表达式 <code class="modern"><em>exp</em></code> 的组名指定为 <code class="modern"><em>name</em></code> 了。要反向引用这个分组捕获的内容，可以使用 <code class="modern">(?P=<em>name</em>)</code> 。</p>



<p>所以上一个例子也可以写成这样：</p>



<p><code class="modern">"\b<mark style="background-color: rgb(255, 220, 209);">(?P&lt;</mark>repeat<mark style="background-color: rgb(255, 220, 209);">&gt;</mark>\w+<mark style="background-color: rgb(255, 220, 209);">)</mark>\b\s+<mark style="background-color: rgb(255, 220, 209);">(?P=</mark>repeat<mark style="background-color: rgb(255, 220, 209);">)</mark>\b"</code></p>



<p>但用圆括号会有一个副作用，使相关的匹配会被缓存，造成匹配速度偏慢。若不需要给捕获的表达式分组，可以使用 <code class="modern">(?:<em>exp</em>)</code> ，它会正常匹配表达式 <code class="modern"><em>exp</em></code> ，但不会给此分组分配组号。</p>



<p><code class="modern">"C<mark style="background-color: rgb(255, 220, 209);">(?:</mark>12|34<mark style="background-color: rgb(255, 220, 209);">)</mark>"</code></p>



<ul><li>会匹配所有的 <code class="modern">"C12"</code> 或 <code class="modern">"C34"</code> ，并且不将 <code class="modern">"12"</code> 或 <code class="modern">"34"</code> 分组。</li></ul>



<hr class="wp-block-separator"/>



<p>当拥有了一个组名或者组编号时，可以使用 <code class="modern">(?(<em>id/name</em>)<em>yes</em>|<em>no</em>)</code> 来表示一个 <strong>yes/no pattern</strong> 。</p>



<p>其规则为：如果 <code class="modern"><em>id/name</em></code> 对应的组成功匹配，则继续匹配 <code class="modern"><em>yes</em></code> 部分对应的正则表达式；如果 <code class="modern"><em>id/name</em></code> 对应的组匹配失败，则会匹配 <code class="modern"><em>no</em></code> 对应的表达式。</p>



<p><code class="modern">"<mark style="background-color: rgb(255, 220, 209);">(?P</mark>a candy<mark style="background-color: rgb(255, 220, 209);">)</mark>?<mark style="background-color: rgb(255, 220, 209);">(?(</mark>group<mark style="background-color: rgb(255, 220, 209);">)</mark> is true<mark style="background-color: rgb(255, 220, 209);">|</mark> is false<mark style="background-color: rgb(255, 220, 209);">)</mark>"</code></p>



<ul><li>如果成功匹配到了 <code class="modern">"a candy"</code> ，则会继续匹配到 <code class="modern">"a candy is true"</code></li><li>如果没有匹配到 <code class="modern">"a candy"</code> ，由于组括号后存在一个 <code class="modern">?</code> ，它会允许该组匹配的结果为 0 次，转而匹配 <code class="modern">" is false"</code></li></ul>



<p><code class="modern">"<mark style="background-color: rgb(255, 220, 209);">(</mark>a candy<mark style="background-color: rgb(255, 220, 209);">)</mark>?<mark style="background-color: rgb(255, 220, 209);">(?(</mark>1<mark style="background-color: rgb(255, 220, 209);">)</mark> (makes me) happy<mark style="background-color: rgb(255, 220, 209);">|</mark>unhappy<mark style="background-color: rgb(255, 220, 209);">)</mark>"</code></p>



<p>如果成功匹配到了 <code class="modern">"a candy"</code> ，则会继续匹配到 <code class="modern">"a candy makes me happy"</code> ，其中 <code class="modern">"a candy"</code> 是组 1，<code class="modern">"makes me"</code> 是组 2。<br>如果没有匹配到 <code class="modern">"a candy"</code> 或 <code class="modern">"a candy makes me"</code> ，则会直接匹配 <code class="modern">"unhappy"</code> 。</p>



<p>从上述例子可以看出，使用 yes/no pattern 有一个细节就是要在组括号后使用 <code class="modern">?</code> 限定符来表示当没有匹配成功时可以忽略该组，从而正确地匹配到 no pattern 的表达式。</p>



<h3 class="wp-block-heading" id="非捕获元">非捕获元</h3>



<p>非捕获元会被匹配，但不会被分到实际捕获的组内（实际不占用捕获的字符），它主要用于定位。</p>



<p><strong>正向零宽断言</strong>的格式为 <code class="modern"><em>exp1</em>(?=<em>exp2</em>)</code> ，用来匹配并捕获 <code class="modern"><em>exp2</em></code> 前面的 <code class="modern"><em>exp1</em></code> ：</p>



<p><code class="modern">"https?<mark style="background-color: rgb(255, 220, 209);">(?=</mark>://<mark style="background-color: rgb(255, 220, 209);">)</mark>"</code></p>



<p>只能匹配 <code class="modern">"http://"</code> 或 <code class="modern">"https://"</code> 中的 <code class="modern">"http"</code> 或 <code class="modern">"https"</code><br>不能匹配单独的 <code class="modern">"http"</code> ，即便在其余某处又出现了不紧邻的 <code class="modern">"://"</code></p>



<p><strong>反向零宽断言</strong>的格式为 <code class="modern">(?&lt;=<em>exp2</em>)<em>exp1</em></code> ，用来匹配并捕获 <code class="modern"><em>exp2</em></code> 后面的 <code class="modern"><em>exp1</em></code> ：</p>



<p><code class="modern"><mark style="background-color: rgb(255, 220, 209);">(?&lt;=</mark>&lt;a&gt;<mark style="background-color: rgb(255, 220, 209);">)</mark>.+<mark style="background-color: rgb(255, 220, 209);">(?=</mark>&lt;/a&gt;<mark style="background-color: rgb(255, 220, 209);">)</mark></code></p>



<ul><li>可以匹配一个无属性的HTML <code class="modern">&lt;a&gt;</code><code class="modern"></code> 标签中的内容</li><li>不会匹配到标签本身，但会匹配到里面嵌套标签的完整内容</li><li>一个细节可能导致匹配会造成出乎意料的结果，详见 <mark style="background-color:rgba(0, 0, 0, 0)" class="has-inline-color has-vivid-green-cyan-color">贪婪匹配与懒惰匹配</mark> 的相关内容</li></ul>



<p><strong>正向否定零宽断言</strong>可以使用 <code class="modern"><em>exp1</em>(?!<em>exp2</em>)</code> 来匹配并捕获后面不是 <code class="modern"><em>exp2</em></code> 的 <code class="modern"><em>exp1</em></code> ：</p>



<p><code class="modern">"name<mark style="background-color: rgb(255, 220, 209);">(?!</mark>error<mark style="background-color: rgb(255, 220, 209);">)</mark>"</code></p>



<ul><li>只不匹配 <code class="modern">"nameerror"</code> 中的 <code class="modern">"name"</code></li><li>对于其它的 <code class="modern">"name"</code> 都可以匹配</li></ul>



<p><strong>反向否定零宽断言</strong>可以使用 <code class="modern">(?&lt;!<em>exp2</em>)<em>exp1</em></code> 来匹配并捕获前面不是 <code class="modern"><em>exp2</em></code> 的 <code class="modern"><em>exp1</em></code> ：</p>



<p><code class="modern">"<mark style="background-color: rgb(255, 220, 209);">(?&lt;!</mark>eco<mark style="background-color: rgb(255, 220, 209);">)</mark>system"</code></p>



<ul><li>只不匹配 <code class="modern">"ecosystem"</code> 中的 <code class="modern">"system"</code></li><li>对于其它的 <code class="modern">"system"</code> 都可以匹配</li></ul>



<hr class="wp-block-separator"/>



<p>在编写正则表达式时，也可以用 <code class="modern">(?#<em style="font-weight: 300;">comment</em>)</code> 代表注释。这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读：</p>



<p><code class="modern">"[0-9][a-g]<mark style="background-color: rgb(255, 220, 209);">(?#</mark><em style="font-weight: 300;">between 0a~9g</em><mark style="background-color: rgb(255, 220, 209);">)</mark>"</code></p>



<p>提示并匹配第一位 0 到 9 ，第二位 a 到 g 的所有字符串。注释内的内容不参与匹配，不造成分组，不产生任何影响。</p>



<h2 class="wp-block-heading" id="使用细节">使用细节</h2>



<h3 class="wp-block-heading" id="特殊字符">特殊字符</h3>



<p>特殊字符为正则表达式中出现的，用来表示匹配规律的词。为了使在匹配过程中能将其当做一个字符而不是表达式进行匹配，必须要用反斜杠 <code class="modern">\</code><code class="modern"></code> 进行转义。</p>



<p>以下为常见的特殊字符：</p>



<p><code class="modern">(){}[]$^*+?.|\</code></p>



<p>除此之外，某些普通字符一旦被转义，含义与原先也截然不同。这点也很好理解，比如常见的字符 <code class="modern">n</code> 在大多数语言中的转义结果都是换行符 <code class="modern">\n</code> 。</p>



<hr class="wp-block-separator"/>



<p>非打印字符指的是肉眼不可视，却又因为排版原因而必要存在的字符。为了使用非打印字符，必须用\进行转义。</p>



<p>以下为常见的非打印字符：</p>



<figure class="wp-block-table"><table><tbody><tr><td><code class="modern">\c<em>X</em></code></td><td>匹配由 <code class="modern"><em>X</em></code> 指明的控制字符。例如，<code class="modern">\cM</code> 匹配一个 Control-M 或回车符。<code class="modern"><em>X</em></code> 的值必须为 A-Z 或 a-z 之一。否则，将 <code class="modern">c</code> 视为一个原义的 <code class="modern">'c'</code> 字符。</td></tr><tr><td><code class="modern">\x<em>NN</em></code></td><td>匹配十六进制数字 <code class="modern"><em>NN</em></code> 对应的字符</td></tr><tr><td><code class="modern">\n</code></td><td>匹配一个换行符。等价于 <code class="modern">\x0a</code> 或 <code class="modern">\cJ</code></td></tr><tr><td><code class="modern">\f</code></td><td>匹配一个换页符。等价于 <code class="modern">\x0c</code> 或 <code class="modern">\cL</code></td></tr><tr><td><code class="modern">\r</code></td><td>匹配一个回车符。等价于 <code class="modern">\x0d</code> 或 <code class="modern">\cM</code></td></tr><tr><td><code class="modern">\s</code></td><td>匹配任何空白字符，包括空格、制表符、换行、换页符等等。等价于表达式 <code class="modern">[ \f\n\r\t\v]</code>（注意空格）。另外注意使用 Unicode 的正则表达式会匹配全角空格符。</td></tr><tr><td><code class="modern">\t</code></td><td>匹配一个制表符。等价于 <code class="modern">\x09</code> 或 <code class="modern">\cI</code></td></tr><tr><td><code class="modern">\v</code></td><td>匹配一个垂直制表符。等价于 <code>\x0b</code> 或 <code class="modern">\cK</code></td></tr><tr><td><code class="modern">\u</code></td><td>匹配一个 Unicode 字符</td></tr></tbody></table></figure>



<p>有时需要查找不属于某个能简单定义的字符类的字符，这时需要用到转义字符的<strong>反义</strong>：</p>



<figure class="wp-block-table"><table><tbody><tr><td><code class="modern">\W</code></td><td>匹配任意不是字母，数字，下划线，汉字的字符，等价于表达式 <code class="modern">[^\w]</code></td></tr><tr><td><code class="modern">\D</code></td><td>匹配任意非数字的字符，等价于表达式 <code class="modern">[^\d]</code></td></tr><tr><td><code class="modern">\S</code></td><td>匹配任何非空白字符，等价于表达式 <code class="modern">[^\s]</code></td></tr><tr><td><code class="modern">\B</code></td><td>匹配不是单词开头或结束的位置，等价于表达式 <code class="modern">[^\b]</code></td></tr></tbody></table></figure>



<p>也就是说，将这些字母变成大写，就代表对应的不匹配。</p>



<p>另外，匹配汉字的正则表达式为：</p>



<p><code class="modern">"[<mark style="background-color: rgb(255, 220, 209);">\u</mark>4e00-<mark style="background-color: rgb(255, 220, 209);">\u</mark>9fa5]"</code></p>



<p>在支持 Unicode 编码的环境中，也可以直接使用汉字精确匹配。</p>



<h3 class="wp-block-heading" id="运算符优先级">运算符优先级</h3>



<p>在正则表达式中，运算符的优先级别从最高到最低为：</p>



<ul><li>转义符 <code class="modern">\</code> 的优先级别最高，即默认字符最先发生转义</li><li>方括号 <code class="modern">[]</code> 和各种圆括号 <code class="modern">()</code> 、<code class="modern">(?:)</code> 、<code class="modern">(?=)</code> 等。因此为了表意清晰，最好多使用括号。</li><li>六种限定符，分别是 <code class="modern">*</code> 、<code class="modern">+</code> 、<code class="modern">?</code> 、<code class="modern">{<em>n</em>}</code> 、<code class="modern">{<em>n</em>,}</code> 、<code class="modern">{<em>n</em>,<em>m</em>}</code></li><li>任何字符和表达任意单个字符的匹配项，如 <code class="modern">^</code> 、<code class="modern">$</code> 和任意转义后的字符</li><li><code class="modern">|</code> ，即“或”逻辑字符。任意用该字符隔开的表达式都是一个完整的匹配项</li></ul>



<h3 class="wp-block-heading" id="匹配模式-贪婪与懒惰">匹配模式：贪婪与懒惰</h3>



<p id="精确匹配"><strong>精确匹配</strong></p>



<p>在正则表达式中，匹配普通字符、普通字符族 <code class="modern">[…]</code> 和转义字符 <code class="modern">\x</code> 的方式都是精确匹配：正则表达式会按照给定的字符串逐个检索字符，每当检索到一个字符在要匹配的字符内，则将该字符标记为匹配成功，并继续向后检索。</p>



<p>正则表达式匹配字符串的方式也是精确匹配：正则表达式会先匹配第一个字符，如果第一个字符匹配成功，则会继续向后逐个检查字符是否匹配。如果每个字符都匹配成功，则记录为一个成功匹配的字符串，并继续向下检索第一个字符，以此类推。</p>



<p><strong>贪婪匹配</strong></p>



<p>正则表达式除了精确匹配外，默认使用贪婪匹配。所谓贪婪匹配，指的是一种尽可能多的匹配字符的匹配模式。</p>



<p>正则表达式的六种限定符 <code class="modern">*</code> 、<code class="modern">+</code> 、<code class="modern">?</code> 、<code class="modern">{<em>n</em>}</code> 、<code class="modern">{<em>n</em>,}</code> 、<code class="modern">{<em>n</em>,<em>m</em>}</code> ，它们会尽可能多的匹配前一个字符。例如：</p>



<p><code class="modern">"10<mark style="background-color: rgb(255, 220, 209);">+</mark>"</code></p>



<ul><li>对于 1 后面跟着无论多少个零（没有除外），它会将 1 和后面的 0 全部匹配，而不是只匹配确定个 0</li></ul>



<p><code class="modern">"&lt;.<mark style="background-color: rgb(255, 220, 209);">+</mark>&gt;"</code></p>



<ul><li>给定一个字符串 <code class="modern">"&lt;book&gt;&lt;title&gt;Python Programming&lt;/title&gt;&lt;/book&gt;"</code> ，它会匹配这个字符串全部，而不仅仅是第一个起始标签，因为整个字符串本身满足这个规则</li></ul>



<p>其贪婪匹配的原理为：正则表达式会先匹配精确字符 <code class="modern">"&lt;"</code> ，然后贪婪匹配字符 <code class="modern">"."</code> ，直至换行符 <code class="modern">"\n"</code> 不能匹配该字符，然后正则表达式开始从后向前匹配字符 <code class="modern">"</code>"&gt;" ，直至匹配成功，则它会将该范围内的字符全部匹配。</p>



<p><code class="modern">"is<mark style="background-color: rgb(255, 220, 209);">{3,6}</mark>"</code></p>



<ul><li>也是遵循这样的匹配方式，如果 i 后面跟着足够多的 s ，正则表达式也会匹配 i 和尽可能多的 s ，直至匹配满 6 个 s 的 <code class="modern">"issssss"</code></li></ul>



<p><strong>懒惰匹配</strong></p>



<p>贪婪匹配可能会导致过多的内容被匹配到，例如：</p>



<p><code class="modern">"(?&lt;=href=").<mark style="background-color: rgb(255, 220, 209);">+</mark>(?=")"</code></p>



<p>本意是想匹配 <code class="modern">href</code> 属性内的值，但贪婪匹配的规则会让符号 <code class="modern">.</code> 一路匹配下去，遇到引号 <code class="modern">"</code> 也不不会停下，直到遇到段尾，为了满足语法再回溯找到遇到的最后一个引号 <code class="modern">"</code> 停在之前。可以预料到，后面几个属性的内容也会被匹配进去。</p>



<p>这就是懒惰匹配的用途。懒惰匹配与贪婪匹配相反，它是一种尽可能少的匹配字符的匹配模式。</p>



<p>懒惰匹配只针对六种限定符 <code class="modern">*</code> 、<code class="modern">+</code> 、<code class="modern">?</code> 、<code class="modern">{n}</code> 、<code class="modern">{<em>n</em>,}</code> 、<code class="modern">{<em>n</em>,<em>m</em>}</code> ，要使用懒惰匹配非常简单，只要在限定符后面再加上一个问号 <code class="modern">?</code> 即可。</p>



<p>也就是说，六种限定符对应的懒惰匹配模式分别为：<code class="modern">*?</code> 、<code class="modern">+?</code> 、<code class="modern">??</code> 、<code class="modern">{<em>n</em>}?</code> 、<code class="modern">{<em>n</em>,}?</code> 、<code class="modern">{<em>n</em>,<em>m</em>}?</code> 。</p>



<p>例如：</p>



<p><code class="modern">"20<mark style="background-color: rgb(255, 220, 209);">*?</mark>"</code></p>



<ul><li>对于 2 后面跟着无论多少个零，只要 2 后面有跟着 0 ，它会忽略后面的 0 ，只匹配 <code class="modern">"2"</code></li></ul>



<p>对于上述例子 <code class="modern">"&lt;book&gt;&lt;title&gt;Python Programming&lt;/book&gt;&lt;/title&gt;"</code> ，使用懒惰匹配模式：</p>



<p><code class="modern">"&lt;.<mark style="background-color: rgb(255, 220, 209);">+?</mark>&gt;"</code></p>



<ul><li>则只会匹配最先出现的 <code class="modern">"&lt;book&gt;"</code></li></ul>



<p>类似地：</p>



<p><code class="modern">"py<mark style="background-color: rgb(255, 220, 209);">{3,}?</mark>"</code></p>



<p>不管 p 后面跟着多少个 y ，只要 y 的个数不低于3个，那么正则表达式便会且仅会匹配最开始的 <code class="modern">"pyyy"</code></p>



<h3 class="wp-block-heading" id="修饰符">修饰符</h3>



<p>修饰符(modifier)可以改变正则表达式的一些规则，来适应不同的使用场景。</p>



<p>下表列举了比较广泛支持的一些修饰符：</p>



<figure class="wp-block-table"><table><tbody><tr><td><code class="modern">m</code>（多行模式）</td><td>在许多编程语言里，<code class="modern">^</code> 和 <code class="modern">$</code> 只会给定匹配字符串的开始和末尾。多行模式可以让这两个字符匹配一行的开始和末尾。</td></tr><tr><td><code class="modern">i</code>（不区分大小写）</td><td>匹配英文字符时将不区分大小写</td></tr><tr><td><code class="modern">x</code>（冗长模式）</td><td>冗长模式专门用于将复杂的正则表达式表达得美观。这种模式下，会忽略正则表达式内的空格并将一行中 <code class="modern">#</code> 号及以后后的部分视为注释（除非使用转义符强制匹配），这样可以将一条正则表达式分为多个部分展示</td></tr><tr><td><code class="modern">s</code>（单行模式）</td><td>该模式下点号 <code class="modern">.</code> 会匹配所有字符，包括换行符</td></tr><tr><td><code class="modern">u</code>（Unicode模式）</td><td>该模式下会强制启用并使用 Unicode 理解下的字符。例如，使用拉丁字母会同时匹配所有变音的字符类，<code class="modern">\d</code> 会匹配全角数字（注意，一些使用Unicode字符串的编程语言会默认开启该模式，这是一个很隐秘的坑）</td></tr></tbody></table></figure>



<p>正则表达式原生支持如下两种修饰符的用法：</p>



<p><strong>内联修饰符</strong>：格式为 <code class="modern">(?<em>flags</em>-<em>flags</em>)</code> ，作用于整个正则表达式对象，会启用减号前所有的修饰符，并停用减号后所有的修饰符（如果不需要停用，则减号可以忽略）。</p>



<p><strong>局部内联修饰符</strong>：格式为 <code class="modern">(?<em>flags</em>-<em>flags</em>:<em>expression</em>)</code> ，用法类似，仅作用于括号内的 <code class="modern"><em>expression</em></code> 。</p>



<br>



<p>以上就是正则表达式的基本用法。对于不同的编程语言，其构造方式、语法细节（如分组引用格式）、支持的修饰符都有部分不同。例如PHP支持正则表达式的递归，DotNet（C#）支持类似栈的平衡组，甚至能用来平衡左右两侧的符号。不管如何，在使用正则表达式之前，请参阅相关语言对正则表达式支持的相关文档。</p>



<p>正则表达式只是一个类似于XPath的工具，它在许多要处理文本的情况下都会用到，例如格式修改、数据清洗，甚至用在编译器的词法分析工具。正则表达式也在不断发展，变得越来越强大。</p>



<h2 class="wp-block-heading" id="参考资料">参考资料</h2>



<p><a href="https://regexr.com/">https://regexr.com/</a></p>



<p>一个在线正则表达式测试工具，包含可视化的词法分析、语法参考，提供了一些常用正则表达式</p>



<p><a href="https://regex101.com/">https://regex101.com/</a></p>



<p>一个非常强大的在线正则表达式测试工具，它提供了详细的可视化词法分析、匹配组信息、语法参考、错误分析，可以使用替换甚至单元测试工具。并且它能支持不同的编程语言，还能为常用的编程语言直接生成相应的代码</p>



<p><a href="https://www.regular-expressions.info/">https://www.regular-expressions.info/</a></p>



<p>一个非常详细的正则表达式参考网站，提供了包括入门、实现细节、使用示例、缺陷说明的完整的介绍，并提供了大部分支持正则表达式编程语言的特性对比，堪称正则表达式的百科全书</p>



<p><a href="https://alf.nu/RegexGolf">https://alf.nu/RegexGolf</a></p>



<p>一个有趣的在线正则表达式闯关游戏，只有匹配了规定的字符串才算通过，并会根据使用正则表达式的长度打分。</p>



<p><a href="https://docs.python.org/3/library/re.html">https://docs.python.org/3/library/re.html</a></p>



<p>Python3正则表达式语言参考</p>



<p><a href="https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions">https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions</a></p>



<p>DotNet正则表达式语言参考</p>



<p><a href="https://developer.mozilla.org/docs/Web/JavaScript/Guide/Regular_Expressions">https://developer.mozilla.org/docs/Web/JavaScript/Guide/Regular_Expressions</a></p>



<p>JavaScript正则表达式语言参考</p>



<p><a href="https://www.cplusplus.com/reference/regex/">https://www.cplusplus.com/reference/regex/</a></p>



<p>C++正则表达式语言参考</p>



<p><a href="https://www.php.net/manual/ref.pcre.php">https://www.php.net/manual/ref.pcre.php</a></p>



<p>PHP正则表达式语言参考<mark style="background-color: rgb(255, 220, 209);"></p>
<p><a rel="nofollow" href="/archives/124">正则表达式简单入门</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/124/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
