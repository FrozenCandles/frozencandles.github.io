<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>单片机与应用归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/category/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8E%E5%BA%94%E7%94%A8/feed?simply_static_page=3599" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Mon, 12 Dec 2022 12:10:10 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>单片机与应用归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>ESP32与MicroPython入门-02 基本外设操作</title>
		<link>/archives/723</link>
					<comments>/archives/723#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 01 Sep 2022 02:38:05 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[ESP32]]></category>
		<category><![CDATA[MicroPython]]></category>
		<guid isPermaLink="false">/?p=723</guid>

					<description><![CDATA[<p>开发板介绍 在介绍 GPIO 的基本操作之前，有必要&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/723">ESP32与MicroPython入门-02 基本外设操作</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>开发板介绍</h2>
<p>在介绍 GPIO 的基本操作之前，有必要先介绍一下所使用的开发板，以便更好地了解其用途。</p>
<p>DOIT ESP32 DEVKIT V1 使用的是 ESP-WROOM-32 模块，其主要参数为：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>主频</td>
<td>240MHZ</td>
</tr>
<tr>
<td>Flash容量</td>
<td>4MB</td>
</tr>
<tr>
<td>RAM容量</td>
<td>512KB</td>
</tr>
</tbody>
</table>
<p>开发板上的一些主要元器件功能如下：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/09/02-esp32-devkits.jpg" alt="开发板"></figure>
<ol>
<li>ESP-WROOM-32 模块，是整个开发板的核心</li>
<li>CP2102 芯片，用于串口转 USB</li>
<li>3.3V 稳压器，使 ESP32 能正常工作</li>
<li>EN(ENABLE) 按键，用于复位芯片</li>
<li>BOOT 按键，用于引导芯片进入烧入状态</li>
</ol>
<p><a href="/archives/673">上一节</a>中，使用 MicroPython 实现了 LED 灯闪烁效果，完整的代码为：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> Pin
<span class="hljs-keyword">import</span> time
led = Pin(<span class="hljs-number">2</span>, Pin.OUT)
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    led.value(<span class="hljs-number">0</span>)
    time.sleep(<span class="hljs-number">0.5</span>)
    led.value(<span class="hljs-number">1</span>)
    time.sleep(<span class="hljs-number">0.5</span>)
</pre></div>
<p>接下来通过详细分析该程序来介绍 MicroPython 操作 GPIO 的一般方法。</p>
<h2>基本GPIO操作</h2>
<h3>GPIO 输出代码分析</h3>
<p>在第一行中，导入了 <code>machine</code> 模块的 <code>Pin</code> 类：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> Pin
</pre></div>
<p><code>machine</code> 是MicroPython提供的一个与芯片的外设交互的接口模块，包括 GPIO 、ADC 、计时器等。而 <code>Pin</code> 类就是对 GPIO 封装。</p>
<p>第二行中，导入了标准库 <code>time</code> ：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">import</span> time
</pre></div>
<p>尽管 MicroPython 删除了很多标准库以及标准库里的函数，但还是有不少标准库可以正常使用。可以使用以下代码检查当前 MicroPython 支持的所有标准库：</p>
<div class="hljs codeblock"><pre><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">help</span>(<span class="hljs-string">'modules'</span>)
__main__          gc                ubinascii         urandom
_boot             inisetup          ubluetooth        ure
_onewire          machine           ucollections      urequests
_thread           math              ucryptolib        uselect
...
Plus <span class="hljs-built_in">any</span> modules on the filesystem
</pre></div>
<p>接下来，以下代码用于初始化 GPIO 口：</p>
<div class="hljs codeblock"><pre>led = Pin(<span class="hljs-number">2</span>, Pin.OUT)
</pre></div>
<p><code>Pin</code> 类的初始化方法中，有以下几个主要的参数：</p>
<ul>
<li><code>id</code> ：指定 GPIO 的引脚号，可以是一个标识符数字，也可以是字符串形式的引脚名称</li>
<li><code>mode</code> ：引脚模式，可以为 <code>Pin.OUT</code> 常规输出、<code>Pin.IN</code> 输入，以及 <code>Pin.OPEN_RAIN</code> 开漏输出模式。</li>
<li><code>pull</code> ：如果设置为 <code>Pin.PULL_UP</code> ，为上拉模式；<code>Pin.PULL_DOWN</code> 为下拉模式；设置为 <code>None</code> 则为悬空模式。</li>
</ul>
<p>当初始化完成后，随时都可以通过以下方法重新设置 GPIO 引脚功能：</p>
<ul>
<li><code>.mode(mode=None)</code> ：更改工作模式。如果忽略参数，则可以查询当前引脚的工作模式</li>
<li><code>.pull(pull=None)</code> ：更改上下拉方式。如果忽略参数，则可以查询当前引脚的上下拉方式</li>
<li><code>.init(mode=None, pull=None)</code> ：根据给定的参数重新初始化引脚</li>
</ul>
<p>GPIO 的输入输出，主要是通过类的 <code>.value(x=None)</code> 方法实现。该方法如果忽略参数，则可以读取当前引脚的数字逻辑电平（ 0 或 1 ）。如果是工作在输出模式，可以通过传入等价于 <code>True</code> 的值让引脚输出高电平，或传入等价于 <code>False</code> 的值让引脚输出低电平。</p>
<p><code>Pin</code> 类还将其封装为方法 <code>.on(self)</code> 和 <code>.off(self)</code> ，能将一个引脚的电平快速置 1 或 0 。</p>
<p>实际上，<code>Pin</code> 类还通过重载 <code>.__call__(self, x=None)</code> 特殊方法，只需要像函数一样调用 <code>Pin</code> 对象就可以读写 GPIO 。</p>
<p>因此，借助 Python 的语法，循环还能写成如下更简洁的形式：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    led(<span class="hljs-keyword">not</span> led())
    sleep(<span class="hljs-number">1</span>)
</pre></div>
<h3>GPIO 按键输入实例</h3>
<p>有了以上对 GPIO 的介绍后，就可以很轻松编写出 GPIO 的按键输入程序了。</p>
<p>例如，与 ESP32 相连的电路为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/09/02-circuit-key-led.jpg" alt="电路图"></figure>
<p>根据电路图，首先需要初始化 GPIO 引脚为：</p>
<div class="hljs codeblock"><pre>led = Pin(<span class="hljs-number">4</span>, Pin.OUT)
key = Pin(<span class="hljs-number">5</span>, Pin.IN, Pin.PULL_UP)
</pre></div>
<p>由于按钮按下时，GPIO5 的输入变为低电平 0 ，因此这里将 GPIO5 初始化设置为上拉模式，在按钮未按下时其值恒为 1 。</p>
<p>以下程序，当按钮按下时，LED 灯也同步亮起；当按钮松开时，LED 灯同步熄灭：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    led.value(key.value())
    time.sleep(<span class="hljs-number">0.1</span>)
</pre></div>
<p>对程序稍加改动，就可以实现通过按键每次按下控制 LED 亮起与熄灭翻转：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> key.value():
        led.value(<span class="hljs-keyword">not</span> led.value())
    time.sleep(<span class="hljs-number">0.1</span>)
</pre></div>
<h2>外设操作：PWM和ADC</h2>
<p>ESP32 提供了许多外设，如 ADC 、UART 、I2C 、SPI 、CAN 等，这些外设不一定都会用到，因此这里先以比较常用且比较简单的 PWM 和 ADC 为例作为介绍，剩余的只有当需要时再作介绍。</p>
<h3>PWM</h3>
<p>PWM(Pulse-Width Modulation, 脉冲宽度调制)，是一种利用数字信号有无来控制某些模拟电路程度的方式。</p>
<p>PWM 可以这样浅显地理解：某些元件（例如 LED ）的工作程度（例如 LED 灯的亮度）是根据功率来确定的，而功率又是根据电压的有效值来决定的。因此，如果让一个数字信号在很短的周期内快速变化，那么得到的电压有效值将介于两者之间，并且高电平持续的时间越长，有效值将越大。</p>
<p>下图展示了 PWM 的概念。PWM 中有一个很重要的概念为<strong>占空比</strong>，指一个周期内高电平占用时间的比例：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/09/02-pwm-concept.jpg" alt="PWM概念"></figure>
<p>可以这样认为，占空比越高，电压利用率也就越高，有效值就越大。</p>
<p>实现 PWM 效果非常容易，<code>machine</code> 模块包含了 <code>PWM</code> 类，可以快速生成 PWM 。首先引入该类：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> PWM
</pre></div>
<p>以下代码将一个 GPIO 引脚包装为 PWM 输出：</p>
<div class="hljs codeblock"><pre>led = Pin(<span class="hljs-number">2</span>, Pin.OUT)
led_pwm = PWM(led)
</pre></div>
<p><code>PWM</code> 类的 <code>.freq(freq=None)</code> 和 <code>.duty(duty=None)</code> 分别用于设置 PWM 的频率和占空比。如果忽略参数，则可以查询当前所用的频率和占空比。频率的设置范围为 0-78125 ，单位为 Hz ；而占空比的设置范围为 0-1023 ，它与 1023 的比值（或者说 0 到该值的范围占 0-1023 的范围比例）则是实际的占空比。这两个值都不能超过这个范围，否则实际结果会被约束到合法范围内。</p>
<p>这里先设置好工作频率：</p>
<div class="hljs codeblock"><pre>FREQUENCY = <span class="hljs-number">5000</span>
led_pwm = PWM(Pin(<span class="hljs-number">2</span>), freq=FREQUENCY)
</pre></div>
<p>这里让占空比不断变化，以达到 LED 的亮度逐渐变化的效果，对应的代码为：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    <span class="hljs-keyword">for</span> duty <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">4</span>):
        led_pwm.duty(duty)
        time.sleep(<span class="hljs-number">0.01</span>)
</pre></div>
<p>运行该代码，可以看到开发板上的蓝色 LED 灯从熄灭开始逐渐变亮，达到最大亮度后再熄灭逐渐变亮，以此循环。</p>
<p>如果要关闭 PWM 效果，可以调用其 <code>.deinit()</code> 方法。</p>
<h3>ADC</h3>
<p>ADC(Analog to Digital Converter, 模拟/数字信号转换)用于处理模拟信号。模拟信号指的是介于 0~Vcc 的电压值，此时该信号不能简单地使用 0 或 1 表示，而是要通过一定方式将其转换为其它可读的值。</p>
<p>和大多数单片机一样，这种功能只有部分引脚具备。下图列出了 DOIT ESP32 DEVKIT V1 的所有 GPIO 口支持的复用功能。需要注意的是，该图所对应的开发板为 30 个引脚，而某些版本的开发板是 36 个引脚的，可能会多出一些功能。但不管怎么说，相同序号的引脚功能是基本相同的。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/09/02-esp32-devkit-pinout.jpg" alt="e"></figure>
<p>注意 GPIO 口和引脚序号是不同步的。</p>
<p>使用 ADC 和使用 PWM 的方式类似，首先都需要将一个引脚变为 ADC 功能：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> Pin, ADC
adc = ADC(Pin(<span class="hljs-number">32</span>))
</pre></div>
<p>默认情况下，ADC 只能测量 1v 左右范围内的电压。如果要测量更大范围，可以使用 <code>.atten(attenuation)</code> 设置 ADC 输入的衰减量，以获取更大的电压测量范围。可以设置以下衰减值：</p>
<ul>
<li><code>ADC.ATTN_0DB</code> ：不衰减，最大输入电压为 1.1v（默认值）</li>
<li><code>ADC.ATTN_2_5DB</code> ：2.5dB 衰减，最大输入电压约为 1.5v</li>
<li><code>ADC.ATTN_6DB</code> ：6dB 衰减，最大输入电压约为 2.2v</li>
<li><code>ADC.ATTN_11DB</code> ：11dB 衰减，最大输入电压约为 3.9v</li>
</ul>
<p>因此，如果要测量 0-3.3v 变化的电压，需要使用以下代码：</p>
<div class="hljs codeblock"><pre>adc.atten(ADC.ATTN_11DB)
</pre></div>
<p>在适当的时候，调用 <code>ADC</code> 类的 <code>.read()</code> 方法就可以获取当前的电压。电压使用一个 12 位的值来描述，因此如果当读取的值为 4095 时，达到最大输入电压。其余值可以根据比例换算成相应的电压。</p>
<blockquote>
<p>注意，ESP32 的 ADC 引脚可以分为两组，GPIO 32-39 是第一组，GPIO 0, 2, 4, 12-15 和 25-27 是第二组。第二组引脚在有些时候（如使用 WiFi 功能时）不能作为 ADC 功能使用。</p>
</blockquote>
<h2>ESP32高级功能</h2>
<h3>触摸检测</h3>
<p>这算是 ESP32 提供的一个非常有意思的功能了。ESP32 的某些引脚具备一种能力，可以检测引脚是否被人体触摸。</p>
<p>ESP32 有 10 个 GPIO 口可用作电容触摸输入，它们分别为：0、2、4、12、13、14、15、27、32、33。在 30 个引脚的开发板中，没有 0 号 GPIO ，这点需要注意。</p>
<p>使用电容触摸检测功能非常简单，只需要将一个 GPIO 引脚转化成触摸口，然后读入电容值即可。在有无触摸情况下，读入的值差别甚大。对应的代码为：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> Pin, TouchPad
<span class="hljs-keyword">import</span> time

touch = TouchPad(Pin(<span class="hljs-number">4</span>))

<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    <span class="hljs-built_in">print</span>(touch.read())
    time.sleep(<span class="hljs-number">0.5</span>)
</pre></div>
<p>运行代码，观察输出结果如下：</p>
<div class="hljs codeblock"><pre><span class="hljs-number">809</span>
<span class="hljs-number">684</span>
<span class="hljs-number">671</span>
<span class="hljs-number">809</span>
<span class="hljs-number">109</span>
<span class="hljs-number">62</span>
<span class="hljs-number">56</span>
<span class="hljs-number">43</span>
<span class="hljs-number">57</span>
<span class="hljs-number">808</span>
<span class="hljs-number">825</span>
</pre></div>
<p>当被触摸时，读取的值变为几十，而未触摸时的值则为几百。当然，具体的值可能会随着环境的改变而不一定，但是只要捕捉到很大的差别就可以判断是否被触摸。</p>
<h3>中断</h3>
<p>MicroPython 可以直接操作中断功能，通过某个信号暂停当前程序的运转并执行特定的功能。下面以外部中断为例简单介绍外部中断的使用方法。</p>
<p>除了 GPIO6 ~ GPIO11 之外的 GPIO 引脚都有这样一种功能，在电平发生跳变的瞬间，发出一个中断信号，并强制跳转执行某些代码。</p>
<p>要使用外部中断，首先需要初始化一个 GPIO 引脚，将其作为输入模式：</p>
<div class="hljs codeblock"><pre>key = Pin(<span class="hljs-number">23</span>, Pin.IN, Pin.PULL_DOWN)
</pre></div>
<p>为了在发送中断时执行某些功能，需要定义一个函数，这个函数要有这样一个参数，当发送外部中断时，传入产生中断的中断源：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">interrupt_handler</span>(<span class="hljs-params">source</span>):</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'interrupt caused by <span class="hljs-subst">{source}</span>'</span>)
</pre></div>
<p>然后，通过调用 GPIO 引脚的 <code>.irq(trigger, handler)</code> 方法，可以将其变成一个中断源。<em><code>trigger</code></em> 表示触发方式，可以为上升沿 <code>Pin.IRQ_RISING</code> 即低电平向高电平跳变的瞬间，或下降沿 <code>Pin.IRQ_FALLING</code> 即高电平向低电平跳变的瞬间。<code>handler</code> 应该传入一个中断处理函数。</p>
<p>例如：</p>
<div class="hljs codeblock"><pre>key.irq(trigger=Pin.IRQ_RISING, handler=interrupt_handler)
</pre></div>
<p>则与按键相连的 GPIO 口在从低电平向高电平跳变的瞬间，会调用 <code>interrupt_handler()</code> 函数，执行其中的代码，在终端中打印 <code>"interrupt caused by Pin(23)"</code> 。</p>

<h2>参考资料/延伸阅读</h2>

<p>
	<a href="https://docs.micropython.org/en/latest/esp32/quickref.html#">https://docs.micropython.org/en/latest/esp32/quickref.html#</a><br>
	MicroPython 官方文档
</p>
<p><a rel="nofollow" href="/archives/723">ESP32与MicroPython入门-02 基本外设操作</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/723/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>ESP32与MicroPython入门-01 搭建开发环境</title>
		<link>/archives/673</link>
					<comments>/archives/673#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 15 Aug 2022 03:20:50 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[ESP32]]></category>
		<category><![CDATA[MicroPython]]></category>
		<guid isPermaLink="false">/?p=673</guid>

					<description><![CDATA[<p>ESP32简介 ESP32 是上海乐鑫公司开发的一款&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/673">ESP32与MicroPython入门-01 搭建开发环境</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>ESP32简介</h2>
<p>ESP32 是上海乐鑫公司开发的一款比较新的32位微控制器，它集成了WiFi及蓝牙等功能，有着性能稳定、功耗低、价格低廉等特点，非常适用于物联网开发，但也可以作为普通的MCU使用。</p>
<p>ESP8266 也是乐鑫公司开发的一种非常流行的WiFi芯片。相比 ESP8266 ，ESP32 更加强大。<a href="https://makeradvisor.com/esp32-vs-esp8266/">这篇文章</a> 比较了 ESP8266 和 ESP32 之间的差别。</p>
<p>ESP32的主要芯片种类有ESP32-C系列、ESP32-S系列和ESP32系列。这些芯片的参数和功能略有差异，例如ESP32-S2就不支持蓝牙功能。在选型时注意检查芯片型号。</p>
<p>完整的芯片型号对比可以参考官方网站的介绍：<a href="https://www.espressif.com/zh-hans/products/socs">https://www.espressif.com/zh-hans/products/socs</a></p>
<p><strong>模块</strong>是基于ESP32芯片，按照一定功能封装了基本的外设等形成的集成芯片。乐鑫提供的ESP32模块主要可分为WROOM系列、WROVER系列以及MINI系列，完整的介绍及对比可以参见官方网站：<a href="https://www.espressif.com/zh-hans/products/modules">https://www.espressif.com/zh-hans/products/modules</a> 。模块参数的详细PDF文档可以从 <a href="https://www.espressif.com/zh-hans/products/modules/esp32">https://www.espressif.com/zh-hans/products/modules/esp32</a> 处下载。</p>
<p>而<strong>开发板</strong>则是由ESP32模块和USB口、复位开关等组成的完整开发套件。开发板的厂商较多，使用时需要查看对应的开发板电路连接原理图，并注意开发板提供的功能。乐鑫提供的官方开发板介绍可以参见 <a href="https://www.espressif.com/zh-hans/products/devkits">https://www.espressif.com/zh-hans/products/devkits</a> 。</p>
<p>这里选择 DOIT ESP32 DEVKIT V1 作为开发板。该开发板的特点为：</p>
<ol>
<li>尺寸很小（约 52mm x 28mm ）</li>
<li>价格低廉（仅需 ￥20 左右，相比乐鑫官方动辄 60+ 非常亲民）</li>
<li>板载一个蓝色 LED 灯，方便在无额外元器件时便可以调试</li>
<li>远销海外（ platformIO 甚至还有该开发板专门的介绍文档）</li>
</ol>
<p>其外观如下。事实上很多商家的 ESP32 的开发板结构都非常类似。在选择开发板时只需注意主要结构及功能即可。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-esp32-devkits.jpg" alt="开发板外观" width="210"></figure>
<h2>MicroPython简介</h2>
<h3>什么是MicroPython</h3>
<p>MicroPython是基于Python实现的简易版本，用于在嵌入式系统中运行，例如树莓派、ARM单片机和ESP32。它兼容大部分Python3语法，因此只要熟悉Python3就能无障碍上手MicroPython。</p>
<p>相比Python3，MicroPython精简了许多实现细节，并且删去了许多标准库以及标准库里的内容。不过，MicroPython却额外包含了能够操作底层GPIO等外设的标准库，这些是对底层寄存器的高度封装。</p>
<h3>建立MicroPython开发环境</h3>
<p>目前来说，有 3 个比较常用的 MicroPython 开发环境，它们都是免费、开源且跨平台的。它们分别为：</p>
<ul>
<li><strong>uPyCraft IDE</strong></li>
</ul>
<p>uPyCraft IDE 是一个简单并且对入门 MicroPython 友好的集成开发环境，它自身可以直接烧入 MicroPython 到 ESP32 中，并且支持从编写程序到串口调试的所有基本功能。除此之外，它还内置了许多示例代码，可以直接运行这些示例代码查看效果。</p>
<p>uPyCraft 的 GitHub 地址为：<a href="https://github.com/DFRobot/uPyCraft">https://github.com/DFRobot/uPyCraft</a> 。可以从中下载软件与查看官方文档。</p>
<ul>
<li><strong>Thonny IDE</strong></li>
</ul>
<p>Thonny IDE 是一个 Python 的集成开发环境，不过它同时也支持直接开发 MicroPython 。Thonny IDE 功能丰富，支持各种调试方式，，并且可以加上插件进一步扩展功能。</p>
<p>Thonny IDE 的官方网站为：<a href="https://thonny.org/">https://thonny.org/</a> ，GitHub 仓库地址为：<a href="https://github.com/thonny/thonny">https://github.com/thonny/thonny</a> 。</p>
<ul>
<li><strong>Visual Studio Code</strong></li>
</ul>
<p>大名鼎鼎的 VSCode 想必许多人都有所耳闻。VSCode 想要开发 MicroPython ，主要依靠插件的支持。</p>
<p>这里推荐将 Thonny IDE 作为开发环境，主要是出于以下考虑：</p>
<ol>
<li>VSCode 相对 MicroPython 入门来说，还是有些过于重量级。并且 VSCode 主要依赖于插件来开发 MicroPython ，并不能很好地用到 VSCode 的所有优势，而且开发环境的配置也对入门级别不是很友好，因此除非日后需要利用到一些进阶功能，否则并是很不推荐将 VSCode 作为入门开发环境。</li>
<li>uPyCraft 尽管是专门支持 MicroPython 的开发环境，但是它目前版本还比较低，不仅功能很少，而且使用者也很少，许多功能没有得到广泛的测试，可能存在许多 bug 未能得到解决。</li>
<li>相比之下，Thonny IDE 非常轻量级，却也支持许多高级的功能。由于有足够多的使用者，现版本的 Thonny 已经非常稳定，完全可以满足 MicroPython 的全流程开发。</li>
</ol>
<p>由于 Thonny 不支持烧入功能，因此需要额外下载烧入工具。在烧入之前，需要安装 CP210x 串口转 USB 驱动，让设备识别到 ESP32 。</p>
<p>该驱动可以在 <a href="https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers">https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers</a> 处下载，打开网站后点击 DOWNLOAD 页面，选择对应系统的驱动下载即可：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-download-driver.jpg" alt="下载页面" width="420"></figure>
<p>下载完成驱动后，安装对应的驱动文件即可，安装方式就和一般的软件一致：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-install-driver.jpg" alt="安装程序" width="390"></figure>
<p>接下来需要下载 Flash 烧入工具，用来将 MicroPython 烧入到 ESP32 内。烧入软件可以选用乐鑫官方提供的 Flash 下载工具，下载地址在 <a href="https://www.espressif.com/zh-hans/support/download/other-tools">https://www.espressif.com/zh-hans/support/download/other-tools</a> ，或在乐鑫官网找到<strong>支持</strong>→<strong>相关下载</strong>→<strong>工具</strong>：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-download-flash-tool.jpg" alt="下载页面" width="470"></figure>
<p>解压下载得到的文件夹即可。</p>
<p>最后一步是下载 MicroPython 固件。下载的地址为：<a href="https://micropython.org/download/esp32/">https://micropython.org/download/esp32/)</a> ，或在 MicroPython 官网首页找到 <strong>Download</strong>→<strong>ESP32</strong> ：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-download-micropython.jpg" alt="下载页面" width="480"></figure>
<p>一般来说，推荐下载第二新的固件版本。注意下载的是 <code>.bin</code> 格式的固件。</p>
<p>接下来就可以准备将 MicroPython 烧入到 ESP32 设备中。</p>
<p>将 ESP32 使用 microusb 线连接到计算机上，如果 ESP32 开发板上的红色灯亮起，同时计算机的设备检测到串口信息，则证明连接正常：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-download-step-2.jpg" alt="设备管理器窗口" width="570"></figure>
<p>打开 ESP32 的 Flash 烧入工具，在第一个下拉菜单芯片类型中选择 ESP32：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-download-step-1.jpg" alt="软件操作界面" width="200"></figure>
<p>接下来进入到烧入配置界面，其中几个关键的选项已经在图中标示出来了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-download-step-3.jpg" alt="软件操作界面" width="310"></figure>
<ol>
<li>烧入的固件文件，可在右侧省略号按钮选取文件</li>
<li>烧入地址为 <code>0x1000</code></li>
<li>记得勾上要烧入的文件</li>
<li>这些选项保持图示的默认选项即可</li>
<li>波特率以 921600 为佳，上方的端口号注意和 ESP32 的端口号匹配</li>
</ol>
<p>接下来就可以下载固件了。下载前需要先擦除原有内容，<em>按住</em>开发板上的“BOOT”按键，然后点击下载工具左下角的“ERASE”按钮。刚点击时上方绿色矩形里的文字会从“等待/IDLE”变成“等待上电同步/SYNC”，如果文字再次变成“下载中/DOWNLOAD”，那么便可以松开开发板上的“BOOT”按键了。等到文字再次变为“完成/FINISH”，则说明擦除成功。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-download-step-4.jpg" alt="BOOT按键位置" width="330"></figure>
<p>接下来点击下载工具左下角的“START”按钮，类似上一步，在开始下载前也需要按住开发板上的“BOOT”按键。在下载时，下载工具最下方的进度条将会显示当前下载进度。</p>
<p>这样，MicroPython 就烧入完毕了。接下来可以建立第一个MicroPython 工程，同时测试烧入是否正确。</p>
<h3>建立第一个工程</h3>
<p>这里使用 Thonny IDE 作为开发环境。首先可以在官网下载该软件：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-download-step-5.jpg" alt="下载页面" width="450"></figure>
<p>也可以在 GitHub 仓库里找到 Release 版本。这些地址在上文都提到过。</p>
<p>安装成功 Thonny 后，打开软件，接下来还需要进行一些初始化配置。</p>
<p>首先，在菜单栏里找到<strong>运行</strong>→<strong>选择解释器</strong>。之前说过 Thonny 主要用于进行常规 Python 开发，因此如果要将其用于 MicroPython 开发需要修改解释器选项：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-config-step-1.jpg" alt="配置界面" width="360"></figure>
<p>修改解释器为 MicroPython (ESP32) 。该页面中同时可以修改端口配置，如果有时发现识别出现问题，不妨检查一下端口号是否正确。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-config-step-2.jpg" alt="配置界面" width="240"></figure>
<p>接下来，将 ESP32 接入计算机，然后点击功能按钮栏里的“停止/重启后端进程(Ctrl+F2)”：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-config-step-3.jpg" alt="配置界面"></figure>
<p>如果此时在下方的终端(Shell)内看到如下所示的 Python 解释器提示，则说明与 MicroPython 的连接成功：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-config-step-4.jpg" alt="配置界面" width="490"></figure>
<p>如果在打开 Thonny 前就维持着 ESP32 与计算机的连接，那么进入 Thonny 时应该就能看到该提示信息。“停止/重启后端进程(Ctrl+F2)”用于重新使计算机与 ESP32 里的 MicroPython 连接，在每次插拔 ESP32 后都需要这样手动使两者重新连接。</p>
<p>终端(Shell)允许在串口通信中使用 MicroPython 命令行交互窗口。例如：</p>
<div class="hljs codeblock"><pre>MicroPython v1<span class="hljs-number">.17</span> on <span class="hljs-number">2021</span>-09-02; ESP32 module <span class="hljs-keyword">with</span> ESP32
<span class="hljs-type">Type</span> <span class="hljs-string">"help()"</span> <span class="hljs-keyword">for</span> more information.
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">'Hello, world!'</span>)
Hello, world!
</pre></div>
<p><code>print()</code> 函数可以让 ESP32 向计算机通过串口发送调试信息。</p>
<p>MicroPython 还支持以文件的形式运行。新建一个文件后，点击保存（如果 Thonny 成功连接上了 ESP32 的 MicroPython ），那么此时就会出现两个选项，可以将 <code>.py</code> 文件保存在计算机上，还可以将其保存在 ESP32 里：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-first-py.jpg" alt="软件界面" width="260"></figure>
<p>选择将文件保存在 ESP32 内，此时会发现 ESP32 内已经有一个 <code>boot.py</code> 文件了。这里，将文件命名为 <code>main.py</code> 保存。<code>boot.py</code> 和 <code>main.py</code> 是 MicroPython 里的两个比较特殊的文件，将在之后详细介绍。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-save-py.jpg" alt="软件界面" width="500"></figure>
<p>在 <code>main.py</code> 内编写以下代码后保存：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">from</span> machine <span class="hljs-keyword">import</span> Pin
<span class="hljs-keyword">import</span> time
led = Pin(<span class="hljs-number">2</span>, Pin.OUT)
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    led.value(<span class="hljs-number">0</span>)
    time.sleep(<span class="hljs-number">0.5</span>)
    led.value(<span class="hljs-number">1</span>)
    time.sleep(<span class="hljs-number">0.5</span>)
</pre></div>
<p>点击功能按钮栏里的“运行当前脚本(F5)”，即可运行以上代码。运行成功后，可以看到开发板上蓝色的 LED 灯以 0.5 秒为间隔闪烁，说明运行成功。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/08/01-led-flash.jpg" alt="成功截图" width="330"></figure>
<p><code>while</code> 循环可以通过在交互式控制台内按下 <kbd>CTRL+C</kbd> 触发键盘中断退出。如果再次将 ESP32 接入计算机后重启后台进程，一直显示 ESP32 处于繁忙状态或无显示，则可能是由于 ESP32 一直在执行代码导致的，可以通过键盘中断强制停止 MicroPython 的执行。</p>
<p><a rel="nofollow" href="/archives/673">ESP32与MicroPython入门-01 搭建开发环境</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/673/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>STM32与物联网02-网络数据收发</title>
		<link>/archives/519</link>
					<comments>/archives/519#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 15 Jul 2022 02:13:17 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[ESP8266]]></category>
		<category><![CDATA[STM32]]></category>
		<category><![CDATA[物联网]]></category>
		<guid isPermaLink="false">/?p=519</guid>

					<description><![CDATA[<p>在上一节中，介绍了 ESP8266 的使用方法。不过&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/519">STM32与物联网02-网络数据收发</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>在<a href="/archives/496">上一节</a>中，介绍了 ESP8266 的使用方法。不过上一节中都是通过串口调试工具手动发送信息的方式来操作 ESP8266 ，这肯定不能用于实际开发。因此，本节介绍如何编写合适的程序来和 ESP8266 交互，从而收发并解析网络数据。</p>
<h2>TCP服务器</h2>
<p>在 TCP 服务器下，可以使用移动设备主动连接 ESP8266 提供的 WiFi 。如果编写正确的程序，那么可以使用移动设备控制 ESP8266 。</p>
<h3>建立TCP服务器</h3>
<p>从上一节的介绍可以了解到，程序和 ESP8266 的交互主要是通过发送 AT 指令完成的，因此程序中首要的任务就是编写合适的程序向 ESP8266 发送指令。</p>
<p>不过在发送指令后，可能还需要判断指令是否被成功接收。一般来说，ESP8266 执行失败时可能返回各种信息，但在成功执行指令后都会返回 OK 。发送指令可以通过以下函数完成：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">ESP8266_SendCmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* cmd, <span class="hljs-keyword">uint8_t</span> timeout)</span> </span>{
    ESP8266_Buffer.Length = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(ESP8266_Buffer.Body, <span class="hljs-number">0</span>, USART_RX_BUF_SIZE);
    <span class="hljs-built_in">USART_printf</span>(USART3, <span class="hljs-string">"%s\r\n"</span>, cmd);
    <span class="hljs-keyword">while</span> (timeout--) {
        <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">100</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"OK"</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</pre></div>
<p>由于不同指令处理的时间也不一致，因此在程序中引入了一个倒计时器，在倒计时结束前不断检查接收到的信息中是否包含 <code>"OK"</code> ，如果是则结束当前倒计时，这样可以确保在指令执行完后就可以立即退出延时，提高程序执行效率。</p>
<p>程序中与 ESP8266 交互基本是都采用这种方式。例如，在程序下载后若希望使 ESP8266 也重启，则可以通过拉低 RST 引脚复位 ESP8266 ，复位后会接到 <code>"ready"</code> 信息，则可以编写以下函数：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">ESP8266_Reset</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> timeout)</span> </span>{
    <span class="hljs-built_in">ESP8266_RST</span>(RESET);
    <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">500</span>);
    <span class="hljs-built_in">ESP8266_RST</span>(SET);
    <span class="hljs-keyword">while</span> (timeout--) {
        <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">100</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"ready"</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</pre></div>
<p>如果某条指令有其余回复的情况，只需要参照以上略做修改即可。</p>
<p>有了以上函数后，就可以编写代码，逐条发送指令了。这里将 ESP8266 设置为 AP 模式，使其变成一个 WiFi 热点，使计算机可以直接连接上 ESP8266 并收发信息，因此首先需要发送 <code>AT+CWMODE=2</code> 指令：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_Reset</span>(<span class="hljs-number">50</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_SendCmd</span>(<span class="hljs-string">"AT+CWMODE=2"</span>, <span class="hljs-number">50</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
</pre></div>
<p>然后可以使用 <code>AT+CWSAP="&lt;ssid&gt;","&lt;password&gt;",&lt;chl&gt;,&lt;enc&gt;</code> 设置 WiFi 参数，一般来说通道号和加密类型都设置为 4 即可：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">char</span> cmd[<span class="hljs-number">64</span>];
<span class="hljs-built_in">sprintf</span>(cmd, <span class="hljs-string">"AT+CWSAP=\"%s\",\"%s\",%d,%d\r\n"</span>, SSID, PASSWORD, <span class="hljs-number">4</span>, WPA_WPA2_PSK);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_SendCmd</span>(cmd, <span class="hljs-number">50</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
</pre></div>
<p>可以将这些参数设置为宏定义以方便修改。接下来的许多设置都和以上代码类似，可以以此为模板替换为其它命令，因此不再展示代码，仅介绍主要命令。</p>
<p>如果要设置固定的局域网 IP ，可以通过 <code>AT+CIPAP="&lt;ip&gt;"</code> 完成。</p>
<p>接下来可以通过指令 <code>AT+CIPMODE=&lt;mode&gt;</code> 设置 ESP8266 的传输模式。该命令可以设置 ESP8266 的两种传输模式：</p>
<ol start="0">
<li>普通传输模式(Normal Transmission Mode)，该模式下，用户可以通过 AT 指令发送 TCP 数据，同时 ESP8266 也会将接收到的数据以 +IPD 等指令的形式返回</li>
<li>透传接收模式(Passthrough Receiving Mode)：该模式下，ESP8266 无法发送 TCP 数据，同时 ESP8266 会将接收到的数据以原始的形式返回给 STM32</li>
</ol>
<p>透传接收模式一般用于开启透传模式。关于透传模式会在后续介绍。</p>
<p>ESP8266 支持多路连接，即一个 TCP 端口可以建立多个连接。通过 <code>AT+CIPMUX=1</code> 可以启用多连接，每个连接到端口上的客户端通过 <code>&lt;id&gt;</code> 标识，连接的数量最后为 5 个，因此 <code>&lt;id&gt;</code> 的取值范围为 0~4 。</p>
<p>多连接必须在所有连接都断开且服务器也关闭时才可以设置，并且只有普通传输模式下才能设置为多连接。</p>
<p>接下来，可以通过 <code>AT+CIPSERVER=1,8266</code> 开启一个位于端口 8266 上的 TCP 服务器。根据以上步骤，TCP 服务器便建立完成，可以准备接收客户端发来的数据了。</p>
<h3>数据获取与解析</h3>
<p>在建立了 TCP 服务器后，ESP8266 便会等待客户端的连接。</p>
<p>TCP 客户端在接到客户端的数据时，会以 <code>+IPD,&lt;id&gt;,&lt;len&gt;:&lt;data&gt;</code> 的指令形式转交数据给 STM32 。由于以上开启了多路连接，因此接收的数据中多了一个字段 <code>&lt;id&gt;</code> 。</p>
<p>因此判断是否有数据收到也很简单，只需要判断接收缓冲区内是否有子串 <code>"+IPD"</code> 即可：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ESP8266_HasData</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body,<span class="hljs-string">"+IPD"</span>) 
        &amp;&amp; <span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body,<span class="hljs-string">":"</span>);
}
</pre></div>
<p>以上同时查找子串 <code>":"</code> 确保数据有效性。根据以上格式，拆解该字符串并截取有效数据如下：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">int8_t</span> <span class="hljs-title">ESP8266_MuxGetData</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* data, <span class="hljs-keyword">uint16_t</span>* len)</span> </span>{
    <span class="hljs-keyword">uint8_t</span> id;
    <span class="hljs-keyword">char</span>* data_ptr = <span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"+IPD"</span>);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(data_ptr,<span class="hljs-string">"+IPD,%d,%d"</span>, &amp;id, len) == <span class="hljs-number">2</span>) {
        <span class="hljs-built_in">memcpy</span>(data, <span class="hljs-built_in">strstr</span>(data_ptr, <span class="hljs-string">":"</span>) + <span class="hljs-number">1</span>, *len);
        data[*len] = <span class="hljs-string">'\0'</span>;
        ESP8266_Buffer.Length = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">memset</span>(ESP8266_Buffer.Body, <span class="hljs-number">0</span>, USART_RX_BUF_SIZE);
        <span class="hljs-keyword">return</span> id;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</pre></div>
<p>以上函数略显复杂。之所以要这么复杂，主要有以下两个方面的原因：<code>scanf()</code> 类函数使用字符串转换说明时，它在读入数据时如果遇到一个空格或回车符，会丢弃后面的所有数据，这显然不能用于截取用户数据。</p>
<p>另外上一节说过工程中接收串口传来的不定长数据的方式是使用串口空闲中断，然而空闲中断接收的一包数据并不都是符合期望的一包数据：在接收到 TCP 连接时，ESP8266 会发送 <code>&lt;id&gt;,CONNECT</code> 表示连接已建立，如果此时建立的连接接收到任何数据，ESP8266 也会立即转发该数据。因此如果连接建立后马上收到数据，那么两次发送的数据时间相隔过短，可能会没有引起空闲中断而被 STM32 认为是同一包数据。在连接取消时，也有同样的问题。</p>
<p>不过发送数据的函数可能更加复杂：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">ESP8266_MuxSendData</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* data, <span class="hljs-keyword">uint16_t</span> length, <span class="hljs-keyword">uint8_t</span> id, <span class="hljs-keyword">uint8_t</span> timeout)</span> </span>{
    <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
    <span class="hljs-built_in">USART_printf</span>(USART3, <span class="hljs-string">"AT+CIPSEND=%d,%d\r\n"</span>, id, length);
    <span class="hljs-keyword">while</span> (timeout--) {
        <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">10</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"&gt;"</span>))
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">if</span> (timeout &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
        <span class="hljs-built_in">USART_SendBytes</span>(USART3, data, length);
        <span class="hljs-keyword">while</span> (timeout--) {
            <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">10</span>);
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"SEND OK"</span>)) {
                <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"link is not valid"</span>)) {
                <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
    }
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</pre></div>
<p>上一节介绍了发送数据主要使用 <code>AT+CIPSEND</code> 指令完成（多连接下需要一个额外的字段指示发送给的 <code>&lt;id&gt;</code> ），如果可以发送 ESP8266 会返回 <code>"&gt; "</code> 作提示。如果发送成功，ESP8266 会返回 <code>"SEND OK"</code> ，通过返回提示就可以知道发送状态。</p>
<p>有了以上函数以后，就可以着手编写主程序了。主程序的处理逻辑非常简单，在建立 TCP 服务器后，便不断判断是否有数据到达，如果有那么便读取数据并回复信息：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">char</span> ipd_data[<span class="hljs-number">512</span>];
<span class="hljs-keyword">int8_t</span> ipd_id;
<span class="hljs-keyword">uint16_t</span> ipd_len;
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">ESP8266_CreateTcpServer</span>())
    <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">200</span>);
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_HasData</span>()) {
        ipd_id = <span class="hljs-built_in">ESP8266_MuxGetData</span>(ipd_data, &amp;ipd_len);
        <span class="hljs-built_in">ESP8266_MuxSendData</span>(<span class="hljs-string">"Acknowledge"</span>, <span class="hljs-number">12</span>, ipd_id, <span class="hljs-number">30</span>);
    }
    <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">500</span>);
}
</pre></div>
<p>可以将得到的数据显示在串口中。在计算机客户端，编写如下套接字程序：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">import</span> socket, time
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((<span class="hljs-string">'192.168.10.1'</span>, <span class="hljs-number">8266</span>))
client.send(time.ctime().encode())
message = client.recv(<span class="hljs-number">1024</span>)
<span class="hljs-built_in">print</span>(message.decode())
client.close()
</pre></div>
<p>将计算机连接到 ESP8266 创建的 WiFi 上并运行该套接字程序，即可观察到实验现象。如果为程序编写合适的用户界面并在 STM32 上进一步解析数据，那么便可以实现手机端控制 STM32 了。</p>
<h2>TCP客户端与HTTP请求</h2>
<p>TCP 客户端的建立与 TCP 服务器类似，这里先使 ESP8266 连接到路由器，借助路由器访问公网上的服务器。</p>
<p>前几步操作与 TCP 客户端类似：在复位 ESP8266 后，首先通过指令 <code>AT+CWMODE=1</code> 设置 Sta 模式，然后通过 <code>AT+CWJAP="&lt;ssid&gt;","&lt;password&gt;"</code> 连接到路由器中。由于客户端无需多个连接，可以使用 <code>AT+CIPMUX=0</code> 关闭多连接。</p>
<p>本次采用透传模式(Passthrough Mode)来收发数据。透传模式是一种特殊的收发数据模式，在透传模式下，用户不能发送 AT 指令，发送的任何数据都会作为原始的数据发送到传输对端；从传输对端收到的数据也会不经由任何 <code>+IPD</code> 封装而原封不动地返回给 STM32 。</p>
<p>使用 <code>AT+CIPMODE=1</code> 可以设置传输模式为透传模式。通过 <code>AT+CIPSTART</code> 连接上服务器后，直接执行 <code>AT+CIPSEND</code> ，待 ESP8266 返回 <code>"&gt;"</code> 后就进入了透传模式。透传模式下，每包数据以 20ms 间隔区分，每包最大 2048 字节，发送和接收数据都不需要封装成指令，方便处理。</p>
<p>正常退出透传模式的唯一方式就是单独发送一包发送指令 <code>+++</code> 。</p>
<p>根据以上原理，可以使用 STM32 发送相应指令，连接到服务器后进入透传模式，并准备发送相应的数据。其代码和上文服务端类似，例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_Reset</span>(<span class="hljs-number">50</span>))
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_SendCmd</span>(<span class="hljs-string">"AT+CWMODE=1"</span>, <span class="hljs-number">20</span>))
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
<span class="hljs-keyword">if</span> (<span class="hljs-built_in">ESP8266_SendCmd</span>(<span class="hljs-string">"AT+CWJAP=\"TP_LINK\",\"abc123456\""</span>, <span class="hljs-number">100</span>))
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
<span class="hljs-comment">// ... and so on</span>
</pre></div>
<p>当然，考虑到一些指令执行成功时不总是返回 <code>OK</code> ，并且为了使程序逻辑更清晰，可以将一些指令封装成函数。例如，以下函数根据地址（可以是 IP 地址或域名，DNS 解析将自动完成）和端口号，连接到特定的 TCP 服务器中并进入透传模式：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint8_t</span> <span class="hljs-title">ESP8266_ConnectServer</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* address, <span class="hljs-keyword">uint16_t</span> port, <span class="hljs-keyword">uint8_t</span> timeout)</span> </span>{
    <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
    <span class="hljs-built_in">USART_printf</span>(USART3, <span class="hljs-string">"AT+CIPSTART=\"TCP\",\"%s\",%d\r\n"</span>, address, port);
    <span class="hljs-keyword">while</span> (timeout--) {
        <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">100</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"CONNECT"</span>)) {
            <span class="hljs-built_in">ESP8266_ClearBuffer</span>();
            <span class="hljs-built_in">USART_printf</span>(USART3, <span class="hljs-string">"AT+CIPSEND\r\n"</span>);
            <span class="hljs-keyword">while</span> (timeout--) {
                <span class="hljs-built_in">delay_ms</span>(<span class="hljs-number">100</span>);
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"\r\nOK\r\n\r\n&gt;"</span>))
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"CLOSED"</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ESP8266_Buffer.Body, <span class="hljs-string">"ALREADY CONNECTED"</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
}
</pre></div>
<p>可以仿照该函数将其它指令封装成具有抽象功能的对应函数。</p>
<p>在本示例中，在使用 TCP 连接到远程服务器的 80 端口的基础上，手动构造合适的 HTTP 请求并发送：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) {
    <span class="hljs-built_in">USART_SendString</span>(USART3, <span class="hljs-string">"GET /api/temperature?time=now HTTP/1.1\r\n"</span>
                            <span class="hljs-string">"Connection: keep-alive\r\n"</span>
                            <span class="hljs-string">"Host: 192.168.1.105:80\r\n\r\n"</span>);
    <span class="hljs-built_in">delay_s</span>(<span class="hljs-number">5</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, ESP8266_Buffer.Body);
}
</pre></div>
<p>这里 5 秒钟便查询一次数据。如果间隔过长，连接可能断开，那么可以先主动断开连接，等需要查询时再发起 TCP 连接。</p>
<p>通过 HTTP 服务器提供的合适接口，ESP8266 便可以从互联网中获取到非常广泛的数据。在测试用的服务器中，该接口返回一个 json 响应并被转发到 STM32 中，串口调试工具中显示的原始数据如下：</p>

<div class="codeblock code-console">HTTP/1.1 200 OK
Date: Wed, 13 Jul 2022 10:57:48 GMT
Server: WSGIServer/0.2 CPython/3.9.1
Content-Type: application/json
X-Frame-Options: DENY
Content-Length: 93
X-Content-Type-Options: nosniff
Referrer-Policy: same-origin

{"temperature": {"high": 37.6, "low": 28.1, "now": 36.7}, "humidity": "50%", "wind": "11mph"}
</div>
<p>通过解析请求头 <code>Content-Length</code> 就可以获取数据的长度，然后查找子串 <code>"{"</code> 的位置便可以提取出接口返回的 json 数据，并可以使用 cJSON 等第三方库解析其中的数据。互联网中存在许多类似的接口，只需要构造合适的请求头，便可以抓取很多有用的信息，不过这需要有一定的抓包或爬虫的基础。</p>
<p>通过路由器可以接入互联网，在 TCP 服务的基础上，构造出合适的 HTTP 等应用层协议的封装，便可以采集互联网中的各种数据，或者向服务器报告自身传感器的数据，由此真正实现物联网的基础。</p>
<p>例如，可以向 HTTP 服务器提供的接口发送 POST 请求，将传感器数据作为参数发送给服务器，服务器解析 POST 请求并更新数据库，然后便可以显示在前端上，这样便可以在任何地点查看 STM32 的状态了。不过由于其实现涉及到的知识点过于广泛，无论是环境的配置还是程序的编写都不是一篇文章能完整介绍的，这里便不再涉及。</p>
<p>一个比较有趣的实现是利用 SMTP 发送电子邮件，可以阅读<a href="/archives/403#email">这篇文章</a>了解 SMTP 应用层协议的原理与基本报文格式，文章中附带了 Python 套接字程序实现，它和 AT 指令的思路具有一定相似性，移植到 STM32 的主要难点是使用 base64 编码完成身份验证，有兴趣的读者可以尝试自行实现。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.espressif.com/projects/esp-at/en/release-v2.2.0.0_esp8266/AT_Command_Set/TCP-IP_AT_Commands.html">https://docs.espressif.com/projects/esp-at/en/release-v2.2.0.0_esp8266/AT_Command_Set/TCP-IP_AT_Commands.html</a><br>TCP/IP 相关 AT 指令集的官方文档。<!-- 讲道理使用 AT 指令真的该读读文档，我 google 时发现很多关于 ESP8266 使用的介绍都是错误的。 --></p>
<p><a rel="nofollow" href="/archives/519">STM32与物联网02-网络数据收发</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/519/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>STM32与物联网01-ESP8266基本操作</title>
		<link>/archives/496</link>
					<comments>/archives/496#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 11 Jul 2022 13:47:08 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[ESP8266]]></category>
		<category><![CDATA[STM32]]></category>
		<category><![CDATA[物联网]]></category>
		<guid isPermaLink="false">/?p=496</guid>

					<description><![CDATA[<p>ESP8266物联网简介 ESP8266简介 ESP&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/496">STM32与物联网01-ESP8266基本操作</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>ESP8266物联网简介</h2>

<h3>ESP8266简介</h3>

<p>ESP8266 是上海乐鑫公司开发的一款具有 WiFi 功能的控制芯片，它带有完整的 TCP/IP 协议栈，因此可以用作物联网开发。</p>

<p>ESP8266 本身也是一个性能不错的 32 位微控制器，完全可以作为普通的 MCU 使用。然而，考虑到 ESP8266 作为 MCU 时需要一整套开发环境，且 ESP8266 的外设并不算丰富，因此这里仅将其作为一个普通外围器件使用，通过 STM32 等 MCU 控制它并接收 ESP8266 收到的网络数据。</p>

<p>在作为外围模块使用时，ESP8266 主要通过串口收发命令和数据，因此任意可以使用串口并设置波特率的 MCU 理论上都可以操作 ESP8266 实现物联网功能，包括但不限于 51 单片机、AVR 、STM32 和树莓派。</p>

<p>这里选用 ESP-01 作为 WiFi 模块，其外观为：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/07/esp8266-appearance.png" alt="" width="220">
    <figcaption>ESP-01S模块</figcaption>
</figure>

<p>它具有的优点为：</p>

<ol>
    <li>价格非常低廉，仅需个位数</li>
    <li>尺寸很小，大约为 25mm x 15mm</li>
    <li>功能完善，它本身也是一个微型开发板，具有 8 个引脚，可以实现程序下载、串口收发等功能</li>
    <li>市面上大多数 ESP-01 模块在售卖时已经内置了串口控制程序，上电后便可以正常工作。如果没有也不要紧，只需再花个位数价格就可以再买一个 ESP8266 固件下载器，结合商家给出的资料就可以重新烧入固件</li>
</ol>

<p>在详细介绍 ESP8266 的使用方法之前，最好先了解以下背景知识：</p>

<p>ESP8266 所使用的 WiFi 是工作频率在 2.4GHz 波段的局域网无线通信。有些笔记本电脑或路由器默认使用的是 5GHz 的网络频段，如果不修改将会无法与 ESP8266 连接上。</p>

<p>ESP8266 支持两种 WiFi 通信模式：AP 和 Sta 。AP 表示接入点(access point)，可以创建一个 WiFi 热点让其余设备连接，一般作为局域网服务器使用；Sta 表示连接设备，该模式下 ESP8266 可以主动连接其它 WiFi 信号，一般作为局域网客户端使用。不过 ESP8266 支持 Sta 和 AP 两模式共存，可以在连接 WiFi 的同时被其余设备连接。</p>

<p>在 ESP-01 模块中，具有 8 个引脚，各个引脚的作用为：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/07/esp8266-pins.png" alt="" width="170">
</figure>

<table>
    <tr>
        <th>序号</th>
        <th>名称</th>
        <th>功能</th>
    </tr>
    <tr>
        <td>1</td>
        <td><code>GND</code></td>
        <td>接地</td>
    </tr>
    <tr>
        <td>2</td>
        <td><code>GPIO 2</code></td>
        <td>通用输入输出（内部已上拉）</td>
    </tr>
    <tr>
        <td>3</td>
        <td><code>GPIO 0</code></td>
        <td>选择模式：低电平为下载模式，未连接或高电平为正常工作模式</td>
    </tr>
    <tr>
        <td>4</td>
        <td><code>RXD</code></td>
        <td>串口 0 数据接收，也可用作普通 GPIO</td>
    </tr>
    <tr>
        <td>5</td>
        <td><code>VCC</code></td>
        <td>3.3V 供电</td>
    </tr>
    <tr>
        <td>6</td>
        <td><code>RST</code></td>
        <td>复位线，若通过外部置为低电平则复位</td>
    </tr>
    <tr>
        <td>7</td>
        <td><code>CH_PD</code></td>
        <td>高电平使能芯片，低电平失能芯片</td>
    </tr>
    <tr>
        <td>8</td>
        <td><code>TXD</code></td>
        <td>串口 0 数据发送，也可用作普通 GPIO</td>
    </tr>
</table>

<p>接下来的程序使用基于 STM32 的标准库编写，并可以比较容易地修改为 HAL 库的代码，或使用其余类似的单片机编写作用相似的代码。</p>

<h3>串口接收不定长数据方法</h3>

<p>在正式介绍 ESP8266 操作方法之前，首先介绍一个基本的要点：如何使用串口接收 ESP8266 可能发来的不定长数据并解析。</p>

<p>不定长数据的接收方法有很多，例如可以通过空字符确定结尾。这里使用串口的空闲中断实现该方法，空闲中断的的产生是由于在两次数据发送间隔，串口没有检测到数据输入而产生的，从而可以判断数据接收完毕，停止接收数据。</p>

<p>首先，为了保存接收数据，需要定义一个缓冲区。这里通过一个结构体的形式确定缓冲区所需成员：</p>

<div class="vscode-block"><div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span> <span style="color: #4876d6;">USART_RX_BUF_SIZE</span> <span style="color: #aa0982;">1024</span></div><div><span style="color: #994cc3;">typedef</span> <span style="color: #994cc3;font-weight: bold;">struct</span><span style="color: #403f53;"> {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">char</span> <span style="color: #0c969b;">Body</span><span style="color: #403f53;">[</span><span style="color: #4876d6;">USART_RX_BUF_SIZE</span><span style="color: #403f53;">];</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;font-weight: bold;">uint16_t</span> <span style="color: #0c969b;">Length</span><span style="color: #403f53;"> &#160; &#160; :</span><span style="color: #aa0982;">15</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;font-weight: bold;">uint16_t</span> <span style="color: #0c969b;">FinishFlag</span><span style="color: #403f53;"> :</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">} </span><span style="color: #4876d6;">USART_Buffer</span><span style="color: #403f53;">;</span></div></div>

<p>注意，由于不总是在中断函数内处理接收数据，因此需要一个比特的字段用于判断数据是否接收完毕。</p>

<p>为了接收串口空闲中断，需要先在初始化函数内使能它：</p>

<div class="vscode-block"><div><span style="color: #994cc3;font-weight: bold;">void</span> <span style="color: #4876d6;">USART_Config</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;"> ...</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">USART_ITConfig(</span><span style="color: #4876d6;">USART3</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">USART_IT_IDLE</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">ENABLE</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">}</span></div></div>

<p>对应的串口中断函数的实现如下：</p>

<div class="vscode-block"><div><span style="color: #4876d6;">USART_Buffer</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">;</span></div><div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">USART3_IRQHandler</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">USART_GetITStatus(</span><span style="color: #4876d6;">USART3</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">USART_IT_RXNE</span><span style="color: #4876d6;">)</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">!=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">RESET</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Length</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">&lt;</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">USART_RX_BUF_SIZE</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">-</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">))</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Body</span><span style="color: #403f53;">[</span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Length</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">] </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> (</span><span style="color: #994cc3;font-weight: bold;">char</span><span style="color: #403f53;">)</span><span style="color: #4876d6;">USART_ReceiveData(</span><span style="color: #4876d6;">USART3</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; }</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">USART_GetITStatus(</span><span style="color: #4876d6;">USART3</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">USART_IT_IDLE</span><span style="color: #4876d6;">)</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">!=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">RESET</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">FinishFlag</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Body</span><span style="color: #403f53;">[</span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Length</span><span style="color: #403f53;">] </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #111111;">'</span><span style="color: #aa0982;">\0</span><span style="color: #111111;">'</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">volatile</span><span style="color: #403f53;"> </span><span style="color: #4876d6;font-weight: bold;">uint16_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">temp</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">temp</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">USART3</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">SR</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">temp</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">USART3</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">DR</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; </span><span style="color: #4876d6;">ESP8266_FrameFinish_CallBack()</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; }</span></div><div><span style="color: #403f53;">}</span></div></div>

<p>在串口中断函数中，对以下两个中断类型响应：<code>USART_IT_RXNE</code> 表示数据接收寄存器收到内容，那么将接收到的内容作为一个字符放入缓冲区中；<code>USART_IT_IDLE</code> 表示数据包接收完毕，在缓冲器结尾添加上一个空字符使其变为字符串，并将结束标志位置 1 。</p>

<p>注意在不接收中断时，串口空闲中断会一直产生，从而干扰程序运行；清除串口空闲中断标志位需要由软件完成，具体做法是通过程序先读取 <var type="register">USART_SR</var> 寄存器，再读取 <var type="register">USART_DR</var> 寄存器。</p>

<p>在程序的最后使用一个回调函数来处理本次接收的数据包，它可以根据当前项目的使用情况自行编写或替换为相应的语句。</p>

<h2>ESP8266基本使用</h2>

<h3>设备连接与初始化</h3>

<p>根据上文的介绍，单片机最少需要 4 个 I/O 口与 ESP8266 相连：这里选用 USART3 作为与 ESP8266 通信的串口，则 <var type="pin">PB10</var> 与 ESP8266 的 RXD 相连，<var type="pin">PB11</var> 与 TXD 相连；<var type="pin">PA4</var> 与 RST 相连，<var type="pin">PA5</var> 与 CH_PD 相连：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/07/esp8266-pin-connect.png" alt="" width="230">
</figure>

<p>这里主要通过以下两个宏操作引脚：</p>

<div class="vscode-block"><div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_RST</span><span style="color: #111111;">(</span><span style="color: #403f53;">state</span><span style="color: #111111;">)</span><span style="color: #403f53;"> &#160; </span><span style="color: #4876d6;">GPIO_WriteBit</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">GPIOA</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">GPIO_Pin_4</span><span style="color: #403f53;">, (</span><span style="color: #4876d6;">BitAction</span><span style="color: #403f53;">)state)</span></div><div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_CH_PD</span><span style="color: #111111;">(</span><span style="color: #403f53;">state</span><span style="color: #111111;">)</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">GPIO_WriteBit</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">GPIOA</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">GPIO_Pin_5</span><span style="color: #403f53;">, (</span><span style="color: #4876d6;">BitAction</span><span style="color: #403f53;">)state)</span></div></div>

<p>本节先介绍一个最简单的、手动操作 ESP8266 的方式演示操作的整个过程：通过计算机的串口调试工具将命令发送给 STM32 ，STM32 接收后转发给 ESP8266 ，并将接收到的数据再转发给串口调试工具：</p>

<figure>
    <img decoding="async" src="/wp-content/uploads/2022/07/esp8266-connect-debug.png" alt="" width="480">
</figure>

<p>因此，在初始化 ESP8266 时需要初始化相应的 GPIO 及两个 USART 外设，并将 RST 和 CH_PD 都置高电平：</p>

<div class="vscode-block"><div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_Init</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_GPIO_Config()</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_USART_Config()</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_RST</span><span style="color: #4876d6;">(</span><span style="color: #4876d6;">SET</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_CH_PD</span><span style="color: #4876d6;">(</span><span style="color: #4876d6;">SET</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">}</span></div></div>

<p>注意，初始化 STM32 连接到 ESP8266 的串口时，需要将波特率设置为 115200 ，否则数据无法被正常接收。当连接上 ESP8266 后，可以通过后续发送指令修改 ESP8266 的串口波特率。</p>

<p>除此之外，还有一些其它的外设如定时器、调试用串口等，其使用情况可以根据项目需要自行管理，对应的初始化过程不再介绍。</p>

<p>在串口 3 中断中，将接收到的 ESP8266 数据转发回串口调试工具：</p>

<div class="vscode-block"><div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">ESP8266_FrameFinish_CallBack</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">printf(</span><span style="color: #111111;">"</span><span style="color: #4876d6;">%s</span><span style="color: #111111;">"</span><span style="color: #4876d6;">, </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #4876d6;">.</span><span style="color: #0c969b;">Body</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">FinishFlag</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">ESP8266_Buffer</span><span style="color: #403f53;">.</span><span style="color: #0c969b;">Length</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">;</span></div><div><span style="color: #403f53;">}</span></div></div>

<p>串口 1 的中断处理过程与以上类似，这里不再重复。</p>

<h3>AT指令简介</h3>

<p>既然是使用串口通信的方式操作 ESP8266 ，那么收、发数据都需要遵循一定格式。ESP8266 的固件内置了 AT 指令，可以通过串口发送 AT 指令控制 ESP8266 。</p>

<p>所谓 AT 指令，是一种字符串形式的数据，但开头都是 <code>AT</code> 两个字符，后续跟上具体的选项。AT 指令有以下 4 种主要的表现形式：</p>

<table>
    <tr>
        <th>指令类型</th>
        <th>指令格式</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>测试指令</td>
        <td>AT+&lt;x&gt;=?</td>
        <td>用于查询设置命令或内部程序设置的参数以及其取值范围</td>
    </tr>
    <tr>
        <td>查询指令</td>
        <td>AT+&lt;x&gt;?</td>
        <td>用于查询参数当前设置的值</td>
    </tr>
    <tr>
        <td>设置命令</td>
        <td>AT+&lt;x&gt;=&lt;...&gt;</td>
        <td>用于设置用户自定义的参数值</td>
    </tr>
    <tr>
        <td>执行指令</td>
        <td>AT+&lt;x&gt;</td>
        <td>用于执行受模块内部程序控制的变参数不可变的功能</td>
    </tr>
</table>

<p>每一个 AT 指令以换行符 CRLF <code>\r\n</code> 作为结尾的标志，在串口调试工具中需要另起一行。</p>

<p>AT 指令很多，但是并不是每一个都会用得到。这里仅介绍需要的 AT 指令，完整的 AT 指令可以从文档中查看。</p>

<blockquote>
    <p>注意，某些厂商在生产开发板时，可能会对 AT 固件做一些裁剪，去除一些用处不大的指令，因此在使用时请阅读商家提供的说明文档。</p>
</blockquote>

<p>最简单的 AT 指令就是单个 <code>AT</code> ，用于测试 AT 固件是否能用。如果能用，ESP8266 会返回 <code>OK</code> ：</p>

<div class="codeblock code-console"><span class="codetoken command">AT</span>
AT


OK</div>

<p>上面发送了一个指令 <code>AT</code> ，而 ESP8266 则先回复了指令内容 <code>AT</code> ，再回复一个 <code>OK</code> ，这种先复述指令内容再发送有效数据的方式称为回显。回显会在一定程度上影响数据解析，并且在设计时 STM32 在接到串口调试工具发送的消息时已经执行了一次回显操作，因此可以使用 <code>ATE0</code> 指令关闭回显：</p>

<div class="codeblock code-console"><span class="codetoken command">ATE0</span>
ATE0


OK
<span class="codetoken command">AT</span>

OK</div>

<p>这样后续发送指令时只会回复有效数据了。在后续的操作中全部关闭回显，命令都是通过 STM32 收到后立即转发回来的。</p>

<p>可以使用 <code>AT+GMR</code> 查看当前固件的版本信息：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+GMR</span>

AT version:0.22.0.0(Mar 20 2015 10:04:26)
SDK version:1.0.0
compile time:Mar 20 2015 11:00:32

OK</div>

<p>如果固件版本过旧，可能也会缺少一些命令。可以使用专用的固件烧入模块通过 USB 为 ESP8266 更新固件。</p>

<p>上文曾经提到 ESP8266 有两种主要的工作模式：Sta 和 AP 。可以使用 <code>AT+CWMODE=&lt;mode&gt;</code> 设置 ESP8266 的通信模式：参数 <code>&lt;mode&gt;</code> 为 <code>1</code> 代表 ESP8266 设置为 Sta 模式；<code>2</code> 代表设置为 AP 模式；参数 <code>3</code> 则是 Sta 模式和 AP 模式共存。</p>

<p>这里将其设置为 Sta 模式，主动连接路由器或笔记本提供的 WiFi ：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CWMODE=1</span>


OK</div>

<p>在 Sta 模式下，可以使用执行命令 <code>AT+CWLAP</code> 列出(List)当前环境下可用的 WiFi 接入点：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CWLAP</span>

+CWLAP:(4,"Laptop",-54,"ac:4e:aa:b2:1f:f2",1)
+CWLAP:(4,"TP-LINK",-28,"51:38:39:a8:d5:e0",1)
+CWLAP:(4,"Mobile",-86,"a8:79:4b:22:42:e6",11)

OK</div>

<p>返回的结果中，每项数据都占一行，有 5 个元素，第一个元素 <code>&lt;ecn&gt;</code> 列出了 WiFi 所使用的加密类型，值 <code>4</code> 代表加密类型为 WPA_WPA2_PSK ；第二个元素 <code>&lt;ssid&gt;</code> 代表 WiFi 名，第三个元素 <code>&lt;rssi&gt;</code> 代表 WiFi 强度，绝对值越小强度越高；第四个元素 <code>&lt;mac&gt;</code> 是设备的 MAC 地址；最后一个元素 <code>&lt;channel&gt;</code> 代表频道。</p>

<blockquote>
    <p>注意，ESP8266 返回的数据都是 UTF-8 编码的，需要将串口调试工具的编码也设置为 UTF-8 ，否则可能出现中文乱码。</p>
</blockquote>

<p>连接(Join) WiFi 可以通过以下命令执行：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CWJAP="TP-LINK","abc123456"</span>


OK</div>

<p>WiFi 名和密码都要以字符串的形式放在双引号内，两者间使用逗号隔开。</p>

<p>连接到 WiFi 后，可以使用 <code>AT+CIFSR</code> 命令查看当前设备的 IP 地址：</p>

<div class="codeblock code-console">AT+CIFSR

+CIFSR:STAIP,"192.168.137.129"
+CIFSR:STAMAC,"65:e8:db:a5:9b:84"

OK</div>

<p>更多的 AT 指令及其用法可以参考官方文档。接下来介绍 ESP8266 从连接 WiFi 到接收网络数据的常用过程。</p>

<h3>WiFi连接与数据收发测试</h3>

<p>以下测试也全部在串口调试工具中发送命令与接收数据。</p>

<p>首先提前设置好 WiFi 名和密码，然后让 ESP8266 主动连接 WiFi ：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CWMODE=1</span>


OK
<span class="codetoken command">AT+CWJAP="TP-LINK","abc123456"</span>


OK</div>

<p>这里将计算机和 ESP8266 都主动连接到路由器提供的 WiFi 中，两者处于同一个局域网内，这样便可以比较方便地互发数据。</p>

<p>连接后，需要在计算机中查看本机在局域网内的地址：(IPv4 Address)</p>

<div class="codeblock code-console"><span class="codetoken prompt">C:\Users\Hello></span> <span class="codetoken command">ipconfig</span>

Windows IP Configuration

Wireless LAN adapter WLAN:

    Connection-specific DNS Suffix  . :
    IPv4 Address. . . . . . . . . . . : 192.168.1.105
    Subnet Mask . . . . . . . . . . . : 255.255.255.0
    Default Gateway . . . . . . . . . : 192.168.1.1
</div>

<p>以下通过 ESP8266 主动向计算机发起连接，并发送查询当前时间的命令；计算机接到命令后，向 ESP8266 返回当前的时间。在计算机的客户端，使用 Python 编写如下套接字程序：</p>

<div class="vscode-block"><div><span style="color: #994cc3;font-weight: bold;">import</span><span style="color: #403f53;"> socket, time</span></div><div><span style="color: #403f53;">server </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> socket.</span><span style="color: #0c969b;">socket</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">socket.AF_INET</span><span style="color: #111111;">,</span><span style="color: #4876d6;"> socket.SOCK_STREAM</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">server.</span><span style="color: #0c969b;">bind</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">(</span><span style="color: #111111;">''</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">12000</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">server.</span><span style="color: #0c969b;">listen</span><span style="color: #403f53;">(</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">)</span></div><div><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> </span><span style="color: #bc5454;">True</span><span style="color: #403f53;">:</span></div><div><span style="color: #403f53;">&#160; &#160; connect, address </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> server.</span><span style="color: #0c969b;">accept</span><span style="color: #403f53;">()</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">print</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">address</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">&#160; &#160; message </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> connect.</span><span style="color: #0c969b;">recv</span><span style="color: #403f53;">(</span><span style="color: #aa0982;">1024</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #4876d6;">print</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">message</span><span style="color: #403f53;">)</span></div><div><span style="color: #403f53;">&#160; &#160; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> message.</span><span style="color: #0c969b;">decode</span><span style="color: #403f53;">() </span><span style="color: #994cc3;">==</span><span style="color: #403f53;"> </span><span style="color: #111111;">'</span><span style="color: #c96765;">time</span><span style="color: #111111;">'</span><span style="color: #403f53;">:</span></div><div><span style="color: #403f53;">&#160; &#160; &#160; &#160; connect.</span><span style="color: #0c969b;">send</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">time.</span><span style="color: #0c969b;">ctime</span><span style="color: #403f53;">()</span><span style="color: #4876d6;">.</span><span style="color: #0c969b;">encode</span><span style="color: #403f53;">())</span></div><div><span style="color: #403f53;">&#160; &#160; connect.</span><span style="color: #0c969b;">close</span><span style="color: #403f53;">()</span></div></div>

<p>使用 Python 编写套接字程序的方法可以参考<a href="/archives/403">这篇文章</a>。运行该程序后，在单片机端通过设置指令 <code>AT+CIPSTART</code> 向该局域网 IP 地址与端口号发起 TCP 连接：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CIPSTART="TCP","192.168.1.105",12000</span>

CONNECT

OK</div>

<p>连接完成以后，可以通过设置指令 <code>AT+CIPSEND</code> 发送数据，参数 <code>&lt;length&gt;</code> 为数据的长度：</p>

<div class="codeblock code-console"><span class="codetoken command">AT+CIPSEND=4</span>


OK
> <span class="codetoken command">time</span>
SEND OK

+IPD,24:Mon Jul 11 14:58:48 2022CLOSED</div>

<p>当收到此命令后，会换行返回 <code>> </code> 符号，表示接下来可以继续接收待发送的数据；后续通过串口发送的数据可以不用以新行结尾，当数据长度达到 <code>&lt;length&gt;</code> 时，ESP8266 才会将数据发送出去并返回 OK 。</p>

<p>在收到网络数据时，ESP8266 会以 <code>+IPD</code> 的指令形式返回，第一个逗号后面代表数据的长度，冒号后面跟随的是实际的数据。最后的 <code>CLOSE</code> 代表连接中断，它和数据是是分两次接收的。通过解析数组 <code>ESP8266_Buffer.Body</code> 中保存的数据，单片机就可以通过网络获取当前的实时时间，并用于校正当前的 RTC 时钟等。</p>

<p>当然，在实际使用时不会通过串口转发这么麻烦的方式，可以在程序中直接操作串口按指定的形式收发数据，下一节将会介绍相应程序的编写方法。</p>

<h2>参考资料/延伸阅读</h2>

<p><a href="https://docs.espressif.com/projects/esp-at/en/release-v2.2.0.0_esp8266/Get_Started/index.html">https://docs.espressif.com/projects/esp-at/en/release-v2.2.0.0_esp8266/Get_Started/index.html</a></p>

<p>ESP-AT 指令文档。不过很少有商家的固件会有这么新的版本。</p>
<p><a rel="nofollow" href="/archives/496">STM32与物联网01-ESP8266基本操作</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/496/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程06-动画</title>
		<link>/archives/425</link>
					<comments>/archives/425#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Tue, 28 Jun 2022 12:35:06 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=425</guid>

					<description><![CDATA[<p>动画可以说是 LVGL 中的特色之一，不过在使用动画&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/425">LVGL库入门教程06-动画</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>动画可以说是 LVGL 中的特色之一，不过在使用动画前，请确保单片机具有足够的性能来维持足够的帧率。</p>
<h2>transition：过渡动画</h2>
<p>当一个控件的状态发生改变时，可以让样式也发生变化以提醒用户。通过过渡动画(transition)可以让样式的改变更自然。例如，按钮在点击时，以及开关在切换时，都具有一小段的过渡动画。</p>
<p>过渡动画使用 <code>lv_style_transition_dsc_t</code> 结构描述。为了要设置过渡动画，需要提供以下信息：</p>
<ul>
<li>哪些属性需要过渡</li>
<li>过渡前的延时</li>
<li>过渡持续的时间</li>
<li>过渡动画（以回调函数的形式提供）</li>
</ul>
<p>这些信息和结构成员是一一对应的。除了直接给结构成员赋值外，也可以使用以下初始化函数一次性设置：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_style_transition_dsc_init</span><span class="hljs-params">(
                <span class="hljs-keyword">lv_style_transition_dsc_t</span>* tr, 
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_style_prop_t</span> props[],
                <span class="hljs-keyword">lv_anim_path_cb_t</span> path_cb, 
                <span class="hljs-keyword">uint32_t</span> time, 
                <span class="hljs-keyword">uint32_t</span> delay, 
                <span class="hljs-keyword">void</span>* user_data)</span></span>;
</pre></div>
<p>第一个参数需要提供被初始化的过渡动画结构，第二个参数数组和字符串一样需要以 <code>0</code> 结尾。例如，假设需要实现这样一个过渡效果：点击时背景颜色发生改变并拉长，那么相应的初始化过程为：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_transition_dsc_t</span> trans;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_style_prop_t</span> trans_props[] = {
    LV_STYLE_WIDTH, LV_STYLE_HEIGHT, LV_STYLE_BG_COLOR, <span class="hljs-number">0</span>,
};
<span class="hljs-built_in">lv_style_transition_dsc_init</span>(&amp;trans, trans_props, 
            lv_anim_path_ease_in_out, <span class="hljs-number">500</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);
</pre></div>
<p>这里使用的动画效果函数为 <code>lv_anim_path_ease_in_out()</code> ，这是一个内置的过渡效果，与之类似的过渡函数可以参考下表：</p>
<table>
<thead>
<tr>
<th>动画函数</th>
<th>过渡效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lv_anim_path_linear</code></td>
<td>等速过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_ease_in</code></td>
<td>先慢后快的过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_ease_out</code></td>
<td>先快后慢的过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_ease_in_out</code></td>
<td>先慢、后快、结尾再变慢的过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_overshoot</code></td>
<td>幅度会稍微过头一些再弹回的过渡</td>
</tr>
<tr>
<td><code>lv_anim_path_bounce</code></td>
<td>和上一个类似，不过会比较快地多弹几次</td>
</tr>
<tr>
<td><code>lv_anim_path_step</code></td>
<td>一步到位，和没动画的区别在于多了个延时</td>
</tr>
</tbody>
</table>
<p>过渡动画是控件样式的一部分，可以将初始化得到的过渡动画描述应用到样式上：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_trans;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_trans);
<span class="hljs-built_in">lv_style_set_transition</span>(&amp;style_trans, &amp;trans);
</pre></div>
<p>过渡动画只有在两种样式切换时才会发生。例如，如果让以上样式应用在按下状态下：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_bg_color</span>(&amp;style_trans, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED));
<span class="hljs-built_in">lv_style_set_width</span>(&amp;style_trans, <span class="hljs-number">150</span>);
<span class="hljs-built_in">lv_style_set_height</span>(&amp;style_trans, <span class="hljs-number">60</span>);
<span class="hljs-built_in">lv_obj_add_style</span>(obj, &amp;style_trans, LV_STATE_PRESSED);
</pre></div>
<p>那么只有在从其它状态变为按下时才会发生过渡：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-transition.gif" alt="image" width="240"></figure>
<p>注意松开时样式是突然转变的。如果要给这部分也添加一个过渡效果，可以给默认状态下的控件添加一个包含过渡的样式。</p>
<h2>animate：通用动画</h2>
<p>过渡只有在状态改变时才会发生，而动画可以在任意时刻进行。除此之外，两者的区别还有：过渡只是样式的一部分，而动画和样式之间是独立的。</p>
<p>实际上，过渡的底层也使用的是动画。</p>
<h3>创建动画</h3>
<p>为了创建动画，需要像样式一样声明一个动画类型并初始化：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_anim_t</span> anim;
<span class="hljs-built_in">lv_anim_init</span>(&amp;anim);
</pre></div>
<p>由于动画是立即执行的，因此可以使用自动变量存储。然后，需要明确该动画将作用于哪一个控件：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_set_var</span>(&amp;anim, obj);
</pre></div>
<p>接下来，可以设置动画的各种轨迹，包括：</p>
<ul>
<li>动画需要改变什么属性</li>
<li>这些属性改变的范围</li>
<li>动画效果</li>
<li>延时和持续时间</li>
</ul>
<p>动画的这些属性和过渡是类似的。例如，假设想做一个控件下落的动画，那么需要提供一个改变 y 坐标值的回调函数，这个函数可以直接使用 <code>lv_obj_set_y()</code> ，然后设定改变的始末值和运动轨迹，对应的代码为：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_set_exec_cb</span>(&amp;anim, (<span class="hljs-keyword">lv_anim_exec_xcb_t</span>)lv_obj_set_y);
<span class="hljs-built_in">lv_anim_set_values</span>(&amp;anim, <span class="hljs-number">-100</span>, <span class="hljs-number">100</span>);
<span class="hljs-built_in">lv_anim_set_path_cb</span>(&amp;anim, lv_anim_path_bounce);
<span class="hljs-built_in">lv_anim_set_time</span>(&amp;anim, <span class="hljs-number">1000</span>);
<span class="hljs-built_in">lv_anim_set_delay</span>(&amp;anim, <span class="hljs-number">1000</span>);
</pre></div>
<p>然后，可以在必要的时候执行动画：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_start</span>(&amp;anim);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-animation-1.gif" alt="image" width="230"></figure>
<blockquote>
<p><strong>关于延迟渲染</strong></p>
<p>之前说过，样式是延迟渲染的，因此样式变量需要使用 <code>static</code> 存储类型修饰符；而动画不是，动画从创建到执行是立即发生的。这也很好理解：样式在创建的过程中可能发生多次修改，因此需要确定最终的表现结果如何，再着手绘制，否则整个控件可能会重绘多次，占用大量无效的资源。</p>
<p>这种特点可能会带来许多意想不到的问题。例如，假设在 <code>lv_anim_set_values()</code> 函数中去获取一个控件的位置、宽度等信息，由于它们都属于样式的一部分，此时还没有实际计算，因此得到的可能是默认值，造成动画始末效果偏离预期轨迹。</p>
<p>要解决这个问题，要么手动设置具体的值，要么让动画等到实际渲染发生了再执行，例如将其作为事件回调函数中的一部分。</p>
</blockquote>
<h3>更复杂的动画</h3>
<p>以上创建的动画是单次不重复的，LVGL 提供了许多函数，可以为动画设置更复杂的属性。</p>
<p>这里介绍一个控件 bar ，它实质上就是没有 knob 部分的滑块，可以借用该控件来创建一个进度条(progress bar)动画。以下创建一个 bar 并将它的模式设定为 <code>LV_BAR_MODE_RANGE</code> ，这样就可以同时修改 indicator 两端的位置了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* bar = <span class="hljs-built_in">lv_bar_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_bar_set_mode</span>(bar, LV_BAR_MODE_RANGE);
</pre></div>
<p>这里使用官方文档中提供的一个样式来使外观更好看，具体细节就无需解释了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_bg;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_indic;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_bg);
<span class="hljs-built_in">lv_style_set_border_color</span>(&amp;style_bg, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
<span class="hljs-built_in">lv_style_set_border_width</span>(&amp;style_bg, <span class="hljs-number">2</span>);
<span class="hljs-built_in">lv_style_set_pad_all</span>(&amp;style_bg, <span class="hljs-number">6</span>);
<span class="hljs-built_in">lv_style_set_radius</span>(&amp;style_bg, <span class="hljs-number">6</span>);
<span class="hljs-built_in">lv_style_set_anim_time</span>(&amp;style_bg, <span class="hljs-number">1000</span>);
<span class="hljs-built_in">lv_style_init</span>(&amp;style_indic);
<span class="hljs-built_in">lv_style_set_bg_opa</span>(&amp;style_indic, LV_OPA_COVER);
<span class="hljs-built_in">lv_style_set_bg_color</span>(&amp;style_indic, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
<span class="hljs-built_in">lv_style_set_radius</span>(&amp;style_indic, <span class="hljs-number">3</span>);
<span class="hljs-built_in">lv_obj_remove_style_all</span>(bar);
<span class="hljs-built_in">lv_obj_add_style</span>(bar, &amp;style_bg, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_add_style</span>(bar, &amp;style_indic, LV_PART_INDICATOR);
<span class="hljs-built_in">lv_obj_set_size</span>(bar, <span class="hljs-number">200</span>, <span class="hljs-number">20</span>);
</pre></div>
<p>然后就可以确定动画效果了。例如，这里期望的动画效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-animation-2.gif" alt="image" width="250"></figure>
<p>那么首先可以编写一个改变属性的回调函数，例如改变 indicator 的范围：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anim_progress_load</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* obj, <span class="hljs-keyword">int32_t</span> v)</span> </span>{
    <span class="hljs-built_in">lv_bar_set_start_value</span>(obj, v, LV_ANIM_ON);
    <span class="hljs-built_in">lv_bar_set_value</span>(obj, <span class="hljs-number">20</span> + v, LV_ANIM_ON);
}
</pre></div>
<p>这些值在 0~80 范围内等速改变，持续时间 1.5 秒，无延时，对应的代码为：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_set_exec_cb</span>(&amp;anim, anim_progress_load);
<span class="hljs-built_in">lv_anim_set_values</span>(&amp;anim, <span class="hljs-number">0</span>, <span class="hljs-number">80</span>);
<span class="hljs-built_in">lv_anim_set_path_cb</span>(&amp;anim, lv_anim_path_linear);
<span class="hljs-built_in">lv_anim_set_time</span>(&amp;anim, <span class="hljs-number">1500</span>);
<span class="hljs-built_in">lv_anim_set_delay</span>(&amp;anim, <span class="hljs-number">0</span>);
</pre></div>
<p>然后这里为其添加一个倒退和重复效果，这样动画就能来回播放了：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_set_playback_time</span>(&amp;anim, <span class="hljs-number">1500</span>);
<span class="hljs-built_in">lv_anim_set_repeat_count</span>(&amp;anim, LV_ANIM_REPEAT_INFINITE);
</pre></div>
<p>实现的进度条动画就像以上 gif 展示的一样。除此之外，还可以修改更多动画的细节，例如：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>设置内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lv_anim_set_start_cb(anim, start_cb)</code></td>
<td>在延时后、开始前执行一个函数</td>
</tr>
<tr>
<td><code>lv_anim_set_playback_delay(anim, delay)</code></td>
<td>设置动画倒退前的延时</td>
</tr>
<tr>
<td><code>lv_anim_set_repeat_delay(anim, delay)</code></td>
<td>设置动画重复前的延时</td>
</tr>
<tr>
<td><code>lv_anim_set_early_apply(&amp;a, bool)</code></td>
<td>是否将起始值应用到动画开始前，使动画执行时不会太突兀</td>
</tr>
</tbody>
</table>
<p>更多的细节可以参考官方文档。</p>
<h3>组合动画效果</h3>
<p>有时候需要同时播放较多动画，此时如果逐个播放的话，需要逐个为动画设计延时，不方便安排。此时，可以使用 LVGL 提供的时间线(timeline)统一安排各个动画。</p>
<p>时间线的创建非常简单。首先，创建一系列动画，但先不调用 <code>lv_anim_start()</code> 让动画开始。</p>
<p>其次，创建一个时间线并将各个动画添加到时间线的某一时刻处：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_anim_timeline_t</span>* anim_timeline = <span class="hljs-built_in">lv_anim_timeline_create</span>();
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">0</span>, &amp;anim_axis);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">100</span>, &amp;anim_obj_01);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">1100</span>, &amp;anim_obj_02);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">2100</span>, &amp;anim_obj_03);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">300</span>, &amp;anim_label_01);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">1300</span>, &amp;anim_label_02);
<span class="hljs-built_in">lv_anim_timeline_add</span>(anim_timeline, <span class="hljs-number">2300</span>, &amp;anim_label_03);
</pre></div>
<p>使用时间线时，无需为动画设计延时，只需要关注动画会在什么时刻播放，延时便会自动计算。</p>
<p>添加完毕后，再调用时间线的执行函数就可以了：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_anim_timeline_start</span>(anim_timeline);
</pre></div>
<p>这样就可以创建很复杂的组合动画效果了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-timeline.gif" alt="image" width="230"></figure>
<p>使用时间线可以方便管理所有动画，可以将时间线上包含的所有动画停播、倒放、跳转等。以下列出了一些常用的时间线控制函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lv_anim_timeline_stop(timeline)</code></td>
<td>暂停播放当前的所有动画</td>
</tr>
<tr>
<td><code>lv_anim_timeline_set_reverse(timeline, bool)</code></td>
<td>设置接下来的播放方向</td>
</tr>
<tr>
<td><code>lv_anim_timeline_set_progress(timeline, progress)</code></td>
<td>跳转到播放进度</td>
</tr>
</tbody>
</table>
<p>如果需要倒放，在设置了播放方向后还需要调用 <code>lv_anim_timeline_start()</code> 重新播放，并且会从当前位置倒放。</p>
<h2>scroll：滚动动画</h2>
<h3>滚动的特点</h3>
<p>滚动也是常见的一种动画效果。如果一个容器的尺寸不足以容纳它包含的控件，那么它就可以通过滚动来展示包含控件的所有部分。</p>
<p>为了使一个控件是可滚动的，它需要拥有标志 <code>LV_OBJ_FLAG_SCROLLABLE</code> 。清除该标志可以隐藏子控件的溢出部分。</p>
<p>滚动是可以冒泡的，如果一个控件已经滚动到底，再次对其尝试滚动将使滚动事件传播到父容器上。可以通过清除 <code>LV_OBJ_FLAG_SCROLL_CHAIN</code> 标志位去除这个性质。</p>
<p>可以通过 <code>lv_obj_set_scroll_dir()</code> 限制滚动的方向。例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_scroll_dir</span>(obj, LV_DIR_RIGHT);
</pre></div>
<p>那么就只能向右滚动到底，不能向左折回。</p>
<p>还可以通过以下几个函数利用代码执行滚动：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_scroll_to</span>(obj, x, y, anim_en);
<span class="hljs-built_in">lv_obj_scroll_by</span>(obj, x, y, anim_en);
<span class="hljs-built_in">lv_obj_scroll_to_view</span>(child, anim_en);
</pre></div>
<p>注意前两个函数的区别：前者是滚动到相应的位置，多次调用只有第一次实际有效；后者是模拟滚动的操作，实际滚动方向是相反的，并且多次调用效果可以叠加。除此之外，后者甚至可以滚动到超出子控件的范围之外。最后一个函数自动滚动到合适的位置，确保子控件可视。</p>
<p>这几个函数都不受滚动方向的约束。它们都具有第三个参数，用于指定滚动时是否提供滚动动画。</p>
<h3>滚动动画</h3>
<p>滚动是有动画的，默认情况下，滚动动画的特点表现在以下几点：</p>
<ul>
<li>滚动是具有惯性的，意思是当输入设备停止交互时，控件还会继续向前滚动一小段距离。可以通过清除 <code>LV_OBJ_FLAG_SCROLL_MOMENTUM</code> 标志位取消这个特征</li>
<li>滚动是具有弹性的，当滚动到底时，继续尝试滚动会使控件超出一定范围，松开后回弹。可以通过清除 <code>LV_OBJ_FLAG_SCROLL_ELASTIC</code> 标志位取消这个特征</li>
<li>除此之外，以上介绍的两个代码实现滚动的函数，如果在第三个参数中应用滚动，那么会发生一小段 easy-out 的切换动画</li>
</ul>
<p>还可以设置一种特殊的滚动效果 snap ，它使滚动时可以自动对齐。为了启用这种效果，需要添加 <code>LV_OBJ_FLAG_SNAPPABLE</code> 标志位，然后设置对齐的方式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_scroll_snap_x</span>(cont, LV_SCROLL_SNAP_START);
</pre></div>
<p>这样便可以按开始位置对齐了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-scroll-snap.gif" alt="image" width="220"></figure>
<p>还可以配合 <code>LV_OBJ_FLAG_SCROLL_ONE</code> 标志位一次只滚过最多一个控件的位置。</p>
<hr>
<p>在滚动时，会触发 <code>LV_EVENT_SCROLL</code> 事件，可以通过在该事件回调函数中对包含的子控件做变换，实现更复杂的滚动效果。</p>
<p>例如，以下在事件回调函数内，根据每个子控件当前位置的纵坐标对横坐标做一些变换：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">scrool_widget_cb</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span> </span>{
    <span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_event_get_target</span>(e);
    <span class="hljs-keyword">uint32_t</span> child_cnt = <span class="hljs-built_in">lv_obj_get_child_cnt</span>(cont);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; child_cnt; i++) {
        <span class="hljs-keyword">lv_obj_t</span>* child = <span class="hljs-built_in">lv_obj_get_child</span>(cont, i);
        <span class="hljs-built_in">lv_obj_set_style_translate_x</span>(child, child-&gt;coords.y1 * <span class="hljs-number">0.5</span> - <span class="hljs-number">60</span>, <span class="hljs-number">0</span>);
    }
}
</pre></div>
<p>然后让每次滚动时都做以上变换：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_add_event_cb</span>(cont, scrool_widget_cb, LV_EVENT_SCROLL, <span class="hljs-literal">NULL</span>);
</pre></div>
<p>这样就能实现斜方向的滚动效果了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-06-scroll-slope.gif" alt="image" width="210"></figure>
<p>这里由于仅在事件中才修改按钮的水平位置，因此一开始控件的摆放不是倾斜的。要解决这个问题，可以添加以下代码：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_scroll_to_view</span>(<span class="hljs-built_in">lv_obj_get_child</span>(cont, <span class="hljs-number">0</span>), LV_ANIM_OFF);
<span class="hljs-built_in">lv_event_send</span>(cont, LV_EVENT_SCROLL, <span class="hljs-literal">NULL</span>);
</pre></div>
<p>前者使各个控件的坐标被计算，后者手动触发事件回调函数，利用计算出的坐标执行位置变换。</p>
<p>LVGL 的官方文档还给出了一个示例，可以实现类似圆形的旋转滚动，效果非常不错，不过涉及的计算较多，感兴趣的可以自行阅读官方文档。</p>
<h3>滚动条</h3>
<p>如果一个控件可以发生滚动，那么它就具有滚动条(scrollbar)。可以通过 <code>lv_obj_set_scrollbar_mode()</code> 函数修改滚动条的模式。例如，使用 <code>LV_SCROLLBAR_MODE_OFF</code> 模式可以使滚动条完全消失，就像上一张 gif 显示的那样。</p>
<p>滚动条是一个控件的 <code>LV_PART_SCROLLBAR</code> 部分，可以通过选择器给滚动条加上不同的样式。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/overview/animation.html">https://docs.lvgl.io/master/overview/animation.html</a></p>
<p><a href="https://docs.lvgl.io/master/overview/scroll.html">https://docs.lvgl.io/master/overview/scroll.html</a></p>
<p><a rel="nofollow" href="/archives/425">LVGL库入门教程06-动画</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/425/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程05-颜色和图像</title>
		<link>/archives/383</link>
					<comments>/archives/383#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 24 Jun 2022 01:49:34 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=383</guid>

					<description><![CDATA[<p>颜色 构造颜色 在 LVGL 中，颜色以结构 lv_&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/383">LVGL库入门教程05-颜色和图像</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>颜色</h2>
<h3>构造颜色</h3>
<p>在 LVGL 中，颜色以结构 <code>lv_color_t</code> 表示。在最开始移植整个工程时，曾经在 <code>lv_conf.h</code> 中修改过颜色深度：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/*Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888)*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_COLOR_DEPTH 32</span>
</pre></div>
<p>LVGL 会自动根据所选的颜色深度创建合适的颜色结构。在接下来几处位置还有几个与颜色有关的配置选项，可以参照注释修改。</p>
<p>例如，16 位 big-endian 的颜色定义为：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> {</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
        <span class="hljs-keyword">uint16_t</span> blue  : <span class="hljs-number">5</span>;
        <span class="hljs-keyword">uint16_t</span> green : <span class="hljs-number">6</span>;
        <span class="hljs-keyword">uint16_t</span> red   : <span class="hljs-number">5</span>;
    } ch;
    <span class="hljs-keyword">uint16_t</span> full;
} <span class="hljs-keyword">lv_color16_t</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">lv_color16_t</span> <span class="hljs-keyword">lv_color_t</span>;
</pre></div>
<p>那么就可以根据该结构创建合适的颜色值了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> orange = {
    .ch = {
        .red   = <span class="hljs-number">0b11111</span>,
        .green = <span class="hljs-number">0b101001</span>,
        .blue  = <span class="hljs-number">0</span>
    }
};
</pre></div>
<p>直接创建 RGB565 的颜色格式有点难以调色，不过可以借用以下函数从十六位颜色中生成合适的颜色值：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> orange = <span class="hljs-built_in">lv_color_make</span>(<span class="hljs-number">0xFF</span>, <span class="hljs-number">0xA5</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 从颜色通道创建</span>
<span class="hljs-keyword">lv_color_t</span> aqua = <span class="hljs-built_in">lv_color_hex</span>(<span class="hljs-number">0x00FFFF</span>);          <span class="hljs-comment">// 从十六进制创建</span>
<span class="hljs-keyword">lv_color_t</span> lightgrey = <span class="hljs-built_in">lv_color_hex3</span>(<span class="hljs-number">0xddd</span>);       <span class="hljs-comment">// 从十六进制简写创建</span>
</pre></div>
<p>这些颜色在创建时，每种颜色通道的值都使用 0~255 表示即可，创建过程中会自动转换为合适的颜色值。</p>
<p>LVGL 还提供了 HSV 格式的颜色支持，</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> red = <span class="hljs-built_in">lv_color_hsv_to_rgb</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);   <span class="hljs-comment">// 从 HSV 颜色空间创建颜色</span>
<span class="hljs-keyword">lv_color_hsv_t</span> blue = <span class="hljs-built_in">lv_color_rgb_to_hsv</span>(r, g, b);  <span class="hljs-comment">// 将 RGB 颜色转换为 HSV 颜色</span>
</pre></div>
<p>除此之外，<code>lv_color_t</code> 、RGB 颜色、HSV 颜色之间也能互相转换。</p>
<hr>
<p>如果觉得 16 进制的颜色还是不够直观，还可以使用调色板功能。LVGL 提供了常用颜色的色值表示，可以直接使用、微调、混合这些颜色。</p>
<p>例如，以下直接调出了一个紫色：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> purple = <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_PURPLE)
</pre></div>
<p>如果觉得默认的紫色太深或太浅的话，还可以在调色板中更改亮度：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> dark_purple = <span class="hljs-built_in">lv_palette_darken</span>(LV_PALETTE_PURPLE, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 调深两级，最多可以调深或浅 4 级</span>
<span class="hljs-keyword">lv_color_t</span> light_purple = <span class="hljs-built_in">lv_color_lighten</span>(purple, <span class="hljs-number">60</span>);  <span class="hljs-comment">// 调浅一些，调到 255 就变成纯白</span>
</pre></div>
<p>甚至还可以将两种颜色混合：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_color_t</span> orange = <span class="hljs-built_in">lv_color_mix</span>(red, yellow, <span class="hljs-number">156</span>);
</pre></div>
<p>比例的取值为 0~255 ，例如设定为 0 就是全红，128 就是红黄各占一半等。</p>
<p>可以将一个颜色类型直接应用到以下样式属性中：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bg_color</code></td>
<td>背景颜色</td>
</tr>
<tr>
<td><code>border_color</code></td>
<td>边框颜色</td>
</tr>
<tr>
<td><code>outline_color</code></td>
<td>轮廓颜色</td>
</tr>
<tr>
<td><code>shadow_color</code></td>
<td>阴影颜色</td>
</tr>
<tr>
<td><code>text_color</code></td>
<td>文本颜色</td>
</tr>
</tbody>
</table>
<p>以及上一节提到的直线和弧线颜色。</p>
<h3>透明度</h3>
<p>有时候两个控件间可能发生重叠，这个时候就可以给它们设置一个透明度。</p>
<p>透明度使用类型 <code>lv_opa_t</code> 表示，LVGL 预定义了几个表示透明度的宏：<code>LV_OPA_TRANSP</code> 表示完全透明，<code>LV_OPA_COVER </code> 表示完全不透明，其余的 <code>LV_OPA_10 </code> ~ <code>LV_OPA_90 </code> 整十表示的透明度依次递减。</p>
<p>可以将透明度应用到以下样式属性中：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bg_opa</code></td>
<td>背景透明度</td>
</tr>
<tr>
<td><code>border_opa</code></td>
<td>边框透明度</td>
</tr>
<tr>
<td><code>outline_opa</code></td>
<td>轮廓透明度</td>
</tr>
<tr>
<td><code>shadow_opa</code></td>
<td>阴影透明度</td>
</tr>
<tr>
<td><code>text_opa</code></td>
<td>文本透明度</td>
</tr>
<tr>
<td><code>opa</code></td>
<td>整体透明度</td>
</tr>
</tbody>
</table>
<p>以及直线和弧线透明度。例如，以下创建了两个部分重叠的控件，并在一个的背景上加透明度：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_grass;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_grass);
<span class="hljs-built_in">lv_style_set_opa</span>(&amp;style_grass, LV_OPA_30);
<span class="hljs-keyword">lv_obj_t</span>* obj = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-keyword">lv_obj_t</span>* cover = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_add_style</span>(cover, &amp;style_grass, <span class="hljs-number">0</span>);
</pre></div>
<p>这样就可以看见被遮挡的控件了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-opacity.jpg" alt="image" width="140"></figure>
<p>注意需要给上层，即后创建的的控件加透明度才会有这样的效果。透明度其实就是为控件重新调色，因此不是 32 位颜色的屏幕也可以使用透明度。</p>
<p><code>lv_opa_t</code> 类型的本质就是 8 位无符号整数，因此可以自行创建一个透明度数值，设为 255 就代表完全透明；还可以将透明度应用到 <code>lv_color_mix()</code> 的第三个参数上。</p>
<h3>渐变色</h3>
<p>可以使用渐变色给控件加上更美观的效果。</p>
<p>只有背景颜色能设置渐变色。一个渐变色的效果由以下几个属性支配：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bg_color</code></td>
<td>主要颜色</td>
</tr>
<tr>
<td><code>bg_grad_color</code></td>
<td>渐变颜色</td>
</tr>
<tr>
<td><code>bg_grad_dir</code></td>
<td>渐变方向</td>
</tr>
<tr>
<td><code>bg_main_stop</code></td>
<td>渐变开始位置</td>
</tr>
<tr>
<td><code>bg_grad_stop</code></td>
<td>渐变结束位置</td>
</tr>
<tr>
<td><code>bg_dither_mode</code></td>
<td>渲染模式</td>
</tr>
</tbody>
</table>
<p>当确定了渐变方向后，渐变从 <code>bg_main_stop</code> 位置开始，由 <code>bg_color</code> 过度到 <code>bg_grad_color</code> ，在 <code>bg_grad_stop</code> 位置结束。这里的位置是由比例衡量的，渐变区域在每个方向都被划分为 256 份，例如 128 代表中间位置，255 代表结束位置等。</p>
<p>例如，以下代码：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* obj01 = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_style_bg_color</span>(obj01, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_color</span>(obj01, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_dir</span>(obj01, LV_GRAD_DIR_HOR, <span class="hljs-number">0</span>);
</pre></div>
<p>渐变效果为水平方向从蓝色一直渐变到红色：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-grad-color-1.jpg" alt="image" width="120"></figure>
<p>再如，以下代码：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* obj02 = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_style_bg_color</span>(obj02, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_GREEN), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_color</span>(obj02, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_PURPLE), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_stop</span>(obj02, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_bg_grad_dir</span>(obj02, LV_GRAD_DIR_VER, <span class="hljs-number">0</span>);
</pre></div>
<p>渐变效果为竖直方向从绿色一直渐变到紫色，但实际渐变区域只有上半部分：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-grad-color-2.jpg" alt="image" width="120"></figure>
<p>还可以使用简写属性 <code>bg_grad</code> 设置完整的渐变属性。这种情况下，渐变使用结构 <code>lv_grad_dsc_t</code> 描述：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
    <span class="hljs-keyword">lv_gradient_stop_t</span> stops[LV_GRADIENT_MAX_STOPS];
    <span class="hljs-keyword">uint8_t</span>            stops_count;
    <span class="hljs-keyword">lv_grad_dir_t</span>      dir    : <span class="hljs-number">3</span>;
    <span class="hljs-keyword">lv_dither_mode_t</span>   dither : <span class="hljs-number">3</span>;
} <span class="hljs-keyword">lv_grad_dsc_t</span>;
</pre></div>
<p>宏 <code>LV_GRADIENT_MAX_STOPS</code> 决定了最大拥有的渐变颜色数，可以在 <code>lv_conf_internal.h</code> 大约 377 行修改该宏的数量：</p>
<div class="hljs codeblock"><pre><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LV_GRADIENT_MAX_STOPS</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_LV_GRADIENT_MAX_STOPS</span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_GRADIENT_MAX_STOPS CONFIG_LV_GRADIENT_MAX_STOPS</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_GRADIENT_MAX_STOPS 3</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</pre></div>
<p>然后就可以自定义多种颜色的渐变了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_grad_dsc_t</span> grad_sunset;
grad_sunset.stops[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">lv_gradient_stop_t</span>){ .color = <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED), .frac = <span class="hljs-number">96</span> };
grad_sunset.stops[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">lv_gradient_stop_t</span>){ .color = <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_ORANGE), .frac = <span class="hljs-number">128</span> };
grad_sunset.stops[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">lv_gradient_stop_t</span>){ .color = <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE), .frac = <span class="hljs-number">216</span> };
grad_sunset.stops_count = <span class="hljs-number">3</span>;
grad_sunset.dir = LV_GRAD_DIR_VER;
<span class="hljs-keyword">lv_obj_t</span>* obj03 = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_style_bg_grad</span>(obj03, &amp;grad_sunset, <span class="hljs-number">0</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-grad-color-3.jpg" alt="image" width="120"></figure>
<h3>颜色的其它内容</h3>
<p>LVGL 还提供了许多处理颜色的滤镜。可以使用样式属性 <code>blend_mode</code> 设置颜色和背景色的融合。例如，以下将控件的颜色设置为背景色的反色：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_style_blend_mode</span>(obj03, LV_BLEND_MODE_SUBTRACTIVE, <span class="hljs-number">0</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-blend-mode-subtract.jpg" alt="image" width="120"></figure>
<p>注意边框的颜色也变成反色了。</p>
<!-- 还可以使用样式属性 `color_filter_dsc` 和 `color_filter_opa` 为控件叠上一层颜色滤镜。这种情况下，滤镜使用以下结构描述：

```cpp
typedef struct _lv_color_filter_dsc_t {
    lv_color_filter_cb_t filter_cb;
    void * user_data;
} lv_color_filter_dsc_t;
```

这里需要提供一个回调函数 `filter_cb` 给它。
-->
<p>最后，LVGL 中还要一个控件 color wheel ，可以快速创建一个颜色选择器。它的默认表现形式为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-colorwheel.gif" alt="image" width="160"></figure>
<p>它类似于圆弧，并可以通过长按切换模式。可以使用函数 <code>lv_colorwheel_get_rgb()</code> 获取当前选择的颜色。</p>
<h2>图片</h2>
<h3>创建图片</h3>
<p>图片可以以两种方式存储：一是作为一个数组之类的变量，二是通过二进制文件的形式存储。由于还没有介绍文件相关的内容，这里仅介绍使用数组的方式来存储并使用图片。</p>
<p>LVGL 已经提供了在线图片转换器，可以直接在 <a href="https://lvgl.io/tools/imageconverter">https://lvgl.io/tools/imageconverter</a> 将一般的 PNG 或 JPG 图片转换为符合要求的 C 语言对象：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-image-converter.jpg" alt="image" width="650"></figure>
<p>注意转换完成后得到的是一个完整的源文件，文件名同时也是图片的变量名。以上唯一值的注意的一点是图片所用的颜色格式，一般来说颜色格式可以分为以下几类：</p>
<ol>
<li>True color ：自动适配当前项目使用的颜色深度</li>
<li>Indexed ：从调色板创建较少的颜色数目</li>
<li>Alpha only ：单色图像，只使用透明度</li>
<li>Raw ：使用图像原本的颜色格式</li>
</ol>
<p>最后一个 RBG565-A8 就不必多说了。值的注意的是，以上有一种叫“Chroma key” 的颜色格式，它对应 <code>lv_conf.h</code> 的第 42 行的配置，注释是这样说的：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/*Images pixels with this color will not be drawn if they are chroma keyed)*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_COLOR_CHROMA_KEY lv_color_hex(0x00ff00)         <span class="hljs-comment">/*pure green*/</span></span>
</pre></div>
<p>更多有关于此的介绍可以阅读维基百科 <a href="https://en.wikipedia.org/wiki/Chroma_key">https://en.wikipedia.org/wiki/Chroma_key</a></p>
<p>转换完成后，将得到的源文件添加到当前工程内，然后通过以下几行代码就可以显示该图像：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">LV_IMG_DECLARE</span>(lvgl_logo);
<span class="hljs-keyword">lv_obj_t</span>* img01 = <span class="hljs-built_in">lv_img_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_img_set_src</span>(img01, &amp;lvgl_logo);
</pre></div>
<p>这里第一个宏的作用本质就是一个 <code>extern</code> 语句。显示的效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-image-create.jpg" alt="image" width="200"></figure>
<p>注意这里在模拟器上创建的图片是具有透明度的。</p>
<h3>图片的属性</h3>
<p>像直线和圆弧一样，图片对象也是有特殊的属性的，不过比较少：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>img_opa</code></td>
<td>图片透明度</td>
</tr>
<tr>
<td><code>img_recolor</code></td>
<td>可以给图片加上一层颜色滤镜</td>
</tr>
<tr>
<td><code>img_recolor_opa</code></td>
<td>这层滤镜的透明度</td>
</tr>
</tbody>
</table>
<p>默认情况下，图片控件会自动调整宽度以适应图片大小。如果控件过小，那么图片的额外部分会被去除；如果控件过大，那么图片会像地砖一样重复铺开来填补剩下的区域。</p>
<p>可以通过 <code>lv_img_set_offset_x(img, x_ofs)</code> 与 y 轴对应的函数给图片设置一个偏移量来修改显示范围。例如，可以通过偏移量结合控件宽度来裁剪图片：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_img_set_offset_x</span>(img01, <span class="hljs-number">-2</span>);
<span class="hljs-built_in">lv_img_set_offset_y</span>(img01, <span class="hljs-number">-7</span>);
<span class="hljs-built_in">lv_obj_set_size</span>(img01, <span class="hljs-number">74</span>, <span class="hljs-number">74</span>);
</pre></div>
<p>这里通过负值来将图片向左上角偏移，从而框选出合适的区域：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-image-clip.jpg" alt="image" width="80"></figure>
<h3>图片按钮</h3>
<p>最后再介绍一个内容，可以通过图片来创建一个按钮。这种情况下，需要准备三张图片，分别描述按钮的左边、中间和右边。</p>
<p>例如，以下准备图片如下：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-imgbtn_left.png" alt="image" height="54">&nbsp;<img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-imgbtn_mid.png" alt="image" height="54">&nbsp;<img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-imgbtn_right.png" alt="image" height="54"></figure>
<p>由于标签的宽度是不确定的，因此中间的图片必须是水平可平铺的。将其转换为对应的图片格式后，可以通过以下代码创建一个图片按钮：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* imgbtn = <span class="hljs-built_in">lv_imgbtn_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_imgbtn_set_src</span>(imgbtn, LV_IMGBTN_STATE_RELEASED, &amp;imgbtn_left, &amp;imgbtn_mid, &amp;imgbtn_right);
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(imgbtn);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"Image Button"</span>);
<span class="hljs-built_in">lv_obj_set_style_img_recolor_opa</span>(imgbtn, LV_OPA_30, LV_STATE_PRESSED);
<span class="hljs-built_in">lv_obj_set_style_img_recolor</span>(imgbtn, <span class="hljs-built_in">lv_color_black</span>(), LV_STATE_PRESSED);
</pre></div>
<p>注意在创建的过程中，将以上图片应用到按钮的普通状态（即什么事件都没有的状态）的外观中。这里通过给点击事件加上一层深色的滤镜使点击时外观可以发生改变：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-05-imagebutton-press.gif" alt="image" width="200"></figure>
<p>这样按钮就可以变得很花哨了。</p>
<p>以上对于图片的介绍比较简单，不过也基本足以应付一般的使用场景了。更多细节可以参考官方文档。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/overview/color.html">https://docs.lvgl.io/master/overview/color.html</a></p>
<p>颜色参考文档</p>
<p><a href="https://docs.lvgl.io/master/overview/image.html">https://docs.lvgl.io/master/overview/image.html</a><br>
<a href="https://docs.lvgl.io/master/widgets/core/img.html">https://docs.lvgl.io/master/widgets/core/img.html</a></p>
<p>有关图片及图片控件的完整使用描述</p>



<p></p>
<p><a rel="nofollow" href="/archives/383">LVGL库入门教程05-颜色和图像</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/383/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程04-样式</title>
		<link>/archives/361</link>
					<comments>/archives/361#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sat, 18 Jun 2022 02:53:33 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=361</guid>

					<description><![CDATA[<p>LVGL样式概述 创建样式 在 LVGL 中，样式都&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/361">LVGL库入门教程04-样式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>LVGL样式概述</h2>
<h3>创建样式</h3>
<p>在 LVGL 中，样式都是以对象的方式存在，一个对象可以描述一种样式。每个控件都可以独立添加样式，创建的样式之间互不影响。</p>
<p>可以使用 <code>lv_style_t</code> 类型创建一个样式并初始化：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style;
<span class="hljs-built_in">lv_style_init</span>(&amp;style);
</pre></div>
<p>样式是延迟渲染的，因此需要使用 <code>static</code> 存储类别说明符或将其声明为全局变量。</p>
<p>样式是多方面的，不仅包括颜色和形状，还包括边距、边框，甚至动画变换效果等细节。</p>
<blockquote>
<p>LVGL 中的样式从 CSS 中吸取了很多灵感，因此对样式的操作都类似 CSS</p>
</blockquote>
<p>接下来，可以对得到的样式对象设置一些样式规则：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/* ... create and init style ... */</span>
<span class="hljs-built_in">lv_style_set_radius</span>(&amp;style_btn_safe, <span class="hljs-number">15</span>);
<span class="hljs-built_in">lv_style_set_bg_opa</span>(&amp;style_btn_safe, LV_OPA_COVER);
<span class="hljs-built_in">lv_style_set_bg_color</span>(&amp;style_btn_safe, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_GREEN));
<span class="hljs-built_in">lv_style_set_border_width</span>(&amp;style_btn_safe, <span class="hljs-number">5</span>);
</pre></div>
<p>所有的设置样式函数都是 <code>lv_style_set_...()</code> 形式，完整的样式规则将在之后介绍。未指定的样式规则将保持控件的默认样式。</p>
<p>然后就可以将样式分配给控件，例如，以下创建了一个按钮并利用 <code>lv_obj_add_style()</code> 函数设置其样式为刚才创建的样式了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_size</span>(btn, <span class="hljs-number">120</span>, <span class="hljs-number">50</span>);
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"Button"</span>);
<span class="hljs-built_in">lv_obj_add_style</span>(btn, &amp;style_btn_safe, <span class="hljs-number">0</span>);
</pre></div>
<p>这样按钮的外观就会被改变了，效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-style-init.jpg" alt="image" width="160"></figure>
<p>以上修改了按钮的颜色，如果对颜色的创建过程不太理解也不要紧，以后会介绍颜色的代码描述。可以简单地将 GREEN 改成其它颜色名来改变不同的颜色。设置样式的函数最后有一个参数 <code>0</code> ，它代表的是样式的选择器，将会在接下来介绍。</p>
<p>一个文件内可以创建多种不同的样式对象，这样同一个界面中按钮可以表现出多种不同的样式。</p>
<h3>样式的级联</h3>
<p>所谓“级联”(cascading)，指的是将多个样式分配给一个对象。此时如果多个样式间设置的样式属性有重复，那么将使用最后设置的样式值。也就是说，后设置的样式具有更高的优先级。</p>
<p>控件在创建时可以视为同时添加了一个默认的样式，因此在代码中指定的任意样式都会覆盖默认的样式。</p>
<p>还有一种特殊的局部样式(local styles)，局部样式具有最高的优先级，但只对单个控件有效。局部样式的创建类似如下：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_style_bg_color</span>(btn, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED), <span class="hljs-number">0</span>);
</pre></div>
<p>它们都是 <code>lv_obj_set_style_...()</code> 形式的函数。</p>
<p>局部样式一旦被设置，只能再次通过局部样式修改回来。因此，局部样式需要谨慎使用。</p>
<h3>选择器</h3>
<p>LVGL 的选择器(selector)与 CSS 不同。在 CSS 中，样式通过选择器选择需要作用的元素；而 LVGL 中，样式通过选择器作用于控件的部分。</p>
<p>要明白什么是控件的部分，需要分析控件的组成。例如，以下代码可以创建一个滑块(slider)控件：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* slider01 = <span class="hljs-built_in">lv_slider_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
</pre></div>
<p>滑块是一种调整类型的控件，用户可以通过拖动它的把手(knob)来调节滑块当前的数值。滑块默认的表现形式为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-slider-create.gif" alt="alt" width="280"></figure>
<p>仔细观察滑块的组成，滑块可以由主体外形、把手(knob)和进度指示条(indicator)组成。可以通过选择器单独设置这三个构成部分的样式。例如，假设需要更改这三个部分的样式，就可以通过选择器分别指定修改的结构：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_slider_main;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_slider_main);
<span class="hljs-built_in">lv_style_set_bg_opa</span>(&amp;style_slider_main, LV_OPA_COVER);
<span class="hljs-built_in">lv_style_set_bg_color</span>(&amp;style_slider_main, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_YELLOW));
<span class="hljs-comment">/* using selectors */</span>
<span class="hljs-built_in">lv_obj_add_style</span>(slider01, &amp;style_slider_main, LV_PART_MAIN);
<span class="hljs-built_in">lv_obj_set_style_radius</span>(slider01, <span class="hljs-number">0</span>, LV_PART_KNOB);
<span class="hljs-built_in">lv_obj_set_style_bg_color</span>(slider01, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED), LV_PART_INDICATOR);
</pre></div>
<p>这里分别使用全局样式和局部样式修改控件的各个部分。修改之后，把手部分变成了方形，主体和进度进度的颜色都发生了变化：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-slider-style.jpg" alt="image" width="280"></figure>
<p>选择器的一个更妙的用途是和控件状态做按位或运算，从而可以修改某个部分在某个状态下的样式。例如，选择器</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_add_style</span>(slider01, &amp;style_slider_main, 
                 LV_PART_MAIN | LV_STATE_PRESSED);
</pre></div>
<p>使滑块的主体只有在按下时才会使用该样式（颜色被改变）：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-slider-state-style.gif" alt="image" width="280"></figure>
<p>LVGL 的选择器在表现形式上效果非常像 CSS 的伪元素和伪类选择器。</p>
<p>滑块在拖动过程中，会不断触发 <code>LV_EVENT_VALUE_CHANGED</code> 事件，可以使用函数</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int32_t</span> <span class="hljs-title">lv_slider_get_value</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_obj_t</span>* obj)</span></span>;
</pre></div>
<p>获取当前获取的滑块数值（介于 0~100 ）。更多的滑块 API 可以参考官方文档的介绍。</p>
<p>接下来详细地介绍样式可以设置的一些属性。</p>
<h2>样式属性</h2>
<h3>尺寸和位置</h3>
<p>要理解尺寸和位置是如何起作用的，首先要理解 LVGL 的盒子模型。官方文档给出了一张图，可以很好地描述一个控件的框架结构：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-boxmodel.png" alt="image" width="460"></figure>
<p>在设置尺寸的时候，长和宽指的是包括边框(border)厚度的长宽，也就是不包括轮廓(outline)的总长宽。</p>
<p>在设置位置的时候，设置的坐标指的是 border 左上角相对父容器的 Content area 的坐标，也就是说如果设置坐标为 0 的话，轮廓(outline)可能会被父容器的边框(border)遮盖。</p>
<p>下表总结了尺寸与位置有关的可用属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>width</code></td>
<td>宽度</td>
<td>由控件类别决定</td>
</tr>
<tr>
<td><code>min_width</code></td>
<td>最小宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>max_width</code></td>
<td>最大宽度</td>
<td>屏幕的宽度</td>
</tr>
<tr>
<td><code>height</code></td>
<td>高度</td>
<td>由控件类别决定</td>
</tr>
<tr>
<td><code>min_height</code></td>
<td>最小宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>max_height</code></td>
<td>最大宽度</td>
<td>屏幕的高度</td>
</tr>
<tr>
<td><code>align</code></td>
<td>对齐方式</td>
<td>左上方</td>
</tr>
<tr>
<td><code>x</code></td>
<td>对齐后在水平方向的偏移量</td>
<td>0</td>
</tr>
<tr>
<td><code>y</code></td>
<td>对齐后在竖直方向的偏移量</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>注意这里有一个最小或最大的宽度和高度，在上一节介绍 flex 和 grid 布局时就展示过控件宽度随布局自动调整的情况，因此可以给它们提供一个阈值防止过大或过小。</p>
<p>不过上一节还有一个地方没有提到：在设置宽度和高度时，除了使用确定的数值外，还可以使用百分比值 <code>lv_pct(x)</code> 来设置控件相对父容器的 Content area 的大小或位置。例如，样式</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_width</span>(&amp;style, <span class="hljs-built_in">lv_pct</span>(<span class="hljs-number">25</span>));
<span class="hljs-built_in">lv_style_set_x</span>(&amp;style, <span class="hljs-built_in">lv_pct</span>(<span class="hljs-number">50</span>));
</pre></div>
<p>可以让一个控件的水平尺寸占据父容器的 1/2~3/4 的位置：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-position-pct.jpg" alt="image" width="360"></figure>
<p>对于父容器而言，还可以使用 <code>LV_SIZE_CONTENT</code> 特殊单位调整其尺寸至可以容纳所有包含控件的合适值。例如，按钮就是一个这样的容器，它的默认样式就通过该值使得其宽度和高度可以自动适应包含的标签尺寸。</p>
<h3>边框和边距</h3>
<p>上图展示的文本框就有一个深灰色的边框。边框就无需额外描述了，与边框有关的样式属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>border_width</code></td>
<td>边框宽度，只能用绝对宽度描述</td>
<td>0</td>
</tr>
<tr>
<td><code>border_side</code></td>
<td>绘制哪些部分的边框</td>
<td><code>LV_SIDE_ALL</code></td>
</tr>
<tr>
<td><code>border_post</code></td>
<td>绘制顺序，设置 <code>true</code> 表示包含的子控件绘制完成了再绘制边框</td>
<td><code>false</code></td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>边框和主体部分之间被边距(padding)隔开。和边距有关的样式属性有：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>pad_top</td>
<td>上边距</td>
<td>0</td>
</tr>
<tr>
<td>pad_bottom</td>
<td>下边距</td>
<td>0</td>
</tr>
<tr>
<td>pad_left</td>
<td>左边距</td>
<td>0</td>
</tr>
<tr>
<td>pad_right</td>
<td>右边距</td>
<td>0</td>
</tr>
<tr>
<td>pad_row</td>
<td>当控件拥有布局时，每行间的间距</td>
<td>0</td>
</tr>
<tr>
<td>pad_column</td>
<td>当控件拥有布局时，每列间的间距</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>不过在设置布局时，还提供了几个简写属性：可以使用 <code>...pad_all()</code> 一并设置上下左右的边距；或使用 <code>...pad_hor()</code> 和 <code>...pad_ver()</code> 设置水平和垂直的边距；还可以使用 <code>...pad_gap()</code> 设置行和列的间距。</p>
<h3>轮廓</h3>
<p>轮廓(outline)类似边框，但轮廓并不算在一个控件的主体内，因此设置坐标、尺寸等属性时都不包含轮廓的尺寸。</p>
<p>轮廓可设置的属性远比边框少。下表列出了轮廓的一些属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>outline_width</code></td>
<td>轮廓宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>outline_pad</code></td>
<td>轮廓到主体的间距</td>
<td>0</td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>轮廓和边框最根本的差异是两者不是同一个东西，因此可以在同一个元素同时使用不同样式的轮廓的边框来实现一些有趣的效果，例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_radius</span>(&amp;style, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_style_set_border_color</span>(&amp;style, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_GREY));
<span class="hljs-built_in">lv_style_set_border_width</span>(&amp;style, <span class="hljs-number">5</span>);
<span class="hljs-built_in">lv_style_set_border_opa</span>(&amp;style, LV_OPA_COVER);
<span class="hljs-built_in">lv_style_set_border_side</span>(&amp;style, LV_BORDER_SIDE_BOTTOM | LV_BORDER_SIDE_RIGHT);
<span class="hljs-built_in">lv_style_set_outline_width</span>(&amp;style, <span class="hljs-number">4</span>);
<span class="hljs-built_in">lv_style_set_outline_pad</span>(&amp;style, <span class="hljs-number">1</span>);
<span class="hljs-built_in">lv_style_set_outline_color</span>(&amp;style, <span class="hljs-built_in">lv_palette_lighten</span>(LV_PALETTE_GREY, <span class="hljs-number">1</span>));
</pre></div>
<p>表现效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-outline-style.jpg" alt="image" width="230"></figure>
<h3>阴影</h3>
<p>阴影可以使控件看起来有立体感。下表列出了设置阴影的一些属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shadow_width</code></td>
<td>设置阴影的模糊半径</td>
<td>0</td>
</tr>
<tr>
<td><code>shadow_ofs_x</code></td>
<td>设置阴影的水平偏移量</td>
<td>0</td>
</tr>
<tr>
<td><code>shadow_ofs_y</code></td>
<td>设置阴影的垂直偏移量</td>
<td>0</td>
</tr>
<tr>
<td><code>shadow_spread</code></td>
<td>设置阴影的放大量</td>
<td>0</td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>例如，以下设置模糊半径为 50 的蓝色阴影：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_shadow_width</span>(&amp;style, <span class="hljs-number">50</span>);
<span class="hljs-built_in">lv_style_set_shadow_color</span>(&amp;style, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-shadow-style-1.jpg" alt="image" width="200"></figure>
<p>以下设置放大有偏移的红色阴影：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_shadow_color</span>(&amp;style, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_RED))
<span class="hljs-built_in">lv_style_set_shadow_width</span>(&amp;style, <span class="hljs-number">15</span>)
<span class="hljs-built_in">lv_style_set_shadow_ofs_x</span>(&amp;style, <span class="hljs-number">10</span>)
<span class="hljs-built_in">lv_style_set_shadow_ofs_y</span>(&amp;style, <span class="hljs-number">20</span>)
<span class="hljs-built_in">lv_style_set_shadow_spread</span>(&amp;style, <span class="hljs-number">10</span>)
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-shadow-style.jpg" alt="image" width="220"></figure>
<p>LVGL 中无法给同一个控件设置多个阴影叠加，从而实现更复杂的效果，这是比较可惜的一点。</p>
<h3>文本样式</h3>
<p>在创建控件时经常要使用文字，下表列出了能影响文字效果的一些属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text_font</code></td>
<td>设置文字的字体</td>
<td>默认字体</td>
</tr>
<tr>
<td><code>text_letter_space</code></td>
<td>字符间隔</td>
<td>0</td>
</tr>
<tr>
<td><code>text_line_space</code></td>
<td>设置多行文本的行间距</td>
<td>0</td>
</tr>
<tr>
<td><code>text_decor</code></td>
<td>设置文本装饰（下划线或删除线）</td>
<td><code>LV_TEXT_DECOR_NONE</code></td>
</tr>
<tr>
<td><code>text_align</code></td>
<td>设置文本对齐方式</td>
<td><code>LV_TEXT_ALIGN_AUTO</code></td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>需要注意的是，文本的样式是可继承的，意思是如果子控件没有特别指定的话，它会使用父容器设置的文本样式。</p>
<p>在一段文本内可能存在许多种样式，对此，可以使用类似 CSS 的 span 来拆分样式在文本内的作用域。为了创建 span ，首先需要创建一个 span-group ：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* spangroup = <span class="hljs-built_in">lv_spangroup_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_size</span>(spangroup, <span class="hljs-number">160</span>, LV_SIZE_CONTENT);
</pre></div>
<p>创建的 span-group 和一般的控件没什么区别，可以给它添加一些样式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_style_border_color</span>(spangroup, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE), <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_border_width</span>(spangroup, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_set_style_pad_all</span>(spangroup, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);
</pre></div>
<p>span-group 提供的以下函数使得它相比标签更适合用来处理大段的文本：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lv_spangroup_set_align(obj, align)</code></td>
<td>设置文本的对齐</td>
</tr>
<tr>
<td><code>lv_spangroup_set_overflow(obj, overflow)</code></td>
<td>控制溢出文本的处理方式</td>
</tr>
<tr>
<td><code>lv_spangroup_set_indent(obj, indent)</code></td>
<td>设置文本的首行缩进，单位为像素</td>
</tr>
<tr>
<td><code>lv_spangroup_set_mode(obj, mode)</code></td>
<td>设置对多行文本的折行处理，可以参见枚举 <code>lv_span_mode_t</code></td>
</tr>
</tbody>
</table>
<p>有了 span-group 以后，可以使用以下代码从中创建一个 span 并设置文本：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_span_t</span>* span = <span class="hljs-built_in">lv_spangroup_new_span</span>(spangroup);
<span class="hljs-built_in">lv_span_set_text</span>(span, <span class="hljs-string">"LVGL is an open-source graphics library"</span>);
</pre></div>
<p>每一个 span 都提供了一个独立的样式接口，可以单独设置范围内文本的样式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_text_color</span>(&amp;span-&gt;style, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
</pre></div>
<p>一个 span-group 可以创建多个 span ，并且它们的样式效果互不影响：</p>
<div class="hljs codeblock"><pre>span = <span class="hljs-built_in">lv_spangroup_new_span</span>(spangroup);
<span class="hljs-built_in">lv_span_set_text</span>(span, <span class="hljs-string">"providing everything"</span>);
<span class="hljs-built_in">lv_style_set_text_decor</span>(&amp;span-&gt;style, LV_TEXT_DECOR_UNDERLINE);
<span class="hljs-built_in">lv_style_set_text_font</span>(&amp;span-&gt;style, &amp;lv_font_montserrat_20);
<span class="hljs-comment">/* ... */</span>
span = <span class="hljs-built_in">lv_spangroup_new_span</span>(spangroup);
<span class="hljs-built_in">lv_span_set_text</span>(span, <span class="hljs-string">"to create embedded GUI"</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-spangroup.jpg" alt="image" width="210"></figure>
<p>可以注意到默认的 span-group 是没什么样式的。span-group 还有很多的 API ，具体可以参照官方文档的相关介绍。</p>
<h3>其它样式</h3>
<p>下表列出了一些其它的样式属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>radius</code></td>
<td>设置控件的圆角，该属性会一并影响边框和轮廓</td>
<td>0，即无圆角</td>
</tr>
<tr>
<td><code>clip_corner</code></td>
<td>如果有圆角，是否要将 Content-aera 超出圆角的部分去除</td>
<td>否</td>
</tr>
<tr>
<td><code>layout</code></td>
<td>设置控件的布局方式</td>
<td>0</td>
</tr>
<tr>
<td><code>base_dir</code></td>
<td>设置文字的书写方向，它会同时影响布局的方向</td>
<td>默认书写方向</td>
</tr>
<tr>
<td>...</td>
<td>与颜色有关的属性将在之后介绍</td>
<td></td>
</tr>
</tbody>
</table>
<p>在设置半径时可以使用百分数，例如 <code>lv_pct(50)</code> 将使控件变成圆形。</p>
<p>以上列出了大部分的样式属性，但是除了颜色外还有许多样式没有介绍，例如变换、动画、渐变等，这些留到之后介绍。LVGL 中还存在一些特殊的样式，它们是为相应的控件设计的，接下来介绍这些控件及样式。</p>
<h2>基本图形：直线和弧线</h2>
<h3>直线</h3>
<p>LVGL 中的直线(line)实际上指的是折线，因为它可以一次性连续绘制多条相接的线段。为了绘制折线，首先要准备一些端点的坐标：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_point_t</span> line_points[] = { {<span class="hljs-number">217</span>, <span class="hljs-number">36</span>}, {<span class="hljs-number">35</span>, <span class="hljs-number">49</span>}, {<span class="hljs-number">281</span>, <span class="hljs-number">163</span>}, {<span class="hljs-number">110</span>, <span class="hljs-number">162</span>}, {<span class="hljs-number">257</span>, <span class="hljs-number">111</span>} };
</pre></div>
<p>然后可以通过这些端点来创建折线：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* line1 = <span class="hljs-built_in">lv_line_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_line_set_points</span>(line1, line_points, <span class="hljs-number">5</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-line-create.jpg" alt="image" width="220"></figure>
<p>创建的折线作为一个整体，实际上也是一个控件，当然可以给它加上各种属性：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_style_t</span> style_line;
<span class="hljs-built_in">lv_style_init</span>(&amp;style_line);
<span class="hljs-built_in">lv_style_set_align</span>(&amp;style_line, LV_ALIGN_TOP_MID);
<span class="hljs-built_in">lv_style_set_border_width</span>(&amp;style_line, <span class="hljs-number">4</span>);
<span class="hljs-built_in">lv_obj_add_style</span>(line01, &amp;style_line, <span class="hljs-number">0</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-line-style.jpg" alt="image" width="220"></figure>
<p>折线拥有一些特殊的样式属性，是其它控件所没有的。下表列出了折线的特殊属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>line_width</code></td>
<td>设置线段宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>line_dash_width</code></td>
<td>设置虚线实部分的距离</td>
<td>0</td>
</tr>
<tr>
<td><code>line_dash_gap</code></td>
<td>设置虚线虚部分的距离</td>
<td>0</td>
</tr>
<tr>
<td><code>line_rounded</code></td>
<td>设置线段端点是否为圆角</td>
<td>否</td>
</tr>
<tr>
<td><code>line_color</code></td>
<td>设置线段颜色</td>
<td>黑色</td>
</tr>
<tr>
<td><code>line_opa</code></td>
<td>设置颜色透明度</td>
<td>不透明</td>
</tr>
</tbody>
</table>
<p>注意，虚线只对水平和垂直的线段有效，并且只有两个属性都不为 0 才有虚线的效果。</p>
<p>例如，样式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_line_color</span>(&amp;style_line, <span class="hljs-built_in">lv_palette_main</span>(LV_PALETTE_BLUE));
<span class="hljs-built_in">lv_style_set_line_width</span>(&amp;style_line, <span class="hljs-number">8</span>);
</pre></div>
<p>表现效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-style-line-1.jpg" alt="image" width="260"></figure>
<p>如果再添加上：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_style_set_line_dash_width</span>(&amp;style_line, <span class="hljs-number">10</span>)
<span class="hljs-built_in">lv_style_set_line_dash_gap</span>(&amp;style_line, <span class="hljs-number">5</span>)
<span class="hljs-built_in">lv_style_set_line_rounded</span>(&amp;style_line, <span class="hljs-literal">true</span>);
</pre></div>
<p>那么效果就变成：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-style-line-2.jpg" alt="image" width="260"></figure>
<p>关于折线还有一个函数 <code>lv_line_set_y_invert(lv_obj_t *obj, bool en)</code> 可以用来控制绘制的折线垂直翻转（即翻转 y 轴）。除此之外折线并没有什么可以介绍的。在后续还会介绍图表，可以绘制更美观的折线效果。</p>
<h3>圆弧</h3>
<p>LVGL 中的圆弧(arc)尽管和直线同属于基础控件，但圆弧的功能远比直线丰富，甚至 API 比起滑块这些复杂的控件都多。</p>
<p>首先简单创建一个圆弧，查看它的默认效果：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* arc01 = <span class="hljs-built_in">lv_arc_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
</pre></div>
<p>默认的效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-create.jpg" alt="image" width="140"></figure>
<p>可以看出圆弧的在默认情况下，它的表现形式实际上就是弧形的滑块。如果想要得到纯粹的圆弧，可以将圆弧的把手删除：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_remove_style</span>(arc01, <span class="hljs-literal">NULL</span>, LV_PART_KNOB);
<span class="hljs-built_in">lv_obj_clear_flag</span>(arc01, LV_OBJ_FLAG_CLICKABLE);
</pre></div>
<p>这里做了两件事：首先是将把手的样式删除，这里第二个参数 <code>NULL</code> 表示删去全部样式；其次将圆弧的可点击标志位清除，使它不再能接收用户的点击事件。这样圆弧看起来就纯粹多了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-remove-knob.jpg" alt="image" width="140"></figure>
<p>还可以进一步删去圆弧的指示条(indicator)，让它更像传统的圆弧。</p>
<p>默认的圆弧是开口向下的 270° 圆弧。为了设置圆弧的形状，可以使用函数</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_arc_set_angles</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">uint16_t</span> start, <span class="hljs-keyword">uint16_t</span> end)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_arc_set_bg_angles</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">uint16_t</span> start, <span class="hljs-keyword">uint16_t</span> end)</span></span>;
</pre></div>
<p>分别修改前景和背景的圆弧起止范围，单位为角度。注意，圆弧的角度 0° 是正右方向，90° 是正下方向，以此类推。这两个函数都有单独设置起或止位置的版本。例如，设置</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_arc_set_bg_angles</span>(arc01, <span class="hljs-number">0</span>, <span class="hljs-number">270</span>);
<span class="hljs-built_in">lv_arc_set_end_angle</span>(arc01, <span class="hljs-number">180</span>);
</pre></div>
<p>可以将圆弧的角度调整为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-angles.jpg" alt="image" width="140"></figure>
<p>圆弧也像直线一样具有特殊的样式，下表列出了圆弧具有的样式属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arc_width</code></td>
<td>设置圆弧宽度</td>
<td>0</td>
</tr>
<tr>
<td><code>arc_rounded</code></td>
<td>设置圆弧端点是否为圆角</td>
<td>否</td>
</tr>
<tr>
<td><code>arc_color</code></td>
<td>设置圆弧颜色</td>
<td>黑色</td>
</tr>
<tr>
<td><code>arc_opa</code></td>
<td>设置圆弧透明度</td>
<td>不透明</td>
</tr>
<tr>
<td><code>arc_img_src</code></td>
<td>设置圆弧填充图片</td>
<td>无填充图片</td>
</tr>
</tbody>
</table>
<p>以上是官方文档的介绍，但这个默认值显然与实际不符。之所以会这样，原因是在 <code>lv_conf.h</code> 大约 514 行，启用过默认的样式：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/*A simple, impressive and very complete theme*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_USE_THEME_DEFAULT 1</span>
</pre></div>
<p>而该样式在初始化时，就会修改包括圆弧在内的一些样式，因此圆弧、按钮等控件才默认表现为这个模样。</p>
<p>圆弧可以作为一个基准让控件对齐。例如，可以使用</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_arc_rotate_obj_to_angle</span>(arc01, label, <span class="hljs-number">25</span>);
</pre></div>
<p>让一个标签旋转对齐圆弧的把手，第三个参数为半径的偏移量，效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-align.jpg" alt="image" width="140"></figure>
<p>与其说是对齐把手，更准确的说法是对齐圆弧当前的值。例如，可以通过以下函数改变圆弧的值：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_arc_set_value</span>(arc01, <span class="hljs-number">20</span>);
</pre></div>
<p>这样效果就很明显了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-04-arc-rotate-align.jpg" alt="image" width="140"></figure>
<p>圆弧默认的取值范围是 0~100 ，也可以通过 <code>lv_arc_set_range(obj, min, max)</code> 函数修改这一取值范围。除此之外，还有另一个函数 <code>lv_arc_align_obj_to_angle(obj, obj_to_align, r_offset)</code> 只对齐控件而不发生旋转。另外需要注意，应该先对齐圆弧后，再设置标签的对齐，否则标签会因为不是包含关系而不随之更新位置。</p>
<p>总体来说，圆弧因为不是纯粹的圆弧，因此它具有滑块的各种特征，例如可以响应 <code>LV_EVENT_VALUE_CHANGED </code> 事件，可以使用 <code>lv_arc_get_value(obj)</code> 获取值等。</p>

<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/overview/style.html">https://docs.lvgl.io/master/overview/style.html</a></p>
<p>官方文档——样式简介</p>
<p><a href="https://docs.lvgl.io/master/overview/style-props.html">https://docs.lvgl.io/master/overview/style-props.html</a></p>
<p>官方文档——所有的样式属性简介</p>
<p><a rel="nofollow" href="/archives/361">LVGL库入门教程04-样式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/361/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程03-布局方式</title>
		<link>/archives/342</link>
					<comments>/archives/342#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 16 Jun 2022 02:37:24 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=342</guid>

					<description><![CDATA[<p>LVGL的布局 上一节介绍了如何在 LVGL 中创建&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/342">LVGL库入门教程03-布局方式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>LVGL的布局</h2>
<p>上一节介绍了如何在 LVGL 中创建控件。如果在创建控件时不给控件安排布局，那么控件默认会被放在父容器的左上角。</p>
<p>可以使用 <code>lv_obj_set_pos(obj, x, y)</code> 调整一个控件的位置（或者使用类似的函数单独调整一个方向的坐标），将它放在相对父容器左上角的合适位置。不过这种布局方式非常死板，因为绝对坐标一旦设定就不能自动调整；而且当控件数量较多时，也很难确定合适的坐标值。</p>
<p>上一节介绍过，可以使用 <code>lv_obj_align(obj, align, x_ofs, y_ofs)</code> 设置一个控件相对父容器的对齐，并用以下图片展示所有的对齐方式：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-align.png" alt="image" width="600"></figure>
<p>从图片中可以看到，控件之间不仅可以内对齐，也可以外对齐。如果两个控件间没有包含关系也不要紧，可以使用 <code>lv_obj_align_to(obj, base, align, x_ofs, y_ofs);</code> 设置两个控件的相对对齐方式。</p>
<p>这种对齐的方式对于控件不多的情况下来说是足够了，但是有些时候需要对很多并列的控件布局（例如，一个计算机界面的所有按钮）。这个时候常规的对齐方式就难以满足需求了。</p>
<p>因此，LVGL 提供了两种更复杂的布局方式：</p>
<ul>
<li>flex（弹性盒子）</li>
<li>grid（网格）</li>
</ul>
<p>这两种布局和 CSS3 新增的 flex 布局和 grid 布局比较相似，如果熟悉 CSS 的话对它们应该不会陌生。</p>
<h2>flex布局</h2>
<p>flex 是一个实验性质的布局，首先需要确定已经在 <code>lv_conf.h</code> 大约 588 行的位置启用了 flex 布局：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/*A layout similar to Flexbox in CSS.*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LV_USE_FLEX 1</span>
</pre></div>
<p>后续介绍的 grid 布局也是如此。</p>
<h3>创建flex布局</h3>
<p>如果不添加任何布局方式，那么所有的控件都会堆放在左上角。flex 布局可以将一些控件按行或列均匀布局，并且可以自动调整它们的间距。</p>
<p>可以给一个容器设置一个 flex-flow 属性，这样容器就可以使用 flex 布局方式：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_ROW);
</pre></div>
<p>对于设置了 flex 布局的容器，在其中创建的元素都会在一个坐标轴上均匀排布。例如，以下使用 <code>for</code> 循环创建多个控件：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">300</span>, <span class="hljs-number">75</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
    <span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
    <span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
    <span class="hljs-built_in">lv_label_set_text_fmt</span>(label, <span class="hljs-string">"%d"</span>, i + <span class="hljs-number">1</span>);
}
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-flow.jpg" alt="image" width="300"></figure>
<p>尽管没有设置按钮的位置，但是每一个按钮都会在水平位置上均匀排布。如果要让排布时不超过父容器的最大宽度，可以使用 <code>LV_FLEX_FLOW_ROW_WRAP</code> 折行。</p>
<p>也可以使用按列的方式排布控件。可以通过 <code>lv_flex_flow_t</code> 枚举类型检查更多的 flex 布局形式。</p>
<h3>flex布局的对齐</h3>
<p>以上 flex 布局中，各控件的尺寸和间距都是固定的，并且第一个控件依然会出现在左上角。如果</p>
<p>可以使用</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_flex_align</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> * obj, 
                           <span class="hljs-keyword">lv_flex_align_t</span> main_place, 
                           <span class="hljs-keyword">lv_flex_align_t</span> cross_place,
                           <span class="hljs-keyword">lv_flex_align_t</span> track_place)</span></span>;
</pre></div>
<p>设置 flex 布局的对齐方式。该函数一次性会设置三个方面的对齐：</p>
<ul>
<li><code>main_place</code> ：设置行或列的对齐</li>
<li><code>cross_place</code> ：设置控件在一行或一列内的对齐（当控件高度或宽度不一致时就可以看出效果）</li>
<li><code>track_place</code> ：flex-flow 方向上的对齐</li>
</ul>
<p>如果接触过 CSS 的话，可以明白这些对齐方式实际上就是 CSS 里的 <code>justify-content</code> 、<code>align-items</code> 和 <code>align-content</code> 。</p>
<p>例如，以下调用</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_ROW_WRAP);
<span class="hljs-built_in">lv_obj_set_flex_align</span>(cont, LV_FLEX_ALIGN_SPACE_EVENLY, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
</pre></div>
<p>创建的每个控件之间在水平方向上均匀对齐、行内上下居中对齐，并作为一个整体上下居中对齐，效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-align-1.jpg" alt="image" width="240"></figure>
<p>又如，以下调用：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_ROW_WRAP);
<span class="hljs-built_in">lv_obj_set_flex_align</span>(cont, LV_FLEX_ALIGN_SPACE_BETWEEN, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
</pre></div>
<p>创建的每个控件之间在水平方向上两端对齐、行内顶端对齐，并作为一个整体顶端对齐，效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-align-2.jpg" alt="image" width="240"></figure>
<p>flex 布局还可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_flex_grow</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">uint8_t</span> grow)</span></span>;
</pre></div>
<p>动态调整各个控件的相对宽度，实现更灵活的布局规则。例如，以下代码在一个 flex-flow 框架内创建了 4 个按钮，并将第二个按钮的相对宽度设置为其它按钮的两倍：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
    <span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
    <span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
    <span class="hljs-built_in">lv_label_set_text_fmt</span>(label, <span class="hljs-string">"%d"</span>, i);
    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)
        <span class="hljs-built_in">lv_obj_set_flex_grow</span>(btn, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">lv_obj_set_flex_grow</span>(btn, <span class="hljs-number">1</span>);
}
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-grow.jpg" alt="image" width="210"></figure>
<p>以下利用相对宽度创建了一个更复杂的类似数字输入键盘的布局规则：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_ROW_WRAP);
<span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">160</span>, <span class="hljs-number">180</span>);
<span class="hljs-built_in">lv_obj_set_flex_align</span>(cont, LV_FLEX_ALIGN_SPACE_BETWEEN, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_START);
<span class="hljs-built_in">lv_obj_set_style_base_dir</span>(cont, LV_BASE_DIR_RTL, <span class="hljs-number">0</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int8_t</span> i = <span class="hljs-number">9</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    <span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
    <span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
    <span class="hljs-built_in">lv_label_set_text_fmt</span>(label, <span class="hljs-string">"%d"</span>, i);
}
<span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
<span class="hljs-built_in">lv_obj_set_flex_grow</span>(btn, <span class="hljs-number">2</span>);
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"OK"</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-flex-layout.jpg" alt="alt" width="160"></figure>
<p>这里使用 <code>lv_obj_set_style_base_dir()</code> 函数设置从右向左的书写方式，因此滚动条才会出现在左侧。后续介绍样式时还会介绍更多类似函数。</p>
<p>一般情况下 flex-grow 和带 wrap 的 flex-flow 是冲突的，也就是说所有设置了 flex-grow 的控件都会在同一行布局，但它们的宽度可能变得很窄。因此，以上的各个数字按钮相对宽度并不一致。</p>
<p>使用这种布局创建键盘非常别扭，不过好在 LVGL 提供了另一种形式的布局：grid 。</p>
<h2>grid布局</h2>
<h3>创建grid布局</h3>
<p>grid 布局是一种网格形式的布局，可以按行或列来对齐控件。</p>
<p>为了创建网格布局，首先要给出格子的长度和宽度。一般来说，可以通过两个数组分别描述网格每一行的宽度和每一列的宽度：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_coord_t</span> col_size[] = { <span class="hljs-number">60</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, LV_GRID_TEMPLATE_LAST };
<span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_coord_t</span> row_size[] = { <span class="hljs-number">40</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, LV_GRID_TEMPLATE_LAST };
</pre></div>
<p>每一个数组都需要以 <code>LV_GRID_TEMPLATE_LAST</code> 结尾。然后就可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_grid_dsc_array</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_coord_t</span> col_dsc[], <span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_coord_t</span> row_dsc[])</span>
</span></pre></div>
<p>函数为一个容器设置网格划分。</p>
<blockquote>
<p>注意，创建的数组一定要声明为 <code>static</code> 或全局变量，因为这部分数据在后续渲染时才会被用上。</p>
</blockquote>
<p>划分好了网格以后，接下来就可以使用以下函数：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_grid_cell</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> * obj, 
    <span class="hljs-keyword">lv_grid_align_t</span> x_align, <span class="hljs-keyword">uint8_t</span> col_pos, <span class="hljs-keyword">uint8_t</span> col_span,
    <span class="hljs-keyword">lv_grid_align_t</span> y_align, <span class="hljs-keyword">uint8_t</span> row_pos, <span class="hljs-keyword">uint8_t</span> row_span)</span></span>;
</pre></div>
<p>将每一个控件摆放在合适的网格位置。<code>align</code> 指定每一个放置在网格上的控件相对格线的对齐；<code>pos</code> 指定控件放置在哪个格子里，最左上角的格子位置为 (0, 0) ；有的控件可能占据不止一个格子的位置，那么就需要使用 <code>span</code> 来跨越多格。</p>
<p>例如，以下代码：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
    <span class="hljs-keyword">uint8_t</span> col = i % <span class="hljs-number">3</span>;
    <span class="hljs-keyword">uint8_t</span> row = i / <span class="hljs-number">3</span>;
    <span class="hljs-keyword">lv_obj_t</span>* btn = <span class="hljs-built_in">lv_btn_create</span>(cont);
    <span class="hljs-built_in">lv_obj_set_grid_cell</span>(btn, LV_GRID_ALIGN_STRETCH, col, <span class="hljs-number">1</span>,
                              LV_GRID_ALIGN_STRETCH, row, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(btn);
    <span class="hljs-built_in">lv_label_set_text_fmt</span>(label, <span class="hljs-string">"r%d c%d"</span>, row, col);
    <span class="hljs-built_in">lv_obj_center</span>(label);
}
</pre></div>
<p>得到的网格为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-grid-desc.jpg" alt="image" width="270"></figure>
<p>这里使用 <code>LV_GRID_ALIGN_STRETCH</code> 让网格内的控件尺寸伸展至网格大小，使网格布局的特点更加明显。</p>
<h3>grid布局的对齐</h3>
<p>使用网格布局时，每个格子内的控件在创建时都可以在网格内对齐。除此之外，还可以设置网格自身的对齐方式：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_grid_align</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> * obj, <span class="hljs-keyword">lv_grid_align_t</span> column_align, <span class="hljs-keyword">lv_grid_align_t</span> row_align)</span></span>;
</pre></div>
<p>网格在横向和竖向对齐摆放时，对齐方式都类似于 flex ，因此可以认为 grid 是一种二维的 flex 布局。</p>
<p>例如，如果略微修改以上代码，添加如下语句：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_set_grid_align</span>(cont, LV_GRID_ALIGN_SPACE_BETWEEN, LV_GRID_ALIGN_END);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) {
    <span class="hljs-comment">/* ... */</span>
    <span class="hljs-built_in">lv_obj_set_grid_cell</span>(btn, LV_GRID_ALIGN_START, col, <span class="hljs-number">1</span>,
                              LV_GRID_ALIGN_START, row, <span class="hljs-number">1</span>);
    <span class="hljs-comment">/* ... */</span>
}
</pre></div>
<p>这里去除了控件尺寸的伸展，使网格的对齐特点更明显：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-grid-align.jpg" alt="image" width="270"></figure>
<hr>
<p>网格也可以使用相对大小，具体做法是利用 <code>LV_GRID_FR(x)</code> 宏计算相对宽度。例如，以下定义了一个这样的宽度数组：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">lv_coord_t</span> col_pos[] = { <span class="hljs-built_in">LV_GRID_FR</span>(<span class="hljs-number">1</span>), <span class="hljs-number">60</span>, <span class="hljs-built_in">LV_GRID_FR</span>(<span class="hljs-number">2</span>), LV_GRID_TEMPLATE_LAST };
</pre></div>
<p>那么第二列的宽度是绝对宽度 60 ，剩余的宽度被划分为 3 份：第一列占 1 份，第三列占 2 份。这种形式创建的网格可以适应容器的尺寸大小：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-grid-devide.jpg" alt="image" width="270"></figure>
<h2>组合控件</h2>
<h3>复选框</h3>
<p>复选框(ckeckbox)是一种类似开关，但是带有标签的控件。可以使用以下代码创建复选框并设置标签文本：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* check = <span class="hljs-built_in">lv_checkbox_create</span>(cont);
<span class="hljs-built_in">lv_checkbox_set_text</span>(check, <span class="hljs-string">"Use DMA"</span>);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-checkbox-create.gif" alt="image" width="180"></figure>
<p>一般用复选框并列表示一些“是/否”的选项，因此多个并列的复选项很适合使用 flex 布局表现。复选框可以通过状态 <code>LV_STATE_CHECKED</code> 检查是否被勾选。</p>
<p>LVGL 中没有提供单选按钮(radio button)这一控件，不过可以使用复选框表示单选按钮。单选按钮在同一时间内只有且必须有一个选择框被选中。首先创建一个框架并使用列模式的 flex 布局：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">140</span>, <span class="hljs-number">200</span>);
<span class="hljs-built_in">lv_obj_set_flex_flow</span>(cont, LV_FLEX_FLOW_COLUMN);
<span class="hljs-built_in">lv_obj_set_flex_align</span>(cont, LV_FLEX_ALIGN_SPACE_EVENLY, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER);
</pre></div>
<p>然后可以在其中创建一些复选框：</p>
<div class="hljs codeblock"><pre><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHECKBOX_ITEMS 4</span>
<span class="hljs-keyword">char</span>* checkbox_labels[CHECKBOX_ITEMS] = {
    <span class="hljs-string">"Use parity bits"</span>, <span class="hljs-string">"Use stop bit"</span>, <span class="hljs-string">"Auto send"</span>, <span class="hljs-string">"Debug mode"</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; CHECKBOX_ITEMS; i++) {
    <span class="hljs-keyword">lv_obj_t</span>* check = <span class="hljs-built_in">lv_checkbox_create</span>(cont);
    <span class="hljs-built_in">lv_checkbox_set_text</span>(check, checkbox_labels[i]);
}
</pre></div>
<p>为了实现单选按钮的效果，需要在点击事件中清除上一个被选中的选择框。这里介绍一个技巧如何获取事件控件的父容器。如果一个控件被设置了冒泡事件标志 <code>LV_OBJ_FLAG_EVENT_BUBBLE</code> ，那么该控件被点击时，事件将会由它的父容器触发（如果父容器也设置了这一标志位，那么事件还会继续向上冒泡）。</p>
<p>可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span>* <span class="hljs-title">lv_event_get_current_target</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span></span>;
</pre></div>
<p>获取最终触发真正送出事件的控件（也就是冒泡后的父控件），而之前介绍的 <code>lv_event_get_target()</code> 函数则获取的是最先触发事件的控件（也就是子控件）。这样通过设置合适的冒泡层数，就可以同时获取控件与它的父容器了。</p>
<p>了解了这一特性后，就可以编写合适的代码了。首先定义一个全局变量 <code>checked_index</code> 记录单选按钮组此刻选中的按钮索引号，并作为用户数据传给回调函数中：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> checked_index = <span class="hljs-number">0</span>;
<span class="hljs-comment">/* ... */</span>
<span class="hljs-built_in">lv_obj_add_event_cb</span>(cont, radio_checked_cb, LV_EVENT_CLICKED, &amp;checked_index);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; CHECKBOX_ITEMS; i++) {
    <span class="hljs-comment">/* ... */</span>
    <span class="hljs-built_in">lv_obj_add_flag</span>(check, LV_OBJ_FLAG_EVENT_BUBBLE);
}
</pre></div>
<p>由于事件最终由父容器触发，因此要给父容器提供回调函数。然后，在回调函数中通过父容器与索引值取消上一个被点击的选择框选择，选择点击的选择框并更新索引值：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">radio_checked_cb</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span> </span>{
    <span class="hljs-keyword">uint8_t</span>* post_checked_index = <span class="hljs-built_in">lv_event_get_user_data</span>(e);
    <span class="hljs-keyword">lv_obj_t</span>* target = <span class="hljs-built_in">lv_event_get_target</span>(e);
    <span class="hljs-keyword">lv_obj_t</span>* parent = <span class="hljs-built_in">lv_event_get_current_target</span>(e);
    <span class="hljs-keyword">if</span> (target == parent) 
        <span class="hljs-keyword">return</span>;
    <span class="hljs-built_in">lv_obj_clear_state</span>(<span class="hljs-built_in">lv_obj_get_child</span>(parent, *post_checked_index), LV_STATE_CHECKED);
    <span class="hljs-built_in">lv_obj_add_state</span>(target, LV_STATE_CHECKED);
    *post_checked_index = <span class="hljs-built_in">lv_obj_get_index</span>(target);
}
</pre></div>
<p>由于父容器也拥有点击事件，因此首先要判断事件是否是由选择框触发的。这种事件处理方式非常简洁高效，而且无需定义额外的辅助数组。</p>
<p>这样就可以使用复选框代替单选按钮了，并且这样的回调函数是可以复用的，如果有另一组单选按钮也可以使用类似的方式提供响应：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-checkbox-as-radio.gif" alt="image" width="200"></figure>
<h2>列表</h2>
<p>LVGL 的列表(list)表现形式更像大多数界面提供的标题栏菜单。这里先介绍列表仅仅是因为它比较简单。列表的核心函数只有 3 个：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span> *<span class="hljs-title">lv_list_create</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *parent)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span> *<span class="hljs-title">lv_list_add_text</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *list, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *txt)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span> *<span class="hljs-title">lv_list_add_btn</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *list, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *icon, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *txt)</span></span>;
</pre></div>
<p>以下应用这三个函数创建一个列表：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* list = <span class="hljs-built_in">lv_list_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_list_add_text</span>(list, <span class="hljs-string">"group1"</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
    <span class="hljs-built_in">lv_list_add_btn</span>(list, <span class="hljs-literal">NULL</span>, <span class="hljs-string">"item"</span>);
<span class="hljs-built_in">lv_list_add_text</span>(list, <span class="hljs-string">"group2"</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint8_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)
    <span class="hljs-built_in">lv_list_add_btn</span>(list, <span class="hljs-literal">NULL</span>, <span class="hljs-string">"item"</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-03-list-create.jpg" alt="image" width="190"></figure>
<p>默认创建的列表尺寸较大，可以手动调整尺寸大小。</p>
<p>列表中的按钮和一般创建的按钮没有区别，可以给返回值提供回调函数。按钮在创建时还可以指定按钮的图标，图标的本质就是 Unicode 中的特殊符号，在 <code>lvgl/src/font/lv_symbol_def.h</code> 中可以查看提供的特殊符号。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/layouts/index.html">https://docs.lvgl.io/master/layouts/index.html</a></p>
<p>官方文档——布局部分。</p>
<p><a rel="nofollow" href="/archives/342">LVGL库入门教程03-布局方式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/342/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程02-基本控件与交互</title>
		<link>/archives/316</link>
					<comments>/archives/316#comments</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Tue, 14 Jun 2022 08:49:13 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<guid isPermaLink="false">/?p=316</guid>

					<description><![CDATA[<p>LVGL 本质上是一个 GUI 库，它包含大量的控件&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/316">LVGL库入门教程02-基本控件与交互</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>LVGL 本质上是一个 GUI 库，它包含大量的控件(widget)，即按钮、标签、滑块、菜单栏这种具有一定人机交互特征的组合图形。LVGL 在设计时，采用了一定面向对象编程的设计思路，有效降低了代码编写的难度。</p>
<p>LVGL 和大多数 GUI 库的工作方式都是类似的，其代码编写的基础思路为：</p>
<ul>
<li>创建 GUI 根窗体对象</li>
<li>在窗体上绘制各种控件</li>
<li>为控件编写响应函数函数</li>
<li>在主事件循环中等待用户触发事件响应</li>
</ul>
<p>如果之前有 GUI 库的使用经验的话，应该可以比较容易明白 LVGL 代码的编写思路。</p>
<h2>标签</h2>
<p>标签(label)应该是 GUI 最简单也是最基础的控件之一。标签的作用就是显示一小段说明文字。接下来通过介绍标签来介绍 LVGL 控件的创建、布局与设置属性。</p>
<h3>标签的创建</h3>
<p>通过以下函数可以创建一个标签：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span>* <span class="hljs-title">lv_label_create</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* parent)</span></span>;
</pre></div>
<p><code>lv_obj_t</code> 是 LVGL 所有控件的通用类型，包括根窗体在内的所有控件都使用该结构描述。</p>
<p>参数 <code>parent</code> 指定了标签需要被放在哪一个父容器中。由于一个较大的项目内会存在许多控件，因此往往需要将一个较大的窗口划分为若干结构，每一个结构放入用途相似的的控件，使用户更易熟悉如何操作。例如，一个文本编辑器窗口可能会按功能分为顶层菜单栏、侧边导航栏、底部状态栏以及中间的编辑区，每个区域的控件都可以安排在各栏内统一调整。</p>
<p>最基本的父容器就是整个显示屏窗口对象，可以使用 <code>lv_scr_act()</code> 函数获取当前的窗口对象。操作系统上的窗口可以设置一些属性，例如窗口大小、标题文字、图标等，不过嵌入式屏幕往往是固定的，因此窗口对象一般只作控件的父容器使用。</p>
<p>使用以下代码就可以在当前窗口中创建一个标签了：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* label01 = <span class="hljs-built_in">lv_label_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
</pre></div>
<p>创建得到的标签没有任何可显示的内容，可以调用 <code>lv_label_set_text()</code> 为标签添加上文字：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_label_set_text</span>(label01, <span class="hljs-string">"Hello, world!"</span>);
</pre></div>
<p>这样就可以在屏幕中显示一些文本了。LVGL 支持直接显示 Unicode 文字，只要在源文件使用 UTF-8 编码即可。如果要显示变量的值，LVGL 也提供了 <code>lv_label_set_text_fmt()</code> 函数，可以直接格式化文本。</p>
<p>接下来编译工程并下载，就可以看到显示的效果了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-getstart-label-create.jpg" alt="-" width="320"></figure>
<h3>标签的布局</h3>
<p>以上创建的标签默认放在屏幕的左上角，并且如果创建多个标签等控件，它们都会被重叠放置在左上角。如果需要将控件安排到合适的位置，就需要安排它们的布局。一般情况下，可以用以下函数重新调整一个控件的布局：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_align</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_align_t</span> align, <span class="hljs-keyword">lv_coord_t</span> x_ofs, <span class="hljs-keyword">lv_coord_t</span> y_ofs)</span></span>;
</pre></div>
<p><code>align</code> 指定了控件的对齐方式，可以检查枚举类型 <code>lv_align_t</code> 来获取支持的对齐方式。<code>x_ofs</code> 和 <code>y_ofs</code> 是对齐后的额外偏移量，正值表示额外向右下偏移。</p>
<blockquote>
<p>LVGL 包含了许多枚举类型，如果不知道该如何传值，可以查看头文件包含的枚举值。</p>
<p>和大多数 GUI 库一样，屏幕的左上角为坐标原点 (0, 0) ，往右为 x 轴正向，往下为 y 轴正向，坐标的单位为像素或分辨率。</p>
</blockquote>
<p>例如，如果额外给以上标签添加对齐：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_align</span>(label01, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">-30</span>);
</pre></div>
<p>那么它就会出现在屏幕中间向上 30 像素的位置：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-getstart-label-align.jpg" alt="-" width="320"></figure>
<p>如果要创建更灵活的布局，可以使用 <code>lv_obj_create()</code> 创建一个基本对象。这种直接创建的基本对象一般用作框架，然后通过嵌套框架的形式组织对齐，例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-comment">/* outer widget align */</span>
<span class="hljs-keyword">lv_obj_t</span>* cont_top = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-keyword">lv_obj_t</span>* cont_bottom = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_align</span>(cont_top, LV_ALIGN_TOP_LEFT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-built_in">lv_obj_align</span>(cont_bottom, LV_ALIGN_BOTTOM_RIGHT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-comment">/* inner widget align */</span>
<span class="hljs-keyword">lv_obj_t</span>* label_top = <span class="hljs-built_in">lv_label_create</span>(cont_top);
<span class="hljs-built_in">lv_label_set_text</span>(label_top, <span class="hljs-string">"At Top Left"</span>);
<span class="hljs-built_in">lv_obj_align</span>(label_top, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">lv_obj_t</span>* label_bottom = <span class="hljs-built_in">lv_label_create</span>(cont_bottom);
<span class="hljs-built_in">lv_label_set_text</span>(label_bottom, <span class="hljs-string">"At Bottom Right"</span>);
<span class="hljs-built_in">lv_obj_align</span>(label_bottom, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</pre></div>
<p>这里先将外层的框架在屏幕上对齐，然后再在框内创建标签，让标签在框架内对齐。效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-getstart-object-align.jpg" alt="!" width="320"></figure>
<p>通过这种嵌套的对齐方式，可以先让一些基础控件在框架内对齐，然后再让框架之间相对对齐。这种对齐方式更灵活，而且方便日后调整各个控件的相对位置。</p>
<p>LVGL 的所有控件都是以这种相对位置的形式组织的。官方文档提供了一张图片，可以很清楚地描述所有的相对对齐方式：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-align.png" alt="alt" width="600"></figure>
<p>由于居中对齐经常用到，可以直接使用 <code>lv_obj_center(*obj*)</code> 函数设置无偏移的居中对齐。</p>
<p>默认的基本控件是有样式的，并且注意到它们长宽都是固定的，如果包含的控件过长，它还会提供一个滚动条。如果需要调整控件的尺寸，可以使用函数，<code>lv_obj_set_width()</code> 和 <code>lv_obj_set_height()</code> 分别调整长宽，或使用 <code>lv_obj_set_size()</code> 一并调整：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(cont);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"Helllllo, world!"</span>);
<span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">160</span>, <span class="hljs-number">50</span>);
<span class="hljs-built_in">lv_obj_center</span>(cont);
<span class="hljs-built_in">lv_obj_center</span>(label);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-getstart-object-resize.jpg" alt="!" width="320"></figure>
<p>所有的控件都具有宽度和高度基本属性，因此这几个函数对任意的控件都有效。</p>
<h3>标签的长模式和颜色调整</h3>
<p>框架包含的控件过长会提供一个滚动条，确保包含的内容都可见。标签在创建时，它的宽度会适应包含文本的宽度。如果给一个标签重新调整尺寸，使得它的宽度小于文本的宽度，那么它包含的文本就会自动折叠：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* label01 = <span class="hljs-built_in">lv_label_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_label_set_text</span>(label01, <span class="hljs-string">"A very loooooooooooooooong text"</span>);
<span class="hljs-built_in">lv_obj_set_width</span>(label01, <span class="hljs-number">100</span>);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-label-too-long.jpg" alt="!" width="170"></figure>
<p>如果文本确实过长，超过了标签的长宽极限，那么可以使用函数</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_label_set_long_mode</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> * obj, <span class="hljs-keyword">lv_label_long_mode_t</span> long_mode)</span></span>;
</pre></div>
<p>给标签设置一个长模式。标签一共有 5 种长模式，每种模式的表现形式如下：</p>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LV_LABEL_LONG_WRAP</code></td>
<td>将过宽的文本换行，以多行的方式显示所有文本</td>
</tr>
<tr>
<td><code>LV_LABEL_LONG_DOT</code></td>
<td>将过长的文本隐藏并以省略号代替</td>
</tr>
<tr>
<td><code>LV_LABEL_LONG_SCROLL</code></td>
<td>将文本来回滚动显示</td>
</tr>
<tr>
<td><code>LV_LABEL_LONG_SCROLL_CIRCULAR</code></td>
<td>将文本循环滚动显示</td>
</tr>
<tr>
<td><code>LV_LABEL_LONG_CLIP</code></td>
<td>去除过长部分的文本</td>
</tr>
</tbody>
</table>
<p>如果文本显示时有多行，那么可以使用</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_set_style_text_align</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_text_align_t</span> value, <span class="hljs-keyword">lv_style_selector_t</span> selector)</span></span>;
</pre></div>
<p>将文本垂直对齐。第三个参数 <code>selector</code> 是设置样式用的，这里可以暂时不用理会。</p>
<p>以下动图展示了三种长模式：显示省略号、换行并居中对齐，以及循环滚动：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-label-long-mode.gif" alt="!" width="300"></figure>
<blockquote>
<p>需要注意的是，除了滚动以外的其它模式如果没有明确高度，都会在文本过长时优先尝试调整标签高度。</p>
</blockquote>
<p>滚动是一种特殊的动画，在后续介绍到动画时还可以创建更丰富的动画效果，可以自行调整文本的滚动行为。</p>
<hr>
<p>标签的文本可以改变颜色。LVGL 里，调整颜色是通过特殊格式的文本作用的。为了改变颜色，首先需要启用这一模式：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_label_set_recolor</span>(label01, <span class="hljs-literal">true</span>);
</pre></div>
<p>重新调整颜色的文本格式为：</p>
<div class="hljs codeblock"><pre>#RRGGBB <em>text</em>#
</pre></div>
<p>这样 <em><code>text</code></em> 对应的文本就会显示为 <code>#RRGGBB</code> 对应的色值。如果屏幕使用的是 16bit 的颜色也不要紧，LVGL 会自动转换颜色。</p>
<p>例如：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_label_set_text</span>(label01, <span class="hljs-string">"#0000ff Re-color# #ff00ff text# #ff0000 of a# label."</span>);
</pre></div>
<p>显示效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-label-recolor.jpg" alt="alt" width="220"></figure>
<h2>按钮</h2>
<p>按钮(button)也是一个比较基础的控件。按钮除了可以显示一些提示文字外，还可以点击并获取响应。接下来通过介绍按钮来介绍为控件绑定事件的一般方式。</p>
<h3>按钮的创建和事件绑定</h3>
<p>按钮的创建和布局方式都与标签类似：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* btn01 = <span class="hljs-built_in">lv_btn_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_align</span>(btn01, LV_ALIGN_CENTER, <span class="hljs-number">0</span>, <span class="hljs-number">-40</span>);
</pre></div>
<p>但是注意，创建得到的按钮只是一个简单的形状。为了给它添加说明文本，需要在其中创建一个标签：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* label01 = <span class="hljs-built_in">lv_label_create</span>(btn01);
<span class="hljs-built_in">lv_label_set_text</span>(label01, <span class="hljs-string">"Button"</span>);
<span class="hljs-built_in">lv_obj_center</span>(label01);
</pre></div>
<p>显示的效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-button-create.jpg" alt="alt" width="210"></figure>
<p>按钮不同于框架，按钮会自动调整宽高来适应其包含的标签大小。</p>
<p>创建的按钮已经默认具有点击动画，不过还无法对点击作出回应。接下来需要给按钮添加回调函数。可以使用以下函数为按钮绑定回调函数：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_add_event_cb</span>(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_event_cb_t</span> event_cb, <span class="hljs-keyword">lv_event_code_t</span> filter, <span class="hljs-keyword">void</span>* user_data);
</pre></div>
<p>任意可交互控件都可以使用该函数添加回调函数。这里不用管该函数的返回值。<code>event_cb</code> 是事件的回调函数，<code>filter</code> 决定按钮会对哪些事件作出响应，可以在 <code>user_data</code> 传入一些自定义的数据。</p>
<p>检查类型 <code>lv_event_cb_t</code> 的定义就可以明白如何编写回调函数。回调函数有且仅有一个 <code>lv_event_t</code> 类型的参数。该类型是一个比较复杂的结构类型，目前只需要明白它包括的结构成员包括自定义数据 <code>user_data</code> 即可。</p>
<p>例如，以下创建了一个简单的回调函数：</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">button_clicked_cb</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> count = <span class="hljs-number">0</span>;
    count++;
    <span class="hljs-built_in">lv_label_set_text_fmt</span>((<span class="hljs-keyword">lv_obj_t</span>*)e-&gt;user_data, <span class="hljs-string">"Clicked: %d"</span>, count);
}
</pre></div>
<p>这里通过自定义参数来修改外部标签的文本。那么在绑定时，就需要这样传入参数：</p>
<div class="hljs codeblock"><pre><span class="hljs-built_in">lv_obj_add_event_cb</span>(btn01, button_simple_cb, LV_EVENT_CLICKED, label01);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-button-click.gif" alt="alt" width="230"></figure>
<p>这里让按钮只对点击事件产生响应。如果要让按钮对多个事件响应的话，需要先让按钮对所有事件 <code>LV_EVENT_ALL</code> 产生响应的话，然后在回调函数内进一步判断事件类型：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_event_code_t</span> code = <span class="hljs-built_in">lv_event_get_code</span>(e);
<span class="hljs-keyword">if</span> (code == LV_EVENT_CLICKED) {
    <span class="hljs-comment">/* ... event handler ... */</span>
}
</pre></div>
<p>这就像在中断函数内判断中断源一样。</p>
<p>不过以上回调还可以使用另一种不传入用户参数的形式完成。首先，通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span>* <span class="hljs-title">lv_event_get_target</span><span class="hljs-params">(<span class="hljs-keyword">lv_event_t</span>* e)</span></span>;
</pre></div>
<p>可以获取产生事件的控件，然后通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">lv_obj_t</span>* <span class="hljs-title">lv_obj_get_child</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">int32_t</span> id)</span></span>;
</pre></div>
<p>获取该控件的子控件。在创建控件时，需要传入父容器控件，创建时父容器也会通过 <code>id</code> 记录包含的子控件，创建最早的控件 id 就是 0 ，第二早的 id 是 1 ，最晚的 id 还可以表示为 -1 等。这样就可以在事件回调函数内获取被点击按钮的标签控件对象了。</p>
<h3>控件的通用行为</h3>
<p>LVGL 中，可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_add_flag</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_obj_flag_t</span> f)</span></span>;
</pre></div>
<p>为控件设置一些通用的标志，来改变控件的行为。</p>
<p>例如，以上按钮都是普遍的按钮，它们通过点击来触发响应。但是还有一部分按钮，像控制键是通过点击来切换启用/关闭状态的。那么此时就可以给按钮添加一个这样的标志：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* btn02 = <span class="hljs-built_in">lv_btn_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_obj_add_flag</span>(btn02, LV_OBJ_FLAG_CHECKABLE);
</pre></div>
<p>这样创建的按钮可以对 <code>LV_EVENT_VALUE_CHANGED</code> 这个特殊的事件响应，而普通的按钮不行。不仅如此，切换之后的部分样式也会发生改变：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-button-toggle.gif" alt="alt" width="230"></figure>
<p>可以给一个控件添加多个标志，只需要使用按位或运算符 <code>|</code> 连接起来即可。还可以清除一个控件的标志。例如，如果给一个框架清除可滚动的标志，那么当它包含长文本时就不再可以滚动显示全部内容：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* cont = <span class="hljs-built_in">lv_obj_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-keyword">lv_obj_t</span>* label = <span class="hljs-built_in">lv_label_create</span>(cont);
<span class="hljs-built_in">lv_obj_clear_flag</span>(cont, LV_OBJ_FLAG_SCROLLABLE);
<span class="hljs-built_in">lv_label_set_text</span>(label, <span class="hljs-string">"A label contains very long text"</span>);
<span class="hljs-built_in">lv_obj_set_size</span>(cont, <span class="hljs-number">160</span>, <span class="hljs-number">50</span>);
</pre></div>
<p>效果为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-obj-unscrollable.jpg" alt="alt" width="230"></figure>
<p>标志是一个很重要的内容，通过为控件加上各种标志，可以自定义更多抽象的控件类型。例如，具有 <code>LV_OBJ_FLAG_CLICKABLE</code> 标志的控件可以响应点击事件，这种响应不仅包括回调函数，还关系着点击时的动画效果。LVGL 一共提供了 27 个独立的标志，其中有 8 个可供用户自定义。可以检查 <code>lv_obj_flag_t</code> 枚举定义来查看包含的所有标志位。</p>
<h2>开关</h2>
<h3>开关的创建</h3>
<p>以上创建的通过点击来切换启用/关闭状态的按钮可以使用开关(switch)代替。创建开关和创建其它控件类似：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* sw = <span class="hljs-built_in">lv_switch_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
</pre></div>
<p>开关的效果如下，通过单击可以切换开关状态：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-switch-create.gif" alt="alt" width="220"></figure>
<p>开关具有标志 <code>LV_OBJ_FLAG_CHECKABLE</code> ，因此可以响应事件 <code>LV_EVENT_VALUE_CHANGED</code> 。</p>
<h3>开关的状态</h3>
<p>一个控件可以具有多种标志，标志就是控件的抽象接口，决定了控件具有哪些行为。控件还具有多种不同的状态，在每种状态下，它的样式都是不一样的。可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_obj_add_state</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_state_t</span> state)</span></span>;
</pre></div>
<p>给一个控件设置不同的状态来切换样式。例如，如果给开关设置状态 <code>LV_STATE_CHECKED</code> ，它会表现出打开的状态。不同状态下控件接收的响应也不一样，例如如果给开关加上 <code>LV_STATE_DISABLED</code> 的状态，点击时它就无法接收任何响应，连样式也不会再切换了。</p>
<p>可以在响应函数内通过 <code>lv_obj_has_state(obj, state)</code> 来判断一个控件处于什么状态，从而决定执行什么样的代码。这种方式更贴合控件的行为。</p>
<p>每个控件都有 9 种独立的状态，还有 4 种状态可以由用户自由定义，这些状态都被放在头文件 <code>lv_obj.h</code> 中。可以使用按位与运算符 <code>|</code> 给一个控件添加多个状态。例如，可以给一个开关设置为既开启又只读 <code>LV_STATE_CHECKED | LV_STATE_DISABLED</code> ，那么它的样式就会表现为：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-switch-check-disable.jpg" alt="alt" width="130"></figure>
<p>状态是在标志之上的概念，在不同的状态下控件可能具有不同的标志。</p>
<h2>基本交互控件</h2>
<h3>下拉列表</h3>
<p>下拉列表(drop-down list)也是一个非常简单的控件。下拉列表在点击后会出现一些选项，点击选择后就可以触发一些事件。</p>
<p>可以通过 <code>lv_dropdown_set_options()</code> 为下拉列表创建列表项：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* drop01 = <span class="hljs-built_in">lv_dropdown_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_dropdown_set_options</span>(drop01, <span class="hljs-string">"STM32F1\n"</span>
                                <span class="hljs-string">"STM32F4\n"</span>
                                <span class="hljs-string">"STM32H7\n"</span>
                                <span class="hljs-string">"STM8"</span>);
</pre></div>
<p>LVGL 会自动拆分多行本文的每一行并分别创建一个列表项。下拉列表默认的行为是展示第一个列表项，并通过用户选择来切换展示的列表项：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-dropdown-create.gif" alt="alt" width="230"></figure>
<p>下拉列表在选择列表项时会触发 <code>LV_EVENT_VALUE_CHANGED</code> 事件，可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">uint16_t</span> <span class="hljs-title">lv_dropdown_get_selected</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_obj_t</span>* obj)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_dropdown_get_selected_str</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">char</span>* buf, <span class="hljs-keyword">uint32_t</span> buf_size)</span></span>;
</pre></div>
<p>来获取当前选中列表项索引或文本，如果要获取文本的话需要自行准备一个文本缓冲区。</p>
<p>下拉列表可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_dropdown_set_text</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* txt)</span>
</span></pre></div>
<p>给它设置一个固定的文本，这样的下拉列表可以充当下拉菜单使用。</p>
<p>下拉列表还可以通过</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_dropdown_set_dir</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">lv_dir_t</span> dir)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_dropdown_set_symbol</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span>* obj, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* symbol)</span></span>;
</pre></div>
<p>修改列表项出现的位置和下拉列表右侧的符号，由此可以组合出上拉列表、左拉列表等。</p>
<h3>滚动列表</h3>
<p>滚动列表(roller)和下拉列表类似，不过它是通过滚动来切换选择的列表项的。</p>
<p>滚动列表的创建、事件响应和获取选中值的方式都和下拉列表类似。以下是滚动列表的创建方式：</p>
<div class="hljs codeblock"><pre><span class="hljs-keyword">lv_obj_t</span>* roller01 = <span class="hljs-built_in">lv_roller_create</span>(<span class="hljs-built_in">lv_scr_act</span>());
<span class="hljs-built_in">lv_roller_set_options</span>(roller01,
                      <span class="hljs-string">"Monday\nTuesday\nWednesday\n"</span>
                      <span class="hljs-string">"Thursday\nFriday\nSaturday\nSunday"</span>,
                      LV_ROLLER_MODE_INFINITE);
</pre></div>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-02-roller-create.gif" alt="alt" width="240"></figure>
<p>在设置列表项时滚动列表多了一个参数，代表滚动到底后需要停止还是循环往复。滚动列表非常适合用于列表项稍微有些多，没有足够的空间展示所有列表项的情况。因此，滚动列表还可以使用函数</p>
<div class="hljs codeblock"><pre><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lv_roller_set_visible_row_count</span><span class="hljs-params">(<span class="hljs-keyword">lv_obj_t</span> *obj, <span class="hljs-keyword">uint8_t</span> row_cnt)</span></span>;
</pre></div>
<p>设置可见的列表项个数。如果设置为偶数，那么会有两个列表项只显示一半，就像动图中展示的一样。</p>
<h2>参考资料/延伸阅读</h2>
<p><a href="https://docs.lvgl.io/master/widgets/index.html">https://docs.lvgl.io/master/widgets/index.html</a></p>
<p>LVGL 官方文档——控件。在此可以查看更多文中没有提到的控件类型和使用细节，并查看官方编写的示例代码。</p>
<p><a rel="nofollow" href="/archives/316">LVGL库入门教程02-基本控件与交互</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/316/feed</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>LVGL库入门教程01-移植到STM32</title>
		<link>/archives/307</link>
					<comments>/archives/307#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 13 Jun 2022 02:55:21 +0000</pubDate>
				<category><![CDATA[单片机与应用]]></category>
		<category><![CDATA[LVGL]]></category>
		<category><![CDATA[STM32]]></category>
		<guid isPermaLink="false">/?p=307</guid>

					<description><![CDATA[<p>LVGL库简介 LVGL(Light and Ver&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/307">LVGL库入门教程01-移植到STM32</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>LVGL库简介</h2>
<p>LVGL(Light and Versatile Graphics Library)是一个免费、开源的嵌入式图形库，可以创建丰富、美观的界面，具有许多可以自定义样式的控件，支持按键或触摸响应，支持中文字符，并且内存占用较低。可以在 <a href="https://lvgl.io/demos">https://lvgl.io/demos</a> 使用网页端体验 LVGL 的动态效果，再决定是否需要使用 LVGL 。</p>
<p>LVGL 使用 C 语言编写，可以用在树莓派、ESP32 、STM32 等单片机上，并支持各种中大型屏幕（只需要提供屏幕的绘图 API 即可）。LVGL 的官网地址为：<a href="https://lvgl.io/">https://lvgl.io/</a> ，GitHub 地址为：<a href="https://github.com/lvgl/lvgl">https://github.com/lvgl/lvgl</a> 。</p>
<p>LVGL 提供了许多示例程序，还提供了 PC 端的模拟器，这都加快了 LVGL 的开发效率。</p>
<h2>移植LVGL</h2>
<p>LVGL 并没有只针对哪一个单片机和哪一个屏幕，事实上它甚至在 PC 机也能运行的起来。完整的 LVGL 的移植可以参考官方文档的介绍 <a href="https://docs.lvgl.io/master/porting/index.html">https://docs.lvgl.io/master/porting/index.html</a> 。在移植前，请自行了解单片机及屏幕的使用方法并提供接口程序。</p>
<h3>建立工程</h3>
<p>接下来以 STM32 系列单片机为例介绍 LVGL 的移植，不同单片机的移植过程也可以参考以下步骤。下表给出了 LVGL 所需的配置，在使用 LVGL 前请确保单片机性能满足要求：</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Minimal</strong></th>
<th><strong>Recommended</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Architecture</strong></td>
<td>16, 32 or 64 bit microcontroller or processor</td>
<td></td>
</tr>
<tr>
<td><strong>Clock</strong></td>
<td>&gt; 16 MHz</td>
<td>&gt; 48 MHz</td>
</tr>
<tr>
<td><strong>Flash/ROM</strong></td>
<td>&gt; 64 kB</td>
<td>&gt; 180 kB</td>
</tr>
<tr>
<td><strong>Static RAM</strong></td>
<td>&gt; 16 kB</td>
<td>&gt; 48 kB</td>
</tr>
<tr>
<td><strong>Draw buffer</strong></td>
<td>&gt; 1 ×<em>hor. res.</em> pixels</td>
<td>&gt; 1/10 screen size</td>
</tr>
<tr>
<td><strong>Compiler</strong></td>
<td>C99 or newer</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote><p>注意：使用 Keil5 请开启“C99 Mode”，否则会编译不通过。还在使用 Keil4 的请升级或更换编译器。</p></blockquote>
<p>首先，在 <a href="https://github.com/lvgl/lvgl">https://github.com/lvgl/lvgl</a> 下载或克隆整个工程。LVGL 的最新版本是 LVGL 8.2 ，注意 LVGL 7 已经不再更新，LVGL 7 和 8 之间库结构发生较大改变，编写出的代码并不很兼容，并且 LVGL 7 的示例代码和模拟器似乎已经在 GitHub 上下架了。本教程以 LVGL 8 为例，移植 LVGL 7 的话可以参考，但一些细节需要注意调整。建议使用最新版本，否则无法得到完整的工具链支持。</p>
<blockquote><p>使用 Keil 的开发者请注意，LVGL 8 似乎不能在 ARM CC v5 下编译成功，请更新编译器版本为 ARM CC v6 。</p>
<p>使用 STM32 的开发者还需要注意，STM32 标准库无法使用 ARM CC v6 编译，请使用 HAL 库或更换编译工具链（如 LLVM-clang 或 GCC-none-eabi ）</p></blockquote>
<p>接下来自行准备一个单片机工程，在 <code>User</code> 或其它等效的目录中，然后新建目录 <code>lvgl</code> 并进入，从克隆得到的 LVGL 工程中复制以下文件或目录到其中：</p>
<div class="codeblock code-template">
	examples<br />
src<br />
lvgl.h<br />
lv_conf_template.h</div>
<p>如果不需要使用官方提供的示例代码，可以不复制 <code>demos</code> 目录。</p>
<p>接下来，将 <code>lv_conf_template.h</code> 重命名为 <code>lv_conf.h</code> ，并移动到上一级目录中。</p>
<blockquote><p>注意：LVGL 库的目录比较复杂，头文件引用相对混乱，在没有充分明白正在做什么之前，请不要随意修改文件夹名或变更文件位置。</p></blockquote>
<p>回到上一级目录，打开 <code>lv_conf.h</code> ，将开头的 <code>#if 0</code> 条件编译取消，启用文件包含的配置：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/* clang-format off */</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span><span style="color: #403f53;"> </span><span style="color: #a8a8a8;">/*Set it to "1" to enable content*/</span></div>
</div>
<p>该配置文件还有几处需要调整的地方，首先最前面（第 27 行）的一个宏定义表示显示屏的颜色深度，需要根据不同的显示屏做调整：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/*Color depth: 1 (1 byte per pixel), 8 (RGB332), 16 (RGB565), 32 (ARGB8888)*/</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_COLOR_DEPTH</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">16</span></div>
</div>
<p>如果屏幕的颜色深度不一致，一定要修改该宏。LVGL 会根据该宏创建合适的颜色定义，如果与实际不一致会造成显示时颜色错乱。</p>
<blockquote><p>如果设置为 8 ，代表使用 8 位的颜色，其中 RBG 色值各占 3 、3 、2 位；如果设置为 16 ，则 RBG 色值各占 5 、6 、5 位，这是许多 TFT 屏采用的颜色格式；32 则是大多数 PC 机和移动设备都使用的带透明度的 32bit 位图，RGB 色值和透明度各占一个字节。</p></blockquote>
<p>第 52 行中还有一处表示最大占用内存量的宏，可以根据实际单片机的情况自行修改，只要保证大于注释中写的 2kB 就行。</p>
<div class="vscode-block">
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/*Size of the memory available for `lv_mem_alloc()` in bytes (&gt;= 2kB)*/</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_MEM_SIZE</span><span style="color: #403f53;"> (</span><span style="color: #aa0982;">32U</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1024U</span><span style="color: #403f53;">) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;">/*[bytes]*/</span></div>
</div>
<p>除此之外，在第 273 和 280 行还有这么两个宏定义，如果将它们设置为 <code>1</code> ，那么可以在屏幕的左下角和右下角显示当前内存占用和帧率，非常适合性能分析：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_USE_PERF_MONITOR</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">LV_USE_MEM_MONITOR</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span></div>
</div>
<p>其它设置可以对照注释和文档修改。</p>
<p>接下来开始导入工程文件，这一步需要将 <code>lvgl/src</code> 中除了 <code>draw</code> 目录中的所有文件全部导入，而 <code>draw</code> 目录中除了根目录的 <code>.c</code> 文件外，只导入 <code>sw</code> 目录中的源文件。LVGL 8 的目录深度较大，请耐心添加，细心检查，不要遗漏文件。</p>
<p>使用 STM32 单片机的话还需要注意在启动文件中修改堆、栈大小，至少各设置 8kB 空间：</p>
<div class="vscode-block">
<div><span style="color: #403f53;">Stack_Size &nbsp; &nbsp; &nbsp;</span><span style="color: #994cc3;font-weight: bold;">EQU</span><span style="color: #403f53;"> &nbsp; &nbsp; 0x00002000</span></div>
<div><span style="color: #403f53;">Heap_Size &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">EQU</span><span style="color: #403f53;"> &nbsp; &nbsp; 0x00002000</span></div>
</div>
<p>全部添加完成之后，尝试编译整个工程，应该是可以零 error 通过了。</p>
<blockquote><p>使用 ARM CC v6 可能会发生 <code>__aeabi_assert</code> 符号未定义的问题，可以在整个项目管理中提前定义宏 <code>NDEBUG</code> 禁用该符号。</p></blockquote>
<h3>显示设备的API对接</h3>
<p>LVGL 只提供了绘图的算法，其它内容需要自行编写。LVGL 提供的接口在 <code>lvgl/examples/porting</code> 目录中，该目录有如下文件：</p>
<ul>
<li><code>lv_port_disp</code> ：显示设备接口</li>
<li><code>lv_port_indev</code> ：输入设备接口</li>
<li><code>lv_port_fs</code> ：文件系统接口</li>
</ul>
<p>将各个文件名结尾的 <code>template</code> 去除。接下来先编写显示设备的接口，至少确保能显示一些东西来。</p>
<hr>
<p>在 <code>lv_port_disp.c</code> 及其头文件中，首先需要去除条件编译，启用这部分内容：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/*Copy this file as "lv_port_disp.h" and set this value to "1" to enable content*/</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">1</span></div>
</div>
<p>由于之前重命名过头文件，因此在源文件中也需要修改对应的名称：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">include</span><span style="color: #403f53;"> </span><span style="color: #111111;">"</span><span style="color: #c96765;">lv_port_disp.h</span><span style="color: #111111;">"</span></div>
</div>
<p>源文件在宏定义区域中有两个宏定义，需要修改为实际的显示屏尺寸。改过了之后记得把 <code>#warning</code> 预处理语句去除了：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">ifndef</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">MY_DISP_HOR_RES</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">//</span><span style="color: #939dbb;">#warning Please define or replace the macro MY_DISP_HOR_RES with the actual screen width, default value 320 is used for now.</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">define</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">MY_DISP_HOR_RES</span><span style="color: #403f53;"> &nbsp; &nbsp;</span><span style="color: #aa0982;">320</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">endif</span></div>
<div><span style="color: #a8a8a8;">/* ... same as above ... */</span></div>
</div>
<p><code>lv_port_disp_init()</code> 是一个最顶层的初始化显示设备的函数，在主函数中需要调用它一次性初始化显示设备的功能。该函数的修改方式注释里已经写的较为清楚了，接下来提供一个修改示例。</p>
<p>首先将 91~102 行的两个提供显示缓存的语句全部注释或删除，只保留 <code>/* Example for 1) */</code> 。然后修改 114~115 行的两个数值为实际的屏幕清晰度。</p>
<div class="vscode-block">
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* Example for 1) */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_disp_draw_buf_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">draw_buf_dsc_1</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_color_t</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">buf_1</span><span style="color: #403f53;">[MY_DISP_HOR_RES </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">];</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_disp_draw_buf_init</span><span style="color: #403f53;">(</span><span style="color: #0c969b;">&amp;</span><span style="color: #403f53;">draw_buf_dsc_1, </span><span style="color: #4876d6;">buf_1</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">NULL</span><span style="color: #403f53;">, MY_DISP_HOR_RES </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/*Set the resolution of the display*/</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">disp_drv</span><span style="color: #403f53;">.hor_res </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">320</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">disp_drv</span><span style="color: #403f53;">.ver_res </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">240</span><span style="color: #403f53;">;</span></div>
</div>
<p>该文件内还有两个函数 <code>disp_init()</code> 和 <code>disp_flush()</code> ，需要提供实际显示设备的接口。</p>
<p><code>disp_init()</code> 中，需要提供屏幕的初始化代码，如果已经在外部初始化过可以忽略。</p>
<p><code>disp_flush()</code> 中，需要在注释的位置根据提供的参数绘制一个像素点，。这一过程也可以使用填充函数获得更快的速度，甚至可以使用 GPU 等加速等方式完成，具体如何编写代码可以参考注释。例如，测试用的屏幕是这样逐个绘制像素点，从而填充一块区域的：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;">/* ... */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">for</span><span style="color: #403f53;">(y </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> area</span><span style="color: #0c969b;">-</span><span style="color: #994cc3;">&gt;</span><span style="color: #403f53;">y1; y </span><span style="color: #994cc3;">&lt;=</span><span style="color: #403f53;"> area</span><span style="color: #0c969b;">-</span><span style="color: #994cc3;">&gt;</span><span style="color: #403f53;">y2; y</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">for</span><span style="color: #403f53;">(x </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">area</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">x1</span><span style="color: #403f53;">; x </span><span style="color: #994cc3;">&lt;=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">area</span><span style="color: #403f53;">-&gt;</span><span style="color: #4876d6;">x2</span><span style="color: #403f53;">; x</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">ILI9341_SetFrontColor(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">ili9341, color_p-&gt;full)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">ILI9341_DrawPixel(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">ili9341, x, y)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; color_p</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #a8a8a8;">/* ... */</span></div>
</div>
<p>至此，API 移植便结束了。接下来可以编写程序测试 LVGL 的效果了。</p>
<h3>LVGL的初始化</h3>
<p>在使用 LVGL 前，需要调用以下两个函数完成 LVGL 库的初始化以及 LVGL 显示设备接口的初始化：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">lv_init</span><span style="color: #403f53;">();</span></div>
<div><span style="color: #4876d6;">lv_port_disp_init</span><span style="color: #403f53;">();</span></div>
</div>
<p>然后就可以绘制图形了。这里提供了一段简单的代码，可以绘制一个按钮：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> btn </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_btn_create</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">lv_scr_act</span><span style="color: #403f53;">()); </span></div>
<div><span style="color: #4876d6;">lv_obj_set_pos</span><span style="color: #403f53;">(btn, </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">10</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">lv_obj_set_size</span><span style="color: #403f53;">(btn, </span><span style="color: #aa0982;">120</span><span style="color: #403f53;">, </span><span style="color: #aa0982;">50</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> label </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_label_create</span><span style="color: #403f53;">(btn);</span></div>
<div><span style="color: #4876d6;">lv_label_set_text</span><span style="color: #403f53;">(label, </span><span style="color: #111111;">"</span><span style="color: #c96765;">Button</span><span style="color: #111111;">"</span><span style="color: #403f53;">);</span></div>
<div><span style="color: #4876d6;">lv_obj_center</span><span style="color: #403f53;">(label);</span></div>
</div>
<p>绘制完之后，还需要在主循环中调用 <code>lv_task_handler()</code> 函数，这样绘制的内容才能实时更新到屏幕上：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> (</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #a8a8a8;">/* ... */</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_task_handler()</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>然后将编译得到的结果下载到单片机内，就可以在屏幕上看到一个按钮了：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-01-disp-test.jpg" alt="-" width="360"></figure>
<h2>LVGL输入设备移植</h2>
<p>上文介绍了如何移植显示设备。但是 LVGL 是一个用户界面库，光有显示设备，不能做一些用户交互的功能还是不太够，因此就需要使用输入设备。</p>
<p>LVGL 支持 5 种类型的输入设备：</p>
<ul>
<li>Touchpad ：触摸屏</li>
<li>Mouse ：鼠标</li>
<li>Keypad ：键盘</li>
<li>Encoder ：编码器</li>
<li>Button ：按键</li>
</ul>
<p>在移植时，不要搞错了输入设备的类型，否则 LVGL 无法对输入作出响应。</p>
<p>LVGL 对输入设备的接口全部存放在 <code>lv_port_indev.c</code> 及其头文件中。接下来以触摸屏为例介绍输入设备的移植，不同设备的 API 有一定区别，在移植时请以官方文档为主。</p>
<p>首先，需要去掉两个文件中的 <code>#if 0</code> 条件编译，启用两个文件。</p>
<p>在 <code>lv_port_indev.c</code> 中，包含了 5 种设备的 API ，但它们不可能都用到，因此需要裁剪无用的函数和定义。尤其是在初始化函数 <code>lv_port_indev_init()</code> 中，如果不去除无用设备的初始化语句，那么在调用时可能会出现问题。</p>
<p>源码在注释中已经着重强调了不同 API 的分区，只需要根据分区保留需要的代码即可。</p>
<p>根据代码的思路（精简后的源码不长，而且抽象程度较高，完全可以读懂），接下来实现三个函数的功能。</p>
<p>首先是 <code>touchpad_init()</code> ，在这里需要对输入设备做初始化，就像上文对触摸屏做初始化一样。</p>
<p>在 <code>touchpad_is_pressed()</code> 中，需要提供一个显示屏触摸函数，判断是否发生了触摸事件：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">bool</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">touchpad_is_pressed</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (</span><span style="color: #4876d6;">XPT2046_TouchDetect()</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">==</span><span style="color: #403f53;"> TOUCH_PRESSED)</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">true</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">return</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">false</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>如果发生了触摸事件，那么会进入 <code>touchpad_get_xy()</code> 函数中，获取触摸点坐标：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">touchpad_get_xy</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">lv_coord_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #403f53;">x</span><span style="color: #403f53;">, </span><span style="color: #4876d6;">lv_coord_t</span><span style="color: #403f53;"> </span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> </span><span style="color: #403f53;">y</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> XPT2046_Coordinate </span><span style="color: #4876d6;">coord</span><span style="color: #403f53;"> </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> { </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">, </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">, </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">, </span><span style="color: #0c969b;">-</span><span style="color: #aa0982;">1</span><span style="color: #403f53;"> };</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">XPT2046_Get_TouchedPoint(</span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">xpt2046, </span><span style="color: #0c969b;">&amp;</span><span style="color: #4876d6;">coord</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; (</span><span style="color: #0c969b;">*</span><span style="color: #403f53;">x</span><span style="color: #403f53;">) </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">coord</span><span style="color: #403f53;">.</span><span style="color: #4876d6;">x</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; (</span><span style="color: #0c969b;">*</span><span style="color: #403f53;">y</span><span style="color: #403f53;">) </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">coord</span><span style="color: #403f53;">.</span><span style="color: #4876d6;">y</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>如果这几个函数都编写正确，那么理论上已经可以实现输入功能了。不过在此之前，还有一个关键的步骤：LVGL 使用一个 tick 系统管理全局事件，它就像 LVGL 的心跳一样，如果没有这个心跳就无法检测事件。</p>
<p>为了给 LVGL 提供心跳，需要不断调用 <code>lv_tick_inc()</code> 函数，该函数的参数为每次心跳的毫秒间隔：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">while</span><span style="color: #403f53;"> (</span><span style="color: #aa0982;">1</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_tick_inc(</span><span style="color: #aa0982;">1</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_task_handler()</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">delay_ms(</span><span style="color: #aa0982;">1</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>使用单片机时更推荐使用定时器完成该函数的调用，设置定时器溢出时间为 1 毫秒后在定时器中断函数内调用它。</p>
<hr>
<p>接下来提供一个示例，可以检测输入设备是否能正常使用。首先在 <code>main</code> 函数的开头执行输入设备的初始化：</p>
<div class="vscode-block">
<div><span style="color: #4876d6;">lv_port_indev_init</span><span style="color: #403f53;">();</span></div>
</div>
<p>然后编写如下函数：</p>
<div class="vscode-block">
<div><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">btn_event_cb</span><span style="color: #403f53;">(</span><span style="color: #4876d6;">lv_event_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> e) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_event_code_t</span><span style="color: #403f53;"> code </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_event_get_code(e)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> btn </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_event_get_target(e)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">if</span><span style="color: #403f53;"> (code </span><span style="color: #994cc3;">==</span><span style="color: #403f53;"> LV_EVENT_CLICKED) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #994cc3;font-weight: bold;">static</span><span style="color: #403f53;"> </span><span style="color: #994cc3;font-weight: bold;">uint8_t</span><span style="color: #403f53;"> cnt </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #aa0982;">0</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; cnt</span><span style="color: #994cc3;">++</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> label </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_obj_get_child(btn, </span><span style="color: #aa0982;">0</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #4876d6;">lv_label_set_text_fmt(label, </span><span style="color: #111111;">"</span><span style="color: #c96765;">Button: </span><span style="color: #4876d6;">%d</span><span style="color: #111111;">"</span><span style="color: #4876d6;">, cnt)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; }</span></div>
<div><span style="color: #403f53;">}</span></div>
<div><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_example</span><span style="color: #403f53;">(</span><span style="color: #994cc3;font-weight: bold;">void</span><span style="color: #403f53;">) {</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> btn </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_btn_create(lv_scr_act())</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_set_pos(btn, </span><span style="color: #aa0982;">10</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">10</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_set_size(btn, </span><span style="color: #aa0982;">120</span><span style="color: #4876d6;">, </span><span style="color: #aa0982;">50</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_add_event_cb(btn, btn_event_cb, LV_EVENT_ALL, NULL)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_t</span><span style="color: #0c969b;">*</span><span style="color: #403f53;"> label </span><span style="color: #994cc3;">=</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">lv_label_create(btn)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_label_set_text(label, </span><span style="color: #111111;">"</span><span style="color: #c96765;">Button</span><span style="color: #111111;">"</span><span style="color: #4876d6;">)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">&nbsp; &nbsp; </span><span style="color: #4876d6;">lv_obj_center(label)</span><span style="color: #403f53;">;</span></div>
<div><span style="color: #403f53;">}</span></div>
</div>
<p>在主函数中调用 <code>lv_example()</code> ，编译后下载到单片机内，可以得到一个和上一个示例相同的按钮，但是每次点击之后，按钮的文本都会发生变化：</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-01-indev-test.jpg" alt="-" width="360"></figure>
<h2>使用LVGL模拟器</h2>
<p>LVGL 是一个图形库，那么在绘制图形时就免不了需要对绘制结果做一些微调。那么每次微调都需要将程序下载到单片机去显然是麻烦的选择，不过幸好 LVGL 提供了模拟器，可以在 PC 端上直接生成可交互的界面，无需下载即可查看绘制效果。</p>
<p>LVGL 可以在各个平台上模拟，完整的模拟器使用指南可以参照 <a href="https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html">https://docs.lvgl.io/master/get-started/platforms/pc-simulator.html</a> 。接下来以 Windows 平台基于 Visual Studio 的模拟为例介绍通用的使用方法。</p>
<p>首先，在 <a href="https://github.com/lvgl/lv_port_win_visual_studio">https://github.com/lvgl/lv_port_win_visual_studio</a> 中下载 Visual Studio 工程源码。注意，在 <code>LVGL.Simulator</code> 目录中包含 3 个外部的仓库，需要将它们一并下载并放在正确的位置。</p>
<p>然后，使用 Visual Studio 打开 <code>LVGL.Simulator.sln</code> 工程，点击编译即可得到 GUI 可执行文件。</p>
<figure><img decoding="async" src="/wp-content/uploads/2022/06/lvgl-01-simulation-test.jpg" alt="-" width="770"></figure>
<p>LVGL 模拟器的屏幕大小可能与实际屏幕大小不符，需要在主函数最前部分 <code>lv_win32_init</code> 初始化时做一些调整。</p>
<p>需要注意的是，Visual Studio 提供的模拟器是使用 C++ 编写的，如果需要自定义函数，需要在头文件中使用</p>
<div class="vscode-block">
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">ifdef</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">__cplusplus</span></div>
<div><span style="color: #994cc3;font-weight: bold;">extern</span><span style="color: #403f53;"> </span><span style="color: #111111;">"</span><span style="color: #c96765;">C</span><span style="color: #111111;">"</span><span style="color: #403f53;"> {</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">endif</span></div>
<div><span style="color: #a8a8a8;">/* ... function prototypes ... */</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">ifdef</span><span style="color: #403f53;"> </span><span style="color: #4876d6;">__cplusplus</span></div>
<div><span style="color: #403f53;">}</span></div>
<div><span style="color: #994cc3;">#</span><span style="color: #994cc3;font-weight: bold;">endif</span></div>
</div>
<p>将函数原型包围起来，否则在使用 C 语言符号时会出错。</p>
<p><a rel="nofollow" href="/archives/307">LVGL库入门教程01-移植到STM32</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/307/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
