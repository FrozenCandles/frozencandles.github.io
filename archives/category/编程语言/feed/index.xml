<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>编程语言归档 - 冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/archives/category/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/feed?simply_static_page=3606" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Thu, 11 May 2023 15:19:15 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>编程语言归档 - 冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Python面向对象编程04-类与实例的方法</title>
		<link>/archives/1059</link>
					<comments>/archives/1059#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 27 Mar 2023 01:08:07 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=1059</guid>

					<description><![CDATA[<p>类方法和静态方法 实例方法 在第一节中，便已经介绍过&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1059">Python面向对象编程04-类与实例的方法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>类方法和静态方法</h2>

<h3>实例方法</h3>

<p>在<a href="/archives/442" class="link-internal">第一节</a>中，便已经介绍过实例方法。实例方法需要有一个实例才能调用，而这个实例是通过第一个通常名为 <code>self</code> 的参数表示的，因此借助该参数可以在定义方法时就去操作一个抽象的实例对象。例如，假设有一个这样的类和实例的定义：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>:</div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">method</span>(self, arg):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">self</span>, arg)</div><br><div><span style="color: #268bd2;">c</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">C</span>()</div></div>

<p>那么可以使用这样的方式通过实例调用该方法，实例对象将会自动作为第一个位置参数传入：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">c</span>.<span style="color: #268bd2;">method</span>(arg<span style="color: #859900;">=</span><span style="color: #cb4b16;">...</span>)</div></div>

<p>许多编程语言在方法内部，对实例的引用是通过 <code>this</code> 关键字完成的；而 Python 则与之不同，实例的引用是通过显式的参数传递的。这样做的好处在于，一是通过显式定义来强调默认定义的方法是实例方法，二是也可以把方法当做第一个参数是实例的函数一样调用：</p>

<div class="vscode-block"><div><span style="color: #cb4b16;">C</span>.<span style="color: #268bd2;">method</span>(<span style="color: #268bd2;">c</span>, arg<span style="color: #859900;">=</span><span style="color: #cb4b16;">...</span>)</div></div>

<p>例如，多个字符串连接默认是通过字符串的 <code>.join()</code> 方法实现，这里调用该方法的字符串实例将被插入被连接的字符串之间：</p>

<div class="vscode-block"><div><span style="color: #2aa198;">'||'</span>.<span style="color: #268bd2;">join</span>([<span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'c'</span>])</div><div><span style="color: #a8a8a8;"># 'a||b||c'</span></div></div>

<p>如果觉得用被插入的字符串去调用该方法比较奇怪，也可以通过 <code>str</code> 类调用该方法，并将被插入的字符串作为第一个位置参数主动传入：</p>

<div class="vscode-block"><div><span style="color: #cb4b16;">str</span>.<span style="color: #268bd2;">join</span>(<span style="color: #2aa198;">'||'</span>, [<span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'c'</span>])</div></div>

<!-- <div class="vscode-block"><div><span style="color: #cb4b16;">str</span>.<span style="color: #268bd2;">replace</span>(<span style="color: #2aa198;">'%time</span><span style="color: #cb4b16;">%-%</span><span style="color: #2aa198;">name%.jpg'</span>, <span style="color: #2aa198;">'%time%'</span>, <span style="color: #268bd2;">ctime</span>())</div></div> -->

<p>因此，实例方法的实质就是一个函数，只不过它的主要用途是处理实例。Python 允许实例方法可以直接由实例调用，使得调用的表示更加简洁。</p>

<h3>类方法</h3>

<p>与实例方法相对应的是<strong>类方法</strong>。类方法是类本身具有的方法，它可以在不需要实例的情况下使用类本身来调用。</p>

<p>Python 中类方法和实例方法相似，但是它需要传入一个名为 <code>cls</code> 的参数，用来代表这个类本身（同样，这个名字不必是 <code>cls</code> ，可以是 <code>typ</code> 或 <code>Lei</code> 等）。但是为了与实例方法区分，类方法在定义时需要使用 <code>@classmethod</code> 装饰器。</p>

<p>因此，一个完整的类方法的定义为：</p>

<div class="codeblock code-template">
    @classmethod<br>
    <strong>def</strong> <em>method_name</em>(cls, ...):<br>
    &nbsp; &nbsp; ...
</div>

<p>类方法有几种比较常见的应用场景。首先是构造前交互，有些时候需要在实例化前做一些准备，例如一个代表数据库的类，可以通过类方法读取配置文件并连接到数据库中，这样随后对实例的操作可以实时反映到对数据库的更新中。由于读取配置文件这种操作需要在得到任意一个实例之前完成，因此可以借助类方法实现。</p>

<p>类方法还可以用于以别的方式构建实例。例如，<code>datetime</code> 是一个用于处理日期与时间的标准库，其中 <code>date</code> 是一个用于表示日期的类。如果要通过该类生成一个具体的日期，在初始化时需要传入代表年、月、日的参数：</p>

<div class="codeblock code-console">>>> from datetime import date
>>> date(2023, 3, 19)
datetime.date(2023, 3, 19)</div>

<p>但有些时候，拿到的信息可能未必包含年月日，它可能是具有特定格式的表示时间的字符串，还有可能是浮点型的时间戳。此时，可以使用 <code>date</code> 类提供的类方法使用这几种信息构造一个日期实例：</p>

<div class="codeblock code-console">>>> date.fromisoformat('2023-03-19')  # python3.7+
datetime.date(2023, 3, 19)
>>> date.fromtimestamp(time.time())
datetime.date(2023, 3, 19)</div>

<p>仿照这种思路，可以为之前自定义的 <code>Point</code> 类编写一个类方法来通过格式字符串构造实例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, x, y):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> x, y</div><div>&#160; &#160; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">classmethod</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">from_format</span>(cls, format):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">format</span>[<span style="color: #d33682;">1</span>:<span style="color: #859900;">-</span><span style="color: #d33682;">1</span>].split(<span style="color: #2aa198;">','</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">cls</span>(<span style="color: #cb4b16;">int</span>(<span style="color: #268bd2;">x</span>), <span style="color: #cb4b16;">int</span>(<span style="color: #268bd2;">y</span>)) &#160;<span style="color: #a8a8a8;"># same as Point(...)</span></div></div>

<p>注意，这里的参数 <code>cls</code> 在调用时会替换为 <code>Point</code> ，因此调用 <code>cls(...)</code> 等价于类的实例化 <code>Point(...)</code></p>

<p>使用这个类方法可以返回一个实例，就像正常方式得到的实例一样可以调用各种方法：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">p</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">from_format</span>(<span style="color: #2aa198;">'(10,40)'</span>)</div><div><span style="color: #268bd2;">p</span>.<span style="color: #268bd2;">distance_to_origin</span>() &#160;<span style="color: #a8a8a8;"># returns 41.23</span></div></div>

<p>从技术上说，也可以用一个普通函数来构造实例。但使用类方法的好处在于，一是使用者容易明白构造出的实例是属于哪个类的，二是当类被重命名后类方法无需跟着修改，降低了因为疏忽导致错误的可能性。</p>

<p>这里顺便说一下，既然实例可以调用类属性，那么实例也可以调用类方法，这等价于用它的类调用类方法。不过一般不推荐利用实例调用类方法，因为这样做可能有些奇怪。</p>

<h3>静态方法</h3>

<p>除了类方法和实例方法外，还有一个特殊的方法称为<strong>静态方法</strong>。静态方法不是类或实例所特有的，它可以被任意的类或实例调用。静态方法不涉及对类和实例的操作，因此被称为静态方法。</p>

<p>静态方法需要使用 <code>@staticmethod</code> 装饰器，并且不需要添加像 <code>self</code> 或 <code>cls</code> 这种特殊的参数，因此不参与对任意属性的修改。</p>

<p>一个静态方法的定义为：</p>

<div class="codeblock code-template">
    @staticmethod<br>
    <strong>def</strong> <em>method_name</em>(...):<br>
    &nbsp; &nbsp; ...
</div>

<p>不难看出，静态方法脱离了类和实例，表现得更像一个普通的函数。</p>

<hr>

<p>实际上，Python 中的方法和函数除了是否位于类的定义中外，并没有本质的区别。Python 中的类可以看作一个独立的<em>命名空间</em>。在 <code>class</code> 关键字引导的代码块中，可以包含各种语句，例如常见的 <code>for</code> 循环和 <code>with</code> 语句：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Type</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">s</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">i</span> <span style="color: #859900;font-weight: bold;">in</span> <span style="color: #cb4b16;">range</span>(<span style="color: #d33682;">10</span>):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">s</span> <span style="color: #859900;">+=</span> <span style="color: #268bd2;">i</span> <span style="color: #859900;">**</span> <span style="color: #d33682;">2</span></div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">with</span> <span style="color: #268bd2;">open</span>(<span style="color: #2aa198;">'settings.txt'</span>, <span style="color: #2aa198;">'r'</span>) <span style="color: #859900;font-weight: bold;">as</span> <span style="color: #268bd2;">f</span>:</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">settings</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">dict</span>([</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">kv</span>.<span style="color: #268bd2;">split</span>(<span style="color: #2aa198;">'='</span>) <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">kv</span> <span style="color: #859900;font-weight: bold;">in</span> <span style="color: #268bd2;">f</span>.<span style="color: #268bd2;">read</span>().<span style="color: #268bd2;">split</span>(<span style="color: #2aa198;">'</span><span style="color: #cb4b16;">\n</span><span style="color: #2aa198;">'</span>)</div><div>&#160; &#160; &#160; &#160; ])</div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">settings</span>.<span style="color: #268bd2;">get</span>(<span style="color: #2aa198;">'value'</span>):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">property</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">value</span>(self):</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">settings</span>[<span style="color: #2aa198;">'value'</span>]</div></div>

<p>注意，这里使用 <code>if</code> 语句动态地定义了一个方法，这是完全可以的。除此之外，在类内定义另一个类也是很常见的情况，这个嵌套类一般用于提供基本的元信息。</p>

<p>在类之中这个独立的命名空间内，可以直接访问其中定义的变量（或者说属性）。而在类外部，访问这些变量需要通过类名来标识其所位于的命名空间：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">Type</span>.<span style="color: #268bd2;">s</span>) &#160;<span style="color: #a8a8a8;"># 285</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">Type</span>().<span style="color: #268bd2;">value</span>) &#160;<span style="color: #a8a8a8;"># 1</span></div></div>

<p>从这个角度上说，类和模块并没有太大的差别。实际上，当模块导入后，它就是一个普通的 Python 对象，只不过是 <code>&lt;class 'module'></code> 类型的对象。所以在 Python 中使用方法时，实际上就是使用一个函数，Python 解释器只是额外提供了一个语法糖，将调用方法的实例自动填写到函数的 <code>self</code> 参数上，仅此而已。</p>

<h2>特殊方法</h2>

<p>在<a href="" class="link-internal">第一节</a>介绍过实例方法时，同时介绍了一个特殊的实例方法 <code>.__init()__</code> ，它会在类初始化时自动调用，以此完成一些初始化工作。之前介绍时同时提及了类还有很多类似的特殊方法，它们都以双下划线开头结尾，有时也被称为双下方法。</p>

<p>Python 的特点是一切皆对象，任何 Python 的变量都是一个对象。而 Python 对这些变量的操作，例如构造、初始化、删除、获取属性，甚至比较、索引、和迭代，都是通过调用一些特殊的方法实现的，这些方法称为 Python 的<strong>特殊方法</strong>(special method)或<strong>魔法方法</strong>(magic method)，它们的名称以双下划线开始，以双下划线结束，代表着对象的一种特殊的操作。一般情况下，使用类方法或实例方法就可以完成类的功能；但在必要时，可以使用或者重写这些特殊方法，来为自己的类提供更加规范的接口。</p>

<p>在后续篇章中，对 Python 面向对象的介绍几乎都围绕这些特殊方法。通过对这些特殊方法的介绍，可以从根本上了解 Python 的运行机制，从而编写出更加优雅、更 Pythonic 的代码。</p>

<p>本节先介绍类的三个特殊方法：<code>.__init__()</code> 、<code>.__new__()</code> 和 <code>.__del__()</code> ，它们参与着实例的生命周期。</p>

<h3>初始化方法</h3>

<p>初始化方法 <code>.__init()__</code> 是第一个介绍的特殊方法，可能也是最常用的特殊方法。每当生成一个实例后，它便会调用该方法，以此完成一些初始化工作。</p>

<p>需要注意的是，<code>.__init__()</code> 方法不能有任何非 <code>None</code> 的返回值，否则就会引起 <code class="error">TypeError</code> ，错误内容将提示该方法应该返回 <code>None</code> 。</p>

<h3>构造方法</h3>

<p><code>.__new__()</code> 被称为构造方法，因为它负责创建一个新的实例。而 <code>.__init__()</code> 负责创建后的初始化，从中也可以明白它们的用途以及调用的先后顺序。</p>

<p><code>.__new__()</code> 负责创建类的实例，它的第一个位置通常名为 <code>cls</code> ，代表生成实例的类，其余参数应该是 <code>.__init__()</code> 方法的其余参数。虽然看起来很像一个类方法，但它却是一个静态方法，并且无需使用 <code>@staticmethod</code> 装饰器。这也是特殊方法和普通方法的根本区别：Python 解释器已经规定了如何使用特殊方法，因此没必要额外声明其它东西。</p>

<p>它的返回值是新的对象实例（通常是 <code>cls</code> 的实例）。例如以下类 <code>Card</code> ，它使用 <code>.__new__()</code> 方法，在每次生成一个实例时，便给予它唯一的一个 <code>.id_</code> 属性：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Card</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">id_</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__new__</span>(cls, <span style="color: #859900;">*</span>args, <span style="color: #859900;">**</span>kwargs):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__new__</span>(<span style="color: #268bd2;">cls</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">id_</span> <span style="color: #859900;">+=</span> <span style="color: #d33682;">1</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">instance</span>.<span style="color: #268bd2;">id_</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">id_</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">instance</span></div><br><div><span style="color: #268bd2;">c01</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c02</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c03</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c03</span>.<span style="color: #268bd2;">id_</span> &#160;<span style="color: #a8a8a8;"># 3</span></div></div>

<p>注意，虽然它表现得很像一个类方法，但不能像之前介绍的类方法一样通过 <code>cls(...)</code> 来创建实例，因为这样做实质上就是在调用该方法，会陷入无限递归。一般来说对象的创建是底层 C 语言的任务，而 Python 中只需要使用 CPython 提供的接口即可，例如使用 <code>super().__new__(cls, ...)</code> 调用 <code>object</code> 类提供的基本 <code>.__new__()</code> 方法，然后在返回之前根据需要修改新创建的实例即可。</p>

<p>由于涉及到对类属性的修改，因此使用 <code>.__init__()</code> 方法不太好实现（当然不是不能实现，在后续会介绍）。同时使用 <code>.__new__()</code> 方法也方便了继承，子类可以正常编写 <code>.__init__()</code> 方法而不影响 <code>.id_</code> 的分配。</p>

<p>通过之前的介绍可以明白构造方法和初始化方法的执行顺序：<code>.__new__()</code> 方法会优先 <code>.__init__()</code> 初始化方法在生成实例前调用。执行了 <code>.__new__()</code> 并不一定会进入 <code>.__init__()</code> ；只有 <code>.__new__()</code> 返回了当前类的实例（即便是父类的实例也不行），才会进入 <code>.__init__()</code> 并为该实例做一定初始化，否则没有东西可以用于初始化。</p>

<p>利用这种特性，可以在 Python 中创建单例。单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。单例提供了创建与访问其唯一对象的方式。使用 <code>.__new__()</code> 方法可以自由控制创建的对象，从而比较方便地实现单例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Singleton</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">_has_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">False</span></div><div>&#160; &#160; <span style="color: #268bd2;">__single_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">None</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__new__</span>(cls, <span style="color: #859900;">*</span>args, <span style="color: #859900;">**</span>kwargs):</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #859900;">not</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">_has_instance</span>:</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">_has_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">True</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">__single_instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__new__</span>(<span style="color: #268bd2;">cls</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">__single_instance</span></div><div>&#160; &#160; </div><div><span style="color: #268bd2;">one_task</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Singleton</span>()</div><div><span style="color: #268bd2;">another_task</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Singleton</span>(<span style="color: #d33682;">123</span>, name<span style="color: #859900;">=</span><span style="color: #2aa198;">'another'</span>)</div><div><span style="color: #268bd2;">one_task</span> <span style="color: #859900;">is</span> <span style="color: #268bd2;">another_task</span> <span style="color: #859900;">is</span> <span style="color: #cb4b16;">Singleton</span>(<span style="color: #2aa198;">'abs'</span>) &#160;<span style="color: #a8a8a8;"># True</span></div></div>

<p>可以看到，不管该类被实例化多少次，如何实例化，得到的都是唯一的实例。单例提供了一种共享数据的方式，并且方便使用 <code><strong>is</strong></code> 判断。但考虑到 Python 能使用全局变量完成相同的工作，因此一般来说在 Python 中没必要使用单例。</p>

<h3>析构方法</h3>

<p>与构造方法相反，析构方法 <code>.__del__()</code> 用于在销毁一个类实例时调用，它对应的是 Python 中的 <code>del</code> 语句。</p>

<p>当一个对象即将被销毁时，它便会调用 <code>.__del__()</code> 方法，通常该方法用于释放实例用到的一些额外的资源（如关闭已经打开的文件）。</p>

<p><code>.__del__()</code> 是实例相关的方法，因此第一个参数应该为 <code>self</code> 。注意区别于 <code>property</code> 的 <code>@.deleter</code> 装饰器，它装饰的方法在删除某个属性时调用，而不是整个实例。由于垃圾回收是后台处理的，且 <code>del</code> 是一个语句，因此 <code>.__del__()</code> 的返回值并没有任何意义。并且在该方法内引发任何异常也是没有作用的，它既不能被所处的 <code>try</code> 块捕获，也不会中断程序的运行。</p>

<p>注意，<code>del</code> 语句在调用时，并没有直接调用实例的 <code>.__del__()</code> 方法，这是因为如果变量仅仅是对实例的一个引用，那么 <code>del</code> 语句只会销毁这个引用的对象。只有当所有的引用都被销毁了，那么 <code>del</code> 语句才会调用 <code>.__del__()</code> 方法来清除这个实例。因此，通过在 <code>.__del__()</code> 中为对象添加一个引用可以暂时推迟对象的删除，但这是很不建议的做法。</p>

<p>通过 <code>.__del__()</code> 方法，可以研究 Python 的垃圾回收机制。例如，以下是在命令行中的一个小测试：</p>

<div class="codeblock code-console">>>> GCTest()
&lt;__main__.GCTest object at 0x00000282CE8907B8>
>>> t = GCTest()
>>> del t
object deleted
>>> 'now delete "_"'
object deleted
'now delete "_"'
</div>

<p>第一个实例被自动保存在 <code>_</code> 变量中，只有这个引用改变了，它才会被删除。</p>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization">https://docs.python.org/3/reference/datamodel.html#basic-customization</a><br>
    Python3 语言参考——数据模型部分，该部分介绍了绝大多数常用的特殊方法、特殊属性与 Python 的运行机制，是深入理解 Python 最好的文档。
</p>
<p><a rel="nofollow" href="/archives/1059">Python面向对象编程04-类与实例的方法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1059/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>XPath简单入门</title>
		<link>/archives/842</link>
					<comments>/archives/842#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 03 Nov 2022 14:55:49 +0000</pubDate>
				<category><![CDATA[编程语言]]></category>
		<category><![CDATA[XPath]]></category>
		<guid isPermaLink="false">/?p=842</guid>

					<description><![CDATA[<p>XPath简介 XPath 是一种用作解析 XML &#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/842">XPath简单入门</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>XPath简介</h2>

<p>XPath 是一种用作解析 XML 并提取所要信息的语法，就像 CSS 选择器一样。XPath 也可以用于解析其它类 XML 的文档结构，例如 HTML 。在本节中也主要以 HTML 为例演示 Path 的各种解析结果。</p>

<p>XPath 应用较为广泛，目前主流浏览器的开发者工具均支持使用 XPath 语法查找页面元素。XPath 解析速度较快，可以实现处理属性等许多 CSS 选择器无法实现的功能，但是语法较为复杂。</p>

<p>本节使用 Python 的<a href="https://lxml.de/">第三方库 lxml</a> ，该库提供了丰富的工具用于解析 XML 和 HTML ，其中就包括 XPath 。<var>lxml</var> 底层使用 libxml2 等 C 语言库实现，因此处理速度非常快。</p>

<p><var>lxml</var> 可以使用 <code>pip</code> 安装：</p>

<div class="codeblock code-console">$ pip install lxml    
</div>

<p>解析 HTML 需要用到 <var>lxml</var> 中的 <var>etree</var> 模块：</p>

<div class="vscode-block"><div><span style="color: #0991b6;font-weight: bold;">from</span> lxml <span style="color: #0991b6;font-weight: bold;">import</span> etree</div></div>

<p>使用 <var>etree</var> 模块中的函数 <code>HTML()</code> ，可以用来将一段 HTML 文本字符串解析为存储 HTML 结构信息的类：</p>

<div class="vscode-block"><div>html <span style="color: #7b30d0;">=</span> etree.HTML(html_str)</div><div><span style="color: #08134a;">print</span>(<span style="color: #dc3eb7;">type</span>(html))</div></div>

<p>该函数对 HTML 支持很好，甚至可以处理有一定破损的 HTML 。以上代码执行结果为：</p>

<div class="codeblock code-console">$ py lxml-xpath.py
&lt;class 'lxml.etree._Element'>   
</div>

<p>可以使用该类的 <code>.xpath()</code> 方法来使用 XPath 语法解析。得到的结果是一个列表，包含解析得到的所有结果。</p>

<p>接下来正式介绍 XPath 的语法。</p>

<h2>XPath语法</h2>

<h3>选取节点</h3>

<p>HTML 等类 XML 文档都是使用树状的结构来表示文档。例如，对于以下简单的 HTML 文档：</p>

<div class="vscode-block"><div><span style="color: #3e3e3e;">&lt;!</span><span style="color: #0444ac;">DOCTYPE</span> <span style="color: #df8618;">html</span><span style="color: #3e3e3e;">&gt;</span></div><div><span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">html</span><span style="color: #3e3e3e;">&gt;</span></div><div><span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">head</span><span style="color: #3e3e3e;">&gt;</span></div><div>&#160; &#160; <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">meta</span> <span style="color: #df8618;">charset</span>=<span style="color: #d86db6;">"</span><span style="color: #a44185;">utf-8</span><span style="color: #d86db6;">"</span><span style="color: #3e3e3e;">&gt;</span></div><div>&#160; &#160; <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">title</span><span style="color: #3e3e3e;">&gt;</span>page<span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">title</span><span style="color: #3e3e3e;">&gt;</span></div><div><span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">head</span><span style="color: #3e3e3e;">&gt;</span></div><div><span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">body</span><span style="color: #3e3e3e;">&gt;</span></div><div>&#160; &#160; <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span>This is a simple <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">strong</span><span style="color: #3e3e3e;">&gt;</span>HTML<span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">strong</span><span style="color: #3e3e3e;">&gt;</span> page<span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span></div><div><span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">body</span><span style="color: #3e3e3e;">&gt;</span></div><div><span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">html</span><span style="color: #3e3e3e;">&gt;</span></div></div>

<p>那么它的所有元素构成的树状结构可以表示为：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/html-dom.png" alt="" width="300">
</figure>

<p>元素节点可以分为标签节点和文本节点。XPath 中通过一个斜杠 <code>/</code> 开头的标签名</p>

<div class="codeblock code-template">
    /<em>tag</em>
</div>

<p>来在文档树中向下<em>匹配</em>某一标签节点 <code><em>tag</em></code> 。通过堆叠这样的表示符号，即可表示若干节点的层级关系。</p>

<p>注意，使用该语法时必须要从根节点处开始搜索，例如：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">"</span><span style="color: #a44185;">/html/body/table/tbody/tr/td/a</span><span style="color: #d86db6;">"</span>)</div><div><span token="comment"># [&lt;Element a at 0x23ada3b7c40&gt;, ...]</span></div></div>

<p>使用单个斜杠只能表示相邻的层级关系，但如果使用两个斜杠：</p>

<div class="codeblock code-template">
    //<em>tag</em>
</div>

<p>就可以跨越表示相差任意深度的层级关系。因此以上匹配（在不引起歧义的话）也可以由下列形式表达：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">"</span><span style="color: #a44185;">//td/a</span><span style="color: #d86db6;">"</span>)</div><div>html.xpath(<span style="color: #d86db6;">"</span><span style="color: #a44185;">/html//td/a</span><span style="color: #d86db6;">"</span>)</div><div>html.xpath(<span style="color: #d86db6;">"</span><span style="color: #a44185;">/html//table//tr/td/a</span><span style="color: #d86db6;">"</span>)</div></div>

<p>也可以将其拆分理解，标签名表示一个具体的标签节点，而单个斜杠 <code>/</code> 表示两个节点的只能具有父子关系，而两个斜杠 <code>//</code> 表示两个节点具有祖孙关系，中间可以相差若干级。</p>

<p>除了使用具体的标签名外，还可以使用两个特殊的节点表示语法：</p>

<p>可以使用一个点</p>

<div class="codeblock code-template">
    .
</div>

<p>来代表当前节点，或使用两个点</p>

<div class="codeblock code-template">
    ..
</div>

<p>来代表上一级节点。例如，以下可以搜索出与 <code>img</code> 标签同级的 <code>figcaption</code> 标签：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">"</span><span style="color: #a44185;">/html/body/article//img/../figcaption</span><span style="color: #d86db6;">"</span>)</div></div>

<p>这种表示节点关系的语法很像 Unix 的文件路径。</p>

<hr>

<p>在使用 <var>lxml</var> 处理文档的时候，很多时候都不能只使用一个 XPath 表达式就选中所有符合的元素，经常需要在处理到某一步后对结果做一些过滤后，再对符合条件的元素进一步处理。</p>

<p>每次调用 <code>.xpath()</code> 方法得到的都是一个列表，其中包含所有匹配的节点。可以在过滤后对其中的节点对象再次应用 <code>.xpath()</code> 方法，但此时注意需要表明“从当前节点开始匹配”，即不能以单个斜杠 <code>/</code> 开头。以下演示了错误的情况和几种正确的表示方法：</p>

<div class="vscode-block"><div><span style="color: #0991b6;font-weight: bold;">for</span> table <span style="color: #0991b6;font-weight: bold;">in</span> html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article//table</span><span style="color: #d86db6;">'</span>):</div><div>&#160; &#160; table.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">/thead//th</span><span style="color: #d86db6;">'</span>) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="comment"># incorrect</span></div><div>&#160; &#160; <span token="comment"># []</span></div><div>&#160; &#160; table.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">./tbody//td</span><span style="color: #d86db6;">'</span>) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span token="comment"># correct, and recommended</span></div><div>&#160; &#160; <span token="comment"># [&lt;Element td at 0x202b8dab080&gt;, ...]</span></div><div>&#160; &#160; table.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">tbody//td</span><span style="color: #d86db6;">'</span>) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span token="comment"># correct</span></div><div>&#160; &#160; <span token="comment"># [&lt;Element td at 0x202b8dab080&gt;, ...]</span></div><div>&#160; &#160; table.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article//table/tbody//td</span><span style="color: #d86db6;">'</span>) &#160; <span token="comment"># correct, but unnecessary</span></div><div>&#160; &#160; <span token="comment"># [&lt;Element td at 0x202b8dab080&gt;, ...]</span></div></div>

<p>这种表示形式有点像 Unix 的相对路径表示，也是当前节点 <code>.</code> 常用的一种场合。</p>

<p>在实际应用中，相比搜寻节点更需要提取节点包含的文本信息。前面说过文本也可以看作一种节点，这种节点可以使用</p>

<div class="codeblock code-template">
    text()
</div>

<p>代表一个标签元素内的文本内容。<var>lxml</var> 会将每一项包含的文本以字符串的形式放入返回的列表中。</p>

<p>在使用 <code>text()</code> 的时候要注意，元素包含的缩进及换行也算在元素的文本内。有些元素的部分文本放在它的子元素内，例如这种：</p>

<div class="vscode-block"><div><span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span>This is a simple <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">strong</span><span style="color: #3e3e3e;">&gt;</span>HTML<span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">strong</span><span style="color: #3e3e3e;">&gt;</span> page<span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span></div></div>

<p>那么需要使用两个斜杠才能将这部分内容一并提取出来，并且提取出的结果被子元素分割了：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article/p//text()</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># ['This is a simple ', 'HTML', ' page']</span></div></div>


<p>最后，总结一下本小节涉及的选取节点的基本路径符号：</p>

<table>
    <tr>
        <th>表达式</th>
        <th>描述</th>
    </tr>
    <tr>
        <td class="cell-code"><em>tag</em></td>
        <td>标签名代表的某个具体的节点</td>
    </tr>
    <tr>
        <td class="cell-code">text()</td>
        <td>文本节点</td>
    </tr>
    <tr>
        <td class="cell-code">/</td>
        <td>所属的子节点；若用在开头，则表示位于根下一层的节点</td>
    </tr>
    <tr>
        <td class="cell-code">//</td>
        <td>所属的后代节点，可以是任意深度</td>
    </tr>
    <tr>
        <td class="cell-code">.</td>
        <td>当前节点</td>
    </tr>
    <tr>
        <td class="cell-code">..</td>
        <td>当前节点的父节点</td>
    </tr>
</table>

<h3>谓语</h3>

<p>上面介绍了 XPath 选取节点的方法，但很多时候并不希望选取路径上的全部节点元素，而是只选取具有特定性质的元素。</p>

<p>XPath 中的<strong>谓语</strong>(predicate)用于<em>限定</em>查找符合特定条件的节点元素。谓语以</p>

<div class="codeblock code-template">
    <em>tag</em>[]
</div>

<p>这样的方括号形式出现在标签名后面。方括号内可以加上具体的谓词。</p>

<p>一个简单的谓词为：</p>

<div class="codeblock code-template">
    <em>n</em>
</div>

<p>代表选择文档中从上至下匹配路径的第 <code><em>n</em></code> 个标签。例如，以下表达式可以提取文章中第一段的所有文本：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article/p[1]//text()</span><span style="color: #d86db6;">'</span>)</div></div>

<p>与之类似的谓词是</p>

<div class="codeblock code-template">
    last()
</div>

<p>代表匹配到的最后一个元素。在介绍了 XPath 的运算符后，可以使用简单运算来得到第任意个元素。当然这一过程也可以交给 Python 处理，写成如下形式：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article/p</span><span style="color: #d86db6;">'</span>)[<span style="color: #174781;">0</span>].xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">.//text()</span><span style="color: #d86db6;">'</span>)</div></div>

<p>注意，尽管这两个谓词都只得到一个元素，但是该方法的返回结果仍然是一个列表。</p>

<p>标签名</p>

<div class="codeblock code-template">
    <em>tag</em>
</div>

<p>也可以做谓词使用，代表选择匹配到的标签需要含有该子标签（只能是父子关系）。例如，以下提取包含链接的单元格文本：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article/table//td[a]//text()</span><span style="color: #d86db6;">'</span>)</div></div>

<p>更为常用的限定与属性相关。XPath 表示属性的符号为：</p>

<div class="codeblock code-template">
    @<em>attribute</em>
</div>

<p>如果直接将属性作为谓词放入方括号中，那么代表标签需要存在该属性。更常用的做法是判断属性的值是否符合要求，那么这个时候就需要使用以下语法：</p>

<div class="codeblock code-template">
    @<em>attribute</em>="<em>value</em>"
</div>

<p>例如，通过 <code>class</code> 属性检索合适的节点是一种很常见的做法：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article//div[@class="item"]</span><span style="color: #d86db6;">'</span>)</div></div>

<p>考虑到这是一种很常用的语法，因此这里提前介绍了一个关系运算符。</p>

<p>属性除了作为谓词，还可以直接用作节点，获取某个属性对应的值。例如获取链接对应的 URL ：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article/a/@href</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># ['https://pypi.org/', '#content', '/jobs/', ...]</span></div></div>

<p>这种情况和文本节点一样不可能再会有子节点和谓语，因此只会出现在最后。当然再对它们应用子节点和谓语也不会发生异常，只是结果可能未必符合预期。</p>

<p>谓语还常与通配符一起使用。在 XPath 中，通配符</p>

<div class="codeblock code-template">
    *
</div>

<p>可以表示任意标签节点，而通配符</p>

<div class="codeblock code-template">
    @*
</div>

<p>可以表示任意属性节点。使用 <code>id</code> 属性寻找元素也是一种常用的做法，此时就可以配合通配符，例如：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//*[@id="content"][1]</span><span style="color: #d86db6;">'</span>)</div></div>

<p>注意这里同时使用了两个谓语串联限定，串联谓语也是从左向右顺序结合。如果想要表示所有的节点（包括标签节点、文本节点和属性节点），那么可以使用</p>

<div class="codeblock code-template">
    node()
</div>

<p>来表示。</p>

<p>由于 HTML 是一种不够规范的标记语言，在编写属性的时候可能会出现多个属性值或有额外空白符。例如，对于以下文档片段：</p>

<div class="vscode-block"><div><span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">pre</span> <span style="color: #df8618;">class</span>=<span style="color: #d86db6;">"</span><span style="color: #a44185;">codeblock python</span><span style="color: #d86db6;">"</span><span style="color: #3e3e3e;">&gt;</span></div><div>&#160; &#160; ...</div><div><span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">pre</span><span style="color: #3e3e3e;">&gt;</span></div></div>

<p>在 CSS 选择器中，可以使用 <code>pre.codeblock</code> 来选中并修改所有代码块的样式。但是 XPath 的解析却很严谨，这会造成因为值没有完全匹配而忽略的情况：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//pre[@class="codeblock"]</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># []</span></div></div>

<p>此时可以使用以下谓词来处理这类标签：</p>

<div class="codeblock code-template">
    contains(<em>node</em>, "<em>value</em>")
</div>

<p>只要节点 <code><em>node</em></code> 对应的值内含有 “ <code><em>value</em></code> ” 字符串，那么该标签就会被匹配。</p>

<p>这种节点可以是属性节点也可以是文本节点，例如对 <code>class</code> 属性的处理一般为：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//pre[contains(@class, "codeblock")]</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># [&lt;Element pre at 0x278d422a480&gt;, ...]</span></div></div>

<p>类似地，也可以使用</p>

<div class="codeblock code-template">
    starts-with(<em>node</em>, "<em>value</em>")
</div>

<p>作为谓词，来选取所有以特定字符串开头的属性值或文本内容。</p>

<p>最后总结一下涉及的语法。注意，所有谓词均可看作布尔值：</p>

<table>
    <tr>
        <th>表达式</th>
        <th>描述</th>
    </tr>
    <tr>
        <td colspan="2">谓词放在 <code><em>node</em>[]</code> 的方括号内，表示限定</td>
    </tr>
    <tr>
        <td class="cell-code"><em>node</em></td>
        <td>包含该类子节点</td>
    </tr>
    <tr>
        <td class="cell-code"><em>n</em></td>
        <td>位于该位置</td>
    </tr>
    <tr>
        <td class="cell-code">last()</td>
        <td>位于最后一个位置</td>
    </tr>
    <tr>
        <td class="cell-code">contains(<em>node</em>, "<em>value</em>")</td>
        <td>节点值包含该字符串</td>
    </tr>
    <tr>
        <td class="cell-code">starts-with(<em>node</em>, "<em>value</em>")</td>
        <td>节点值以该字符串开头</td>
    </tr>
    <tr>
        <td class="cell-code">@<em>attribute</em></td>
        <td>属性节点</td>
    </tr>
    <tr>
        <td class="cell-code">*</td>
        <td>任意标签节点</td>
    </tr>
    <tr>
        <td class="cell-code">@*</td>
        <td>任意属性节点</td>
    </tr>
    <tr>
        <td class="cell-code">node()</td>
        <td>任意节点</td>
    </tr>
</table>

<h3>运算符</h3>

<p>之前说到 XPath 的谓词可以看作布尔值，因此可以使用或、与、非做逻辑运算，通过多个条件获得需要匹配的标签。</p>

<p>逻辑运算“与”“或”“非”的关键字分别为：</p>

<div class="codeblock code-template">
    and<br>
    or<br>
    not()
</div>

<p>为了防止歧义，逻辑非需要像函数一样加上括号。以下是两个使用示例：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//a[not(@href)]</span><span style="color: #d86db6;">'</span>)</div><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//div[contains(@id, "content") and 1]</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># different from [contains(@id, "content")][1]</span></div></div>

<p>除了逻辑运算外，XPath 也有自身的运算符。这些运算符都作为谓语的一部分使用。</p>

<p>例如数学运算：</p>

<table>
    <tr>
        <th>运算符</th>
        <th>功能</th>
        <th>运算符</th>
        <th>功能</th>
    </tr>
    <tr>
        <td>+</td>
        <td>加法</td>
        <td>ceiling()</td>
        <td>向上取整</td>
    </tr>
    <tr>
        <td>-</td>
        <td>减法</td>
        <td>floor()</td>
        <td>向下取整</td>
    </tr>
    <tr>
        <td>*</td>
        <td>乘法</td>
        <td>mod</td>
        <td>取余</td>
    </tr>
    <tr>
        <td>div</td>
        <td>除法</td>
        <td></td>
        <td></td>
    </tr>
</table>

<p>例如，要选取倒数第二个列表项，可以使用：</p>

<div class="vscode-block"><div><span token="comment"># &#160; (Emmet markup) ol&gt;li*7{$} </span></div><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//ol/li[last() - 1]/text()</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># ['6']</span></div></div>

<p>再如，如果要选择中间项，可以使用：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//ol/li[floor(last() div 2 + 0.5)]/text()</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># ['4']</span></div></div>

<p>除了算术运算符外，还可以使用以下关系运算符：</p>

<div class="codeblock code-template">
    = != &gt; &gt;= > >=
</div>

<p>关系运算符常用在对纯 XML 文档的解析上，因为 XML 经常使用某个标签存储一个数值。不过关系运算符可以配合以下函数</p>

<div class="codeblock code-template">
    position()
</div>

<p>该函数泛指位置，配合关系运算符就可以选取特定位置范围的标签，例如：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//ol/li[position() &lt; 4]/text()</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># ['1', '2', '3']</span></div></div>

<p>或者以下函数</p>

<div class="codeblock code-template">
    count(<em>node</em>)
</div>

<p>用于统计符合条件的子节点个数，例如：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//ol[count(li) &gt;= 4]</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># [&lt;Element ol at 0x2628154a480&gt;]</span></div></div>

<p>表达式组合应用得当可以处理很多关系，例如像 CSS 选择器的伪类一样选择偶数位置的节点：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//ol/li[position() = ((position() mod 2) = 0)]/text()</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># ['2', '4', '6']</span></div></div>

<p>以上涉及的表达式都用在谓语内，还可以使用符号</p>

<div class="codeblock code-template">
    |
</div>

<p>用在两个表达式内，表示对两个表达式匹配的元素取并集。例如，以下可以选取所有的链接：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//@src | //@href</span><span style="color: #d86db6;">'</span>)</div></div>

<h3>轴</h3>

<p><strong>轴</strong>(Axes)是 XPath 中的一个更高级的概念。轴用于从文档树中定位和当前节点具有一定位置关系的那些节点，相比基本的 XPath 表达式可以表示更复杂的位置关系。</p>

<p>轴的使用通过以下语法表示：</p>

<div class="codeblock code-template">
    <em>axisname</em>::<em>node</em>
</div>

<p>其中 <code><em>axisname</em></code> 表示限定位置关系，<code><em>node</em></code> 表示限定该位置上的节点类型。这些位置关系可以有：</p>

<table>
    <tr>
        <th>名称</th>
        <th>效果</th>
        <th>名称</th>
        <th>效果</th>
    </tr>
    <tr>
        <td class="cell-code">ancestor</td>
        <td>选取所有祖先</td>
        <td class="cell-code">ancestor-or-self</td>
        <td>选取所有祖先及自身</td>
    </tr>
    <tr>
        <td class="cell-code">descendant</td>
        <td>选取所有后代</td>
        <td class="cell-code">descendant-or-self</td>
        <td>选取所有后代及自身</td>
    </tr>
    <tr>
        <td class="cell-code">following</td>
        <td>选取文档中位于其之后的所有节点</td>
        <td class="cell-code">following-sibling</td>
        <td>选取之后的所有兄弟节点</td>
    </tr>
    <tr>
        <td class="cell-code">preceding</td>
        <td>选取文档中位于其之前的所有节点</td>
        <td class="cell-code">preceding-sibling</td>
        <td>选取之前的所有兄弟节点</td>
    </tr>
    <tr>
        <td class="cell-code">child</td>
        <td>选取所有子节点</td>
        <td class="cell-code">attribute</td>
        <td>选取节点的所有属性</td>
    </tr>
    <tr>
        <td class="cell-code">parent</td>
        <td>选取所有父节点</td>
        <td class="cell-code">self</td>
        <td>选取当前节点</td>
    </tr>
    <tr>
        <td class="cell-code">namespace</td>
        <td>选取所有命名空间节点</td>
        <td class="cell-code"></td>
        <td></td>
    </tr>
</table>

<p>例如，对于以下 HTML 结构：</p>

<div class="vscode-block"><div><span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">article</span><span style="color: #3e3e3e;">&gt;</span></div><div>&#160; &#160; <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">h2</span><span style="color: #3e3e3e;">&gt;</span>...<span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">h2</span><span style="color: #3e3e3e;">&gt;</span></div><div>&#160; &#160; <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span>...<span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span></div><div>&#160; &#160; <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">h2</span> <span style="color: #df8618;">id</span>=<span style="color: #d86db6;">"</span><span style="color: #a44185;">xpath-tutorial</span><span style="color: #d86db6;">"</span><span style="color: #3e3e3e;">&gt;&lt;/</span><span style="color: #0444ac;">h2</span><span style="color: #3e3e3e;">&gt;</span></div><div>&#160; &#160; <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span>...<span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span></div><div>&#160; &#160; <span style="color: #3e3e3e;">&lt;</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span>...<span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">p</span><span style="color: #3e3e3e;">&gt;</span></div><div><span style="color: #3e3e3e;">&lt;/</span><span style="color: #0444ac;">article</span><span style="color: #3e3e3e;">&gt;</span></div></div>

<p>如果想提取 <code>#xpath-tutorial</code> 的二级标题后的第一段，假设使用一般的同级节点表示方法：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//h2[@id="xpath-tutorial"]/../p</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># [&lt;Element p at 0x24c5f54a480&gt;, </span></div><div><span token="comment"># &#160;&lt;Element p at 0x24c5f54a1c0&gt;, </span></div><div><span token="comment"># &#160;&lt;Element p at 0x24c5f54a4c0&gt;]</span></div></div>

<p>那么没法定位到这样一个结果。而使用轴就可以很清楚地表示这种位置关系：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//h2[@id="xpath-tutorial"]/following-sibling::p[1]</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># [&lt;Element p at 0x209deaca3c0&gt;]</span></div></div>

<p>就像它的名称一样，轴是一种很强大的定位关系。</p>

<h2>lxml的其余内容</h2>

<h3>其它XPath语法</h3>

<p>前文说了在 <var>lxml</var> 中，通过 <code>.xpath()</code> 方法都会返回匹配节点组成的列表。然而 <var>lxml</var> 还支持这样的一些 XPath 语法，它们的返回结果是单个值。因此这些语法并不一定在浏览器的调试界面中能得出结果。</p>

<p>例如，当 <code>count()</code> 作用于一个表达式时，会返回包含的结果个数，并且在 <var>lxml</var> 中结果以浮点数形式给出：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">count(//ol/li[text()])</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># 7.0</span></div></div>

<p>再如，<code>string-length()</code> 可以返回一个文本的字符个数，并且结果可以被用在关系运算中：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article/p[string-length() &gt; 10]</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># [&lt;Element p at 0x23224bea380&gt;, ...]</span></div></div>

<p>还有一个比较好用的 <code>local-name()</code> 用于获取节点的标签名，有时在使用通配符时会用到：</p>

<div class="vscode-block"><div>html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">local-name(//*[@id="content"])</span><span style="color: #d86db6;">'</span>)</div><div><span token="comment"># "article"</span></div></div>

<p>XPath 还有许多类似这样的语法，不过并不是很常用，因此这里就不介绍了。</p>

<p>最后需要说明的是，本节的主要目的是为了介绍 XPath 语法，而不是介绍使用 <var>lxml</var> 处理 XML 文档的方法，因此可能涉及一些虽然很强大，但实际上并不直接使用的 XPath 语法。就像正则表达式不能表示所有的情况一样，XPath 尽管很强大，但也不是万能的，在适当的时候还是应该辅以编程语言的功能协助处理。例如提取一个元素包含标签、属性以及文本的所有结构，使用纯 XPath 比较难实现，但是 <code>lxml</code> 就提供了 Python 函数来处理这个问题：</p>

<div class="vscode-block"><div>etree.tostring(html.xpath(<span style="color: #d86db6;">'</span><span style="color: #a44185;">//article/p</span><span style="color: #d86db6;">'</span>)[<span style="color: #174781;">0</span>])</div><div><span token="comment"># b'&lt;p&gt;This is a simple &lt;strong&gt;HTML&lt;/strong&gt; page&lt;/p&gt;\n &#160; &#160; &#160; &#160;'</span></div></div>

<p>此外，一昧地追求复杂的 XPath 表达式可能会让代码变得晦涩难懂，并不是一种合理的使用方式。</p>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/">https://www.w3.org/TR/2017/REC-xpath-31-20170321/</a><br>
    XPath 3.1 标准
</p>

<p>
    <a href="https://devhints.io/xpath">https://devhints.io/xpath</a><br>
    一份 XPath 语法小抄
</p>
<p><a rel="nofollow" href="/archives/842">XPath简单入门</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/842/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python面向对象编程03-类的继承</title>
		<link>/archives/579</link>
					<comments>/archives/579#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 28 Jul 2022 14:08:34 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=579</guid>

					<description><![CDATA[<p>类的继承 什么是继承 在 Python 中，有些时候&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/579">Python面向对象编程03-类的继承</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>类的继承</h2>

<h3>什么是继承</h3>

<p>在 Python 中，有些时候会遇到一个已经写好的类，这个类实现了一些基本的功能、方法，但是并不完善。例如，假设要编写一个游戏，在游戏中实现了怪物类 <code>Monster</code> ，它具有一些基本的属性和交互逻辑：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Monster</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, hp, damage):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">max_hp</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__hp</span> <span style="color: #859900;">=</span> hp</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__damage</span> <span style="color: #859900;">=</span> damage</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">attack</span>(self, target):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target.hp <span style="color: #859900;">-=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__damage</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">cure</span>(self, hp<span style="color: #859900;">=</span><span style="color: #b58900;">None</span>):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> hp <span style="color: #859900;">is</span> <span style="color: #b58900;">None</span> <span style="color: #859900;">or</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__hp</span> <span style="color: #859900;">+</span> hp <span style="color: #859900;">&gt;</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">max_hp</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__hp</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">max_hp</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">else</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__hp</span> <span style="color: #859900;">+=</span> <span style="color: #268bd2;">self</span>.hp</div></div>

<p>通过实例化该类，就可以往合适的位置添加一些怪物，并且每只怪物都可以拥有独立的攻击力等属性。</p>

<p>然而，游戏中往往存在许多类型的怪物，同类怪物还可以细分为许多不同的形态，如果要为每一种怪物都从头编写一个类，考虑到这些基础的属性及方法的定义都不会改变，就必须将这些重复的代码片段复制过来，就像：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Slime</span>:</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">attack</span>(self, target):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target.hp <span style="color: #859900;">-=</span> <span style="color: #268bd2;">self</span>.__damage</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Zombie</span>:</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">attack</span>(self, target):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target.hp <span style="color: #859900;">-=</span> <span style="color: #268bd2;">self</span>.__damage</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Guardian</span>:</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">attack</span>(self, target):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; target.hp <span style="color: #859900;">-=</span> <span style="color: #268bd2;">self</span>.__damage</div></div>

<p>这很明显是一种低效的方法：一个实现了基本功能的类可能有上百行代码，如果将所有代码复制过来，显然不方便调整和修改，容易产生疏漏，而且一旦游戏的底层逻辑被更新（例如增加了护甲这一概念），那么要为涉及的所有类重写方法，显然非常不合适。</p>

<p>在面向对象编程中，<strong>继承</strong>(inheritance)机制经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），此时可以不用直接复制代码，而是通过<mark>继承获取被继承类拥有的属性与方法</mark>，从而轻松实现类的复用。</p>

<p>在 Python 中，定义类的时候如果在类名称后面加上一个小括号，里面传入需要继承的类名，表示这个类是继承基于已定义的类的：</p>

<div class="codeblock code-template">
    <strong>class</strong> <em>DerivedType</em>(BaseType):<br>
    &nbsp; &nbsp; ...
</div>

<p>这里的 <code>DerivedType</code> 是继承自 <code>BaseType</code> ，它拥有 <code>BaseType</code> 的所有属性和方法。被继承的类称为<strong>父类</strong>或超类，继承得到的对象称为<strong>子类</strong>(subclass)。在明确父类的定义后，子类通过继承获得的所有属性与方法实现均与父类相同。</p>

<p>由于子类继承的方法实际上是对父类方法的引用，因此当父类方法更新时，子类的调用结果也会随之改变。</p>

<p>对于上述类 <code>Monster</code> ，可以通过继承它来创建一个新的类，例如：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Goblin</span>(<span style="color: #cb4b16;">Monster</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">enrage</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__damage</span> <span style="color: #859900;">*</span> <span style="color: #d33682;">2</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">max_hp</span> <span style="color: #859900;">*</span> <span style="color: #d33682;">1.25</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">cure</span>()</div></div>

<p>子类无需额外编写包括初始化在内的所有方法，就可以直接使用父类提供的属性操作，不仅省时省力，还降低了出现疏漏的可能。</p>

<h3>继承与面向对象</h3>

<p>面向对象编程思想的最终目的就包括使程序灵活性、重用性和可扩展性得以提升，而类的继承便很好地满足了该目的。</p>

<p>继承使子类可以拥有父类所有的属性和方法，在实际应用时，往往会提前写好一些具有基本功能的<strong>基类</strong>，在使用时要做的就是继承它们，然后添加上合适的业务功能，使开发效率可以大幅提升。</p>

<p>例如，以下是第三方库 SQLAlchemy 的使用示例。SQLAlchemy 用于处理 SQL 数据库，它已经提前编写好了数据表操作的基类，通过继承该基类，可以创建一个自定义的数据表：</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">import</span> <span style="color: #cb4b16;">sqlalchemy</span> <span style="color: #859900;font-weight: bold;">as</span> <span style="color: #cb4b16;">sa</span></div><div><span style="color: #859900;font-weight: bold;">from</span> <span style="color: #cb4b16;">sqlalchemy</span>.<span style="color: #cb4b16;">ext</span>.<span style="color: #cb4b16;">declarative</span> <span style="color: #859900;font-weight: bold;">import</span> <span style="color: #268bd2;">declarative_base</span></div><div><span style="color: #268bd2;">Base</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">declarative_base</span>()</div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">User</span>(<span style="color: #268bd2;">Base</span>):</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">__tablename__</span> <span style="color: #859900;">=</span> <span style="color: #2aa198;">'user'</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">id</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Column</span>(<span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Integer</span>, primary_key<span style="color: #859900;">=</span><span style="color: #b58900;">True</span>, autoincrement<span style="color: #859900;">=</span><span style="color: #b58900;">True</span>)</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">username</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Column</span>(<span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">String</span>(<span style="color: #d33682;">64</span>), unique<span style="color: #859900;">=</span><span style="color: #b58900;">True</span>)</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">password</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Column</span>(<span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">String</span>(<span style="color: #d33682;">64</span>))</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">email</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">Column</span>(<span style="color: #cb4b16;">sa</span>.<span style="color: #cb4b16;">String</span>(<span style="color: #d33682;">128</span>), unique<span style="color: #859900;">=</span><span style="color: #b58900;">True</span>)</div></div>

<p>继承得到的类只需要考虑数据表具有什么样的字段，而无需知道如何与数据库交互。在合适的时候，基类的方法会被调用，自动执行数据的更新或查找等操作，而无需考虑这些方法到底如何实现。</p>

<p>当有一个现有的、功能已经相当完善的类时，有些时候为了扩展这些类的功能，也会继承它并定义一些新方法，这样可以在保留原有类的优点时丰富它的功能。Python 标准库中的类都是很好的继承对象。</p>

<p>以字典类为例，可以基于它实现一个自己的字典：</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">from</span> <span style="color: #cb4b16;">collections</span> <span style="color: #859900;font-weight: bold;">import</span> <span style="color: #cb4b16;">OrderedDict</span></div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">SortableDict</span>(<span style="color: #cb4b16;">OrderedDict</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">sort_value</span>(self, reverse<span style="color: #859900;">=</span><span style="color: #b58900;">False</span>):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">item_list</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">list</span>(<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">items</span>())</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">item_list</span>.<span style="color: #268bd2;">sort</span>(key<span style="color: #859900;">=</span><span style="color: #586e75;font-weight: bold;">lambda</span> x: x[<span style="color: #d33682;">1</span>])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> reverse:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">item_list</span>.<span style="color: #268bd2;">reverse</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #cb4b16;">OrderedDict</span>(<span style="color: #268bd2;">item_list</span>)</div></div>

<p>对于这一个继承的字典类，它保留了字典的所有性质，并可以通过方法 <code>.sort_value()</code> 对值进行排序。它完全可以像字典一样使用：</p>

<div class="codeblock code-console">&gt;&gt;&gt; scores = SortableDict(John=72, Tom=83, Joe=75, Emma=92)
&gt;&gt;&gt; scores.sort_value(reverse=True)
OrderedDict([('Emma', 92), ('Tom', 83), ('Joe', 75), ('John', 72)])</div>

<p>子类也可以被继承，类可以这样无限继承下去，每继承一次，它的功能就更丰富了一层。</p>

<p>事实上，在 Python3 中定义一个类时，如果没有明确类是继承自哪一个类的，那么这个类便自动继承自内置类 <code>object</code> 。<code>object</code> 是 Python 类的基础，它实现了一些最基本的方法例如分配资源、名称表示等，可以说任何定义的类最终都是它的子类。</p>

<p>方法重写也是面向对象编程常用的一种手段。尽管有一些类已经实现了某个方法，但为了适应不同的业务逻辑，有时也需要重写父类提供的方法。</p>

<p>例如，以下是第三方库 Scrapy 的一个简单示例，通过继承 <code>scrapy.Spider</code> 基类，可以创建一个网络爬虫类。该类已经写好了完整了爬虫处理过程并在合适的时候调用相应的方法，而用户要做的就是重写关键的方法来适应当前爬虫业务。例如替换要爬取的网站等关键信息，以及重写 <code>.parse()</code> 方法来处理数据的解析流程：</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">import</span> scrapy</div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">BookSpider</span>(<span style="color: #cb4b16;">scrapy</span>.<span style="color: #6c71c4;">Spider</span>):</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">name</span> <span style="color: #859900;">=</span> <span style="color: #2aa198;">'books'</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">start_urls</span> <span style="color: #859900;">=</span> [<span style="color: #2aa198;">'https://scrapy.org/resources/'</span>]</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">parse</span>(self, response):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">resource</span> <span style="color: #859900;">in</span> response.css(<span style="color: #2aa198;">'div.resource'</span>):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">link</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">resource</span>.xpath(<span style="color: #2aa198;">'./div/a/@href'</span>).extract_first()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">title</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">resource</span>.xpath(<span style="color: #2aa198;">'./div/a/text()'</span>).extract_first()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">yield</span> {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #2aa198;">'link'</span>: <span style="color: #268bd2;">link</span>,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #2aa198;">'title'</span>: <span style="color: #268bd2;">title</span>,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div></div>

<p>重写之后该方法就可以替换原有流程的数据解析部分，而执行请求、解析数据等方法可以让父类提供，也可以通过重写实现自己的要求。</p>

<p>继承和重写使类的设计更模块化，在编写类的时候可以将整个过程拆解为一个个的方法，如果需要修改过程中的某一步，只需要继承该类并重写对应的方法，只要方法的参数和返回值等符合上下文调用的需求，即可简洁、清晰地做局部调整。</p>

<p>继承和重写也符合面向对象编程中<strong>多态</strong>的概念，即当多个类继承某一个类时，如果这些类都重写了某些方法，那么对不同的类调用相同的方法，就可以得到不同的结果。例如对以上的爬虫类，对不同的爬虫调用 <code>.parse()</code> 方法，解析数据的方式也不尽相同。</p>

<p>在 Python 中，继承还有一个很典型的应用场景就是异常。通过继承异常类型，可以逐步缩减异常涉及的范围，从而易于通过 <code>except</code> 语句捕获不同异常。</p>

<h3>多继承</h3>

<p>在 Python 中，一个类可以继承自多个类，只需要在代表继承的括号中输入多个类名：</p>

<div class="codeblock code-template">
    <strong>class</strong> <em>DerivedType</em>(BaseType01, BaseType02, ...):<br>
    &nbsp; &nbsp; ...
</div>

<p>这个新的子类就会保留继承的所有父类的属性和方法，同时兼具继承的所有类的特性。</p>

<p>对于多个父类中包含同名的类属性与方法，Python 会根据子类继承时圆括号中父类的前后次序决定，括号中排在前面的属性与方法会覆盖后面的同名属性与方法。</p>

<p>在使用多继承时，往往将其中一部分类用作接口。接口类定义了这些类中需要具有什么特性，也就是说需要拥有什么属性与方法。</p>

<p>在继承时，可以编写一种特殊的抽象基类。抽象基类不具有实际含义，不能被实例化，仅用于在继承时提示被继承的类具有什么特性，这种抽象基类往往被用于接口。<code>collections.abc</code> 模块提供了基础的抽象基类，继承该模块的抽象基类提示该类应该实现某些方法来实现特殊操作。</p>

<p>例如，以下的 <code>Directory</code> 类继承自 <code>Path</code> 类，提示它拥有路径的一些操作（例如切换目录、计算相对路径等），同时它还继承自 <code>Iterable</code> 类，这说明该类<em>应该</em>实现了某些方法，从而变成一个可迭代对象，</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">from</span> <span style="color: #cb4b16;">collections</span>.<span style="color: #cb4b16;">abc</span> <span style="color: #859900;font-weight: bold;">import</span> <span style="color: #cb4b16;">Iterable</span></div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Path</span>:</div><div>&nbsp; &nbsp; <span style="color: #cb4b16;">...</span></div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Directory</span>(<span style="color: #cb4b16;">Path</span>, <span style="color: #cb4b16;">Iterable</span>):</div><div>&nbsp; &nbsp; <span style="color: #cb4b16;">...</span></div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># Some methods need to be implemented to support for loop</span></div></div>

<p>可以使用 <code>for</code> 循环从该类中迭代每一个成员（例如目录中的每一个文件或子目录）。关于可迭代对象的概念将会在后续介绍。</p>

<h2>继承与super类</h2>

<h3>为什么要使用super类</h3>

<p>前文中介绍了多继承，多继承允许一个类使用所有父类的属性与方法。然而这样做有一个很严重的问题：那就是父类之间的方法或属性标识符可能会冲突，从而相互之间发生覆盖造成一定问题。</p>

<p>考虑以下简单示例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Sequence</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self): <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">size</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">11</span></div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Window</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self): <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">size</span> <span style="color: #859900;">=</span> (<span style="color: #d33682;">400</span>, <span style="color: #d33682;">300</span>)</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">create</span>(self): </div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #586e75;font-weight: bold;">f</span><span style="color: #2aa198;">'window created with size </span><span style="color: #cb4b16;">{</span><span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">size</span><span style="color: #cb4b16;">}</span><span style="color: #2aa198;">'</span>)</div></div>

<p>这两个类在单独编写或继承时，并没有什么问题。但是在多继承时，便会产生问题了：</p>

<div class="codeblock code-console">&gt;&gt;&gt; class Windows(Sequence, Window):
...     pass
...
&gt;&gt;&gt; Windows().create()
window created with size 11</div>

<p>两个类的初始化方法发生了覆盖，造成同名变量的赋值也被覆盖，这种覆盖是十分危险的。由于初始化方法需要为实例准备一些必要的属性，如果缺失这一步会造成缺少方法需要的资源，从而产生错误。</p>

<p>一种更复杂的继承情况涉及单继承和多继承的结合，这种情况下，多次调用同一方法也可能造成一定问题。例如，考虑以下继承关系：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">A</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is A'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">B</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">A</span>.<span style="color: #268bd2;">identify</span>(<span style="color: #268bd2;">self</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is B'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">A</span>.<span style="color: #268bd2;">identify</span>(<span style="color: #268bd2;">self</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is C'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">D</span>(<span style="color: #cb4b16;">B</span>, <span style="color: #cb4b16;">C</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">B</span>.<span style="color: #268bd2;">identify</span>(<span style="color: #268bd2;">self</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">C</span>.<span style="color: #268bd2;">identify</span>(<span style="color: #268bd2;">self</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is D'</span>)</div></div>

<p>这种继承关系如下所示，箭头之间构成了一个菱形，因此有时也称为菱形继承：</p>

<div class="codeblock code-console">    A
 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2197.png" alt="↗" class="wp-smiley" style="height: 1em; max-height: 1em;" />  <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2196.png" alt="↖" class="wp-smiley" style="height: 1em; max-height: 1em;" />
B      C
 <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2196.png" alt="↖" class="wp-smiley" style="height: 1em; max-height: 1em;" />  <img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2197.png" alt="↗" class="wp-smiley" style="height: 1em; max-height: 1em;" />
   D</div>

<p>在菱形继承中，各种类方法之间复杂地纠缠在一起，稍不注意就可能产生混乱的调用问题。在以上示例中，尝试调用 <code>D</code> 类的方法：</p>

<div class="codeblock code-console">D().identify()
This is A 
This is B 
This is A 
This is C 
This is D</div>

<p>从中可以看出，调用两个父类的方法时都各自调用了一遍 <code>A</code> 类的方法。当继承关系进一步变复杂时，调用还会更加混乱。</p>

<p>这种时候，可以使用 Python 内置的 <code>super</code> 类。</p>

<h3>使用super类</h3>

<p><code>super(<em>type</em>, <em>object_or_type</em>)</code> 将得到一个父类或同级类的代理对象(proxy object)，用于访问已在类中重写的继承方法。</p>

<p>其中，参数 <code><em>type</em></code> 是一个类名，而 <code><em>object_or_type</em></code> 必须是一个该类或该类的子类的实例化对象。</p>

<p>如果用在在类的实例方法内部，<code>super()</code> 函数的两个参数是可以省略的。这种情况下该类代表父类，可以用该类得到的实例来调用父类的方法，例如：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">A</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">m</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'=&gt; A.m &lt;='</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">B</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span><span style="color: #268bd2;">m</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">sth</span><span style="color: #859900;">=</span><span style="color: #cb4b16;">super</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">sth</span>.<span style="color: #268bd2;">m</span>()</div></div>

<p>那么此时如果调用 <code>B().m()</code> ，通过 <code>super</code> 类就可以调用父类的方法，在控制台中打印提示文本。</p>

<p>在这个最简单的使用场景中，<code>super</code> 类充当了对父类的一个隐式引用，通过它来调用父类的方法。当然也可以直接使用父类调用父类的方法，不过采用 <code>super</code> 类含义更加明确，也更不容易出现疏漏。</p>

<p>在许多继承场合中，都需要额外调用父类的初始化方法来准备一些必要的属性，例如 Python 用于编写简易用户界面的标准库 tkinter 中，如果想继承一个控件类实现自己的控件，就需要调用这些类的初始化方法，为界面绘制提供参数：</p>

<div class="vscode-block"><div><span style="color: #859900;font-weight: bold;">import</span> <span style="color: #cb4b16;">tkinter</span> <span style="color: #859900;font-weight: bold;">as</span> <span style="color: #cb4b16;">tk</span></div><br><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">MainPanel</span>(<span style="color: #cb4b16;">tk</span>.<span style="color: #cb4b16;">Frame</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, master):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__init__</span>(master) &nbsp;<span style="color: #a8a8a8;"># ignore this will cause an error</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">...</span></div></div>

<p>当然也可以直接通过父类调用初始化方法 <code>tk.Frame.__init__(self, master)</code> 。</p>

<h3>super类与多继承</h3>

<p>以上对 <code>super</code> 类的应用似乎可有可无。解决多继承问题才是该类提出的根本目的。</p>

<p>在介绍 <code>super</code> 类处理多继承前，需要先了解 Python 的 MRO 。MRO(Method Resolution Order, 方法解析顺序)是 Python 中定义类的继承顺序的依据，用来处理多继承时的继承顺序。</p>

<p>在创建一个类时，Python 都会自动为该类创建一个 <code>.__mro__</code> 属性，这个属性就是 Python 的 MRO 机制生成的。可以通过类的 <code>.__mro__</code> 属性或类的 <code>.mro()</code> 方法来查看上面菱形继承的 <code>D</code> 类的 <code>__mro__</code> 属性值：</p>

<div class="codeblock code-console">&gt;&gt;&gt; D.__mro__
    (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)
</div>

<p><code>.mro()</code> 方法除了返回的结果是列表而不是元组外，结果是相同的。</p>

<blockquote>
    <p>目前 Python3 采用 C3 算法来获取类的 MRO 信息，该算法的细节可以在 <a href="https://www.python.org/download/releases/2.3/mro/">https://www.python.org/download/releases/2.3/mro/</a> 查询到，这里对此做简要介绍，仅供了解所用。</p>
    
    <p>如下是一个复杂的继承关系，箭头指向父类，并且先继承的类位于左侧：</p>

    <figure>
        <img decoding="async" src="/wordpress/wp-content/uploads/2022/07/mro.png" alt="" width="140">
    </figure>
    
    <p>当要生成 F 的继承顺序时，C3 算法过程如下：首先将被指向箭头数量为 0 的节点（没有被继承的类）F 放入 MRO 列表，并将这些节点及与有关箭头从继承树中删除；接下来继续找相似特征的节点，此时如果同时找到符合条件的类，则取左侧优先放入 MRO 列表并从树中删除下一步查找满足的节点有 A 和 E ，根据左侧优先取出 A ，按如此顺序得到的 MRO 为 <code>F,D,A,E,B,C</code> 。不过注意，Python 所有类都有一个共同的父类 <code>object</code> ，因此最后会将 <code>object</code> 放入列表末尾。</p>

    <p>最终生成列表中元素顺序为：<code>F→D→A→E→B→C→object</code> 。感兴趣的话可以编写代码验证。</p>
</blockquote>

<p>当用 super 调用父类的方法时，会按照 __mro__ 属性中的元素顺序逐个查找方法，<code><em>object_or_type</em></code> 对应的类负责确定 <code>__mro__</code> 属性，而 <code><em>type</em></code> 参数在 <code>__mro__</code> 中寻找上一个类作为父类。</p>

<p>如果不是很理解这个表述，请看以下复杂继承的示例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">A</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is A'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">B</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is B'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is C'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">D</span>(<span style="color: #cb4b16;">A</span>, <span style="color: #cb4b16;">B</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is D'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">E</span>(<span style="color: #cb4b16;">B</span>, <span style="color: #cb4b16;">C</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is E'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">F</span>(<span style="color: #cb4b16;">D</span>, <span style="color: #cb4b16;">E</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is F'</span>)</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">A</span>, <span style="color: #cb4b16;">F</span>()).identify()</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">B</span>, <span style="color: #cb4b16;">F</span>()).identify()</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">D</span>, <span style="color: #cb4b16;">F</span>()).<span style="color: #268bd2;">identify</span>()</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">E</span>, <span style="color: #cb4b16;">F</span>()).<span style="color: #268bd2;">identify</span>()</div><div><span style="color: #cb4b16;">super</span>(<span style="color: #cb4b16;">F</span>, <span style="color: #cb4b16;">F</span>()).<span style="color: #268bd2;">identify</span>()</div></div>

<p>以上代码一共得到了 5 种不同的代理对象，它们的指代分别为：</p>

<div class="codeblock code-console">This is E
This is C
This is A
This is B
This is D</div>

<p>尽管 <code>A</code> 类看起来与 <code>E</code> 类没有任何关系，但是代表的却是 E 类的实例。回顾一下这种继承关系得到的 MRO 顺序：</p>

<div class="codeblock code-template">
    F→D→A→E→B→C→object
</div>

<p>结果便不言而喻了。记住 <code><em>type</em></code> 参数确定的父类的是 <code><em>object_or_type</em></code> 参数在 MRO 中指向的后一个类。</p>

<blockquote>
    <p>之前说过 <code>super()</code> 的第二个参数也可以是一个类，不过这是对于调用类方法而言的。有关类方法的内容将会在下一节介绍</p>
</blockquote>

<p>回到之前提出的第二个问题，如果采用 <code>super</code> 类来调用父类方法：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">A</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self): <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is A'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">B</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">identify</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is B'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>(<span style="color: #cb4b16;">A</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">identify</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is C'</span>)</div><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">D</span>(<span style="color: #cb4b16;">B</span>, <span style="color: #cb4b16;">C</span>):</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">identify</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">identify</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">print</span>(<span style="color: #2aa198;">'This is D'</span>)</div></div>

<p>那么就不会出现重复调用的情况了：</p>

<div class="codeblock code-console">&gt;&gt;&gt; D().identify()
This is A 
This is C 
This is B 
This is D</div>

<p>任意复杂的继承情况，每一个类在 MRO 中只会出现一次，因此这样避免了方法的重复调用，使得复杂的继承也不容易出错。</p>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://docs.python.org/3/tutorial/classes.html#inheritance">https://docs.python.org/3/tutorial/classes.html#inheritance</a><br>
    Python3 官方文档对继承的介绍，不过这部分比较简洁
</p>

<p>
    <a href="https://docs.python.org/3/library/functions.html#super">https://docs.python.org/3/library/functions.html#super</a><br>
    Python3 官方文档对内置函数 <code>super</code> 的介绍
</p>
<p><a rel="nofollow" href="/archives/579">Python面向对象编程03-类的继承</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/579/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python3 with语句和上下文管理器</title>
		<link>/archives/509</link>
					<comments>/archives/509#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 14 Jul 2022 09:21:33 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=509</guid>

					<description><![CDATA[<p>with语句和上下文管理器 with语句 在 Pyt&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/509">Python3 with语句和上下文管理器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>with语句和上下文管理器</h2>

<h3>with语句</h3>

<p>在 Python 中，传统的处理文本文件读写的方式都是这样：</p>

<div class="vscode-block"><div><span style="color: #405c79;">file = </span><span style="color: #8b56bf;">open</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">1.txt</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;">)</span></div><div><span style="color: #bf8b56;">...</span><span style="color: #405c79;"> &#160;</span><span style="color: #a8a8a8;"># 读写操作</span></div><div><span style="color: #405c79;">file.close()</span></div></div>

<p>这也是多数编程语言都使用的常规的处理文件的流程：打开文件、读写文件、关闭文件。</p>

<p>不过这种文本文件的处理方式存在一些潜在的问题：对于复杂的读写操作，可能在其中的某一步出现异常，造成 <code>file.close()</code> 语句未能顺利执行；如果读写操作过于复杂，也可能忘记添加 <code>file.close()</code> 语句。这几种情况下，文件都可能因为未被关闭而保存失败，或资源持续占用等问题。</p>

<p>文件是否关闭可以通过编写测试代码来检查，智能的 IDE 也可能发现未关闭的文件。对于可能出现错误的情况，一般采取的解决方法是将其放在 <code>try</code> 语句中捕获可能的错误，并在 <code>finally</code> 中确保关闭文件：</p>

<div class="vscode-block"><div><span style="color: #405c79;">file = </span><span style="color: #8b56bf;">open</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">1.txt</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;">)</span></div><div><span style="color: #bf568b;font-weight: bold;">try</span><span style="color: #405c79;">:</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;"> &#160;</span><span style="color: #a8a8a8;"># 读写操作</span></div><div><span style="color: #bf568b;font-weight: bold;">except</span><span style="color: #405c79;">:</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;"> &#160;</span><span style="color: #a8a8a8;"># 错误处理</span></div><div><span style="color: #bf568b;font-weight: bold;">finally</span><span style="color: #405c79;">:</span></div><div><span style="color: #405c79;">&#160; &#160; file.close()</span></div></div>

<p>以上做法稍显复杂。实际上 Python 的语法中存在一种 <code>with</code> 语句，也称为<strong>上下文管理语句</strong>。使用上下文管理语句操作文件时，其代码为：</p>

<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">with</span> <span style="color: #8b56bf;">open</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">1.txt</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> file:</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;"> &#160;</span><span style="color: #a8a8a8;"># 读写操作</span></div></div>

<p>这时，不需要手动在代码中关闭文件，因为 <code>with</code> 语句相当于打开了一个上下文，只要当 <code>with</code> 内语句执行完毕或出现异常时，它都会自动执行一条退出命令，即 <code>file.close()</code> 。</p>

<p><code>with</code> 语句的结构为：</p>

<div class="codeblock code-template">
    <strong>with</strong> <em>context_manager</em> as <em>cm</em>:<br>
    &nbsp; &nbsp; ... &nbsp;<span class="codetoken comment"># some operations</span>
</div>

<p>以上语句通过 <code>with</code> 语句生成了一个上下文(context)，并可能通过 <code>as</code> 语句得到上下文管理对象。在 <code>with</code> 语句中的所有操作，都位于这个上下文以内。不管这些操作成功还是失败，它都需要进入和退出这个环境。而它退出时，便会进行相应的清理工作：对于文件操作，对应的会执行 <code>file.close()</code> 语句。</p>

<p>以上便是 Python 内置的关于文件的上下文管理操作。上下文管理操作是 Python 的一个高级语法，在合理的场景使用，不仅降低了程序出错的概率，而且可以使程序更简洁明了。</p>

<p>另一个使用上下文管理器的典型场景是 Python 中的多线程锁。使用 <code>with</code> 语句配合多线程锁时，锁的获取与释放都会自动执行：</p>

<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> threading</span></div><br><div><span style="color: #405c79;">lock = threading.Lock()</span></div><div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> lock:</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf8b56;">...</span></div></div>

<p>接下来看看如何实现自定义的上下文管理操作。</p>

<h3>上下文管理器</h3>

<p>可以自行实现一个上下文管理器(context manager)来完成上下文管理操作。</p>

<p>如果一个对象是一个上下文管理器，它需要实现两个特殊方法：<code>.__enter__()</code> 和 <code>.__exit__()</code> ：</p>

<p><code>.__enter__()</code> 方法是进入上下文语句后需要进行的操作，例如它可能会初始化一些上下文管理所需的对象。该方法可以返回一个合适的上下文管理对象，该对象会被 <code>as</code> 部分接收，并在上下文中被处理。</p>

<p>而 <code>.__exit__()</code> 方法是退出上下文时需要进行的操作，该方法的完整结构为：<code>.__exit__(self, exc_type, exc_val, exc_tb)</code> ，它需要四个参数，后三个参数分别是异常类型、异常信息和回溯栈。在该方法中，可以释放所需资源，或处理可能遇到的异常等。</p>

<p>以下示例是一个自定义的上下文管理器：</p>

<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> sys</span></div><br><div><span style="color: #bf568b;font-weight: bold;">class</span> <span style="color: #568bbf;">Log</span><span style="color: #405c79;">:</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf568b;font-weight: bold;">def</span> <span style="color: #8b56bf;">__init__</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">self</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">filename</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #bfbf56;">self</span><span style="color: #405c79;">.__file = </span><span style="color: #8b56bf;">open</span><span style="color: #405c79;">(filename, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">a</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">encoding</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">utf-8</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf568b;font-weight: bold;">def</span> <span style="color: #8b56bf;">__enter__</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">self</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #bfbf56;">self</span><span style="color: #405c79;">.__saved_stdout = sys.stdout</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; sys.stdout = </span><span style="color: #bfbf56;">self</span><span style="color: #405c79;">.__file</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #bf568b;font-weight: bold;">return</span> <span style="color: #bfbf56;">self</span><span style="color: #405c79;">.__file</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf568b;font-weight: bold;">def</span> <span style="color: #8b56bf;">__exit__</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">self</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">exc_type</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">exc_value</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">exc_tb</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #bfbf56;">self</span><span style="color: #405c79;">.__file.close()</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; sys.stdout = </span><span style="color: #bfbf56;">self</span><span style="color: #405c79;">.__saved_stdout</span></div></div>

<p>该示例可以比较好的说明上下文管理器的一些性质。一个调用该上下文管理器的示例为：</p>

<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> time </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> ctime</span></div><br><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">hello</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div><div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> Log(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">log.txt</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> log:</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'[</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">ctime()</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">] sqrt of 10 is: </span><span style="color: #bf8b56;">{10</span><span style="color: #405c79;"> ** </span><span style="color: #bf8b56;">0.5}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;">)</span></div><div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">world</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div></div>

<p>运行该程序，在观察到输出的同时，还会在本地生成一个日志文件：</p>

<div class="codeblock code-console">$ python -u with.py
hello
world
$ cat log.txt
[Wed Jul 13 10:59:34 2022] sqrt of 10 is: 3.1622776601683795
</div>

<p>首先在 <code>.__init__()</code> 方法中，通过初始化该类时传递的参数，打开了一个文件对象；在 <code>.__enter__()</code> 方法中，做了一些初始化工作：将系统的标准输出流重定向到初始化打开的文件对象，并返回该文件对象用于上下文操作；在 <code>.__exit__()</code> 方法中，保存该日志文件，并改回系统的标准输出流。</p>

<p>如果在执行 <code>with</code> 语句的语句体期间发生了异常，则会立即进入 <code>.__exit__()</code> 方法中，确保文件正常关闭且标准输出流被改回，同时其余的 3 个参数会给出异常提示。在其它情况下，这三个参数均为 <code>None</code> 。</p>

<h2>contextlib标准库：上下文管理工具</h2>

<p><code>contextlib</code> 是 Python3 标准库之一，它提供了一些上下文处理的工具，帮助编写合适的上下文管理器来处理 <code>with</code> 语句。</p>

<h3>装饰器形式的上下文管理器</h3>

<p><code>ContextDecorator</code> 基类用于将一个上下文管理器变成一个装饰器，通过继承该类，可以让一个上下文管理器装饰函数，使函数变成上下文。例如：</p>

<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> contextlib </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> ContextDecorator</span></div><br><div><span style="color: #bf568b;font-weight: bold;">class</span><span style="color: #405c79;"> </span><span style="color: #568bbf;">Log</span><span style="color: #405c79;">(</span><span style="color: #56bf8b;">ContextDecorator</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf8b56;">...</span></div><br><div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">Log</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">log.txt</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div><div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">func</span><span style="color: #405c79;">():</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf8b56;">...</span><span style="color: #405c79;"> &#160;</span><span style="color: #a8a8a8;"># some operations</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">... record ...</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div></div>

<p>该函数内的代码便会被作为上下文被执行。这种装饰器形式可以不显式使用 <code>with</code> ，不过它也没有 <code>as</code> ，不能利用得到的上下文管理对象。</p>

<hr>

<p>如果每次定义一个上下文管理器都需要创建一个新类，不免会有些麻烦。<code>contextlib</code> 提供了一种函数形式的更简单的自定义上下文管理器的方式：通过使用 <code>@contextmanager</code> 装饰器，可以将一个函数变成上下文管理器。被装饰的函数需要有类似如下的结构：</p>

<div class="codeblock code-template">
    @contextmanager<br>
    <strong>def</strong> func_name(...):<br>
    &nbsp; &nbsp; <em>cm</em> = ... &nbsp;<span class="codetoken comment"># get context object</span><br>
    &nbsp; &nbsp; <strong>try</strong>:<br>
    &nbsp; &nbsp; &nbsp; &nbsp; <strong>yield</strong> <em>cm</em><br>
    &nbsp; &nbsp; <strong>finally</strong>:<br>
    &nbsp; &nbsp; &nbsp; &nbsp; ... &nbsp;<span class="codetoken comment"># exit context</span>
</div>

<p>在这个函数（或者说生成器）形式的上下文管理器中，<code>yield</code> 生成的内容将会作为 <code>as</code> 的目标值，而 <code>finally</code> 对应的语句将会是退出上下文语句后执行的部分。</p>

<p>以下是一个上下文管理函数示例：</p>

<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> pymysql</span></div><div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> contextlib </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> contextmanager</span></div><br><div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">contextmanager</span></div><div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">open_database</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">db_name</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&#160; &#160; connection = pymysql.Connect(</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #bf8b56;">host</span><span style="color: #405c79;">=settings.db_host,</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #bf8b56;">user</span><span style="color: #405c79;">=settings.db_username,</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #bf8b56;">password</span><span style="color: #405c79;">=settings.db_password,</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #bf8b56;">database</span><span style="color: #405c79;">=db_name</span></div><div><span style="color: #405c79;">&#160; &#160; )</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf568b;font-weight: bold;">try</span><span style="color: #405c79;">:</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> connection.cursor()</span></div><div><span style="color: #405c79;">&#160; &#160; </span><span style="color: #bf568b;font-weight: bold;">finally</span><span style="color: #405c79;">:</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; connection.commit()</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; connection.close()</span></div></div>

<p>在这个上下文管理函数内，在进入上下文时连接到数据库中，并返回一个游标作为上下文对象；借助游标可以对数据库做一些做一些操作，例如：</p>

<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> open_database(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">demo</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> db:</span></div><div><span style="color: #405c79;">&#160; &#160; db.execute(</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">INSERT INTO user(username, password) VALUES (</span><span style="color: #bf8b56;">%s</span><span style="color: #56bf8b;">, </span><span style="color: #bf8b56;">%s</span><span style="color: #56bf8b;">)</span><span style="color: #405c79;">'</span><span style="color: #405c79;">,</span></div><div><span style="color: #405c79;">&#160; &#160; &#160; &#160; [</span><span style="color: #8b56bf;">input</span><span style="color: #405c79;">(), </span><span style="color: #8b56bf;">input</span><span style="color: #405c79;">()]</span></div><div><span style="color: #405c79;">&#160; &#160; )</span></div></div>

<p>在退出上下文时，将操作更新到数据库中，并断开连接。这种函数形式的上下文管理器显然更简洁，不用特地编写一个类。</p>

<h3>其它上下文管理器</h3>

<p><code>closing(<em>thing</em>)</code> 是一个简单的上下文管理器，它可以将任意对象变成一个上下文管理对象，并在结束上下文时调用其 <code>.close()</code> 方法。</p>

<p>许多对象都包含 <code>.close()</code> 方法，就可以通过该函数将其变成上下文管理对象，例如套接字：</p>

<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> socket</span></div><div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> contextlib </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> closing</span></div><br><div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> closing(socket.socket(socket.</span><span style="color: #bf8b56;">AF_INET</span><span style="color: #405c79;">, socket.</span><span style="color: #bf8b56;">SOCK_STREAM</span><span style="color: #405c79;">)) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> client:</span></div><div><span style="color: #405c79;">&#160; &#160; client.connect((</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">192.168.1.105</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">8000</span><span style="color: #405c79;">))</span></div><div><span style="color: #405c79;">&#160; &#160; client.send(message.encode())</span></div></div>

<p><code>supress(*<em>exceptions</em>)</code> 用于在一个上下文中忽略特定类型的错误，相当于将其放入一个 <code>try</code> 内并捕获特定错误。</p>

<p>例如，可以使用该上下文管理器在创建文件或目录时忽略文件已存在的问题，从而无需提判断文件是否存在：</p>

<div class="vscode-block"><div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> contextlib </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> suppress</span></div><div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> os </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> mkdir</span></div><br><div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> suppress(</span><span style="color: #bf568b;">FileExistsError</span><span style="color: #405c79;">):</span></div><div><span style="color: #405c79;">&#160; &#160; mkdir(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">imgs</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div></div>

<p>还有两个上下文管理器 <code>redirect_stdout(<em>io</em>)</code> 和 <code>redirect_stderr(<em>io</em>)</code> 可以重定向标准输出流和标准错误流，其原理和用法和以上编写的 <code>Log</code> 类似。</p>

<p>除此之外，还有一类特殊的异步上下文管理器，它们相比上文介绍的上下文管理器在命名时前面都带了个“ a ”（包括需要实现的特殊方法也是 <code>.__aenter__()</code> 和 <code>.__aexit__()</code> ）。由于异步上下文管理器主要应用于异步编程中，除此之外和普通的上下文管理器相差不大，因此这里不再介绍。</p>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://docs.python.org/3/library/contextlib.html">https://docs.python.org/3/library/contextlib.html</a><br>
    Python3 标准库官方文档—— <code>contextlib</code>
</p>

<p>
    <a href="https://docs.python.org/3/reference/datamodel.html#context-managers">https://docs.python.org/3/reference/datamodel.html#context-managers</a><br>
    Python3 复合语句 <code>with</code> ，里面还有两个链接指向相关话题
</p>

<p>
    <a href="https://peps.python.org/pep-0343/">https://peps.python.org/pep-0343/</a><br>
    PEP343 ——关于 <code>with</code> 语句的提案和背景
</p>
<p><a rel="nofollow" href="/archives/509">Python3 with语句和上下文管理器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/509/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python面向对象编程02-类与实例的属性</title>
		<link>/archives/448</link>
					<comments>/archives/448#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Tue, 05 Jul 2022 04:13:11 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=448</guid>

					<description><![CDATA[<p>实例的属性 在上一节中，已经详细解释了实例的属性。实&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/448">Python面向对象编程02-类与实例的属性</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>实例的属性</h2>

<p>在上一节中，已经详细解释了实例的属性。实例的属性可以使用 <code>instance.<em>attribute</em></code> 来访问并赋值。假设有一个类 <code>Stack</code> ，它的属性可以有栈长度、栈顶位置、栈段，那么该类的实现可以是：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Stack</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, length):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">length</span> <span style="color: #859900;">=</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">body</span> <span style="color: #859900;">=</span> [<span style="color: #d33682;">0</span>] <span style="color: #859900;">*</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">push</span>(self, value):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">&gt;=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">length</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">OverflowError</span>(<span style="color: #2aa198;">'Not enough space to push'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">body</span>[<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span>] <span style="color: #859900;">=</span> value</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">+=</span> <span style="color: #d33682;">1</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">pop</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">&lt;</span> <span style="color: #d33682;">0</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">OverflowError</span>(<span style="color: #2aa198;">'Stack is empty'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">elem</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">body</span>[<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span>]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">top</span> <span style="color: #859900;">-=</span> <span style="color: #d33682;">1</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">elem</span></div></div>

<p>这里为其编写了一个初始化方法用于构造栈所需的属性，以及两个普通方法用于入栈和出栈。这里属性还充当着在多个方法间传递数据的角色，这样不用使用参数和返回值，就可以在一个方法执行完后，将栈顶位置的变化实时作用在另一个方法上。</p>

<h2>受保护属性和私有属性</h2>

<p>属性不但可以用于表示一个类具有哪些特征，而且可以保存这些特征的变化。然而有些时候，并不希望属性直接被访问到，因为多个属性间往往具有一定的关联，对单个属性的修改可能会导致这个关联被破坏掉。</p>

<p>例如，以上实现的 <code>Stack</code> 类，栈元素和栈顶之间具有一定关联，一般只期望通过提供的 <code>.push()</code> 和 <code>.pop()</code> 方法一并修改它们，如果只修改栈顶位置的话，有些栈元素可能再也无法访问了。</p>

<p>针对上述问题，Python的一个默认约定是使用下划线 <code>_</code> 开头的名称来作为实例属性，来表示受保护属性。那么栈的初始化可以改成这样：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Stack</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, length):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">length</span> <span style="color: #859900;">=</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">body</span> <span style="color: #859900;">=</span> [<span style="color: #d33682;">0</span>] <span style="color: #859900;">*</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div></div>

<p>这样，属性 <code>self._top</code> 就是一个受保护属性。在一般情况下，不应该去访问它并且修改这个属性。</p>

<p>不过需要注意的是，受保护属性是 Python 编程时的一个约定，它并没有阻止访问 <code>._top</code> 这个属性，只是一般情况下，如果不是刻意，编程时很少会特地访问这些以下划线开头的属性，从而减少受保护属性被意外修改的可能性。</p>

<hr>

<p>实际上，Python 还可以创建实例的私有属性。相比受保护属性，私有属性进一步降低了属性被意外修改的误操作。</p>

<p>许多编程语言都提供了 <code>private</code>关键字。而在 Python 中，私有属性是以两个下划线 <code>__</code> 开头的实例属性，例如 <code>self.__length</code> 。这样一来，在实例化一个类后，便不再能够访问该属性。如果想要强行访问如 <code>stack.__length</code> ，会引起 <code class="error">AttributeError</code> ，错误内容大概是没有这个属性。</p>

<p>通过使用私有属性，可以很好地将一个属性隐藏起来。例如以上的 <code>Stack</code> 类，正常情况下栈段和栈的长度都是不应该通过直接访问的形式去修改的，那么就可以将这两个属性变成私有属性：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Stack</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, length):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__length</span> <span style="color: #859900;">=</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__body</span> <span style="color: #859900;">=</span> [<span style="color: #d33682;">0</span>] <span style="color: #859900;">*</span> length</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">push</span>(self, value):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span> <span style="color: #859900;">&gt;=</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__length</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">OverflowError</span>(<span style="color: #2aa198;">'Not enough space to push'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__body</span>[<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span>] <span style="color: #859900;">=</span> value</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_top</span> <span style="color: #859900;">+=</span> <span style="color: #d33682;">1</span></div></div>

<p>以上说的实例的私有属性无法访问，是针对类定义的外部，操作实例时而言的。如果在类的定义内，知道自己在做什么，当然可以继续使用 <code>self.__length</code> 。</p>

<p>因此，一个常见的做法是为类编写一个方法，提供查看私有属性的接口，例如：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Stack</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">get_length</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__length</span></div></div>

<p>这样，使用该类时只能利用提供的确定、合理的的接口获取类的属性，或者对类进行一些操作。在本文的最后，还会介绍一个 Python 给出的更高级、更优雅的解决方式。</p>

<hr>

<p>实际上，私有属性和受保护属性一样，也没有真正阻止通过实例来修改它的属性。如果使用内置的 <code>dir()</code> 函数来查看一个实例支持的一些属性和方法，结果为：</p>

<div class="codeblock code-console">&gt;&gt;&gt; stack = Stack(10)
&gt;&gt;&gt; dir(stack)
['_Stack__body', '_Stack__length', '__class__', ..., '__weakref__', '_top', 'get_length', 'pop', 'push']
</div>

<p>在结果返回的列表中，没有找到什么名为 <code>.__length</code> 之类的属性。但是注意，实例却有两个属性 <code>._Stack__body</code> 和 <code>._Stack__length</code> 。试着访问一下它们：</p>

<div class="codeblock code-console">&gt;&gt;&gt; stack._Stack__body
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</div>

<p>原来，实例的私有属性并不是真正的私有，只不过将一个实例的属性命名以双下划线开头，在结束类的定义后，Python就会将该属性的名称前面再加上 <code>_<em>ClassName</em></code> ，即一个下划线和对应类的名称。如此一来，要访问实例的属性难度变得更大了，也更不易出错了。</p>

<p>尽管这样做已经可以避免在实际编程中意外修改实例的私有属性，并允许刻意去修改这些私有属性。不过仍然有一些细节需要注意：首先，尽量不要将实例的其它属性命名为私有属性加上保护前缀后的属性。尽管在类定义中不会有什么影响，但这可能造成实例化一个对象后的命名冲突。其次，以两个下划线开头结尾的双下属性并不受该规则影响，但是<a href="/archives/442" class="internal">上一节</a>也说过了，它们可能是一个实例的特殊属性，对它们的任意赋值及修改可能会打乱类的运行，造成意想不到的问题。</p>

<h2>类属性和实例属性</h2>

<p>实例属性是每一个实例所独自拥有的、不同实例间通过实例属性的区别而可能产生一定的差异。在上文中，已经见过了许多实例属性，对于每一个 <code>Stack</code> 实例，它们的大小、栈顶位置、包含的元素都不尽相同，因此需要通过属性予以区分。如果该类还没有一个实例，那么这些属性只是一个笼统的概念，无法进行具体的讨论，也就无法仅通过类来访问实例属性并获取值。</p>

<p>与实例属性相对的概念是类属性。在类中，方法之外创建的变量称为<strong>类属性</strong>。例如，以下为 <code>Point</code> 类创建了一个类属性：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">3</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, x, y, z):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">z</span> <span style="color: #859900;">=</span> x, y, z</div></div>

<p>类属性的特点是，所有类的实例化对象都同时共享类属性。也就是说，类变量在所有实例化对象中是共有的。这也很好理解，对于定义的类 <code>Point</code> 来说，它是三维的点，因此它所有的实例 <code>.dimensions</code> 都是 <code>3</code> ，这是无法更改的事实，因此所有该类的实例都必须具有这一个确定的属性。</p>

<p>类属性与实例属性的一个区别是类属性可以由类直接访问。当创建了一个实例对象时，通过实例对象也可以访问类的属性，例如：</p>

<div class="codeblock code-console">&gt;&gt;&gt; Point.dimensions
3
&gt;&gt;&gt; p01 = Point(3, 4, 5)
&gt;&gt;&gt; p01.dimensions
3</div>

<p>类属性是一个确定的定义，只要实例是属于该类的，那么它们都必须和类一样具有这个共同的属性。</p>

<p>事实上，在实例内部定义的方法，同样属于这个类的类属性。因此可以使用匿名函数与赋值的方式来定义一个方法，也是完全可以的：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">3</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">get_coordinates</span> <span style="color: #859900;">=</span> <span style="color: #586e75;font-weight: bold;">lambda</span> self: (<span style="color: #268bd2;">self</span>.x, <span style="color: #268bd2;">self</span>.y, <span style="color: #268bd2;">self</span>.z)</div></div>

<p>在类内部定义一个方法，可以理解为定义一个函数后，将其作为类属性放在类内部。</p>

<p>通过类和实例都可以访问类属性，类属性也可以通过赋值语句进行修改。但是如果是通过类修改的类属性，会影响到所有实例来访问这个类属性。而通过实例修改这个类属性，则不会影响到类和实例中访问的类属性。例如：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">p02</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>(<span style="color: #d33682;">3</span>, <span style="color: #d33682;">7</span>, <span style="color: #d33682;">9</span>)</div><div><span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #2aa198;">'three'</span> &nbsp;<span style="color: #a8a8a8;"># 通过实例修改类属性</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>, <span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>, <span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>)</div><div><span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">4</span> &nbsp; &nbsp; &nbsp;<span style="color: #a8a8a8;"># 通过类修改类属性</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>, <span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>, <span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>)</div></div>

<p>结果为：</p>

<div class="codeblock code-console">python -u demo.py
three 3 3
three 4 4
</div>

<p>注意到当通过类修改类属性后，第一个实例的属性并没有被修改，但是第二个实例的属性却被修改了。</p>

<p>关于这一点，可以通过内置的 <code>id()</code> 函数来查看对应的类属性的身份变化：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>))</div><div><span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #2aa198;">'three'</span> &nbsp;<span style="color: #a8a8a8;"># 通过实例修改类属性</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>))</div><div><span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">4</span> &nbsp; &nbsp; &nbsp;<span style="color: #a8a8a8;"># 通过类修改类属性</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p01</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #268bd2;">p02</span>.<span style="color: #268bd2;">dimensions</span>), <span style="color: #268bd2;">id</span>(<span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">dimensions</span>))</div></div>

<p>结果为：</p>

<div class="codeblock code-console">python -u demo.py
15757472 15757472 15757472
26266752 15757472 15757472
26266752 15757488 15757488</div>

<p>观察结果不难发现，当实例化一个类后，通过实例访问的属性仅仅是对类属性的一个引用，因此通过类修改类属性会引起实例访问类属性的变化。而通过实例修改类属性后，实际上是创建了一个新的实例属性，因此通过类修改类属性，当然不会影响这个实例属性。</p>

<p>要解释以上原因的底层原理还为时过早。在后续介绍描述符这一概念时，才会明白属性查找的原理。</p>

<h2>使用类的property</h2>

<h3>为什么需要用property</h3>

<p>在前面章节中，一直使用 <code>instance.<em>attribute</em></code> 的方式来访问实例的属性，但是有些情况下希望属性应该是隐藏的，只允许通过提供的接口方法来间接实现对实例属性的访问和修改。</p>

<p>例如，以下实现了一个类 <code>Color</code> ，用来表示计算机存储的颜色数据：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, red, green, blue):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span> <span style="color: #859900;">=</span> red, green, blue</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_hsv_update</span>()</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">_hsv_update</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">_max</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">max</span>(<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">_min</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">min</span>(<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__v</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">max</span>(<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__s</span> <span style="color: #859900;">=</span> (<span style="color: #268bd2;">_max</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">_min</span>) <span style="color: #859900;">/</span> <span style="color: #268bd2;">_max</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span> <span style="color: #859900;">==</span> <span style="color: #268bd2;">_max</span>: </div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__h</span> <span style="color: #859900;">=</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span>) <span style="color: #859900;">/</span> (<span style="color: #268bd2;">_max</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">_min</span>) <span style="color: #859900;">*</span> <span style="color: #d33682;">60</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span> <span style="color: #859900;">==</span> <span style="color: #268bd2;">_max</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__h</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">120</span> <span style="color: #859900;">+</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span>) <span style="color: #859900;">/</span> (<span style="color: #268bd2;">_max</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">_min</span>) <span style="color: #859900;">*</span> <span style="color: #d33682;">60</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__b</span> <span style="color: #859900;">==</span> <span style="color: #268bd2;">_max</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__h</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">240</span> <span style="color: #859900;">+</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span>) <span style="color: #859900;">/</span> (<span style="color: #268bd2;">_max</span> <span style="color: #859900;">-</span> <span style="color: #268bd2;">_min</span>) <span style="color: #859900;">*</span> <span style="color: #d33682;">60</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__h</span> <span style="color: #859900;">&lt;</span> <span style="color: #d33682;">0</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; H <span style="color: #859900;">+=</span> <span style="color: #d33682;">360</span></div></div>

<p>由于计算机存储的色彩空间未必是 RGB ，这里也提供了 HSV 色彩空间的支持，并且每次在更新了 RGB 色值后，会将这个更新实时反应到 HSV 上。因此这里将 RGB 属性都设置为私有属性，为了就是防止 RGB 色值被意外修改而造成两种色彩空间不同步。</p>

<p>如果确实需要对颜色做一些调整，或者获取当前的 RGB 色值，可以编写一些 <code>.get()</code> 和 <code>.set()</code> 等接口方法，在设置颜色时确保可以将其同步到 HSV 色彩空间中：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">get_red</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">set_red</span>(self, red):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #859900;">not</span> <span style="color: #d33682;">0</span> <span style="color: #859900;">&lt;=</span> red <span style="color: #859900;">&lt;=</span> <span style="color: #d33682;">255</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">ValueError</span>(<span style="color: #2aa198;">'red must be between 0 and 255'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span> <span style="color: #859900;">=</span> red</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_hsv_update</span>()</div></div>

<p>对于其它两种基本颜色属性，也可以编写类似函数。</p>

<p>以上是比较传统的想法，通过将实例属性设置成私有属性，然后提供 <code>.get()</code> 和 <code>.set()</code> 等接口方法来获取或设置属性，并在设置属性时进行一些合适的检查。但实际上，Python 提供了一些内置的工具，可以更为方便地操作实例的属性。</p>

<h3>property类</h3>

<p>Python 中，一个 <code>property</code> 类可以将众多 <code>.get()</code> 和 <code>.set()</code> 等接口方法封装成一个属性，这样通过对该属性访问和赋值等操作，实际上就是在调用这些接口方法。<code>property</code> 类的完整初始化函数形式为：</p>

<div class="codeblock code-template">
    property(<em>fget</em>=None, <em>fset</em>=None, <em>fdel</em>=None, <em>doc</em>=None)
</div>

<p>通过实例化该类，可以为该类添加一个特殊的 <code>property</code> 实例属性。在它的参数中：</p>

<ul>
    <li><code>fget</code> 是获取属性值时调用的接口方法</li>
    <li><code>fset</code> 是设置属性值时调用的接口方法</li>
    <li><code>fdel</code> 是删除属性时调用的接口方法</li>
    <li><code>doc</code> 则用来创建属性的 docstring</li> 
</ul>

<p>例如，如果采用 <code>property</code> 属性对 <code>color</code> 类做以下封装：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">del_red</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__r</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_hsv_update</span>()</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">red</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">property</span>(<span style="color: #268bd2;">get_red</span>, <span style="color: #268bd2;">set_red</span>, <span style="color: #268bd2;">del_red</span>, <span style="color: #2aa198;">"Red component of color"</span>)</div></div>

<p>如果 <code>background</code> 是一个 <code>Color</code> 类的实例，那么访问 <code>background.<em>red</em></code> 会调用它的 <code>.get_red()</code> 方法；<code>background.<em>red</em> = <em>value</em></code> 会调用它的 <code>.set_red()</code> 方法，并将 <code>value</code> 作为第二个参数；而 <code>del background.<em>red</em></code> 会调用它的 <code>.del_red()</code> 方法。</p>

<p>如果 <code>doc</code> 不为 <code>None</code> ，那么可以在类内通过 <code>red.__doc__</code> 来访问它的 docstring（注意，不能通过 <code>background.red.__doc__</code> 的方式访问它的 docstring ，因为前半部分会先运算而得到红色数值）。否则，<code>property</code> 会将 <code>fget</code> 函数的 docstring 拷贝为 <code>background</code> 的 docstring 。</p>

<p>需要特别注意的是，在 <code>.get_red()</code> 方法中，一定要使用私有属性，而不能直接使用 <code>property</code> 封装的实例属性；否则，当在 <code>.get_red()</code> 内访问 <code>self.red</code> 的话，又会调用该方法，造成无限递归引起程序终止。</p>

<h3>@property装饰器</h3>

<p>如果程序中不希望支持修改或删除这些属性，那么可以在初始化方法中将对应的接口方法设置为 <code>None</code> 。除了使用 <code>property</code> 类，还有一种更清晰的方法是使用 <code>@property</code> 装饰器，它用来装饰一个类的方法，将该方法名变成同名的属性。如果对装饰器这一概念比较陌生，可以阅读<a class="internal" href="/archives/276">这篇文章</a>。</p>

<p>下面以 <code>Color</code> 类的绿色属性为例介绍该装饰器的使用方法。<code>@property</code> 装饰器可以将类方法变成同名属性的 <code>.get()</code> 接口。这样一来，便可以通过 <code>instance.<em>attribute</em></code> 的方式来访问它了：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">property</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">green</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #2aa198;">"""Green component of color"""</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span></div></div>

<p>访问 <code>@property</code> 包装后的 <code>.<em>attribute</em></code> 属性，相当于访问属性的 <code>.get()</code> 方法。除此之外，<code>.property</code> 属性还支持 <code>.set()</code> 和 <code>.delete()</code> 方法，它们需要使用 <code>@<em>attribute</em>.setter</code> 装饰器和 <code>@<em>attribute</em>.deleter</code> 装饰器。例如：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Color</span>:</div><div>&nbsp; &nbsp; <span style="color: #a8a8a8;"># ...</span></div><div>&nbsp; &nbsp; <span style="color: #268bd2;">@</span><span style="color: #268bd2;">green</span><span style="color: #268bd2;">.setter</span></div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">green</span>(self, green):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #859900;">not</span> <span style="color: #d33682;">0</span> <span style="color: #859900;">&lt;=</span> green <span style="color: #859900;">&lt;=</span> <span style="color: #d33682;">255</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">raise</span> <span style="color: #cb4b16;">ValueError</span>(<span style="color: #2aa198;">'green must be between 0 and 255'</span>)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">__g</span> <span style="color: #859900;">=</span> green</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">_hsv_update</span>()</div></div>

<p>当为属性 <code>background.green</code> 赋值时，会调用它的 <code>@green.setter</code> 装饰器装饰的方法。类似地可以编写一个 <code>@green.deleter</code> 装饰器装饰的方法，以被 <code>del</code> 语句删除属性时调用。注意：这些方法名必须和 <code>@property</code> 包装的属性名相同，代表为属性设置新的操作接口。</p>

<p>试着编写一些代码：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">background</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Color</span>(<span style="color: #d33682;">128</span>, <span style="color: #d33682;">64</span>, <span style="color: #d33682;">192</span>)</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">red</span>)</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">hue</span>)</div><div><span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">green</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">255</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">hue</span>)</div><div><span style="color: #859900;font-weight: bold;">del</span> <span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">blue</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">background</span>.<span style="color: #268bd2;">hue</span>)</div></div>

<p>结果为：</p>

<div class="codeblock code-console">$ python -u demo.py
128
270.0
150.23622047244095
89.88235294117646</div>

<p>可以看到对 RGB 色值的更新实时反应在 HSV 上。</p>

<p>本节介绍了类与实例属性的概念，并提出了私有属性的概念，私有属性配合接口方法，可以避免实例的完整性被破坏，使对属性的操作更规范。这也符合面向对象编程中常用的<strong>封装</strong>思路，即隐藏对象的属性和实现细节，仅对外公开接口，以控制在程序中属性的访问和修改。</p>

<p>通过 <code>property</code> 可以简化接口的操作方式，使代码更优雅。如果仅看 <code>property</code> 的使用方式，可能会觉得比较费解，比如这样定义的明明像一个类属性，为什么得到的却是一个实例属性？要解释以上原因的底层原理还为时过早，同样在后续介绍描述符时，才会介绍其根本原因，到时候将会对类与实例的属性有更深刻的认知。</p>

<h2>参考资料/延伸阅读</h2>

<p><a href="https://docs.python.org/3/library/functions.html#property">https://docs.python.org/3/library/functions.html#property</a></p>

<p>Python3 官方文档对 <code>property</code> 的介绍。</p>

<p>本文使用的 RGB to HSV 转换算法来自百度百科 <a href="https://baike.baidu.com/item/HSV/547122">https://baike.baidu.com/item/HSV/547122</a></p>
<p><a rel="nofollow" href="/archives/448">Python面向对象编程02-类与实例的属性</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/448/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python面向对象编程01-类的定义与使用</title>
		<link>/archives/442</link>
					<comments>/archives/442#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sun, 03 Jul 2022 12:45:12 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=442</guid>

					<description><![CDATA[<p>类和对象的基本概念 什么是类 在编程时，往往需要通过&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/442">Python面向对象编程01-类的定义与使用</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>类和对象的基本概念</h2>

<h3>什么是类</h3>

<p>在编程时，往往需要通过程序修改变量。但有时候多个变量间可能有很强的关联，是一个整体。此时，可以使用结构体描述这一个整体。然而，结构体只能包含数据成员，却不包含对这些数据操作所需要的函数。</p>

<p>如果把需要描述并操作的某些变量和函数看成一个整体，这个整体就称为<strong>类</strong>(type)。类定义了该集合中每个对象所共有的属性和支持的操作。例如，对于每一种数据结构如链表、栈、二叉树等，每个集合可能都具有一些相同的属性例如后向指针、栈顶位置、树结点值，但还有一些操作如增(add)、删(remove)、改(update)、查(find)，不同的数据结构执行的操作也不一样。这种将一系列属性与方法作为一个整体封装成一个类的编程思路，称为 <strong>面向对象编程</strong> (object-oriented programming)。面向对象编程是一种编程思路而不是具体的编程语言，使用 C 语言照样可以编写具有面向对象编程思想的代码，只是实现起来比较麻烦。</p>

<p>Python 是一种原生支持 面向对象编程 的编程语言，可以轻松实现面向对象编程的大多数要求。Python 提供了许多内置的类，例如列表就是其中之一。<code>list</code> 类的属性有各个元素（暂且可以这么认为），方法有修改，排序数据等。除此之外还可以实现自己的类，例如向量类，这个类的属性有方向和大小，它的方法有获取模长、标量放缩等。</p>

<p>在 Python 中，实现一个最简单的类是这样的：</p>

<div class="codeblock code-template">
    <strong>class</strong> SomeType:<br>
    &nbsp; &nbsp; ...
</div>

<p>类的定义以关键字 <code>class</code> 开头，之后跟着一个类名，并且以冒号和缩进确定类的主体。</p>

<p>类名是一个标识符，必须符合 Python 标识符的命名规则。一般建议类的命名应该遵循大驼峰式标记，即类的任意一个英文单词都应该以大写字母开头。</p>

<p>紧跟类的定义后是类的内容，并且需要缩进。由于第一个类目前并没有实际完成一些事情，因此使用了 <code>pass</code> 关键字表示类的主体暂时忽略。</p>

<p>可以使用内置函数 <code>type()</code> 来查看刚刚定义的类的类型：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">SomeType</span>:</div><div>&nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">pass</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">SomeType</span>, <span style="color: #cb4b16;">type</span>(<span style="color: #cb4b16;">SomeType</span>))</div></div>

<p>结果为：</p>

<div class="codeblock code-console">$ python -u demo.py
    &lt;class '__main__.SomeType'&gt; &lt;class 'type'&gt; 
</div>

<p>结果表明，<code>SomeType</code> 的类型是“类”</p>

<h3>什么是实例</h3>

<p>有了类以后，还需要一个具体的<strong>实例</strong>(instance)来完成具体的行为。对于内置的 <code>list</code> 类，需要有一个存储了具体数据的列表来完成对列表的操作。同样，对于上述的自定义类向量，也需要一个具体的向量实例来完成取模、计算等操作。</p>

<p>对于以上定义的类，获得一个类的实例的方法如下：</p>

<div class="vscode-block"><div>SomeType()</div></div>

<p>通过输入类名并紧跟一对小括号，便可以获得一个类的对象。这种由类创建出的具体对象称为实例(instance)。类是抽象的概念，而实例是具体的概念。</p>

<p>例如，假设有一个类 Fruit(水果)，显然它有一些属性例如 taste(味道)、color(颜色) 等，但只有获得了一个实例 apple(苹果) 后，这些属性才能具体描述。</p>

<p>回到上述语句，获得一个实例有点像调用一个函数，当然这实际上是根据类名生成了一个类的实例。并且由于这个类缺乏具体描述，因此小括号中暂时不需要传入参数。</p>

<p>可以将实例赋值给一个变量，并且每次使用括号，都会为该类生成一个新的实例。例如，以下代码生成了两个类，并使用 <code>type()</code> 函数查看它们的类型：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">one_instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">SomeType</span>()</div><div><span style="color: #268bd2;">another_instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">SomeType</span>()</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">one_instance</span>, <span style="color: #cb4b16;">type</span>(<span style="color: #268bd2;">another_instance</span>))</div></div>

<p>结果为：</p>

<div class="codeblock code-console">$ python -u demo.py
    &lt;__main__.SomeType object at 0x0000020644132FD0&gt; &lt;class '__main__.SomeType'&gt;
</div>

<p>观察上述结果，打印实例变量时，它输出了一个地址，这表明每一个实例之间都是独一无二的。另外，结果显示实例 <code>another_instance</code> 的类型是“当前文件的 <code>SomeType</code> 类”。</p>

<h3>什么是属性</h3>

<p>以上创建的类和实例看起来没有任何作用，它不包含任何数据，也不做任何事情。对于一个已经创建的类，最首要的就是明确类的<strong>属性</strong>(attribute)。</p>

<p>前文说过，属性用来描述一个类有哪些特性。对于一个类，它的每个实例属性具体的值可能不太一样，但是它们都存在这个属性。</p>

<p>假设将平面上的一个点看出一个类，那么可以这样定义它：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">pass</span></div><div><span style="color: #268bd2;">one_point</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>()</div></div>

<p>这个类 <code>Point</code> 需要描述它的坐标，可以通过点记法给一个实例赋予任意的属性。例如，可以这样描述它的属性：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">one_point</span>.x <span style="color: #859900;">=</span> <span style="color: #d33682;">5</span></div><div><span style="color: #268bd2;">one_point</span>.y <span style="color: #859900;">=</span> <span style="color: #d33682;">6</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">one_point</span>.x, <span style="color: #268bd2;">one_point</span>.y)</div></div>

<p>以上描述为实例添加属性的语法为：</p>

<div class="codeblock code-template">
    instance.<em>attribute</em> = <em>value</em>
</div>

<p>这种语法称为点记法，它的赋值过程和变量的赋值是一样的，值可以是任意的，甚至是一个函数或者另一个类。</p>

<p>通过在实例后面加上一个点，就可以表示它的属性，这种方式就和结构体访问字段是一样的。运行以上代码，即可打印属性值：</p>

<div class="codeblock code-console">$ python -u demo.py
    5 6
</div>

<p>这几行代码表明，<code>one_point</code> 实例被添加了两个属性，一个是代表横坐标的 <code>x</code> ，一个是代表纵坐标的 <code>y</code> 。并且它们的属性都被赋予了一个具体的整数值。</p>

<h3>什么是方法</h3>

<p>之前说过，类是属性和操作的集合。获得一个带属性的类以后，这个类还需要完成一些事情，来改变这些属性。改变属性的行为称为<strong>方法</strong>(method)。</p>

<p>例如，对于内置类 <code>list</code> ，它有一些方法，比如增加数据(<code>append</code> 、<code>insert</code> 、<code>extend</code> )、移除数据(<code>remove</code>)等，每个具体的方法实现的效果都不一样。对于自定义的向量类，可以使用方法对它做一些放缩、运算、取模等操作。对于抽象一些的类 Fruit(水果) 来说，它也可以定义一些方法，例如 cut(把一个具体的水果切成小块) 、flavor(给水果加上调料改变味道) 等。</p>

<p>从之前实现的 <code>Point</code> 类开始，可以给它添加一个叫做 <code>move_to_origin</code> 的方法，该方法用来将这个点移动到原点。包含该方法后，完整的类的定义为：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">move_to_origin</span>(self):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div></div>

<p>Python 中类的方法和定义一个函数类似，都以关键字 <code>def</code> 开头，然后是一个函数/方法名和一对小括号，括号内包含一些参数，以冒号引出函数/方法的主体。一般推荐方法名遵循蛇形命名规则，即名称中的单词字母全部小写并以下划线连接。</p>

<p>注意方法和函数有一点不一样，所有针对实例的方法都必须包含一个参数，这个参数通常被称为 <code>self</code> ，它必须是第一个位置参数，不过它的名称不一定要是 <code>self</code> ，也可以改成 <code>this</code> 或者 <code>Hello</code> 。一般情况下，定义方法的语法为：</p>

<div class="codeblock code-template">
    <strong>def</strong> method(self, ...):<br>
    &nbsp; &nbsp; ...
</div>

<p>一个方法中的 <code>self</code> 参数，是对调用这个方法对象的一个引用。</p>

<p>不过无需手动传入这个 <code>self</code> 参数，调用一个实例方法的方式是实例名后面跟上一个点，再跟上一个方法名，后面像调用函数一样加上一个括号，即：</p>

<div class="codeblock code-template">
    instance.<em>method</em>(...)
</div>

<p>Python 会自动将一个具体的实例作为第一个参数传给 <code>self</code> 。此时，<code>self.x</code> 实际上就是 <code>instance.x</code> ，替换为实际参数后可以看出形式参数 <code>self</code> 用来代表某个具体的实例，而执行方法时将某个具体的实例对象传给这个形式参数。</p>

<p>例如，以下尝试调用该方法：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">another_point</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>()</div><div><span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">x</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">10</span></div><div><span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">20</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">y</span>)</div><div><span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">move_to_origin</span>()</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">another_point</span>.<span style="color: #268bd2;">y</span>)</div></div>

<p>结果为：</p>

<div class="codeblock code-console">$ python -u demo.py
10 20 
0 0</div>

<p>可以看出执行了 <code>.move_to_origin()</code> 方法后，该点确实被移到了原点。如果在定义方法时忘记了 <code>self</code> 参数，那么通过实例调用方法时，会产生 <code class="error">TypeError</code> ，错误信息是某方法需要 0 个参数，却传入了 1 个，这就是因为调用方法时需要参数 <code>self</code> 来代表一个具体的实例，才能通过参数去获取、更改它的属性。</p>

<p>实际上也可以在类中调用这个函数，并且将类的一个实例作为实际参数传给方法：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">p</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>()</div><div><span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">move_to_origin</span>(<span style="color: #268bd2;">p</span>)</div><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">p</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">p</span>.<span style="color: #268bd2;">y</span>)</div></div>

<p>两者是完全一样的。许多面向对象编程的语言都使用关键字 <code>this</code> 表示对实例的一个引用，而 Python 使用这种参数的形式来获取实例，加强了类与实例间的联系。</p>

<p>以下定义了一个更复杂的方法 <code>scale</code> ，用来在坐标轴上按相对位置缩放一个点：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">scale</span>(self, scalar: <span style="color: #cb4b16;">float</span>, relative: <span style="color: #cb4b16;">Point</span><span style="color: #859900;">=</span><span style="color: #b58900;">None</span>):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #859900;font-weight: bold;">if</span> relative <span style="color: #859900;">is</span> <span style="color: #b58900;">None</span>:</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relative <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>()</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relative.<span style="color: #268bd2;">x</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relative.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span> <span style="color: #859900;">=</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span> <span style="color: #859900;">-</span> relative.<span style="color: #268bd2;">x</span>) <span style="color: #859900;">*</span> scalar</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> (<span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">-</span> relative.<span style="color: #268bd2;">y</span>) <span style="color: #859900;">*</span> scalar</div></div>

<p>通过这个方法，可以看出方法和函数一样，都可以有多个参数，都可以有返回值，甚至可以拥有类型标注。通过实例调用一个方法就类似于直接执行一个函数，只不过第一个位置参数是自动传入的。</p>

<h2>类的初始化</h2>

<p>在上一节中，定义了一个类 <code>Point</code> ，并使用 <code>.x</code> 和 <code>.y</code> 属性来描述它的坐标，<code>.move_to_origin()</code> 和 <code>.scale()</code> 方法来多点执行一些操作。然而，在每次实例化一个类后，都需要给它的 <code>.x</code> 和 <code>.y</code> 属性赋一个具体值，否则会访问不到它们的属性，产生 <code class="error">AttributeError</code> 。</p>

<p>最好能在实例化类时，就能给实例的属性赋予一个具体值，这样即使后续忘记赋值，也不影响程序的执行。然而，为了给实例添加上属性，只能通过 <code>self.</code> 的格式从形式参数中获取类的实例，然而只有在有实例时，该方法才能调用，也就是说还是只能在生成实例后手动为每一个实例添加属性。</p>

<p>事实上，类有一个特殊的方法 <mark><code>.__init__()</code></mark> ，它是一个初始化方法，用来初始化类的属性。类还有很多类似的<strong>特殊方法</strong>(special method, or magic method)，它们都以双下划线开头，双下划线结尾，有时也被称为双下方法(dunder method)。所有的特殊方法在以后会逐一介绍。</p>

<p>在创建自己的方法时，尽量不要以双下划线开头结尾，否则一旦创建了一些特殊的方法，可能会在不必要的时刻被调用，从而招致莫名其妙的错误。</p>

<blockquote>
    <p><code>.__init__()</code> 方法类似别的面向对象编程语言的构造方法，不过 Python 的构造方法另有它用，<code>.__init__()</code> 的实际效果等效于构造方法。</p>
</blockquote>

<p>一旦类拥有了这样一个初始化方法，在实例化该类时，使用类名加上一对圆括号，实际上就是在调用这个方法。假设下面有一个类 <code>Vector</code> ：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Vector</span>:</div><div>&nbsp; &nbsp; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, direction, magnitude):</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">direction</span> <span style="color: #859900;">=</span> direction</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">magnitude</span> <span style="color: #859900;">=</span> magnitude</div></div>

<p>在初始化时，调用 <code>Vector()</code> 实际上就是在调用它的初始化方法。由于 <code>.__init__()</code> 方法有两个参数，因此实例化时，也需要传入两个参数：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">v</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Vector</span>(direction<span style="color: #859900;">=</span><span style="color: #d33682;">90</span>, magnitude<span style="color: #859900;">=</span><span style="color: #d33682;">6</span>)</div></div>

<p>这样，在初始化时，就向实例传入了两个参数，这样确保了只要成功生成了一个实例，它就自动执行一些代码，生成了一些属性，无需后续再手动添加属性，减少了代码量和出错率。</p>

<p>试着调用一下实例的属性：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">v</span>.<span style="color: #268bd2;">direction</span>, <span style="color: #268bd2;">v</span>.<span style="color: #268bd2;">magnitude</span>)</div></div>

<div class="codeblock code-console">$ python -u demo.py
90 6</div>

<p>可以看出在初始化时，它成功地创建了一些属性。</p>

<p>当然，初始化方法也不一定要添加参数，它也可以仅包含 <code>self</code> 参数，但这样就不能在创建时通过传参为每个实例添加不同的属性了。仅包含 <code>self</code> 参数的 <code>.__init__()</code> 构造方法，又称为类的默认构造方法。在有些时候只需要确定的实例属性，当然可以这么做。</p>

<p>本节介绍了面向对象编程的基础和使用 Python 编写面向对象程序的基本语法。面向对象编程是一种非常实用，也应用非常广泛的编程思想，许多编程语言都提供了面向对象编程的语法支持。本节对面向对象编程的思想介绍并不深刻，有兴趣的读者可以自行去 stackoverflow 、知乎等网站搜索，许多人都对其有自己独到的理解。</p>

<h2>参考资料/延伸阅读</h2>

<p><a href="https://docs.python.org/3/tutorial/classes.html">https://docs.python.org/3/tutorial/classes.html</a></p>

<p>Python3 官方文档对 Python 面向对象编程的简介，目前仍是 Python 面向对象编程入门的最好教程。</p>
<p><a rel="nofollow" href="/archives/442">Python面向对象编程01-类的定义与使用</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/442/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程10 functools模块：高阶函数工具</title>
		<link>/archives/296</link>
					<comments>/archives/296#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Tue, 07 Jun 2022 05:53:18 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Python标准库]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=296</guid>

					<description><![CDATA[<p>functools 库包含许多实用的函数操作工具，并&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/296">Python函数式编程10 functools模块：高阶函数工具</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p><code>functools</code> 库包含许多实用的函数操作工具，并且它们都是高阶函数。</p>
<h2>常用函数</h2>
<h3>lru_cache：缓存结果</h3>
<p><code>@lru_cache(maxsize)</code> 装饰器能保存已有计算结果，从而加快函数运行，其中 LRU 指最近使用的(least recent used) 。该装饰器会将最近得到的计算结果保留在缓存中，并在必要时清除不常用的计算结果。</p>
<p>例如，以下是使用缓存改进后的递归形式的斐波那契数列函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">lru_cache</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">maxsize</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">1024</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">fibonacci_cached</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> n &lt; </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> n</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> fibonacci_cached(n - </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">) + fibonacci_cached(n - </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">)</span></div>
</div>
<p>接下来在 IPython 环境中对有无缓存的情况测试执行效率，结果为：</p>
<div class="codeblock code-console"><span class="codetoken ipython-in">In [1]:</span> def fibonacci_without_cache():<br />
...:     return fibonacci(34)<br />
...: def fibonacci_with_cache():<br />
...:     fibonacci_cached.cache_clear()<br />
...:     return fibonacci_cached(34)<br />
<span class="codetoken ipython-in">In [2]:</span> %timeit fibonacci_without_cache<br />
2.12 s ± 7.21 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)<br />
<span class="codetoken ipython-in">In [3]:</span> %timeit fibonacci_with_cache<br />
12.6 µs ± 67.8 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</div>
<p>注意，不能直接使用 <code>%timeit</code> 命令测试函数，因为它会多次执行取平均时间，而第一次执行后由于缓存的存在使后续结果直接从缓存中获取，干扰测试效果。因此，每次测试后都通过装饰器的 <code>.cache_clear()</code> 方法清空缓存。</p>
<p>从测试结果中可以看出，缓存的存在极大提升了递归函数的执行效率。</p>
<h3>partial：冻结参数</h3>
<p><code>partial(<em>func</em>, /, *<em>args</em>, **<em>kwargs</em>)</code> 可以将函数的部分参数固定，得到一个新的函数。</p>
<p>例如，如果想要设置打开一个文件时，永远是以 UTF-8 编码的形式打开，那么可以使用 <code>partial</code> 将 <code>open()</code> 函数的 <code><em>encoding</em></code> 参数固定，形成一个新的函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">uopen = partial(</span><span style="color: #8b56bf;">open</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">encoding</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">utf8</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
</div>
<p>这样每次确保都是以 UTF-8 编码对文件操作的：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> uopen(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">demo.txt</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">w</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> f:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; f.write(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f641.png" alt="🙁" class="wp-smiley" style="height: 1em; max-height: 1em;" />✯<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/26c8.png" alt="⛈" class="wp-smiley" style="height: 1em; max-height: 1em;" />⚝<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2602.png" alt="☂" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2601.png" alt="☁" class="wp-smiley" style="height: 1em; max-height: 1em;" />︎<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/1f636.png" alt="😶" class="wp-smiley" style="height: 1em; max-height: 1em;" /></span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
</div>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/10-unicode-txt.jpg" alt="" width="150"></figure>
<p><code>partial()</code> 非常适用于冻结高阶函数的函数参数，这种情况下，可以提前写好一个函数，从而让一个比较泛化的高阶函数具有更具体的功能，例如：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> operator </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> add, mul</span></div>
<div><span style="color: #8b56bf;">sum</span><span style="color: #405c79;"> = partial(reduce, add) </span></div>
<div><span style="color: #405c79;">prod = partial(reduce, mul) </span></div>
</div>
<p>该装饰器的本质就是给一部分参数提前赋值，也可以使用匿名函数实现类似的效果。</p>
<h3>singledispatch：单分派</h3>
<p><code>@singledispatch</code> 装饰器可以根据参数的类型指定不同的函数，可以在一定程度上使用泛型。</p>
<p>例如，假设要实现一个函数 <code>scale(<em>data</em>, <em>scalar</em>)</code> ，将数据缩放。但是传入的数据可能是一个数值，也可能是一个数组。那么就需要在函数内判断传入数据的类型。</p>
<p><code>@singledispatch</code> 装饰器则可以简化判断的流程，它可以根据参数类型的不同，指定调用不同的函数。为了实现这一点，需要先将目标函数装饰起来：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">singledispatch</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
</div>
<p>然后调用目标函数的 <code>@.register(<em>type</em>)</code> 方法作为装饰器，将不同类型的参数导向不同的函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">float</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">_scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">float</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> data * scalar</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">list</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">_scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x * scalar, data))</span></div>
</div>
<p>此时，如果传入的参数类型不同，那么就会被不同的函数调用了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; scale(0.7, 2)<br />
1.4<br />
&gt;&gt;&gt; scale(list(range(10)), 0.3)<br />
[0.0, 0.3, 0.6, 0.8999999999999999, 1.2, 1.5, 1.7999999999999998, 2.1, 2.4, 2.6999999999999997]</div>
<p>如果对一个分派函数同时使用多个装饰器，那么这些类型的参数都会汇合到这个函数中：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">tuple</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">scale</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">register</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">list</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">_scale</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">data</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">scalar</span><span style="color: #405c79;">):</span></div>
</div>
<p>Python3.7 对该函数做了一些改进，如果已经提供了类型注解，那么可以直接使用方法对象作为装饰器，即 <code>@scale.register</code> 这种不调用的形式。</p>
<p>这种单分派函数可以在一定程度上实现函数签名效果，但可惜的是它只支持一个参数。</p>
<p>除此之外，functools 还包含一系列其它的高阶函数，例如<a href="/archives/239">第 4 节</a>中介绍到的 <code>reduce()</code> 函数、在介绍面向对象编程时装饰类的 <code>@total_ordering</code> 装饰器、Python3.9 新增的 <code>@cache</code> 装饰器，以及以上提到的装饰器都有用于方法的改版。更多标准库的介绍可以参阅 Python 标准库官方文档。</p>
<h2>参考资料</h2>
<p><a href="https://docs.python.org/3/library/functools.html">https://docs.python.org/3/library/functools.html</a></p>
<p>Python3 标准库 <code>functools</code> 官方文档</p>
<p><!-- finished(all):2022-06-02 --></p>
<p><a rel="nofollow" href="/archives/296">Python函数式编程10 functools模块：高阶函数工具</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/296/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程09 闭包和装饰器</title>
		<link>/archives/276</link>
					<comments>/archives/276#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 03 Jun 2022 03:07:51 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=276</guid>

					<description><![CDATA[<p>闭包 闭包的概念 在第 3 节中，介绍了高阶函数的概&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/276">Python函数式编程09 闭包和装饰器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>闭包</h2>
<h3>闭包的概念</h3>
<p>在<a href="/archives/246">第 3 节</a>中，介绍了高阶函数的概念，一个高阶函数可以返回另一个函数。但实际上，Python 的函数定义还有另一个有意思的地方：一个函数的定义可以嵌套在另一个函数之内，也就是说，如下所示的定义：</p>
<div class="codeblock code-template">
    <strong>def</strong> func(...):<br />
&nbsp; &nbsp; ...<br />
&nbsp; &nbsp; <strong>def</strong> inner_func(...):<br />
&nbsp; &nbsp; &nbsp; &nbsp; ...<br />
&nbsp; &nbsp; ...</div>
<p>是完全可以的。这种情况下，内部定义的函数会视为在函数内创建了一个类型为函数的局部对象。</p>
<p>嵌套定义的函数有一个特别的地方在于，嵌套函数可以使用函数内定义的局部变量；并且如果嵌套函数被当做结果返回时，如果调用这个返回结果，它可以访问到内部定义的局部变量。</p>
<p>以下展示了一个这样的情形，注意到在调用函数后，就将这个函数给删除了：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">func</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; n = </span><span style="color: #bf8b56;">10</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_n</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> n</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_n</span></div>
<div><span style="color: #405c79;">inner_func = func()</span></div>
<div><span style="color: #bf568b;font-weight: bold;">del</span><span style="color: #405c79;"> func</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(inner_func())</span></div>
</div>
<p>结果为：</p>
<div class="codeblock code-console">python -u demo.py<br />
10</div>
<p>可以看到，即便函数被删除后，内部函数依旧记录着函数提供的局部变量的信息。这种返回的函数包含外部函数绑定的变量，称为<strong>闭包</strong>(closure)。</p>
<p>闭包能够让内部函数记录局部变量的信息，本质上通过在内部函数中使用 <code>__closure__</code> 属性保存这些数据。</p>
<p>闭包的一个用途就是通过函数批量生成所需的参数。例如，以下函数利用闭包的特性，可以批量生成多项式函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> itertools </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> starmap</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">polinomial</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">coeffs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(starmap(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">i</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">coeff</span><span style="color: #405c79;">: coeff * x ** i,</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #8b56bf;">enumerate</span><span style="color: #405c79;">(</span><span style="color: #8b56bf;">reversed</span><span style="color: #405c79;">(coeffs)))</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner</span></div>
</div>
<p>这样可以通过控制几个参数得到不同的函数：</p>
<div class="codeblock code-console">&gt;&gt;&gt; regr = polinomial(2, 1)<br />
&gt;&gt;&gt; regr(3)<br />
7<br />
&gt;&gt;&gt; polinomial(4, 3, 7, 2)<br />
&lt;function polinomial.&lt;locals&gt;.inner at 0x0000023B89B85A60&gt;</div>
<h3>闭包和nonlocal声明</h3>
<p>函数内可能会处理全局变量，同理嵌套在其他函数中的函数也可能需要处理不在全局作用域中的外部变量：如果在嵌套函数内对不在全局作用域中的外部变量重新赋值，那么影响范围只会局限于嵌套函数中。</p>
<p>一般的函数使用 <code>global</code> 关键字来在函数内将一个变量声明为全局变量；Python3 引入了关键字 <code>nonlocal</code> ，它的作用效果类似：<code>nonlocal</code> 关键字可以声明一个变量为一个不在全局作用域中的外部变量声明，使得对该变量的重新赋值或修改的影响范围不局限于嵌套函数体内部。</p>
<h2>装饰器</h2>
<h3>装饰器的基本概念</h3>
<p><strong>装饰器</strong>(decorator)是 Python 的语法糖，其作用是增强函数的功能。在编写大型项目时，需要给很多函数加上某个相似功能，或是一些函数的某个基本功能需要重复使用，又或者需要将函数内某部分内容独立出来便于维护和更新，这些便可以使用函数的装饰器来实现。</p>
<p>装饰器可以在不改变函数原有的结构下，增强函数的功能。装饰器适用于以下两个场景：</p>
<ol>
<li>增强被装饰函数的功能</li>
<li>代码复用</li>
</ol>
<p>装饰器的思路可以从高阶函数开始。假设有函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">demo01</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">hello</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">demo02</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">hello</span><span style="color: #405c79;">'</span></div>
</div>
<p>在某个比较大的项目内，可能不知道这两个函数是在哪里执行的。现在需要增加这两个函数的功能，能让函数在调用时，显示函数名、调用时间、保存的局部变量等信息，但又希望不要逐个修改函数结构，否则这样会让工程量大大增加，而且容易出现疏忽。</p>
<p>这个时候，很自然地就会想到利用高阶函数。即新定义一个函数，它能够利用传入的函数对象输出其基本信息，然后再执行该函数。也就是说，对于这个高阶函数的需求有：</p>
<ul>
<li>它需要接受一个函数作为参数，这样在函数体内输出该函数的函数名</li>
<li>考虑到函数是要被调用的，所以高阶函数不能影响函数正常的调用功能，这就要求高阶函数返回结果必须要是传入的函数</li>
</ul>
<p>那么关于该提供调试信息的高阶函数便可以是这样：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">log</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; result = func()</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'[</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">strftime(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">%H:%M:%S</span><span style="color: #405c79;">"</span><span style="color: #405c79;">, localtime())</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">]'</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">' </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> returns </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">result</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
</div>
<p>测试运行的效果为：</p>
<div class="codeblock code-console">&gt;&gt;&gt; log(demo01)<br />
hello<br />
[21:31:49] demo01 returns None<br />
&gt;&gt;&gt; type(log(demo02))<br />
[21:31:50] demo02 returns hello<br />
&lt;class 'str'&gt;</div>
<p>该函数基本实现了要求的功能，即不修改原函数的定义、不影响原函数的调用，同时又可以输出原函数名。</p>
<p>不过以上定义的高阶函数存在一定问题，例如对于以下这些函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">double = polinomial(</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">triple = polinomial(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">)</span></div>
</div>
<p>这些函数是含有参数的，如果使用原先的高阶函数，则会因为高阶函数传入的参数不再是一个函数名了，而是一个返回值而出错。因此，这样一来对高阶函数的需求又增加了：高阶函数应该能支持函数的传入参数功能。</p>
<p>这就可以使用之前介绍闭包时提到过的批量生产函数的用法：可以让函数在生产时不改变其用法，只输出基本信息，也就是说在高阶函数内部定义一个嵌套函数，让高阶函数传入的参数来供嵌套函数使用，再由返回的嵌套函数来执行需要的传参功能。因此，该高阶函数便可以是：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">log</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; result = func()</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'[</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">strftime(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">%H:%M:%S</span><span style="color: #405c79;">"</span><span style="color: #405c79;">, localtime())</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">]'</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">' </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> returns </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">result</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_func</span></div>
</div>
<p>注意到定义装饰器函数时，其传参是依靠内层函数来完成的，因此嵌套函数的参数应该与装饰器函数的内层函数的参数数量相一致。这里使用可变参数 <code>*args</code> 和 <code>**kwargs</code> 组合，就可以表示任意的传参情况。接下来的一个技巧就是使用覆盖原有的函数定义，使用添加功能后的同名函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">double = log(double)</span></div>
<div><span style="color: #405c79;">triple = log(triple)</span></div>
</div>
<p>这样不但可以正常地进行传参功能，还可以利用生产得到的具有更多功能的函数替换原有函数，来执行更高级的效果：</p>
<div class="codeblock code-console">&gt;&gt;&gt; triple(3) * 8<br />
[21:41:34] inner returns 9<br />
72</div>
<p>如果不需要这些功能了，就把生成与覆盖的过程去掉即可。</p>
<p>这就是装饰器的基本思路，使用嵌套函数实现的生产函数效果来替换原有函数，实现更丰富的功能。不过这种使用高阶函数的方式略显复杂，而且还需要定义很多新函数来执行传入参数功能。实际上，Python 中可以使用装饰器来很好地实现以上操作。相对于赋值创建一个新函数的方法去改变原有函数的功能，可以在函数定义的前一行，通过 <code>@</code> 符号加上高阶函数名，来作为一个函数的装饰器。例如，以上修改后的高阶函数便可以作为一个装饰器来装饰函数：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">log</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">four_times</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> x * </span><span style="color: #bf8b56;">4</span></div>
</div>
<p>是 Python 提供的一种更简洁的写法。也就是说，函数的装饰器使用下列形式来装饰一个函数：</p>
<div class="codeblock code-template">
    @decorator<br />
<strong>def</strong> function():<br />
&nbsp; &nbsp; ...</div>
<p>等价于下面这种普通形式：</p>
<div class="codeblock code-template">
    <strong>def</strong> function():<br />
&nbsp; &nbsp; ...<br />
function = decorator(function)</div>
<p>装饰器实际上就是一个函数，它将一个函数装饰成一个它修改之后的新的函数。需要注意的是，装饰器的函数是一个高阶函数，且必须要有一个位置参数。</p>
<p>可以看出，<mark>装饰器可以在不影响函数结果的同时，为函数增加一些新的功能</mark>，也就是“装饰”的字面意义。</p>
<p>下图表达了这种装饰的思路，可以看到装饰器就像一张图片的花边，让图片内容变得更丰富，但又不改变图片原有的含义：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/06/09-decorator-concept.jpg" alt="" width="330"><figcaption>图片素材来源于网络</figcaption></figure>
<p>例如，以下实现了一个装饰器 <code>@timer</code> ，可以在调用函数时同时检查函数运行的时间，从而统计出是哪一个函数拖慢了程序的运行：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">timer</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">wrapper</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">args</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">kwargs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; start = perf_counter()</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; result = func(*args, **kwargs)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> execs </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">perf_counter() - start</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;"> second(s)'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> wrapper</span></div>
</div>
<p>一个函数的定义可以使用多个装饰器，结果与装饰器的位置顺序有关。例如：</p>
<div class="codeblock code-template">
    @outer_decor<br />
@inner_decor<br />
<strong>def</strong> func(..):<br />
&nbsp; &nbsp; ...</div>
<p>它等价于：</p>
<div class="codeblock code-template">
    <strong>def</strong> func(...):<br />
&nbsp; &nbsp; ...<br />
func = outer_decor(inner_decor(func))</div>
<p>每一次添加装饰器，函数的功能就又丰富了一层。</p>
<h3>带参数的装饰器</h3>
<p>由于装饰器的本质就是高阶函数，当然可以在装饰函数时就加上参数。让装饰器加上参数可以进一步丰富装饰器的功能。</p>
<p>前文说过，装饰器</p>
<div class="codeblock code-template">
    @decorator<br />
<strong>def</strong> function():<br />
&nbsp; &nbsp; ...</div>
<p>等价于下面这种普通形式：</p>
<div class="codeblock code-template">
    <strong>def</strong> function():<br />
&nbsp; &nbsp; ...<br />
function = decorator(function)</div>
<p>如果此时让装饰器加上一个参数，例如 <code>@decorator(<em>arg</em>)</code> 。那么此时，真正作为高阶函数的表达式应该是 <code>@decorator(<em>arg</em>)</code> ，这个表达式可以接收一个函数作为参数，并且生成一个新的函数。也就是说，这个高阶函数再次嵌套了一个函数。</p>
<p>例如，以下修改之前定义的 <code>log</code> 函数，使它能够在装饰函数时可以通过参数自由控制显示的内容。这样，该函数便可以再嵌套一次，以完成二次传参作用：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">log</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">time</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">check_arg</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">False</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">outer_wrapper</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_wrapper</span><span style="color: #405c79;">(*</span><span style="color: #bf8b56;">args</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">kwargs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = func(*args, **kwargs)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> time:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'[</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">strftime(</span><span style="color: #405c79;">"</span><span style="color: #56bf8b;">%H:%M:%S</span><span style="color: #405c79;">"</span><span style="color: #405c79;">, localtime())</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">]'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">end</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"> </span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">end</span><span style="color: #405c79;">=</span><span style="color: #405c79;">''</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> check_arg:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">(</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, *args, *[</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">'</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">k</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">=</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">v</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> k, v in kwargs.items()], </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">)</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">end</span><span style="color: #405c79;">=</span><span style="color: #405c79;">''</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">' returns </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">result</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_wrapper</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> outer_wrapper</span></div>
</div>
<p>先分析一下该函数，当该函数作为装饰器装饰 <code>function</code> 函数时，等价于这种形式：</p>
<div class="codeblock code-template">
    function = log(<em>time</em>, <em>check_arg</em>)(function)</div>
<p>该函数自左向右执行，首先将 <code>log(<em>time</em>, <em>check_arg</em>)</code> 返回 <code>outer_wrapper</code> ，变成 <code>outer_wrapper(function)</code> ，进一步执行返回 <code>inner_wrapper</code> ，赋值给变量 <code>function</code> ，因此传参和执行都由 <code>inner_wrapper</code> 来完成，该函数在执行时，会调用 <code>log(<em>time</em>, <em>check_arg</em>)</code> 接收的参数，并给函数增加更为复杂的功能。</p>
<p>以下编写了两个函数：<code>isprime()</code> 用于判断一个数是否为质数；<code>prime_factorization()</code> 则根据结果将一个大数分解为它的质因数。如果给第一个函数加上 <code>@log</code> 装饰器，那么在调用函数时就可以很清楚地看到程序执行的过程：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">log</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">check_arg</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">isprime</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">number</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">int</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, number // </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> number % i == </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">False</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">True</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">prime_factorization</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">number</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">int</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; factors = []</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">while</span><span style="color: #405c79;"> not isprime(number):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, number // </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> number % i == </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; factors.append(i)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; number //= i</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">break</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; factors.append(number)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> factors</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(prime_factorization(</span><span style="color: #bf8b56;">6108984</span><span style="color: #405c79;">))</span></div>
</div>
<p>通过结果可以观察到质因数的分解过程：</p>
<div class="codeblock code-console">python -u demo.py<br />
[11:05:32] isprime( 6108984 ) returns False<br />
[11:05:32] isprime( 3054492 ) returns False<br />
[11:05:32] isprime( 1527246 ) returns False<br />
[11:05:32] isprime( 763623 ) returns False<br />
[11:05:32] isprime( 254541 ) returns False<br />
[11:05:32] isprime( 84847 ) returns False<br />
[11:05:32] isprime( 12121 ) returns False<br />
[11:05:32] isprime( 713 ) returns False<br />
[11:05:32] isprime( 31 ) returns True<br />
[2, 2, 2, 3, 3, 7, 17, 23, 31]</div>
<p>当然，以上编写的程序运行效率还有许多优化空间，不过对于较小的数字还算够用。</p>
<h3>完善装饰器</h3>
<p>装饰器的基本结构已经大致完成，但是仍然有一些小缺陷。例如，以下装饰器可以将任意函数的返回值包装成 HTML 标签：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">tag</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">attrs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">outer_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">contain</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr = </span><span style="color: #405c79;">''</span><span style="color: #405c79;">.join([</span><span style="color: #bf568b;font-weight: bold;">f</span><span style="color: #56bf8b;">' </span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">k</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">="</span><span style="color: #bf8b56;">{</span><span style="color: #405c79;">v</span><span style="color: #bf8b56;">}</span><span style="color: #56bf8b;">"'</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> k, v in attrs.items()])</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">&lt;</span><span style="color: #bf8b56;">{0}{1}</span><span style="color: #56bf8b;">&gt;</span><span style="color: #bf8b56;">{2}</span><span style="color: #56bf8b;">&lt;/</span><span style="color: #bf8b56;">{0}</span><span style="color: #56bf8b;">&gt;</span><span style="color: #405c79;">'</span><span style="color: #405c79;">.format(tag, attr, func(contain))</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_func</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> outer_func</span></div>
</div>
<p>这个装饰器本身没有任何问题，以下是一个装饰示例：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">p</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">a</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">href</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">javascript: upload(this);</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">legalize</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">string</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #405c79;">"""</span><span style="color: #56bf8b;">Make the string a valid filename</span><span style="color: #405c79;">"""</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> sub(</span><span style="color: #bf568b;font-weight: bold;">r</span><span style="color: #405c79;">'</span><span style="color: #bf8b56;">[</span><span style="color: #568bbf;">\\\/</span><span style="color: #bf8b56;">:*?"&lt;&gt;|]</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"> </span><span style="color: #405c79;">'</span><span style="color: #405c79;">, string)</span></div>
<div><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(legalize(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">&lt;User&gt;: name</span><span style="color: #405c79;">'</span><span style="color: #405c79;">))</span></div>
</div>
<p>这里为函数提供了帮助文档。运行结果为：</p>
<div class="codeblock code-console">python -u demo.py<br />
&lt;p&gt;&lt;a href="javascript: upload(this);"&gt; User   name&lt;/a&gt;&lt;/p&gt;</div>
<p>但是如果查看它的帮助文档，结果就变得奇怪了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; help(legalize)<br />
Help on function inner_func in module __main__:</p>
<p>inner_func(contain: str)</p>
</div>
<p>这个帮助文档看起来根本不是之前编写的函数。这是因为，当装饰器装饰函数后，被装饰函数被当做一个参数传递给了装饰器，然后就被同名变量取代了，实际上执行的是装饰器提供的 <code>inner_func()</code> 函数，因此获取的是这个函数的帮助文档。</p>
<p>要想完善该问题，可以在装饰器函数内部返回 inner_func 前进行一些改动，手动将原有函数的属性拷贝给返回的函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">tag</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">attrs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">outer_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">contain</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; inner_func.</span><span style="color: #8b56bf;">__name__</span><span style="color: #405c79;"> = func.</span><span style="color: #8b56bf;">__name__</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; inner_func.</span><span style="color: #8b56bf;">__doc__</span><span style="color: #405c79;"> = func.</span><span style="color: #8b56bf;">__doc__</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># too many attributes need to update</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_func</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> outer_func</span></div>
</div>
<p>这样的做法稍显复杂，因为函数的属性实际上是非常多的（例如，<code>__dict__</code> 包含了各种额外属性，如果不更新会导致这些属性丢失）。实际上，Python 提供了一种方法，可以快速拷贝函数对象的所有属性给另一个函数，通过使用 <code>functools</code> 模块的 <code>@wraps()</code> 装饰器来完成该操作：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> functools </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> wraps</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">html_tag</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">tag</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">, **</span><span style="color: #bf8b56;">attrs</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">outer_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">func</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; @</span><span style="color: #8b56bf;">wraps</span><span style="color: #405c79;">(func)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">inner_func</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">contain</span><span style="color: #405c79;">: </span><span style="color: #bf568b;">str</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> inner_func</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> outer_func</span></div>
</div>
<p>这样再次检查帮助文档的结果就正确了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; help(legalize)<br />
Help on function legalize in module __main__:</p>
<p>legalize(string)<br />
Make the string a valid filename</p>
</div>
<p>至此，装饰器便已经非常完善了。装饰器作为在不修改函数本义的情况下，可以增加函数的功能，有效增加了代码的复用性，并使写出的代码结构更清晰。在一些大型框架中，通过编写强大的装饰器，只需要非常简短的函数就可以装饰出非常丰富的功能，大大降低了编程的复杂程度。</p>
<p>例如，以下是第三方框架 Flask 的一个非常简单的示例：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> flask </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> Flask, render_template</span></div>
<div><span style="color: #405c79;">app = Flask(</span><span style="color: #8b56bf;">__name__</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">@</span><span style="color: #8b56bf;">app</span><span style="color: #405c79;">.</span><span style="color: #8b56bf;">route</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">/</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">methods</span><span style="color: #405c79;">=[</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">GET</span><span style="color: #405c79;">'</span><span style="color: #405c79;">])</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">main</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> render_template(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">index.html</span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">__name__</span><span style="color: #405c79;"> == </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">__main__</span><span style="color: #405c79;">'</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; app.run(</span><span style="color: #bf8b56;">debug</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">)</span></div>
</div>
<p>只需要一个装饰器，便可以将一个只有两行的函数变成一个网络应用，当在浏览器中访问本地端口时就会将 <code>index.html</code> 中的内容显示在浏览器上，但在代码中几乎完全不用涉及这方面的内容，这就是装饰器的强大之处。</p>
<p><!-- finished(all):2022-06-01 --></p>
<p><a rel="nofollow" href="/archives/276">Python函数式编程09 闭包和装饰器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/276/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程08 itertools模块：更多迭代器</title>
		<link>/archives/270</link>
					<comments>/archives/270#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 01 Jun 2022 04:46:00 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[Python标准库]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=270</guid>

					<description><![CDATA[<p>itertools 模块中包含大量迭代器函数，是处理&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/270">Python函数式编程08 itertools模块：更多迭代器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p><code>itertools</code> 模块中包含大量迭代器函数，是处理数据的非常好用的工具。</p>
<blockquote><p>生成器是迭代器的一个部分，迭代器和生成器的用途是一致的，只是迭代器并不都是使用 <code>yield</code> 这种关键字的方式定义。可以用生成器的概念来理解它。</p></blockquote>
<h2>无限迭代器</h2>
<p>以下迭代器如果在迭代时不使用 <code>break</code> 终止或遇到错误，那么它会一直执行下去。</p>
<h3>count：计数迭代器</h3>
<p>内置的 <code>range()</code> 函数需要定义范围的上界，而下限和步长值可选。count(start=0, step=1) 函数与之相反，需要给出可选的起始值和步长，无须定义上界。在停止之前，该生成器会一直执行下去。</p>
<p><code>count()</code> 函数的参数可以是浮点数，但是由于进制带来的舍入误差会随着程序的运行逐渐累积，因此尽量在较大的计数过程中慎用浮点数计数，或者使用整型计数再转换为浮点数的方式。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">count(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 10 11 12 13 14 ...</span></div>
<div><span style="color: #405c79;">count(</span><span style="color: #bf8b56;">2.5</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0.5</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 2.5 3.0 3.5 ...</span></div>
</div>
<h3>cycle：循环迭代器</h3>
<p><code>cycle()</code> 函数重复循环一组值，可用它循环数据集标识符对数据集进行分组。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">cycle(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; A B C A B C A B C ...</span></div>
</div>
<h3>repeat：重复迭代器</h3>
<p><code>repeat(<em>elem</em>, <em>n</em>=None)</code> 用于重复单个值，不过也可以通过第二个参数将其限制为有限的迭代器。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">repeat(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 10 10 10</span></div>
</div>
<h2>有限迭代器</h2>
<p>有限迭代器更多，也更常用。它们具体的长度一般取决于给定序列的长度或特征。</p>
<h3>accumulate：归约迭代器</h3>
<p><code>accumulate()</code> 函数基于给定的函数返回一个可迭代对象，将一系列归约值汇总在一起，遍历迭代器得出当前汇总值。以下给出了一个这样的示例：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">accumulate([</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 1 3 6 10 15</span></div>
</div>
<p><code>accumulate()</code> 函数的第二个参数 <code>func</code> 的默认行为是加法，也可以改成其它的归约函数。</p>
<h3>chain：组合迭代器</h3>
<p><code>chain()</code> 函数将多个迭代器组合为单个迭代器，可以用于一次处理多个集合。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">chain(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">), </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">20</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">)) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 0 1 2 3 4 10 12 14 16 18</span></div>
</div>
<p>如果多个迭代器被放在一个可迭代对象内，那么还可以使用 chain.from_iterable() 类方法取代以上这种可变参数的形式。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">chain.from_iterable([</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">DEF</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; A B C D E F</span></div>
</div>
<h3>groupby：分组迭代器</h3>
<p><code>groupby(<em>iterable</em>, <em>key</em>=None)</code> 通过对每个元素应用 <code><em>key</em></code> 函数求值，并根据求值结果将一个迭代器切分为多个小迭代器，具体的规则为：如果后一个元素的 key 返回值等于前一个元素的 key 返回值，会将这两个元素放在同一个分组中；如果与前一个元素的 key 值不同，则当前分组结束，将当前元素放到新的分组中。</p>
<p>该生成器每一次迭代的结果都是一个 <code>(key, group)</code> 形式的元组，其中第二个元素是生成器。</p>
<p>以下是一个简单的示例，将一个排序好的列表按十位分组：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">from</span><span style="color: #405c79;"> random </span><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> randint</span></div>
<div><span style="color: #405c79;">target = </span><span style="color: #8b56bf;">filter</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">_</span><span style="color: #405c79;">: randint(</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">), </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">50</span><span style="color: #405c79;">))</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in groupby(target, </span><span style="color: #bf8b56;">key</span><span style="color: #405c79;">=</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x // </span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(i[</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">], </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">(i[</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]))</span></div>
</div>
<p>结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
0 [2, 4, 6]<br />
1 [10, 11, 13, 16, 19]<br />
2 [23, 26, 27, 29]<br />
3 [30, 31, 32, 35, 37, 38]<br />
4 [40, 41, 46, 47, 48]</div>
<p>因此，<code>groupby()</code> 函数的输入列表必须是排序好的，以确保分在一组中的元素是相邻的。</p>
<h3>compress：选择迭代器</h3>
<p>内置的 <code>filter()</code> 根据函数求值结果为真或假决定是否保留元素，而 <code>compress(<em>data</em>, <em>selectors</em>)</code> 则根据 <code><em>selectors</em></code> 可迭代对象给出的布尔值决定是否保留同一位置处的元素。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">compress(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCDEF</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; A C E</span></div>
</div>
<h3>islice：切片迭代器</h3>
<p><code>islice(<em>iterable</em>, <em>start</em>=0, <em>stop</em>, <em>step</em>=1)</code> 函数可以对迭代器实现切片操作，就像 <code>slice</code> 类对序列实现切片操作一样。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">islice(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCDEFG</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># =&gt; C D E F G</span></div>
<div><span style="color: #405c79;">islice(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCDEFG</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">None</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; B D F</span></div>
</div>
<h3>dropwhile和takewhile：过滤状态迭代器</h3>
<p><code>dropwhile(<em>predicate</em>, <em>iterable</em>)</code> 和 <code>takewhile(<em>predicate</em>, <em>iterable</em>)</code> 都是过滤函数，其用法是：从 <code><em>predicate</em></code> 函数给定的一种布尔模式开始，当布尔状态变换后，则函数的过滤规则也发生变化。<code>dropwhile()</code> 函数开始采用拒绝模式，当谓词函数变为 <code>False</code> 时切换并一直保持为通过模式。<code>takewhile()</code> 则从通过模式开始，当谓词函数变为 <code>False</code> 时切换并一直保持为拒绝模式。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">dropwhile(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x &lt; </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 6 4 1</span></div>
<div><span style="color: #405c79;">takewhile(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x &lt; </span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span><span style="color: #405c79;">]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 1 4</span></div>
</div>
<p>这两个函数的一种常见用法是过滤掉文件的头部和尾部的一些无用信息。例如，假设有如下附加了额外头部信息的 CSV 文件：</p>
<div class="vscode-block">
<div><span style="color: #24292e;">Author: Hello</span></div>
<div><span style="color: #24292e;">Date: 2022-05-31</span></div>
<div><span style="color: #24292e;">sepal_length,</span><span style="color: #d73a49;">sepal_width,</span><span style="color: #6f42c1;">petal_length,</span><span style="color: #a8a8a8;">petal_width,</span><span style="color: #032f62;">species</span></div>
<div><span style="color: #24292e;">5.1,</span><span style="color: #d73a49;">3.5,</span><span style="color: #6f42c1;">1.4,</span><span style="color: #a8a8a8;">0.2,</span><span style="color: #032f62;">Iris-setosa</span></div>
<div><span style="color: #24292e;">4.9,</span><span style="color: #d73a49;">3.0,</span><span style="color: #6f42c1;">1.4,</span><span style="color: #a8a8a8;">0.2,</span><span style="color: #032f62;">Iris-setosa</span></div>
<div><span style="color: #24292e;">6.4,</span><span style="color: #d73a49;">3.2,</span><span style="color: #6f42c1;">4.5,</span><span style="color: #a8a8a8;">1.5,</span><span style="color: #032f62;">Iris-versicolor</span></div>
<div><span style="color: #24292e;">6.9,</span><span style="color: #d73a49;">3.1,</span><span style="color: #6f42c1;">4.9,</span><span style="color: #a8a8a8;">1.5,</span><span style="color: #032f62;">Iris-versicolor</span></div>
</div>
<p>那么可以使用如下方式处理它：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">with</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">open</span><span style="color: #405c79;">(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">header.csv</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">r</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">as</span><span style="color: #405c79;"> f:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; data = dropwhile(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">row</span><span style="color: #405c79;">: </span><span style="color: #bf568b;font-weight: bold;">not</span><span style="color: #405c79;"> row[</span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">].isdigit(), f)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">row</span><span style="color: #405c79;">: row.replace(</span><span style="color: #405c79;">'</span><span style="color: #568bbf;">\n</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">''</span><span style="color: #405c79;">).split(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">,</span><span style="color: #405c79;">'</span><span style="color: #405c79;">), data):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(i)</span></div>
</div>
<p>该程序检查 CSV 文件的每一行（注意文件对象也是可迭代对象，每次迭代结果为文件中的一行），判断每一行的首字符是不是数字，并将头部非数字开头的行丢弃。其结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
['5.1', '3.5', '1.4', '0.2', 'Iris-setosa']<br />
['4.9', '3.0', '1.4', '0.2', 'Iris-setosa']<br />
['6.4', '3.2', '4.5', '1.5', 'Iris-versicolor']<br />
['6.9', '3.1', '4.9', '1.5', 'Iris-versicolor']</div>
<h2>改进的迭代器</h2>
<p>以下迭代器是对内置迭代器的补充或改进。</p>
<h3>zip_longest：不截短的zip</h3>
<p>在<a href="/archives/239">第 4 节</a>介绍了 <code>zip()</code> 迭代器，它接收多个序列，返回结果的长度是其中最短序列的长度。而 <code>zip_longest(*<em>iterables</em>, <em>fillvalue</em>=None)</code> 则为较短的序列填充 <code><em>fillvalue</em></code> 参数提供的默认值，直到遍历完最长的序列。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">zip_longest(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCD</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">xy</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">fillvalue</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">*</span><span style="color: #405c79;">'</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; Ax By C* D*</span></div>
</div>
<h3>filterfalse：filter的反相过滤</h3>
<p>内置的 <code>filter()</code> 迭代器会保留所有求值结果为 <code>True</code> 的数据；而 <code>filterfalse()</code> 则与之相反，它会保留所有求值结果为 <code>False</code> 的数据。</p>
<div class="vscode-block">
<div><span style="color: #8b56bf;">filter</span><span style="color: #405c79;">(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x % </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">)) &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># =&gt; 1 3 5 7 9</span></div>
<div><span style="color: #405c79;">filterfalse(</span><span style="color: #bf568b;font-weight: bold;">lambda</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">x</span><span style="color: #405c79;">: x % </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">)) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 0 2 4 6 8</span></div>
</div>
<p>通过组合这两个迭代器，可以方便地将输入数据分为“保留”和“舍弃”两组。</p>
<h3>starmap：平铺的map</h3>
<p>内置的 <code>map()</code> 迭代器可以接收多个可迭代对象，它将每一个可迭代对象中的元素组合为所需的参数；而 <code>starmap()</code> 迭代器只接收一个可迭代对象，它将其中元素展开后变成所需的参数。以下给出了一个这样的示例：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">starmap(</span><span style="color: #8b56bf;">pow</span><span style="color: #405c79;">, [(</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">,</span><span style="color: #bf8b56;">5</span><span style="color: #405c79;">), (</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">,</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">), (</span><span style="color: #bf8b56;">10</span><span style="color: #405c79;">,</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">)]) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 32 9 1000</span></div>
</div>
<p>因此，使用 <code>zip()</code> 迭代器可以非常简单地将 <code>map()</code> 变成 <code>starmap()</code> ：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">starmap</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">function</span><span style="color: #405c79;">, *</span><span style="color: #bf8b56;">iterables</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">map</span><span style="color: #405c79;">(function, </span><span style="color: #8b56bf;">zip</span><span style="color: #405c79;">(iterables))</span></div>
</div>
<h3>tee：克隆迭代器</h3>
<p><code>tee(<em>iterable</em>, <em>n</em>=2)</code> 函数可以突破<mark>迭代器只能使用一次</mark>的限制，将可迭代对象拷贝 <code><em>n</em></code> 份，并将拷贝结果以元组的形式返回。</p>
<p>不过该函数在使用时有一些限制：它的实现实际上有将迭代器转化为序列的过程，因此在处理大型数据集且拷贝次数较少时的效果往往不佳。</p>
<h2>组合迭代器</h2>
<p>接下来的迭代器与排列组合有关，因此它们往往需要输入多个序列。</p>
<h3>product：笛卡儿积</h3>
<p><code>product(*<em>iterables</em>, <em>repeat</em>=1)</code> 用于得到笛卡儿积，即基于一组集合生成所有可能的元素组合。<code><em>repeat</em></code> 参数可以将提供的集合重复若干次参与组合。例如：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">product(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">), </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">)) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 00 01 02 10 11 12 20 21 22</span></div>
<div><span style="color: #405c79;">product(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">AB</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">repeat</span><span style="color: #405c79;">=</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AA AB BA BB</span></div>
</div>
<p>该函数的作用结果类似嵌套的 <code>for</code> 循环。以下再次给出了一个示例：</p>
<div class="codeblock code-console">&gt;&gt;&gt; from random import choice<br />
&gt;&gt;&gt; cards = list(product(range(1, 14), '<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2663.png" alt="♣" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" /><img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2660.png" alt="♠" class="wp-smiley" style="height: 1em; max-height: 1em;" />'))<br />
&gt;&gt;&gt; choice(cards)<br />
(2, '<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2666.png" alt="♦" class="wp-smiley" style="height: 1em; max-height: 1em;" />')<br />
&gt;&gt;&gt; choice(cards)<br />
(9, '<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2665.png" alt="♥" class="wp-smiley" style="height: 1em; max-height: 1em;" />')</div>
<h3>排列组合相关迭代器</h3>
<p><code>permutations(<em>iterable</em>, <em>r</em>=None)</code> 函数会排列集合中所有元素；如果给出参数 <code><em>r</em></code> ，则它会限制参与排列元素的个数，例如：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">permutations(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">)) &nbsp; </span><span style="color: #a8a8a8;"># =&gt; 012 021 102 120 201 210</span></div>
<div><span style="color: #405c79;">permutations(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCD</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AB AC AD BA BC BD CA CB CD DA DB DC</span></div>
</div>
<p>由于 <span class="math">\\( n \\)</span> 个元素的排列结果有 <span class="math">\\( P_n^r = \frac{n!}{(n-r)!} \\)</span> 个，因此随着元素个数的上升，排列结果的长度急剧上升。</p>
<p>与之类似的函数是 <code>combinations(<em>iterable</em>, <em>r</em>)</code> ，它会以忽略顺序的形式组合集合中所有元素。</p>
<div class="vscode-block">
<div><span style="color: #405c79;">combinations(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABCD</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AB AC AD BC BD CD</span></div>
<div><span style="color: #405c79;">combinations(</span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">4</span><span style="color: #405c79;">), </span><span style="color: #bf8b56;">3</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; 012 013 023 123</span></div>
</div>
<p>还有一个类似的迭代器 <code>combinations_with_replacement(<em>iterable</em>, <em>r</em>)</code> ，其区别是该迭代器在组合时允许元素重复：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">combinations(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># =&gt; AB AC BC</span></div>
<div><span style="color: #405c79;">combinations_with_replacement(</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">ABC</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">) &nbsp;</span><span style="color: #a8a8a8;"># =&gt; AA AB AC BB BC CC</span></div>
</div>
<p>这些迭代器通常用于处理排列组合相关的数学问题中。</p>
<p>使用这些迭代器可以代替许多算法中出现的简单循环，并使执行过程更高效。<code>itertools</code> 模块中还给出了更多范例，将基本的迭代器组合成更高级、有用的迭代器，可以高效地处理复杂的数据，参见 <a href="https://docs.python.org/3/library/itertools.html#itertools-recipes">https://docs.python.org/3/library/itertools.html#itertools-recipes</a> 。</p>
<h2>参考资料</h2>
<p><a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a></p>
<p><code>itertools</code> 模块的官方文档。本文中的许多示例代码都来自该文档中。</p>
<p>文章中使用到的 CSV 数据来自 kaggle 。</p>
<p><!-- finished(all):2022-05-31 --></p>
<p><a rel="nofollow" href="/archives/270">Python函数式编程08 itertools模块：更多迭代器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/270/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python函数式编程07 生成器</title>
		<link>/archives/262</link>
					<comments>/archives/262#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sun, 29 May 2022 04:55:09 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[函数式编程]]></category>
		<guid isPermaLink="false">/?p=262</guid>

					<description><![CDATA[<p>生成器的概念 为什么需要生成器 在 Python 中&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/262">Python函数式编程07 生成器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[<h2>生成器的概念</h2>
<h3>为什么需要生成器</h3>
<p>在 Python 中，如果一个函数不使用 <code>return</code> 关键字返回数据，而是使用 <code>yield</code> 关键字得到数据，那么该函数就称为<strong>生成器函数</strong>。也就是说，生成器函数的特征为：</p>
<div class="codeblock code-template">
    <strong>def</strong> function(...):<br />
&nbsp; &nbsp; ...  # statements<br />
&nbsp; &nbsp; <strong>yield</strong> expression</div>
<p>既然可以使用返回值，为什么需要生成器这种奇怪的语法？下面通过一个示例来说明函数存在的不足。</p>
<p>重新回到之前编写的生成斐波那契数列的函数，该函数的代码如下：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">fibonacci</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">n</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; result = []</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; a, b = </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">while</span><span style="color: #405c79;"> a &lt; n:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; result.append(a)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; a, b = b, a + b</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> result</span></div>
</div>
<p>既然编写了这个函数，那么它肯定就会有用得到的地方。例如，假设要从斐波那契数列中找到是否存在一个完全平方数，那么可以再编写一个函数 <code>issquare()</code> ，然后使用以下代码判断：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in fibonacci(</span><span style="color: #bf8b56;">1000</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> issqare(i):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #a8a8a8;"># do something</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">break</span></div>
</div>
<p>这种形式有一个明显的不足，注意在程序中，调用了两次循环：一次用于挨个生成斐波那契数列的元素，另一次用于从得到的斐波那契数列中挨个判断是否满足条件，这就会造成有一半的时间都会浪费在重复地将一个无用的元素塞入列表，然后再取出上。</p>
<p>除此之外，这个函数还返回了一个列表，这是另一个问题：如果要判断的数据量很多，那么这个列表也势必很大，但是真正要用到的值只有一个，那么这个列表又浪费了太多无用的空间。而且必须得等到列表生成完毕以后，再去列表中取值；但问题是在生成列表时，还不知道结果是多少，那么也不知道生成的列表到底要多大，这样要么得到的列表长度不足，其中不包含结果；要么得到的列表结果过大，其中包含了许多压根不会用上的元素。</p>
<p>这样的缺点不仅降低了效率，还可能招致严重的问题。</p>
<p>如果是在命令式编程，那么只需要在同一个循环内，在生成元素的时候顺便判断一下结果是否满足就行了。当然也可以把它封装成一个函数，但是如果判断斐波那契数列中是否存在平方数这种宏观的问题都需要用一个函数处理的话，那么判断斐波那契数列中素数的个数是否大于 10 个是否也要编写一个函数？这种问题塞到一个函数显然不够合适，因为它处理的问题太过细致了，这种函数显然不会用很多次，如果程序中都是这样不太能复用的函数，那么肯定不够合适。</p>
<p>生成器就是为了解决以上问题的。接下来先介绍生成器的特征，这样可以更好地明白使用生成器解决上述问题的优点所在。</p>
<h3>什么是生成器</h3>
<p>首先看看 <code>yield</code> 关键字会得到什么样的结果，以下编写了一个最基本的生成器函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">func</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">3</span></div>
</div>
<p>然后检查一下函数对象：</p>
<div class="codeblock code-console">&gt;&gt;&gt; func<br />
&lt;function func at 0x0000013CD9737C10&gt;</div>
<p>结果表明函数依旧是函数，这点没有发生改变。那么再试着调用一下函数：</p>
<div class="codeblock code-console">&gt;&gt;&gt; func()<br />
&lt;generator object func at 0x0000013CD934F890&gt;</div>
<p>调用函数的结果显示，该函数返回了一个生成器对象。</p>
<p><strong>生成器</strong>(generator)是一种特殊的数据类型，生成器只在需要的时候，才会产生具体的值，这就避免了时间上的浪费；生成器在产生一个值时，会将上一次产生的值抛弃，这就避免了空间上的浪费。生成器是 Python 的一大特性，使用生成器可以让代码变得更加简洁、优雅。</p>
<p>以上说法可能只能让人似懂非懂，下面结合一个具体的示例说明。以下将上面的斐波那契函数改成生成器函数的形式，如下所示：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">fibonacci</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; a, b = </span><span style="color: #bf8b56;">0</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">while</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> a</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; a, b = b, a + b</span></div>
</div>
<p>一个生成器最基本、最实用的用法就是使用 <code>for</code> 循环对生成器迭代，每一次迭代过程中，如果遇到 <code>yield</code> 语句，那么<mark>后面的表达式就会被作为<em>本次迭代</em>的结果返回</mark>给中间变量如 <code>i</code> 后续利用。</p>
<p>这也揭示出了生成器函数与普通函数的区别：</p>
<ul>
<li>普通函数在执行到 <code>return</code> 语句后就终止，后面的所有语句都会被忽略；生成器函数执行到 <code>yield</code> 语句后，只是暂时将结果返回，下一次遍历时，又会从暂停的位置继续执行下去</li>
<li>因此，一个生成器函数在执行时，可以遇到多个<code>yield</code> 语句；普通函数虽然可以串列多个 <code>return</code> 语句，但是遇到第一个语句后就会终止</li>
<li>也正是因为这个特点，生成器会在迭代过程中一直保存其中的局部变量，直到迭代结束</li>
</ul>
<p>以下示例展示了生成器的用法：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in fibonacci():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #8b56bf;">print</span><span style="color: #405c79;">(i, </span><span style="color: #bf8b56;">end</span><span style="color: #405c79;">=</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;"> </span><span style="color: #405c79;">'</span><span style="color: #405c79;">)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> i &gt; </span><span style="color: #bf8b56;">30</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">break</span></div>
</div>
<p>以上代码的执行结果为：</p>
<div class="codeblock code-console">$ python -u demo.py<br />
0 1 1 2 3 5 8 13 21 34</div>
<p>这里简单分析一下程序的执行过程，首先生成器函数执行到 <code>yield</code> 语句时，变量 <code>a</code> 的值是 0 ，因此 0 被作为生成结果传递给迭代的中间变量 <code>i</code> ；第二次进入迭代时函数从 yield 语句后继续运行，变量的值发生改变，<code>a</code> 变成了 1 ，再次作为生成结果传递给迭代的中间变量；以此类推，第三次执行到 <code>yield</code> 时返回的结果是 1 ，第四次是 2 ……。</p>
<blockquote><p>使用集成开发环境的读者可以使用 debug 功能，对程序下断点，进一步观察每一步代码是如何执行、变量的值是如何变化的。</p></blockquote>
<p>下图表示了这一过程：</p>
<figure>
    <img decoding="async" src="/wp-content/uploads/2022/05/07-generator-procedure.jpg" alt="" width="330"></figure>
<p>最后，在外部使用 <code>break</code> 语句强行终止了这一过程。如果不手动终止的话，迭代会一直发生下去，生成器可以一直生成新的值出来，因此这类的生成器也称为<strong>无限生成器</strong>。这又是生成器相对普通函数的优点：普通函数不可能返回一个具有无穷长度的列表，但是生成器可以一直源源不断地计算新的结果。</p>
<p>可以从这个角度理解：函数返回的是结果，而生成器返回的是<em>过程</em>。</p>
<p>实际上，在第四节中介绍的内置函数 <code>map()</code> 、<code>enumerate()</code> 等，得到的结果就是一个类似生成器的对象。</p>
<h3>生成器与生成器函数</h3>
<p>前面介绍了生成器的概念，并通过示例展示了生成器的用法。但是注意，生成器在使用时有一些注意事项。</p>
<p>以上提到了一个基本的事实：生成器函数在调用时，才会返回一个生成器。但是注意，在介绍生成器时，还提到了：<mark>生成器在产生一个值时，会将上一次产生的值抛弃</mark> 。这种性质虽然节约了空间的开销，但也使得一个生成器只能被迭代一次，一旦调用完成后该值便不再保存在内存当中，因此生成器中生成的值只能访问一次。</p>
<p>为了理解这句话，给定以下生成器：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">odd</span><span style="color: #405c79;">():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; i = </span><span style="color: #bf8b56;">0</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">while</span><span style="color: #405c79;"> </span><span style="color: #bf8b56;">True</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> i * </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;"> + </span><span style="color: #bf8b56;">1</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; i += </span><span style="color: #bf8b56;">1</span></div>
</div>
<p>第一次对生成器迭代的结果很正常：</p>
<div class="codeblock code-console">&gt;&gt;&gt; for i in g1:<br />
...     print(i, end=' ')<br />
...     if i &gt; 15:<br />
...         break<br />
...<br />
0 2 4 6 8 10 12 14 16</div>
<p>但是第二次生成的结果就有些变化了：</p>
<div class="codeblock code-console">&gt;&gt;&gt; for i in g1:<br />
...     print(i, end=' ')<br />
...     if i &gt; 30:<br />
...         break<br />
...<br />
18 20 22 24 26 28 30 32</div>
<p>这一次，生成器是顺着上一次的结果继续执行了下去，这说明前面的值都被抛弃了，再也访问不到了。或者也可以从生成器的执行过程分析：生成器还没执行完成，只是这一过程暂停了。</p>
<p>因此，以下两种使用生成器的方式：</p>
<div class="vscode-block">
<div><span style="color: #a8a8a8;"># 1</span></div>
<div><span style="color: #405c79;">g2 = odd()</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in g2:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in g2:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #a8a8a8;"># 2</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in odd():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
<div><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in odd():</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
</div>
<p>得到的是完全不同的结果，因为第一次只创建了一个生成器，第二次创建了两个生成器。</p>
<p>这种特性是生成器的优点，但它有时也会带来问题。因为生成器的迭代可能是显式的，也有可能是隐式的，有些时候生成器在生成值时难以被察觉。考虑以下简单的函数：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">average</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">l</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">return</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">sum</span><span style="color: #405c79;">(l) / </span><span style="color: #8b56bf;">len</span><span style="color: #405c79;">(</span><span style="color: #bf568b;">tuple</span><span style="color: #405c79;">(l))</span></div>
</div>
<p>该函数用于求一个序列或可迭代对象的平均值，为了弥补 <code>len()</code> 函数不可作用于可迭代对象的缺点，它在内部将其转换为元组。但是真正使用的结果可能出乎意料：</p>
<div class="codeblock code-console">&gt;&gt;&gt; average(map(lambda x: x ** 2, range(10)))<br />
Traceback (most recent call last):<br />
File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br />
File "&lt;stdin&gt;", line 2, in average<br />
ZeroDivisionError: division by zero</div>
<p>这段代码直接产生了错误。不过定义的函数不长，稍微分析就能发现问题所在：序列的长度变成 0 了，因此发生了错误。</p>
<p>这就是对同一个生成器两次迭代带来的后果，在第一次使用 <code>sum()</code> 函数时，它就会隐式迭代生成器，迭代完成后，生成器就变空了，因此第二次得到的是一个空序列，自然就会出错。</p>
<h2>生成器的高级用法</h2>
<h3>生成器与递归调用</h3>
<p>普通的函数允许递归，通过在函数中调用自身是实现循环的一种方式。而生成器函数有时为了实现类似迭代生成的功能，也会需要类似递归的用法。</p>
<p>考虑以下生成器，该生成器用于将一个任意嵌套的列表碾平成一维列表：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">ls = [</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">1</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, [</span><span style="color: #bf8b56;">2</span><span style="color: #405c79;">, </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">a</span><span style="color: #405c79;">'</span><span style="color: #405c79;">, [[</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">hello</span><span style="color: #405c79;">'</span><span style="color: #405c79;">], </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">w</span><span style="color: #405c79;">'</span><span style="color: #405c79;">], </span><span style="color: #bf8b56;">6</span><span style="color: #405c79;">], [[[</span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">o</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]], </span><span style="color: #bf8b56;">7</span><span style="color: #405c79;">, </span><span style="color: #bf8b56;">9</span><span style="color: #405c79;">], </span><span style="color: #405c79;">'</span><span style="color: #56bf8b;">d</span><span style="color: #405c79;">'</span><span style="color: #405c79;">]</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">flatten</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">nest</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in nest:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> not </span><span style="color: #8b56bf;">isinstance</span><span style="color: #405c79;">(i, </span><span style="color: #bf568b;">list</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> i</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf8b56;">...</span></div>
</div>
<p>首先看看生成器该如何处理这种问题：首先生成器遍历列表的每一个元素，如果已经是一个基本的元素，那就将其生成出来。如果是一个嵌套的列表的话，那么应该将该列表内的元素生成出来，再次嵌套的列表继续作类似处理。</p>
<p>上下级之间以相同的逻辑处理，这就很符合递归的一些特性。但是注意，如果按照普通函数递归的思路，可能有些人的第一印象是写作</p>
<div class="vscode-block">
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> flatten(i)</span></div>
</div>
<p>这是完全错误的写法，因为仔细分析该语句的目的是生成出了一个生成器对象作为本次迭代的结果。回想一下，函数递归的特点是函数在函数体调用时，又在内部调用自身，是 <code>return func()</code> 这种嵌套调用的形式而不是 <code>return func</code> 直接把函数对象返回。</p>
<p>类比这种特点，那么生成器在递归时，也应该是生成器函数在生成值时，包含了一个自身的生成器，并将自身生成的结果作为生成的结果。</p>
<p>这种说法可能有点绕，下面借用代码说明。以下是函数递归的特性，函数在调用时，又在内部调用自身：</p>
<div class="codeblock code-template">
    func(...)&nbsp; <span class="codetoken comment"># function call</span><br />
<strong>=&gt;</strong> func(...)&nbsp; <span class="codetoken comment"># nested function call</span></div>
<p>那么，生成器函数的递归思路也是如此。生成器函数在迭代时，又在内部迭代自身：</p>
<div class="codeblock code-template">
    <strong>for</strong> i in gener(...):<br />
&nbsp; &nbsp; ...&nbsp; &nbsp; <span class="codetoken comment"># generator iterate</span><br />
<strong>=&gt;</strong> <strong>for</strong> i in gener():<br />
<strong>=&gt;</strong> &nbsp; &nbsp; &nbsp; ...&nbsp; <span class="codetoken comment"># nested generator iterate</span></div>
<p>这样，上述生成器递归部分的代码为：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> k in flatten(i):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> k</span></div>
</div>
<p>生成器在迭代自身时，自身的迭代过程又迭代了自身，这就是递归的过程。</p>
<p>以上代码的检验结果为：</p>
<div class="codeblock code-console">&gt;&gt;&gt; list(flatten(ls))<br />
['1', 2, 'a', 'hello', 'w', 6, 'o', 7, 9, 'd']</div>
<p>可以看到它很好地完成了工作。并且这种情况下生成器比函数的递归调用方便，因为这种混乱嵌套的列表，很难将其拆解成上下级的递推关系。</p>
<p>实际上，Python 中还新增了组合关键字 <code>yield from</code> ，用于生成器的递归调用。也就是说，以上递归部分可以简单地改成：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield from</span><span style="color: #405c79;"> flatten(i)</span></div>
</div>
<p>这样的表述非常清晰，每次遇到一个 <code>yield from</code> ，就转从另一个生成器里面生成结果，这样就实现了生成器的递归。</p>
<p>以下再次给出了一个生成器函数示例，该生成器函数从一个给定的文件夹中找出文件，如果遇到嵌套的文件夹，它便递归地从嵌套的文件夹中找出包含的文件：</p>
<div class="vscode-block">
<div><span style="color: #bf568b;font-weight: bold;">import</span><span style="color: #405c79;"> os</span></div>
<div><span style="color: #bf568b;font-weight: bold;">def</span><span style="color: #405c79;"> </span><span style="color: #8b56bf;">get_files</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">dir</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> f in os.listdir(</span><span style="color: #8b56bf;">dir</span><span style="color: #405c79;">):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; path = os.path.join(</span><span style="color: #8b56bf;">dir</span><span style="color: #405c79;">, f)</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> os.path.isfile(path):</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield</span><span style="color: #405c79;"> path</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">else</span><span style="color: #405c79;">:</span></div>
<div><span style="color: #405c79;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span style="color: #bf568b;font-weight: bold;">yield from</span><span style="color: #405c79;"> get_files(path)</span></div>
</div>
<p>这样就可以实现文件的搜索功能。</p>
<h3>生成器表达式</h3>
<p>除了使用函数和 <code>yield</code> 关键字创建生成器外，简短的生成器还有另一种创建方式：</p>
<div class="vscode-block">
<div><span style="color: #405c79;">g = (i ** </span><span style="color: #bf8b56;">2</span><span style="color: #405c79;"> </span><span style="color: #bf568b;font-weight: bold;">for</span><span style="color: #405c79;"> i in </span><span style="color: #8b56bf;">range</span><span style="color: #405c79;">(</span><span style="color: #bf8b56;">1000</span><span style="color: #405c79;">) </span><span style="color: #bf568b;font-weight: bold;">if</span><span style="color: #405c79;"> isprime(i))</span></div>
</div>
<p>熟悉列表解析语法的读者应该可以很容易理解它的语法。列表解析的介绍可以参见 <a href="javascript: alert('还没发布呢')">这篇文章</a> 。</p>
<div class="codeblock code-console">&gt;&gt;&gt; g<br />
&lt;generator object &lt;genexpr&gt; at 0x0000013CD934F890&gt;<br />
&gt;&gt;&gt; type(g)<br />
&lt;class 'generator'&gt;</div>
<p>这种最外层使用圆括号的语法不是什么元组解析，而是生成器表达式，它本质就是一个生成器。这种短小的生成器表达式一般用于简单的应用场景中。</p>
<p><!-- finished(all):2022-05-27 --></p>
<p><a rel="nofollow" href="/archives/262">Python函数式编程07 生成器</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/262/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
