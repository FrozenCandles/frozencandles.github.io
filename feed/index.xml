<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>冰封残烛的个人小站</title>
	<atom:link href="http://localhost/wordpress/feed?simply_static_page=3162" rel="self" type="application/rss+xml" />
	<link></link>
	<description>FrozenCandle&#039;s Personal Site</description>
	<lastBuildDate>Thu, 18 May 2023 03:00:18 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.2.1</generator>

<image>
	<url>/wp-content/uploads/2022/02/cropped-preview-2-150x150.jpg</url>
	<title>冰封残烛的个人小站</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>积分表(上)</title>
		<link>/archives/1116</link>
					<comments>/archives/1116#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 17 May 2023 14:25:17 +0000</pubDate>
				<category><![CDATA[微积分]]></category>
		<guid isPermaLink="false">/?p=1116</guid>

					<description><![CDATA[<p>注意：本页面含有大量公式，加载时渲染较慢。 常用不定&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1116">积分表(上)</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[

<p><span class="text-frame">注意：本页面含有大量公式，加载时渲染较慢。</span></p>
    
<h2>常用不定积分积分表</h2>

<h3>多项式类</h3>

<h4 id="anchor-case-1">含有 <span class="math">\\( ax+b \\)</span> 的积分</h4>

<div class="math">
\\[
    \begin{align}
    (1). \cques{\int \frac{\dd x}{ax+b}} &= \frac 1 a \int \frac{\dd (ax)}{ax+b} = \frac 1 a \int \frac{\dd (ax+b)}{ax+b} \\
        &= \cansw{\frac 1 a \ln |ax+b| + C}
    \end{align}
\\]
</div>
<div class="math">
\\[
    \begin{align}
    (2). \cques{\int (ax+b)^\mu \dd x} &= \frac 1 a \int (ax+b)^\mu \dd (ax+b) = \frac 1 a \cdot \frac 1 {\mu+1} \int (\mu+1) (ax+b)^\mu \dd (ax+b) \\
        &= \cansw{\frac 1 {a(\mu+1)} (ax+b)^{\mu+1} \qquad (\mu \neq -1)}
    \end{align}
\\]
</div>
<div class="math">
\\[
    \begin{align}
    (3). \cques{\int \frac{x}{ax+b} \dd x} &= \frac 1 a \int \frac {ax+b-b}{ax+b} \dd x = \frac 1 a \int \left(1 - \frac b{ax+b}\right) \dd x\\
        &= \frac 1 a \int \dd x - \frac 1 a \int \frac b {ax+b} \dd x = \cansw{\frac x a - \frac b {a^2} \ln |ax+b| + C}
    \end{align}
\\]
</div>
<div class="math">
\\[
    \begin{align}
    (4). \cques{\int \frac {x^2}{ax+b} \dd x} &= \int \bigg( \frac x a - \frac b {a^2} + \cfrac{\cfrac{b^2}{a^2}}{ax+b} \bigg) \dd x
        = \frac 1 a \int x \dd x - \frac b {a^2} \int \dd x + \frac {b^2} {a^2} \int \frac{\dd x}{ax+b} \\
        &= \cansw{\frac {1}{2a} x^2 - \frac b {a^2} x + \frac {b^2} {a^3} \ln|ax+b|+C}
    \end{align}
\\]
</div>
<div class="math">
    \\[
    \begin{align}
    (5). \cques{\int \frac{\dd x}{x(ax+b)}} &= \int \bigg(\frac{A_1}{x} + \frac{A_2}{ax+b}\bigg) \dd x = \int \bigg(\frac{\cfrac{1}{b_1}}{x} + \frac{-\cfrac a b}{ax+b}\bigg) \dd x \\
        &= \frac 1 b \int \frac 1 x \dd x - \frac a b \int \frac{1}{ax+b} \dd x = \frac 1 b \ln |x| - \frac 1 b \ln|ax+b| +C \\
        &= \cansw{\frac 1 b \ln|\frac{x}{ax+b}| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (6). \cques{\int \frac{\dd x}{x^2(ax+b)}} &= \int \bigg(\frac{A_1} x + \frac{A_2}{x^2} + \frac{A_3}{ax+b}\bigg) \dd x
        = \int \bigg(\frac{-\cfrac{a}{b^2}}{x} + \frac{\cfrac{1}{b}}{x^2} + \frac{\cfrac{a^2}{b^2}}{ax+b} \bigg) \dd x \\
        &= - \frac{a}{b^2}\int \frac{1}{x} \dd x + \frac 1 b \int \frac{1}{x^2} \dd x + \frac {a^2}{b^2} \int \frac 1 {ax+b} \dd x \\
        &= -\frac a {b^2} \ln |x| - \frac 1 b \cdot \frac 1 x + \frac a {b^2} \ln |ax+b| + C \\
        &= \cansw{\frac a {b^2} \ln \bigg|\frac{ax+b}{x}\bigg|-\frac 1 {bx} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (7). {\cques{ \int \frac{x}{(ax+b)^2} \dd x }} = \int \bigg(\frac {A_1}{ax+b} + \frac {A_2}{(ax+b)^2}\bigg)\dd x
        = \int \bigg(\frac {\cfrac 1 a}{ax+b} + \frac {-\cfrac b a}{(ax+b)^2}\bigg)\dd x\\
        = \frac 1 a \int \frac{\dd x}{ax+b} - \frac b a \int \frac{\dd x}{(ax+b)^2}
        = \cansw{\frac 1 {a^2} \ln |ax+b|+\frac {b} {a^2(ax+b)} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (8). \cques{\int \frac{x^2}{(ax+b)^2} \dd x} &= \int \bigg(\frac 1 {a^2} + \frac{-\cfrac{2b} a x - \cfrac{a^2}{b^2}}{(ax+b)^2}\bigg) \dd x
        = \int \bigg(\frac 1 {a^2} + \frac{A_1}{ax+b} + \frac{A_2}{(ax+b)^2}\bigg) \dd x \\
        &= \int \bigg(\frac 1 {a^2} + \frac{-\cfrac{2b}{a^2}}{ax+b} + \frac{\cfrac{b^2}{a^2}}{(ax+b)^2}\bigg) \dd x
        = \cansw{\frac 1 {a^2} x - \frac{2b}{a^3} \ln |ax+b|-\frac {b^2} {a^3} \cdot \frac 1 {ax+b}}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (9). \cques{\int \frac{\dd x}{x(ax+b)^2}}&=\int \bigg(\frac{A_1}x + \frac{A_2}{ax+b} + \frac{A_3}{(ax+b)^2}\bigg)\dd x
        =\int \bigg(\frac{\cfrac 1 {b^2}}x + \frac{-\cfrac a {b^2}}{ax+b} + \frac{-\cfrac a b}{(ax+b)^2}\bigg)\dd x\\
        &= \frac 1 {b^2} \ln |x| - \frac 1 {b^2} \ln|ax+b| - \frac 1 b \cdot \frac 1 {ax+b} + C\\
        &= \cansw{\frac 1 {b^2} \ln \bigg|\frac x {ax+b}\bigg| - \frac 1 {b(ax+b)} + C\\}
    \end{align}
    \\]
</div>

<h4 id="anchor-case-2">含有 <span class="math">\\( \quB \\)</span> 的积分</h4>

<div class="math">
    \\[
    \begin{align}
    (10). \cques{\int \quB\dd x} &= \frac 1 a \int (ax+b)^\frac 1 2 \dd (ax)
        = \frac {2}{3a}\int \frac 3 2 (ax+b)^\frac 1 2 \dd (ax+b)\\
        &= \cansw{\frac {2}{3a}(ax+b)^\frac 3 2 + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (11). \cques{\int x \quB \dd x} 
        &= \frac 1 a \int (ax+b-b) (ax+b)^{\frac 1 2} \dd x 
         = \frac 1 a \int (ax+b)^{\frac 3 2} \dd x - \frac b a \int (ax+b)^{\frac 1 2} \dd x \\
        &= \frac 2 {5a^2} (ax+b)^{\frac 5 2} - \frac{2b}{3a^2}(ax+b)^{\frac 3 2} + C = \cansw{\frac 2{15a^2}(3ax-2b)(ax+b)^{\frac 3 2} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (12). \cques{\int x^2 \quB \dd x} &= \frac 1 {a^2} \int [(ax+b)^2-2abx-b^2] \quB \dd x\\
        &= \frac 1 {a^2} \int (ax+b)^{\frac 5 2} \dd x - \frac {2b} a \int x \quB \dd x - \frac {b^2}{a^2} \int \quB \dd x \\
        &= \frac 2 {7a^3}(ax+b)^{\frac 7 2} - \frac {2b}{a} \left[ \frac 2{15a^2}(3ax-2b)(ax+b)^{\frac 3 2} \right] - \frac {2b^2}{3a^3}(ax+b)^\frac 3 2\\
        &= \cansw{\frac 2 {15a^3} (3a^2x^2-4abx+8b^2)(ax+b)^{\frac 3 2} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (13). \cques{\int \fc x {\quB} \dd x} &= \fc 1 a \int \fc {\quA - b}{\sqrt{\quA}} \dd x = \fc 1 a \int (\quA)^{\fc 1 2} \dd x - \fc b a \int (\quA)^{-\fc 1 2} \dd x\\
        &= \cansw{\fc 2 {3a^2}(ax-2b)\quB + C}
    \end{align}
    \\]
</div>

<div class="math">
    \\[
    \begin{align}
    (14). \cques{\int \fc {x^2}{\quB} \dd x} &= \fc 1 {a^2} \int \fc {(\quA)^2-2abx-b^2}{\quB} \dd x \\
        &= \fc 1 {a^2} \int (\quA)^{\fc 3 2} - \fc {2b} a \int \fc x {\quB} \dd x - \fc {b^2}{a^3} \int \fc 1 {\quB} \dd x\\
        &= \fc 2 {5a^3}(\quA)^\fc 5 2 - \fc {2b} a \left[ \fc 2 {3a^2}(ax-2b)\quB \right] - \fc {2b^2}{a^3} (\quA)^\fc 1 2 + C \\
        &= \cansw{\fc 2 {15a^3}(3a^2x^2-4abx+8b^2)\quB + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (15). \cques{\int \fc {\dd x }{x \quB}} &\xlongequal{\textstyle u=\quB} \int \cfc {\cfc 1 a 2u \dd u}{\cfc{u^2-b} a u} = 2 \int \fc {\dd u}{u^2-b} \\
        &= \begin{cases}
            (b > 0) &\displaystyle \int \fc 1 {\sq{b}} \left( { \fc 1 {u-\sq{b}} - \fc 1 {u+\sq{b}} } \right) \dd u
            = \fc 1 {\sq{b}} \ln \left| {\fc {u-\sq{b}}{u+\sq{b}}} \right| + C \\
            (b &lt; 0) &\displaystyle 2 \int \fc 1 {1 + (\cfc {u}{\sq{-b}} )^2} \dd u = \fc 2 {\sq{-b}} \arctan \left(\cfc {u}{\sq{-b}} \right) + C
        \end{cases} \\
        
        &= \cansw{
            \begin{cases}
                (b > 0) &\displaystyle \fc 1 {\sq{b}} \ln \left| {\fc {\quB-\sq{b}}{\quB+\sq{b}}} \right| + C\\
                (b &lt; 0) &\displaystyle \fc 2 {\sq{-b}} \arctan \sq{\cfc {\quA}{-b}}  + C
            \end{cases}
        } \\


    \end{align}
    \\]
</div>

<div class="math">
    \\[
    \begin{align}
    (18). \cques{\int \fc {\quB} {x^2} \dd x} &= \int \quB \dd \abig(){-\frac 1 x} = -\fc 1 x \quB - \int - \fc 1 x \dd (\quB) \\
        &= \cansw{-\fc{\quB}{x} + \fc a 2 \int \fc{\dd x}{x \quB} = \dots}
    \end{align}
    \\]
</div>

<div class="math">
    \\[
    \begin{align}
    (17). \cques{\int \fc {\quB}{x} \dd x} &\xlongequal{\textstyle u=\quB} \int \fc {au}{u^2-b} \cdot \fc 1 a 2u \dd u = \int \fc{2u^2}{u^2-b} \dd u\\
        &= \int \abig(){2+\fc{2b}{u^2-b}} \dd u =  2u + b \int \fc{2\dd u}{u^2-b} \\
        &= \cansw{2 \quB + b \int \fc{\dd x}{x \quB} = \dots}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (16). \cques{\int \fc{\dd x}{x^2 \quB}} &= \int \bigg( \fc {A_1 \quB}{x^2} + \fc {A_2}{x \quB} \bigg)\dd x = \int \bigg( \fc {\cfc 1 b \quB}{x^2} + \fc {-\cfc a b}{x \quB} \bigg)\dd x \\
        &= \cansw{\fc 1 b\int \fc {\quB} {x^2} \dd x - \fc a b \int \fc{\dd x}{x \quB} = -\fc{\quB}{bx} - \fc a {2b} \int \fc{\dd x}{x \quB} = \dots}
    \end{align}
    \\]
</div>

<h4 id="anchor-case-3">含有 <span class="math">\\( x^2\pm a^2 \\)</span> 的积分</h4>

<div class="math">
    \\[
    \begin{align}
    (19). \cques{\int \fc {\dd x}{x^2+a^2}} &= \int \fc {\dd \cfc x a}{1+(\cfc x a)^2}\\
        &= \cansw{\fc 1 a \arctan \fc x a + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (21). \cques{\int \fc {\dd x}{x^2-a^2}} &= \int \fc 1 {2a} \left( \fc 1 {x-a} - \fc 1 {x+a} \right) \dd x 
        = \fc 1 {2a} \left( \int \fc {\dd (x-a)}{x-a} - \int \fc {\dd (x+a)}{x+a} \right) \\
        &= \cansw{\fc 1 {2a} \ln \left| \fc{x-a}{x+a} \right| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (20). \cques{\int \fc {\dd x}{(x^2+a^2)^n}} &= \fc x {(x^2+a^2)^n} - \int x \dd \abig[]{\fc 1 {(x^2+a^2)^n}}
        = \fc x {(x^2+a^2)^n} - \int x \cdot \fc {-n}{(x^2+a^2)^n} \cdot 2x \dd x \\
        &= \fc x {(x^2+a^2)^n} + 2n \int \fc {x^2+a^2-a^2}{(x^2+a^2)^{n+1}} \dd x\\ 
        &= \fc x {(x^2+a^2)^n} + 2n \int \fc 1 {(x^2+a^2)^n} \dd x - 2na^2 \int \fc 1 {(x^2+a^2)^{n+1}} \dd x
    \end{align}
    \\]
</div>
<div class="math">
\\[
    \quad \text{so, } \quad
    \cques{\int \fc {\dd x}{(x^2+a^2)^{n+1}}} = \cansw{\fc x {2na^2(x^2+a^2)^n} + \fc {2n-1}{2na^2} \int \fc {\dd x}{(x^2+a^2)^n} + C} 
\\]
</div>
<!-- 
<div class="math">
    \\[
    \begin{align}
    (). \cques{\int} &=
        &= \cansw{ + C}
    \end{align}
    \\]
</div> -->
<!-- 
<div class="math">
    \\[
    \begin{align}
    (). \cques{\int} &=
        &= \cansw{ + C}
    \end{align}
    \\]
</div> -->

<h4 id="anchor-case-4">含有 <span class="math">\\( \quC \quad (a>0) \\)</span> 的积分</h4>

<div class="math">
    \\[
    \begin{align}
    (22). \cques{\int \fc {\dd x}{\quC}} &= 
        \begin{cases}
            (b>0) & \displaystyle \int \fc {\dd x}{(\sq{a}x)^2 + (\sq{b})^2} \xlongequal[\textstyle d=\sq{b}]{\textstyle u=\sq a x} 
                \fc 1 {\sq a} \int \fc {\dd u}{u^2 + d^2} \\
            (b&lt;0) & \displaystyle \int \fc {\dd x}{(\sq{a}x)^2 - (\sq{-b})^2} \xlongequal[\textstyle d=\sq{-b}]{\textstyle u=\sq a x} 
                \fc 1 {\sq a} \int \fc {\dd u}{u^2 - d^2} 
        \end{cases} \\
        &= \begin{cases}
            (b>0) & \displaystyle \fc 1 {\sq a d} \arctan \fc u d + C = \cansw{\fc 1 {\sq {ab}} \arctan \sq{\fc a b} x + C} \\
            \displaystyle
            (b&lt;0) & \displaystyle \fc 1 {2\sq a d} \ln \abig||{\fc{u-d}{u+d}} + C = \cansw{\fc 1 {2\sq {-ab}} \ln \abig||{\fc{\sq a x - \sq{-b}}{\sq a x + \sq{-b}}} + C}
        \end{cases}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (23). \cques{\int \fc x {\quC}} \dd x &= \fc 1 2 \int \fc {\dd (x^2)}{\quC} \\
        &= \fc 1 {2a} \int \fc {\dd (\quC)}{\quC} = \cansw{\fc 1 {2a} \ln |\quC| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (24). \cques{\int \fc {x^2}{ax^2+b} \dd x} &= \fc 1 a \int \fc {ax^2+b-b}{ax^2+b} \dd x = \fc 1 a \int (1-\fc {b}{ax^2+b}) \dd x\\
        &= \cansw{\fc x a - \fc b a \int \fc {\dd x}{\quC} + C = \dots}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (25). \cques{\int \fc {\dd x}{x(\quC)}} &= \int \abig(){\fc {A_1} x + \fc {A_2 x + A_3}{\quC}} \dd x = \int \bigg( {\fc {\cfc 1 b} x + \fc {-\cfc a b x}{\quC}} \dd x \bigg) \\
        &= \cansw{\fc 1 b \ln |x| - \fc a b \int \fc x {\quC} \dd x + C = \fc 1 {2b} \ln \abig||{\fc {x^2}{\quC}} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (26). \cques{\int \fc {\dd x}{x^2(\quC)}} &= \int \abig(){\fc {A_1} {x^2} + \fc {A_2}{\quC}} \dd x 
        = \int \bigg( \fc {\cfc 1 b}{x^2} + \fc{-\cfc a b}{\quC} \bigg) \dd x \\
        &= \cansw{-\fc 1 {bx} - \fc a b \int \fc {\dd x}{\quC} + C = \dots}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (27). \cques{\int} & \xlongequal{\textstyle x = \sq u} \int \fc {\cfc 1 {2 \sq u} \dd u}{u \sq u (au+b)} = \cansw{\fc 1 2 \int \fc {\dd u}{u^2(au+b)} + C} \\
        &= \cansw{- \fc 1 {2bx^2} + \fc a {2b^2} \ln \abig||{\fc {ax^2+b}{x^2}} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (28). \cques{\int \fc {\dd x}{(\quC)^2}} &= \fc 1 {2a} \int \fc {x \dd x}{x (\quC)^2} = \fc 1 {2a} \int \fc {\dd (\quC)}{x (\quC)^2} 
        = - \fc 1 {2a} \int \fc 1 x \dd \abig(){\fc 1 \quC} \\
        &= \cansw{- \fc 1 {2ax(\quC)} - \fc 1 {2a} \int \fc {\dd x}{x^2(\quC)} + C} \\
        &= \cansw{\fc x {2b(\quC)} + \fc 1 {2b} \int \fc {\dd x}{\quC}}
    \end{align}
    \\]
</div>

<h4 id="anchor-case-5">含有 <span class="math">\\( \quD \quad (a>0) \\)</span> 的积分</h4>

<div class="math">
    \\[
    \begin{align}
    (29). \cques{\int \fc {\dd x}{\quD}} &= \int \fc {\dd x} {a \abig(){x+\cfc b {2a}}^2 + \cfc {4ac-b^2}{4a}}
        \xlongequal[\textstyle d = \dfc {4ac-b^2}{4a}]{\textstyle u = x + \dfc b {2a}} \cansw{ \int \fc {\dd u}{au^2+d} } \\
        &= \cansw{\begin{cases} 
            (4ac-b^2>0) & \displaystyle \fc 2 {\sq {4ac-b^2}} \arctan \fc {2ax+b}{\sq {4ac-b^2}} + C \\
            (4ac-b^2 &lt; 0) & \displaystyle \fc 1 {\sq {b^2-4ac}} \ln \abig||{\fc {2ax+b-\sq{b^2-4ac}}{2ax+b+\sq{b^2-4ac}}} + C
        \end{cases}}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (30). \cques{\int \fc x {\quD} \dd x} &= \fc 1 2 \int \fc {\dd x^2} {\quD} = \fc 1 {2a} \int \fc {\dd (\quD)}{\quD} - \fc 1 {2a} \int \fc {\dd (bx+c)}{\quD} \\
        &= \cansw{\fc 1 {2a} \ln |\quD| - \fc b {2a} \int \fc {\dd x}{\quD} + C}
    \end{align}
    \\]
</div>

<h3>三角换元类</h3>

<h4 id="anchor-case-6">含有 <span class="math">\\( \quE \quad (a>0) \\)</span> 的积分</h4>

<div class="math">
    \\[
    \begin{align}
    (31). \cques{\int \fc {\dd x}{\quE}} & \xeqt{x=a\tan t} \int \fc {a \sec^2 t}{a\sec t} \dd t = \int \sec t \dd t = \ln |\sec t + \tan t| + C_1\\
        &= \ln \abig||{\fc{\quE} a + \fc x a} + C_1 = \cansw{\ln |\quE+x| + C}
    \end{align}
    \\]
</div>

<p>注：这部分常用的换元为：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/05/integral-table-xatant.png" alt="" width="380">
</figure>

<div class="math">
    \\[
    \begin{align}
    (32). \cques{\int \fc {\dd x}{(\quE)^3}} & \xeqt{x=a\tan t} \int \fc {a\sec^2 t \dd t}{a^3 \sec^3 t} = \fc 1 {a^2} \int \cos t \dd t\\
        &= \fc {\sin t}{a^2} + C = \cansw{\fc x {a^2\quE} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (33). \cques{\int \fc x {\quE} \dd x} &= \int \fc {\dd (x^2+a^2)}{2\quE}
        = \cansw{\quE + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (34). \cques{\int \fc x {(\quE)^3}} \dd x &= \int (x^2+a^2)^{-\fc 3 2} \cdot \fc 1 2 \dd (x^2+a^2)
        = \cansw{- (x^2+a^2)^{-\fc 1 2} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (41). \cques{\int x \quE \dd x} &= \fc 1 2 \int (x^2+a^2)^{\fc 1 2} \dd (x^2+a^2) = \cansw{\fc 1 3 (x^2+a^2)^{\fc 3 2} + C}
    \end{align}
    \\]
</div>

<p>这里插播一个常用定理：</p>

<div class="math">
\\[
\begin{align}
    \int \sec ^n x \dd x &= \int \sec ^{n-2} x \dd (\tan x) = \int \tan x \sec ^{n-2} x - \int \tan x \dd (\sec ^{n-2} x) \\
        &= \tan x \sec ^{n-2} x - \int (n-2) \sec ^{n-2} x \tan^2 x \dd x \\
        &= \tan x \sec ^{n-2} x - \int (n-2) \sec ^{n-2} x (\sec^2 x - 1) \dd x  \\
        &= \tan x \sec ^{n-2} x - (n-2) \int sec ^n x \dd x + (n-2) \int \sec ^{n-2} x \dd x
\end{align}
\\]
</div>

<p>所以 <span class="math">\\( \displaystyle \cansw{\int \sec^n x \dd x = \fc {\tan x \sec ^{n-2} x}{n-1} + \fc {n-2}{n-1} \int \sec^{n-2} x \dd x} \\)</span> </p>

<p>可以推出：</p>

<div class="math">
\\[
    \int \sec^3 x \dd x = \fc 1 2 (\tan x \sec x + \ln |\sec x + \tan x|) + C
\\]
</div>
<div class="math">
\\[
    \int \sec^5 x \dd x = \fc {\tan x \sec ^3 x} 4 + \fc 3 8 (\tan x \sec x + \ln|\sec x+ \tan x |)+C
\\]
</div>

<div class="math">
    \\[
    \begin{align}
    (35). \cques{\int \fc {x^2}{\quE} \dd x} & \xeqt{x=a\tan t} \int \fc {a^2\tan^2 t}{a\sec t} \cdot a \sec ^2 t \dd t = a^2 \int (\sec ^2 t - 1) \sec t \dd t \\
        &= a^2 \int \sec ^3 t \dd t + a^2 \int \sec t \dd t 
        = \fc {a^2} 2 \tan t \sec t - \fc {a^2} 2 \ln |\sec t + \tan t| + C_1 \\
        &= \cansw{\fc 1 2 x \quE - \fc {a^2}2 \ln|x+\quE| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (36). \cques{\int \fc {x^2}{(\quE)^3} \dd x} & \quEsub \int \fc {a^2\tan^2 t}{a^3\sec^3 t} a \sec^2 t \dd t \\
        &= \int \fc {\sec^2 t - 1}{\sec t} \dd t = \int \sec t \dd t - \int \cos t \dd t \\
        &= \cansw{\ln |x+\quE| - \fc x {\quE} + C}
    \end{align}
    \\]
</div>

<div class="math">
    \\[
    \begin{align}
    (37). \cques{\int \fc {\dd x}{x \quE}} &\quEsub \int \fc 1 {a \tan t \cdot a \sec t} a \sec^2 t \dd t \\
        &= \fc 1 a \int \csc t \dd t = \cansw{\fc 1 a \ln \abig||{\fc {\quE - a} x} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (38). \cques{\int \fc {\dd x}{x^2 \quE}} & \quEsub \int \fc 1 {a^2 \tan^2 t} \cdot \fc 1 {a \sec t} \cdot a \sec^2 t \dd t\\
        &= \fc 1 {a^2} \int \fc {\sec t }{\tan ^2 t} \dd t = \fc 1 {a^2} \int \fc {\cos t}{\sin^2 t}\dd t = \fc 1 a^2 \cdot -\fc 1 {\sin t} \\  
        &= \cansw{- \fc {\quE}{a^2x} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (39). \cques{\int \sq {x^2+a^2} \dd x} & \quEsub \int a \sec t \cdot a \sec ^2 t \dd t = a^2 \int \sec ^3 t \dd t \\
        &= \fc {a^2} 2 (\tan t \sec t + \ln |\sec t + \tan t|+C) \\
        &= \cansw{\fc {x\quE} 2 + \fc {a^2} 2 \ln |x+\quE| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (40). \cques{\int (\quE)^3 \dd x} & \quEsub \int a^3 \sec ^3 t \cdot a \sec^2 t \dd t = a^4 \int \sec ^5 t \dd t \\
        &= a^4\bigg[\fc {x (x^2+a^2)^{\fc 3 2}}{4a^4} + \fc 3 8 \abig(){\fc {x\quE}{a^2} + \ln \abig||{\fc x a+\fc {\quE} a}}\bigg] + C_1 \\
        &= a^4 \abig[]{\fc {\quE}{4a^4} x (x^2+a^2) + \fc 3 {2a} x \fc {\quE}{4a}+ \fc 3 8 \ln |x + \quE|} + C\\
        &=\cansw{x\quE \fc {2x^2+5a^2} 8 + \fc 3 8 a^4 \ln |x+\quE| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (42). \cques{\int x^2 \quE \dd x} & \quEsub \int a^2 \tan^2 t \cdot a \sec t \cdot a \sec^2 t \dd t = \int a^4 (\sec^2 t - 1) \sec^3 t \dd t\\
        &= a^4 \int \sec^5 t \dd t - a^4 \int \sec ^3 t \dd t
        = \fc {a^4} 4 \tan t\sec ^3 t - \fc {a^4} 8 \tan t\sec t - \fc {a^4} 8 \ln |\sec t +\tan t| + C_1 \\
        &= \cansw{\fc {x\quE} 8 (2x^2+a^2) - \fc {a^4} 8 \ln|x+\quE| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (43). \cques{\int \fc {\quE}x \dd x } & \quEsub \int \fc {a\sec t}{a\tan t } \cdot a \sec ^2 \dd t = a \int \fc {\sec t}{\tan t} (1+\tan^2 t) \dd t \\
        &= a\int \csc t \dd t + a \int \sec t \tan t \dd t = a \ln |\csc t - \cot t| + a \sec t + C_1\\
        &= \cansw{a\ln \abig||{\fc {\quE - a} x} + \quE + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (44). \cques{\int \fc{\quE}{x^2} \dd x} & \quEsub \int \fc {a\sec t }{a^2 \tan^2 t } \cdot a \sec^2 \dd t = \int \fc {\sec t}{\tan^2 t}(1+\tan^2 t) \dd t\\
        &= \int \fc {\cos t }{\sin^2 t} \dd t + \int \sec t \dd t = -\fc 1 {\sin t}+ \ln|\sec t +\tan t | + C_1 \\
        &= \cansw{-\fc {\quE} x + \ln|x+\quE| + C}
    \end{align}
    \\]
</div>

<h4 id="anchor-case-7">含有 <span class="math">\\( \quF \quad (a>0) \\)</span> 的积分</h4>

<div class="math">
    \\[
    \begin{align}
    (47). \cques{\int \fc x {\quF} \dd x} &= \int \fc {\dd (\quFF)}{2\quF} \dd x 
        = \cansw{\quF + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (48). \cques{\int \fc x {(\quF)^3} \dd x} &= \int (\quFF)^{-\fc 3 2} \cdot \fc 1 2 \dd (\quFF)
        = \cansw{-(\quFF)^{\fc 1 2} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (55). \cques{\int x \quF \dd x} &= \int (\quFF)^{\fc 1 2} \cdot \fc 1 2 \dd (\quFF)
        = \cansw{\fc 1 3 (\quFF)^{\fc 3 2} + C}
    \end{align}
    \\]
</div>

<div class="math">
    \\[
    \begin{align}
    (45). \cques{\int \fc {\dd x}{\quF}} & \quFsub \int \fc {a\sec t \tan t \dd t}{a\tan t} = \int \sec t \dd t \\
        &= \ln|\fc{\quF} a + \fc x a| + C_1 = \cansw{\ln|\quF + x| + C}
    \end{align}
    \\]
</div>

<p>注：这部分常用的换元为：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/05/integral-table-xasect.png" alt="" width="440">
</figure>

<div class="math">
    \\[
    \begin{align}
    (46). \cques{\int \fc {\dd x}{(\quF)^3}} & \quFsub \int \fc{a\sec t \tan t \dd t}{a^3\tan^3 t} \\
        &= \fc 1 {a^2} \int \fc {\cos t}{\sin^2 t} \dd t = - \fc 1 {a^2 \sin t}
        = \cansw{-\fc x {a^2 \quF} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (49). \cques{\int \fc {x^2}{\quF} \dd x} & \quFsub \int \fc {a^2 \sec ^2 t}{a \tan t} \cdot a\sec t \tan t \dd t = a^2 \int \sec ^3 t \dd t \\
        &= \fc {a^3} 2 (\tan t \sec t + \ln |\sec t + \tan t|) + C_1\\
        &= \cansw{\fc 1 2 x\quF + \fc {a^2}2 \ln |\quF + x| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (50). \cques{\int \fc {x^2}{(\quF)^3} \dd x} & \quFsub \int \fc {a^2 \sec^2 t}{(a\tan t)^3} a\sec t \tan t \dd t = \int \csc^2 t\sec t \dd t\\
        &= \int \sec t \cdot -\dd (\cot t) = -\sec t \cot t + \int \cot t \dd (\sec t)\\
        &= -\csc t + \int \sec t \dd t = \cansw{-\fc x {\quF} + \ln|x+\quF| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (52). \cques{\int \fc {\dd x}{x^2 \quF}} & \quFsub \int \fc {a \sec t \tan t \dd t}{a^2 \sec^2 t \cdot a\tan t}\\
        &= \fc 1 {a^2} \int \cos t \dd t = \fc {\sin t}{a^2} +C = \cansw{\fc {\quF}{a^2x} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (53). \cques{\int \quF \dd x} & \quFsub \int a\tan t \cdot a \sec t \tan t \dd t = a^2 \int \sec t (\sec^2 t - 1) \dd t\\
        &= a^2 \int \sec^3 t \dd t - a^2 \int \sec t \dd t = \fc {a^2} 2 (\tan t \sec t ) - \fc {a^2} 2 \ln |\sec t + \tan t | + C_1\\
        &= \cansw{\fc {x\quF} 2 - \fc {a^2} 2 \ln |x + \quF| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (54). \cques{\int (\quF)^3 \dd x} & \quFsub \int a^3 \int a^3 \tan^3 t \cdot a\sec t \tan t \dd t = a^4 \int (\sec^2 t - 1)^2 \sec t \dd t\\
        &= a^4 \int \sec^5 t \dd t - 2 a^4 \int \sec^3 t \dd t + a^4 \int \sec t \dd t \\
        &= \fc 1 4 a^4 \tan t \sec^3 t - \fc 5 8 a^4 \tan t\sec t + \fc 3 8 a^4 \ln|\sec t + \tan t| + C_1\\ 
        &= \cansw{\fc 1 8 (2x^2-5a^2) x\quF + \fc 3 8 a^4 \ln|x+\quF| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (56). \cques{\int x^2 \quF \dd x} & \quFsub \int a^2 \sec^2 t \cdot a \tan t \cdot a \sec t \tan t \dd t = a^4 \int \sec^3 t (\sec^2 t - 1) \dd t\\
        &= a^4 \int \sec^5 t \dd t - a^4 \int \sec^3 t \dd t \\
        &= \fc {a^4} 4 \tan t \sec^3 t - \fc 1 8 a^4 \tan t \sec t - \fc 1 8 a^4 \ln |\sec t + \tan t| + C_1\\
        &= \cansw{\fc 1 8 (2x^2-a^2) x\quF - \fc {a^4} 8 \ln |x+\quF| + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (58). \cques{\int \fc {\quF} {x^2} \dd x} &= \int \quF \dd \abig(){-\fc 1 x} = -\fc{\quF}x + \int \fc 1 x \dd (\quF)\\
        &= -\fc{\quF}x + \int \fc 1 x \cdot \fc {2x \dd x}{2\quF} = -\fc{\quF}x + \int \fc {\dd x}{\quF}\\ 
        &= \cansw{-\fc{\quF}x + \ln|x+\quF| + C}
    \end{align}
    \\]
</div>

<div class="math">
    \\[
    \begin{align}
    (51). \cques{\int \fc {\dd x}{x \quF}} & \quFsub \int \fc {a\sec t \tan t}{a\sec t \cdot a\tan t} \dd t = \fc 1 a \int \dd t = \fc t a\\
        &= \cansw{\fc 1 a \arccos \fc a {|x|} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (57). \cques{\int \fc{\quF}x \dd x} & \quFsub \int \fc {a\tan t}{a\sec t} \cdot a\sec t\tan t \dd t = a \int (\sec^2 t -1) \dd t = a \tan t - at\\
        &= \cansw{\quF - a\arccos \fc a {|x|} + C}
    \end{align}
    \\]
</div>

<h4>含有 <span class="math">\\( \quG \quad a>0 \\)</span> 的积分</h4>

<div class="math">
    \\[
    \begin{align}
    (61). \cques{\int \fc x {\quG} \dd x} &= \int \fc {-\dd(\quGG)}{2\quG}
        = \cansw{-\quG + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (62). \cques{\int \fc x {(\quG)^3} \dd x} &= \int (\quGG)^{-\fc 3 2} \cdot -\dd (\quGG)
        = \cansw{(\quGG)^{-\fc 1 2} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (69). \cques{\int x\quG \dd x} &= \int (\quGG)^{-\fc 1 2} \cdot -\fc 1 2 \dd (\quGG) = \cansw{-\fc 1 3 (\quGG)^{\fc 3 2} + C}
    \end{align}
    \\]
</div>

<div class="math">
    \\[
    \begin{align}
    (59). \cques{\int \fc {\dd x}{\quG}} & \quGsub \int \fc{a\cos t \dd t}{a\cos t} = \int \dd t = t\\
        &= \cansw{\arcsin \fc x a + C}
    \end{align}
    \\]
</div>

<p>注：这部分常用的换元为：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/05/integral-table-xasint.png" alt="" width="370">
</figure>

<div class="math">
    \\[
    \begin{align}
    (60). \cques{\int \fc {\dd x}{(\quG)^3}} & \quGsub \int \fc{a\cos t \dd t}{(a\cos t)^3} = \fc 1 {a^2} \int \sec^2 t \dd t\\
        &= \fc 1 {a^2} \tan t + C \cansw{\fc x {a^2 \quG} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (63). \cques{\int \fc {x^2}{\quG} \dd x} & \quGsub \int \fc{a^2\sin^2 t}{a\cos t} a\cos t \dd t = a^2 \int \sin^2 t \dd t\\
        &= a^2 \int \fc {1-\cos 2t} 2 \dd t = \fc {a^2} 2 \int \dd t - \fc{a^2} 4 \int \cos 2t \dd (2t) \\
        &= \fc {a^2} 2 t - \fc {a^2} 4 2\sin t \cos t + C = \cansw{\fc {a^2} 2 \arcsin \fc x a - \fc 1 2 x \quG + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (64). \cques{\int \fc {x^2}{(\quG)^3} \dd x} & \quGsub \int \fc{a^2\sin^2 t}{(a\cos t)^3} a\cos t \dd t = \int \tan^2 t \dd t\\
        &= \int \sec^2 t \dd t - \int \dd t = \tan t - t = \cansw{\fc x {\quG} - \arcsin \fc x a + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (65). \cques{\int \fc {\dd x}{x\quG}} & \quGsub \int \fc {a\cos t \dd t}{a\sin t \cdot a \cos t} = \fc 1 a \int \csc t \dd t\\
        &= \fc 1 a \ln |\csc t - \cot t| + C = \cansw{\fc 1 a \ln \abig||{\fc {a-\quG} x} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (66). \cques{\int \fc {\dd x}{x^2 \quG}} & \quGsub \int \fc {a\cos t \dd t}{a^2 \sin^2 t \cdot a \cos t} = \fc 1 {a^2} \int \csc^2 t \dd t\\
        &= -\fc 1 {a^2} \cot t + C = \cansw{-\fc {\quG}{a^2 x} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (67). \cques{\int \quG \dd x} & \quGsub \int a \cos t \cdot a \cos t \dd t = a^2 \int \fc {1+\cos 2t} 2 \dd t \\
        &= \fc {a^2} 2 \int \dd t + \fc {a^2} 4 \int \cos 2t \dd (2t) = \text{ref (63).} \\
        &= \cansw{\fc {a^2} 2 \arcsin \fc x a + \fc 1 2 x \quG + C}
    \end{align}
    \\]
</div>

<p>这里插播一个也算常用定理：</p>

<div class="math">
\\[
\begin{align}
    \int \cos^n \dd x &= \int \cos^{n-1} \dd (\sin x) = \sin x \cos^{n-1} x - \int \sin x \dd (\cos^{n-1} x)\\
        &= \sin x \cos^{n-1} x - (n-1)\int \sin x \cos^{n-2} x \cdot -\sin x \dd x\\
        &= \sin x \cos^{n-1} x + (n-1) \int \cos^{n-2} x \dd x - (n-1)\int \cos ^n x \dd x
\end{align}
\\]
</div>

<p>因此有以下规律：</p>

<div class="math">
\\[
    \cansw{\int \cos^n x \dd x = \fc {\sin x \cos^{n-1} x} n + \fc {n-1} n \int \cos ^{n-2} x \dd x}
\\]
</div>

<div class="math">
    \\[
    \begin{align}
    (68). \cques{\int (\quG)^3 \dd x} & \quGsub \int a^3 \cos^3 t \cdot a \cos t \dd t = a^4 \int \cos^4 t \dd t\\
        &= a^4 \abig(){\fc {\sin t \cos^3 t} 4 + \fc {3\sin t \cos t} 8 + \fc {3t} 8 } + C\\
        &= \cansw{\fc {5a^2 - 2x^2} 8 x\quG + \fc 3 8 a^4 \arcsin \fc x a + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (70). \cques{\int x^2 \quG \dd x} & \quGsub \int a^2\sin^2 t \cdot a\cos t \cdot a\cos t \dd t = a^4 \int \cos^2 t (1-\cos^2 t) \dd t \\
        &= -a^4 \cos^4 t \dd t + a^4 \int \cos^2 t \dd t \\
        &= -a^4 \cos^4 t \dd t + \fc {4a^2} 8 x\quG + \fc {4a^4} 8 \arcsin \fc x a \\
        &= \cansw{\fc {2x^2-a^2} 8 x\quG + \fc 1 8 a^4 \arcsin \fc x a + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (71). \cques{\int \fc {\quG}x \dd x} & \quGsub \int \fc {a\cos t}{a\sin t} a\cos t \dd t  = a\int \fc {1-\sin^2 t}{\sin t} \dd t \\
        &= a\int \csc t \dd t - a\int \sin t \dd t = \ln |\csc t - \cot t| + \cos t \\
        &= \cansw{\quG + a \ln \abig||{\fc {a-\quG} x} + C}
    \end{align}
    \\]
</div>
<div class="math">
    \\[
    \begin{align}
    (72). \cques{\int \fc {\quG} {x^2} \dd x} & \quGsub \int \fc {a\cos t}{a\sin t} a\cos t \dd t = \int \cot^2 t \dd t \\
        &= \int (\csc^2 t - 1) \dd t = -\cot t - t = \cansw{-\fc {\quG} x - \arcsin \fc x a + C}
    \end{align}
    \\]
</div>



<p></p>
<p><a rel="nofollow" href="/archives/1116">积分表(上)</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1116/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>微积分-泰勒展开式</title>
		<link>/archives/1094</link>
					<comments>/archives/1094#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Thu, 04 May 2023 08:05:14 +0000</pubDate>
				<category><![CDATA[微积分]]></category>
		<category><![CDATA[数学]]></category>
		<guid isPermaLink="false">/?p=1094</guid>

					<description><![CDATA[<p>泰勒展开式 泰勒展开式的由来 在数学中，加法、减法、&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1094">微积分-泰勒展开式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>泰勒展开式</h2>

<h3>泰勒展开式的由来</h3>

<p>在数学中，加法、减法、乘法和除法是四种最基本、也是最简单的运算。要计算任意复杂的加法、减法、乘法和除法在内的混合运算，只需要熟记九九乘法表，再结合竖式就可以计算得到最终的结果。</p>

<p>多项式函数是由常数和变量之间的加、减、乘以及幂次方运算得到的，它的表达式为：</p>

<div class="math">
\\[
a_0 + a_1 x + a_2 x^2 + \cdots + a_n x^n + \cdots
\\]
</div>

<p>多项式函数可以算是比较友好的函数，因为给定一个 <span class="math">\\( x \\)</span> ，可以比较容易地计算出函数的值。而且多项式函数求导、积分运算也非常方便。</p>

<p>但并不是所有表达式的计算都很简单，也不是所有函数的结果都易于求出。在几种初等函数中，三角函数 <span class="math">\\( \sin(x) \\)</span> 就是这样一个例子。虽然有一些特殊情况例如 <span class="math">\\( \sin(\cfrac{\pi}{6})=\cfrac 1 2 \\)</span> ，但是想要求出 <span class="math">\\( \sin(2.36) \\)</span> 这种值，目前似乎并没有一个已知的工具能快速、准确地给出它的精确或近似精确的解。</p>

<p>其余的几个基本函数也存在这种问题，例如对于 <span class="math">\\( e^{7.52} \\)</span> ，这种非整数次幂就很难直接计算出。因此，这些函数虽然性质很简单，但真正需要计算的时候却难以下手。这时候就会想到，这些函数是否能像多项式函数一样，借用基本的四则运算工具就能计算结果。</p>

<p>也就是说，是否有可能存在这样一个多项式函数</p>

<div class="math">
\\[
    g(x) = a_0 + a_1 x + a_2 x^2 + \cdots + a_n x^n + \cdots
\\]
</div>

<p>和一些复杂的函数 <span class="math">\\( f(x) = e^x/\sin x /\cos x \\)</span> 能够相等，或者说至少在某一个范围能至少能近似相等，这样就可以使用多项式函数去计算复杂函数任一点处的值了，就像这样：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/05/04-taylor-derive-step-0.png" alt="" width="410">
</figure>

<p>这个多项式函数是 <span class="math">\\( \displaystyle{g(x) = x-\frac 1 6 x^3 + \frac 1 {120} x^5 - \frac 1 {5040} x^7 + \frac 1 {362880} x^9} \\)</span> ，它与 <span class="math">\\( f(x)=\sin(x) \\)</span> 在 <span class="math">\\( [-3,3] \\)</span> 范围内表现出惊人的相似性，<span class="math">\\( f(3) \\)</span> 与 <span class="math">\\( g(3) \\)</span> 的差值只有 <span class="math">\\( 0.0042 \\)</span> ，<span class="math">\\( f(1) \\)</span> 与 <span class="math">\\( g(1) \\)</span> 的差值更是只有 <span class="math">\\( 0.000000025 \\)</span> ，这个精度用于计算已经很高了。</p>

<p>一个四项的多项式函数就能和 <span class="math">\\( \sin(x) \\)</span> 在一定范围内如此接近，有理由相信可能存在一个项数更多的多项式函数，它能在更大的范围内接近 <span class="math">\\( \sin(x) \\)</span> ，或者在此范围内更接近 <span class="math">\\( \sin(x) \\)</span> 甚至完全一致。接下来研究如果这样的多项式函数如果存在，它需要满足怎么样的一个规律或性质。</p>

<hr>

<p>如果</p>

<div class="math">
    \\[
    \begin{align}
        g(x) &amp;= a_0 + a_1 x + a_2 x^2 + \cdots + a_n x^n + \cdots\\
        f(x) &amp;= e^x/\sin x /\cos x/\cdots
    \end{align}
    \\]
</div>

<p>这两个函数能够相等的话，那么对于定义域内任意一点 <span class="math">\\( x_0 \\)</span> ，总有 <span class="math">\\( f(x_0)=g(x_0) \\)</span> 。</p>

<p>当然，这两个函数不一定能完全相等，不过这两个函数哪怕能在一个点的附近能够近似相等，也非常具有研究价值。<span class="math">\\( x=0 \\)</span> 是一个比较特殊的点，因为该点处 <span class="math">\\( g(x) \\)</span> 除了第一项外其余项的结果都为 <span class="math">\\( 0 \\)</span> ；并且对于函数 <span class="math">\\( f(x)=e^x/\sin x /\cos x \\)</span> 它们在 <span class="math">\\( x=0 \\)</span> 处的值也是容易求得的，分别为 <span class="math">\\( 1/0/1 \\)</span> 。</p>

<p>接下来就以 <span class="math">\\( x=0 \\)</span> 附近为例，研究这两个函数的相等条件。如果这附近能存在 <span class="math">\\( f(x)=g(x) \\)</span> ，它必定要满足以下条件：</p>

<div class="math">
\\[
\begin{align}
    g(0) &amp;= a_0 + a_1 \cdot 0 + a_2 \cdot 0^2 + \cdots + a_n \cdot 0^n + \cdots\\
        &amp;= a_0\\
        &amp;= f(0)
\end{align}
\\]
</div>

<p>这样就可以解出 <span class="math">\\( a_0 = f(0) \\)</span> 了。</p>

<p>但好像除了 <span class="math">\\( x=0 \\)</span> ，不存在其它的特殊点能够解出其它参数了。不过实际上对 <span class="math">\\( x=0 \\)</span> 这个点的研究并没有结束。<span class="math">\\( f(0)=g(0) \\)</span> 真的能说明两个函数在 <span class="math">\\( x=0 \\)</span> 附近完全一致吗？例如以下两个函数：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/05/04-taylor-derive-step-1.png" alt="" width="290">
</figure>

<p>如果只看 <span class="math">\\( x=0 \\)</span> 附近的范围，可以发现两个函数虽然值的大小相近，但是值的<em>变化率</em>或者说函数图像的<em>倾斜程度</em>并不相近，这就会导致 <span class="math">\\( f(x) \\)</span> 和 <span class="math">\\( g(x) \\)</span> 在离开 <span class="math">\\( x=0 \\)</span> 后立刻就不相等了，并且离得越远差异越大。这样就会使得用这个多项式函数计算一个很接近但不完全是 <span class="math">\\( x=0 \\)</span> 附近的函数值，结果和原函数值的差距可能也很大。</p>

<p>说到变化率，很自然就联想到<a>导数</a>。也就是说两者的导函数必须要在 <span class="math">\\( x=0 \\)</span> 处相等，即 <span class="math">\\( g'(0)=f'(0) \\)</span> 。</p>

<p>对于这三个函数 <span class="math">\\( e^x/\sin x /\cos x \\)</span> ，它们的导数分别为 <span class="math">\\( e^x/\cos x /-\sin x \\)</span> 。而它们导数在 <span class="math">\\( x=0 \\)</span> 这一点的值也容易求得，分为为 <span class="math">\\( 1/1/0 \\)</span> 。</p>

<p>而多项式函数 <span class="math">\\( g(x) \\)</span> 的导数为：</p>

<div class="math">
\\[
    g'(x) = 0 + a_1 \cdot 1 + a_2 \cdot 2 x + a_3 \cdot 3 x^2 + \cdots + a_n \cdot n x^{x-1} + \cdots
\\]
</div>

<p>容易发现，<span class="math">\\( x=0 \\)</span> 仍然是一个特殊点，该点处 <span class="math">\\( g'(x) \\)</span> 除了第二项外其余项的结果都为 <span class="math">\\( 0 \\)</span> 。也就是说，如果要使 <span class="math">\\( f(x) \\)</span> 和 <span class="math">\\( g(x) \\)</span> 在离开 <span class="math">\\( x=0 \\)</span> 后还能保持一小段距离的相等，它们在 <span class="math">\\( x=0 \\)</span> 的增长率需要一致，也就是说要满足以下条件：</p>

<div class="math">
\\[
\begin{align}
    g'(0) &amp;= 0 + a_1 \cdot 0 + a_2 \cdot 0 + a_3 \cdot 0 + \cdots + a_n \cdot 0 + \cdots\\
        &amp;= a_1\\
        &amp;= f'(0)
\end{align}
\\]
</div>

<p>不过一阶导数相等还不能说明两者在 <span class="math">\\( x=0 \\)</span> 附近就能完全一致，例如：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/05/04-taylor-derive-step-2.png" alt="" width="280">
</figure>

<p>可以看到，虽然两者在 <span class="math">\\( x=0 \\)</span> 附近确实保持了一段距离近似相等，但没过一会这个差距又迅速拉开了。这种情况说明两者的变化率虽然在一点处相等，但是<em>凹凸性</em>并不相等，也可以说两者<em>变化率的变化率</em>不等。</p>

<p>说到这两个指标，可以想到二阶导数。也就是说，两者的二阶导函数也需要在 <span class="math">\\( x=0 \\)</span> 处相等。而多项式函数的二阶导数为：</p>

<div class="math">
    \\[
        g''(x) = 0 + 0 + a_2 \cdot 2 + a_3 \cdot 3 \cdot 2 x + \cdots + a_n \cdot n \cdot (n-1) x^{x-2} + \cdots
    \\]
</div>

<p>对于二阶导数，<span class="math">\\( x=0 \\)</span> 处 <span class="math">\\( g''(x) \\)</span> 除了第三项外其余项的结果都为 <span class="math">\\( 0 \\)</span> 。也就是说，如果要使 <span class="math">\\( f(x) \\)</span> 和 <span class="math">\\( g(x) \\)</span> 在离开 <span class="math">\\( x=0 \\)</span> 后增长率保存一致，并且增长率的变化也保持一致，那就要使两者在 <span class="math">\\( x=0 \\)</span> 的加速度相等，即：</p>

<div class="math">
    \\[
    \begin{align}
        g''(0) &amp;= 0 + 0 + a_2 \cdot 2 + a_3 \cdot 0 + \cdots + a_n \cdot 0 + \cdots\\
            &amp;= a_2 \cdot 2\\
            &amp;= f''(0)
    \end{align}
    \\]
</div>

<p>根据这个规律推广下去，如果要让多项式函数和它“模仿”的原函数在 <span class="math">\\( x=0 \\)</span> 附近完全等价，就要求两者在该点处的任意阶导数相等。而这么一直推导下去可以得到如下规律：</p>

<div class="math">
\\[
    \begin{align}
    g'''(x) &amp;=6a_3+24a_4x+60x^2+ \cdots +n(n-1)(n-2)x^{n-3}+ \cdots = f'''(x) \\
    g^{(4)}(x) &amp;=24a_4+120x+ \cdots +n(n-1)(n-2)(n-3)x^{n-4}+ \cdots = f^{(4)}(x) \\
     &amp;\vdots\\
    g^{(n)}(x) &amp;=n!a_n + (n+1)!a_{n+1}x + \cdots = f^{(n)}(x)
    \end{align}
\\]
</div>

<p>如果要使两者在 <span class="math">\\( x=0 \\)</span> 附近完全等价，那么令各式中的 <span class="math">\\( x=0 \\)</span> ，就有如下规律：</p>

<div class="math">
\\[
\begin{align}
    g(0)    &amp;= a_0   = f(0) \\
    g'(0)   &amp;= a_1   = f'(0) \\ 
    g''(0)  &amp;= 2a_2  = f''(0) \\
    g'''(0) &amp;= 6a_3  = f'''(0) \\
    g^{(4)}(0) &amp;= 24a_4  = f^{(4)}(0) \\
    &amp;\cdots \\
    g^{(n)}(0) &amp;= n!a_n = f^{(n)}(0)
\end{align}
\\]
</div>

<p>也就是说，通过每一阶的导数，都可以解出多项式每一项的系数：</p>

<div class="math">
\\[
    a_0=f(0) \quad a_1=\frac{f'(0)}{1!} \quad
    a_2=\frac{f''(0)}{2!} \quad a_3=\frac{f'''(0)}{3!}
    \quad \cdots \quad
    a_n=\frac{f^{(n)}(0)}{n!}
\\]
</div>

<p>于是，可以得到 <span class="math">\\( f(x) \\)</span> 在 <span class="math">\\( x=0 \\)</span> 处的展开式：</p>

<div class="math">
\\[
\begin{align}
    f(x) &amp;= g(x)\\
        &amp;=\frac{f(0)}{0!}+\frac{f'(0)}{1!}x+\frac{f''(0)}{2!}x^2+\frac{f'''(0)}{3!}x^3
            + \cdots + \frac{f^{(n)}(0)}{n!}x^n + \cdots
\end{align}
\\]
</div>

<p>以上公式称为<strong>麦克劳林(Maclaurin)展开式</strong>。麦克劳林展开式表明如果要用一个多项式函数和一个任意复杂的函数在 <span class="math">\\( x=0 \\)</span> 处完全等价，那么这个多项式函数是什么。</p>

<p>该展开式有一个缺点，就是只能用于计算 <span class="math">\\( x=0 \\)</span> 附近等价的多项式，而对其它点不适用；而且如果 <span class="math">\\( f(x) \\)</span> 在 <span class="math">\\( x=0 \\)</span> 处没有定义或不可导，那么麦克劳林展开式似乎就失效了。</p>

<p>不过这个缺点也很好解决：如果函数 <span class="math">\\( f(x) \\)</span> 在 <span class="math">\\( x=x_0 \\)</span> 处任意阶可导，只需把该函数平移到原点就可以应用麦克劳林展开式。<span class="math">\\( f(x) \\)</span> 向左平移 <span class="math">\\( x_0 \\)</span> 距离的结果为 <span class="math">\\( f(x-x_0) \\)</span> ，就是把所有的 <span class="math">\\( x \\)</span> 改写成 <span class="math">\\( x-x_0 \\)</span> 的方式。这便是<strong>泰勒(Taylor)展开式</strong>的一般形式：</p>

<div class="math">
\\[
    \begin{align}
    f(x)&amp;=g(x)\\
    &amp;=f(x_0)+\frac{f'(x_0)}{1!}(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+\frac{f'''(x_0)}{3!}(x-x_0)^3
    + \cdots + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + \cdots
    \end{align}
\\]
</div>

<h3>佩亚诺余项</h3>

<p>当对函数应用泰勒展开式时，它只有展开项数趋于无穷时，两者才能在某点附近完全相等。但无穷项根本不可能用于计算，实际中总是希望只使用一个有限的多项式</p>

<div class="math">
\\[
p(x)=f(x_0)+\frac{f'(x_0)}{1!}(x-x_0)+\frac{f''(0)}{2!}(x-x_0)^2+ \cdots + \frac{f^(n)(0)}{n!}(x-x_0)^n
\\]
</div>

<p>来表示它。其余被忽略的部分称为<strong>余项</strong>，记作 <span class="math">\\( R(x) \\)</span> 。因此一个函数的展开式也可以表示为多项式和余项之和 <span class="math">\\( f(x)=p(x)+R(x) \\)</span> 。</p>

<p>注意到泰勒展开的一个特点是，展开越多，项的次数越大，余项的次数全都比多项式的次数大，因此余项在 <span class="math">\\( x_0 \\)</span> 附近，它收敛到 0 的速度要远比多项式快，即：</p>

<div class="math">
\\[
    \lim_{x \to x_0} \frac{R(x)}{p(x)} =\lim_{x \to x_0} \cfrac{
        \cfrac{f^{(n+1)}(x_0)}{(n+1)!}(x-x_0)^{n+1}+\cfrac{f^{(n+2)}(x_0)}{(n+2)!}(x-x_0)^{n+2}+\cdots
    }{
        \cfrac{f^{(n)}(0)}{n!}(x-x_0)^n + \cfrac{f^{(n-1)}(0)}{(n-1)!}(x-x_0)^{n-1} +\cdots
    }=0
\\]
</div>

<p>使用洛必达法则也很容易求解这个极限。所以<strong>佩亚诺(Peano)余项</strong>将其表示为一个高阶无穷小 <span class="math">\\( R(x)=o((x-x_0)^n) \\)</span> 。</p>

<p>泰勒展开式的项是无限多的，而佩亚诺余项则引入了“精度”这一概念：可以根据外界环境精度的要求，决定需要展开到几项多项式，后续的部分则可以省略。这就像将一个无限小数四舍五入到某一位一样。</p>

<p>例如，假设要求以下极限的值：</p>

<div class="math">
\\[
    \lim_{x \to 0} \frac{\tan x - x}{x^3}
\\]
</div>

<p>这里的精度要求是 <span class="math">\\( x^3 \\)</span> ，更高次的项可以忽略，那么可以将 <span class="math">\\( \tan x \\)</span> 在 <span class="math">\\( x=0 \\)</span> 展开为带有佩亚诺余项的多项式：</p>

<div class="math">
\\[
    (x\to 0) \quad \tan x = x + \frac{x^3}{3} + o(x^3)
\\]
</div>

<p>这时极限的结果就非常容易求得了：</p>

<div class="math">
\\[
    \begin{align}
    \lim_{x \to 0} \frac{\tan x - x}{x^3} &amp;= \lim_{x \to 0} x + \cfrac{x + \cfrac{x^3}{3} + o(x^3) - x}{x^3}\\
    &amp;= \lim_{x \to 0} \frac{x^3}{3 \cdot x^3} = \frac 1 3
    \end{align}
\\]
</div>

<h3>拉格朗日余项</h3>

<p>佩亚诺余项使用无穷小的方式来表示余项，这样做虽然简单直接，在很多计算极限问题中很有用，但它终究还是回避了“余项到底有多大”这个主题，这就使得当 <span class="math">\\( x \\)</span> 稍微远离 <span class="math">\\( x_0 \\)</span> 时，佩亚诺余项不能用于估算有限的多项式和原函数的误差。</p>

<p>在之前的学习中，已经知道了柯西中值定理。如果 <span class="math">\\( f(x) \\)</span> 在 <span class="math">\\( [x_1,x_2] \\)</span> 内连续，在 <span class="math">\\( (x_1,x_2) \\)</span> 内可导且 <span class="math">\\( g(x) \\)</span> 的导数不为 0 ，则有：</p>

<div class="math">
\\[
    \frac{f(x_1)-f(x_2)}{g(x_1)-g(x_2)}=\frac{f'(\xi)}{g'(\xi)}
\\]
</div>

<p>其中 <span class="math">\\( \xi \\)</span> 是介于 <span class="math">\\( x_1 \\)</span> 与 <span class="math">\\( x_2 \\)</span> 之间的某个值。</p>

<p>柯西中值定理的几何解释就是，由 <span class="math">\\( x \\)</span> 引导的参数方程确定的曲线，任取其中光滑的某一段，这段内一定有一点的切线斜率和两端的斜率相等：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/05/04-cauchy-mean-value.png" alt="" width="340">
</figure>

<p>而泰勒公式的余项为：</p>

<div class="math">
\\[
    R(x) = \frac{f^{(n+1)}(x_0)}{(n+1)!}(x-x_0)^{n+1}+\frac{f^{(n+2)}(x_0)}{(n+2)!}(x-x_0)^{n+2}+\cdots 
        +\frac{f^{(\infty)}(x_0)}{(\infty)!}(x-x_0)^{\infty}\\
\\]
</div>

<p>余项中的每项都不一样，不过它们都有 <span class="math">\\( S(x) = (x-x_0)^{n+1} \\)</span> 这个公因式。为了方便分析，可以先将这些公因式去除：</p>

<div class="math">
\\[
    \frac{R(x)}{S(x)}
\\]
</div>

<p>不过先不急着展开，分子分母这两个函数都有一个点比较特殊，就是 <span class="math">\\( x=x_0 \\)</span> ：在 <span class="math">\\( x=x_0 \\)</span> 处，有 <span class="math">\\( R(x)=S(x)=0 \\)</span> ，所以可以应用柯西中值定理：</p>

<div class="math">
\\[
\frac{R(x)}{S(x)}=\frac{R(x)-R(x_0)}{S(x)-S(x_0)}=\frac{R'(\xi)}{S'(\xi)}
\\]
</div>

<p>其中 <span class="math">\\( \xi \\)</span> 为介于 <span class="math">\\( x \\)</span> 和 <span class="math">\\( x_0 \\)</span> 的某个值。这样便可以使用这两个多项式等价之前的余项和公因式：</p>

<div class="math">
\\[
\begin{align}
R'(\xi) &amp;= \frac{f^{(n+1)}(x_0)}{(n)!}(\xi-x_0)^{n}+\frac{f^{(n+2)}(x_0)}{(n+2)!}(\xi-x_0)^{n+1}+\cdots \\
S'(\xi) &amp;= (n+1)(\xi-x_0)^{n}
\end{align}
\\]
</div>

<p>因为 <span class="math">\\( \xi \\)</span> 可能是介于 <span class="math">\\( x \\)</span> 和 <span class="math">\\( x_0 \\)</span> 的任意值，因此这两个多项式可以看作关于 <span class="math">\\( \xi \\)</span> 的函数。而它们在 <span class="math">\\( \xi=x_0 \\)</span> 处，仍有：<span class="math">\\( R'(\xi)=S'(\xi)=0 \\)</span> ，故上式仍然可以运用柯西中值定理：</p>

<div class="math">
\\[
\frac{R'(\xi)}{S'(\xi)}=\frac{R'(\xi)-R'(x_0)}{S'(\xi)-S'(x_0)}=\frac{R''(\xi_2)}{S''(\xi_2)}
\\]
</div>

<p>其中 <span class="math">\\( \xi_2 \\)</span> 为介于 <span class="math">\\( \xi \\)</span> 和 <span class="math">\\( x_0 \\)</span> 之间的某个值。考虑到 <span class="math">\\( \xi \\)</span> 是介于 <span class="math">\\( x \\)</span> 和 <span class="math">\\( x_0 \\)</span> 之间的某个值，实际上 <span class="math">\\( \xi_2 \\)</span> 也是这个范围内的值。</p>

<p>像这样多次应用柯西中值定理，可以得出：</p>

<div class="math">
\\[
\frac{R(x)}{S(x)}=\frac{R'(\xi)}{S(\xi)}=\frac{R''(\xi_2)}{S''(\xi_2)}=\cdots=
\frac{R^{(n+1)}}{S^{(n+1)}}=\frac{R^{(n+1)}(\xi_{n+1})}{(n+1)!}
\\]
</div>

<p>柯西中值定理是一个将函数与导数相关联的定理。对多项式求导是一种<em>降低次数</em>的过程：因为 <span class="math">\\( R^{(n+1)}(x)=f^{(n+1)}(x)-p^{(n+1)}(x) \\)</span> ，而 <span class="math">\\( p(x) \\)</span> 的最高次为 <span class="math">\\( n \\)</span> ，所以经过 <span class="math">\\( n+1 \\)</span> 次求导，多项式 <span class="math">\\( p^{(n+1)}(x)=0 \\)</span> ，这种情况下 <span class="math">\\( R^{(n+1)}(x)=f^{(n+1)}(x) \\)</span> ，余项将决定原函数的走向，所以有 <span class="math">\\( R^{(n+1)}(\xi)=f^{(n+1)}(\xi) \\)</span> 。整理得</p>

<div class="math">
\\[
R(x)=\frac{R^{(n+1)}(\xi_{n+1})}{(n+1)!}S(x)=\frac{f^{(n+1)}(\xi_{n+1})}{(n+1)!}(x-x_0)^{n+1}
\\]
</div>

<p>其中 <span class="math">\\( \xi_{n+1} \\)</span> 为介于 <span class="math">\\( x \\)</span> 与 <span class="math">\\( x_0 \\)</span> 之间的某个值。以上的余项记作 <span class="math">\\( R_n(x) \\)</span> ，称作<strong>拉格朗日(Lagrange)余项</strong>。</p>

<p>拉格朗日余项表明，如果以多项式 <span class="math">\\( p(x) \\)</span> 近似表达函数 <span class="math">\\( f(x) \\)</span> 时，两者的误差为 <span class="math">\\( |R_n(x)| \\)</span> 。如果多项式的最高项 <span class="math">\\( n \\)</span> 是确定的，在 <span class="math">\\( x \\)</span> 与 <span class="math">\\( x_0 \\)</span> 范围内函数 <span class="math">\\( n+1 \\)</span> 阶导数的界限 <span class="math">\\( |f^{(n+1)}(x)| \le M \\)</span> 已知，那么误差的估计式为：</p>

<div class="math">
\\[
    |R_n(x)| \le \frac{M}{(n+1)!}|x-x_0|^{n+1}
\\]
</div>

<p>利用以上估计式，就可以得知利用有限项多项式计算的精度，这在数值计算时很有用。</p>

<h2>泰勒展开与级数</h2>

<!-- <p class="text-indent" css-text-indent="4em">注：以下内容需要无穷级数相关知识。</p> -->

<p>通过之前对泰勒展开式的介绍可以知道，泰勒展开式使用多项式在某点附近模拟一个函数。例如，<span class="math">\\( \sin x \\)</span> 在 <span class="math">\\( x=0 \\)</span> 附近的展开式（麦克劳林展开）为：</p>

<div class="math">
\\[
\sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} + \dots + \frac{(-1)^n x^{2n+1}}{(2n+1)!}
\\]
</div>

<p>绘制 <span class="math">\\( \sin x \\)</span> 逐项展开后的函数图像如下：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/05/04-expand-sinx.png" alt="" width="500">
</figure>

<p>观察以上展开式可以发现，随着展开的项数越来越多，多项式向着两侧越来越贴合正弦函数的形状，这就像逐渐将一根铁丝掰成波浪线的过程。</p>

<p>接下来考虑泰勒展开式在 <span class="math">\\( x_0 \\)</span> 附近多大的范围（邻域）上能和原函数相等。</p>

<hr>

<p>泰勒展开式是无穷多个幂函数之和，因此它是一个无穷级数，还是一个幂级数。因此泰勒展开式也可以写作：</p>

<div class="math">
\\[
f(x)=\sum\limits_{n=0}^{\infty}\frac{f^{(n)}(x_{0})}{n!}(x-x_{0})^{n}
\\]
</div>

<p>对于一个级数，首先要考虑的就是它的收敛性。如果一个级数都不收敛，那么就没有讨论的必要了。</p>

<p>幂级数收敛性有一个很重要的定理：对于形如 <span class="math">\\( \displaystyle \sum_{n=0}^{\infty} a_n(x-x_0)^n \\)</span> 的幂级数，若 <span class="math">\\( \displaystyle \lim_{n\to\infty}\left|\frac{a_{n+1}}{a_n}\right|=\frac 1 R \\)</span> ，则该幂级数在 <span class="math">\\( |x-x_0|\lt R \\)</span> 上是收敛的，至于边界上的收敛情况要单独讨论。</p>

<p>而泰勒展开的幂级数通项为：</p>

<div class="math">
\\[
P_{n}(x)=\frac{f^{(n)}(x_{0})}{n!}(x-x_{0})^{n}
\\]
</div>

<p>因此，泰勒级数的收敛半径为：</p>

<div class="math">
\\[
R=\lim_{n\to\infty}\left|\frac{a_n}{a_{n+1}}\right|=\lim_{n\to\infty}\left|\frac{(n+1)f^{(n)}(x_0)}{f^{(n+1)}(x_0)}\right|
\\]
</div>

<p>例如，对于 <span class="math">\\( e^x \\)</span> 的泰勒展开，它的每一阶导数都是相同的，这就有：</p>

<div class="math">
\\[
R=\lim_{n\to\infty}\left|\frac{a_n}{a_{n+1}}\right|=\lim_{n\to\infty}\left|\frac{(n+1)e^{x_0}}{e^{x_0}}\right|=\lim_{n\to\infty}|n+1|=\infty
\\]
</div>

<p>这说明对 <span class="math">\\( e^x \\)</span> 展开后的泰勒级数在 <span class="math">\\( \mathbb{R} \\)</span> 上全部收敛，展开式对任何 <span class="math">\\( x \\)</span> 都能计算出一个值。</p>

<p>既然泰勒展开的级数在这些范围内收敛，接下来看看它到底收敛到什么程度。以 <span class="math">\\( \sin x \\)</span> 为例，它在 <span class="math">\\( x=0 \\)</span> 处展开后，其展开式在任意 <span class="math">\\( x \\)</span> 处的拉格朗日余项为：</p>

<div class="math">
\\[
R(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}
\\]
</div>

<p><span class="math">\\( x \\)</span> 的各阶导数导来导去就是 <span class="math">\\( \pm\sin x \\)</span> 或 <span class="math">\\( \pm\cos x \\)</span> 中的一个，因此导数这部分产生的误差为 <span class="math">\\( f^{(n+1)}(\xi) \le 1 \\)</span> ，所以余项的误差界限为：</p>

<div class="math">
\\[
|p(x) − \sin(x)| \le \frac{|x|^{n+1}}{(n+1)!}
\\]
</div>

<p>如果让原函数展开到无限多项，那么误差就逐渐趋于以下值：</p>

<div class="math">
\\[
    \lim_{n\to\infty} \frac{|x|^{n+1}}{(n+1)!}
\\]
</div>

<p>对于这个极限，可以这样理解：分子和分母都是 <span class="math">\\( n+1 \\)</span> 个数相乘，但对于 <span class="math">\\( |x|^{n+1} \\)</span> 来说，每个相乘的数都是 <span class="math">\\( x \\)</span> ，是不变的；但 <span class="math">\\( (n+1)! \\)</span> 随着 <span class="math">\\( n \\)</span> 的无止境上升，总有那么一刻 <span class="math">\\( n \\)</span> 的大小会超过 <span class="math">\\( x \\)</span> 的大小，在这之后 <span class="math">\\( (n+1)! \\)</span> 将很快追平并超过 <span class="math">\\( |x|^{n+1} \\)</span> ，并且随着 <span class="math">\\( n \\)</span> 的无限增长，这个差距将无限扩大。因此，原极限将趋于 0 ：</p>

<div class="math">
\\[
    \lim_{n\to\infty} \frac{|x|^{n+1}}{(n+1)!}=0
\\]
</div>

<p>余项趋于 0 ，这说明 <span class="math">\\( \sin x \\)</span> 展开的泰勒级数不仅在 <span class="math">\\( \mathbb{R} \\)</span> 内收敛，并且在这个范围内还和原函数相等。</p>

<p>这个结论初看有点难以置信，泰勒展开只通过了一点上的多项式展开，却得到了整个实数范围的函数趋近。对于这个问题的理解：在一点处无穷多阶导数的信息实在是太丰富了，通过一阶导数，能预测到函数在下一个微小范围内的变化；通过二阶导数能预测到一阶导数在下一个微小范围内的变化，从而预测函数在下下个微小范围内的变化，……。这样无限多的信息便有可能预测到函数在整个实数范围的走势。</p>

<p>泰勒展开的应用非常广泛，除了求解极限问题外，泰勒展开常用于函数值以及积分和微分方程的近似计算。除此之外，利用复数域中的泰勒展开可以发现许多特别的性质。例如，对 <span class="math">\\( e^{ix} \\)</span> 的展开等价于 <span class="math">\\( \cos x+ i\sin x \\)</span> 的展开，代入 <span class="math">\\( x=\pi \\)</span> 就可以得到著名的欧拉公式 <span class="math">\\( e^{i\pi}+1=0 \\)</span> 。</p>

<h2>附录</h2>

<h3>常用函数的麦克劳林展开</h3>

<p>以下列出了常用函数的麦克劳林展开式，通过将 <span class="math">\\( x \\)</span> 改写为 <span class="math">\\( x-x_0 \\)</span> 便可以得到对应的泰勒展开式。</p>

<div class="math">
\\[
\begin{align}
(1)&amp;\quad e^x =1+x+\frac{x^2}{2!}+\cdots+\frac{x^n}{n!}+\cdots &amp;&amp;=\sum_{n=0}^{\infty}\frac{x^n}{n!} &amp;&amp; x \in \mathbb{R}\\ 
(2)&amp;\quad \sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!} + \dots + (-1)^n\frac{x^{2n+1}}{(2n+1)!}+\cdots &amp;&amp;=\sum_{n = 0}^{\infty} (-1)^n \frac{x^{2n+1}}{(2n+1)!} &amp;&amp; x \in \mathbb{R}\\
(3)&amp;\quad \cos x =1-\frac{x^2}{2!}+\frac{x^4}{4!}-\cdots+(-1)^n\frac{x^{n+1}}{n+1}+\cdots &amp;&amp;=\sum_{n=0}^{\infty}(-1)^n \frac{x^{2n}}{(2n)!} &amp;&amp; x \in \mathbb{R}\\
(4)&amp;\quad \ln (1+x) =x-\frac{x^2}{2}+\frac{x^3}{3}-\cdots+(-1)^n\frac{x^{n+1}}{n+1}+\cdots &amp;&amp;=\sum_{n=1}^{\infty} (-1)^{n-1} \frac{x^n}{n} &amp;&amp; -1 &lt; x \le 1\\
(5)&amp;\quad \frac{1}{1-x} =1+x+x^2+x^3+\cdots+x^n &amp;&amp;=\sum_{n=0}^{\infty} x^n &amp;&amp; -1&lt;x&lt;1\\
\end{align}
\\]
</div>

<h3>参考资料/延伸阅读</h3>

<p>
    <a class="link-external" href="https://www.bilibili.com/video/av11251323">https://www.bilibili.com/video/av11251323</a><br>
    3b1b 对泰勒展开式的介绍
</p>

<p>
    <a class="link-external" href="https://www.ixigua.com/6577670049224458765">https://www.ixigua.com/6577670049224458765</a><br>
    <a class="link-external" href="https://www.ixigua.com/6578415087093023239">https://www.ixigua.com/6578415087093023239</a><br>
    妈咪叔对泰勒展开式的介绍
</p>
<p><a rel="nofollow" href="/archives/1094">微积分-泰勒展开式</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1094/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>机器学习-参数选择与模型验证</title>
		<link>/archives/1081</link>
					<comments>/archives/1081#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Sat, 15 Apr 2023 09:29:37 +0000</pubDate>
				<category><![CDATA[机器学习]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1081</guid>

					<description><![CDATA[<p>在很多时候并不能直接将数据以可视化的形式表达出来，这&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1081">机器学习-参数选择与模型验证</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p>在很多时候并不能直接将数据以可视化的形式表达出来，这就意味着无法以直观的方式检验模型的分类效果。本节介绍机器学习中常用的模型验证方法以及如何选择恰当的超参数。</p>

<h2>模型检验方法</h2>

<h3>交叉验证</h3>

<p>最简单验证模型的方法就是调用模型的 <code>.score()</code> 方法，检查给定数据的准确率。例如，对于以下数据：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-output-demo-data-1.png" alt="" width="380">
</figure>

<p>接下来建立一个决策树模型并用 <code>.score()</code> 方法检查训练数据的准确率：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>tree <span token="keyword">import</span> DecisionTreeClassifier</div><br><div>model <span style="color: #7c4dff;">=</span> DecisionTreeClassifier<span token="symbol">()</span></div><div>model<span token="symbol">.</span>fit<span token="symbol">(</span>X<span token="symbol">,</span> y_true<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><div class="sklearn-model"><p>DecisionTreeClassifier()</p></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>model<span token="symbol">.</span>score<span token="symbol">(</span>X<span token="symbol">,</span> y_true<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1.0</div>
</div>

<p>结果显示模型的准确率是 100% 。当然，这种验证方法是不合理的，因为以上并没有对决策树模型做任何约束，此时可能已经发生了过拟合，因此可以 100% 拟合训练数据。</p>

<p>解决过拟合的一种思路是引入测试数据，测试数据不供模型学习，可以防止过拟合的影响。但是有时不易获取测试数据，这就需要将现有数据拆分为训练集和测试集：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>model_selection <span token="keyword">import</span> train_test_split </div><br><div>X_train<span token="symbol">,</span> X_test<span token="symbol">,</span> y_train<span token="symbol">,</span> y_test <span style="color: #7c4dff;">=</span> train_test_split<span token="symbol">(</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; X<span token="symbol">,</span> y_true<span token="symbol">,</span> <span style="color: #e53935;">random_state</span><span style="color: #7c4dff;">=</span><span token="number">6</span><span token="symbol">,</span> <span style="color: #e53935;">train_size</span><span style="color: #7c4dff;">=</span><span token="number">0.7</span><span token="symbol">)</span></div></div>
    <div class="jupyter-separator"></div>
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>model<span token="symbol">.</span>fit<span token="symbol">(</span>X_train<span token="symbol">,</span> y_train<span token="symbol">)</span></div><div>model<span token="symbol">.</span>score<span token="symbol">(</span>X_test<span token="symbol">,</span> y_test<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.9142857142857143</div>
</div>

<p>以上函数将现有数据拆分为训练集和测试集，其中训练集占所有数据的 70% 。对测试集应用 <code>.score()</code> 方法的结果表明，模型的准确率为 91.4% ，更接近模型真实的准确率。</p>

<p>直接将数据分为训练集和测试集的缺点是模型失去了一部分可用于训练的数据，且这部分数据中可能包含某些关键的信息（比如支持向量）。一个更好的思路是将数据集划分为若干部分，每次将一个部分用于检验，其它部分用于训练，这样数据集的每个部分都能用于训练和检验。这种策略称为<strong>交叉验证</strong>(cross validation)。下图展示了一个 4 轮交叉验证的构成：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-cross-validation.png" alt="" width="320">
</figure>

<p>手动拆分数据比较繁琐，不过可以借助 Scikit-Learn 提供的工具来处理：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>model_selection <span token="keyword">import</span> cross_val_score</div><br><div>scores <span style="color: #7c4dff;">=</span> cross_val_score<span token="symbol">(</span>model<span token="symbol">,</span> X<span token="symbol">,</span> y_true<span token="symbol">,</span> <span style="color: #e53935;">cv</span><span style="color: #7c4dff;">=</span><span token="number">5</span><span token="symbol">)</span></div><div>scores</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0.975, 0.9  , 0.975, 0.875, 0.925])</div>
</div>

<p>可以通过 <code><em>cv</em></code> 参数修改交叉验证的轮数，默认采用 5 轮交叉验证。对每轮交叉验证的准确率取均值，就非常接近实际的准确率了：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>scores<span token="symbol">.</span>mean<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.93</div>
</div>

<p>一种极端的情况是将交叉验证的轮数设置为和样本的个数一样多，这种情况下每次只使用一个样本用于验证，而其它的样本都用于训练，这称为留一(leave-one-out, LOO)交叉检验。要使用留一交叉验证不能直接将 <code><em>cv</em></code> 设置为样本的大小，而是需要借助 <code>LeaveOneOut</code> 类：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>model_selection <span token="keyword">import</span> LeaveOneOut</div><div>scores <span style="color: #7c4dff;">=</span> cross_val_score<span token="symbol">(</span>model<span token="symbol">,</span> X<span token="symbol">,</span> y_true<span token="symbol">,</span> <span style="color: #e53935;">cv</span><span style="color: #7c4dff;">=</span>LeaveOneOut<span token="symbol">())</span></div><div>scores<span token="symbol">.</span>mean<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.925</div>
</div>

<p>在之前的学习中认识了模型的过拟合现象。过拟合现象就是随着模型的复杂度上升，虽然对数据的拟合效果变好，但是模型的泛化程度下降，对新的数据不能很好地处理。反应在交叉验证下，就是训练集效果越来越好，但是测试集效果反而越来越差：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-cross-validation-overfitting.png" alt="">
</figure>

<p>这个曲线同时表明训练集的准确率总是比验证集的准确率高，并且随着模型复杂度的提升，训练集的准确率越来越高，甚至趋近 100% ；而验证集的准确率增长到某个值后反而开始下降。</p>

<h3>混淆矩阵</h3>

<p>以上均使用准确率作为衡量模型好坏的指标，但这可能会导致一些问题。一个准确率较高的模型不一定效果就好。例如，对于以下数据：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-output-demo-data-2.png" alt="" width=350>
</figure>

<p>假设使用逻辑回归模型拟合这些数据，并且不对数据添加额外特征，那么得到模型的准确率为：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>linear_model <span token="keyword">import</span> LogisticRegression</div><div>model <span style="color: #7c4dff;">=</span> LogisticRegression<span token="symbol">().</span>fit<span token="symbol">(</span>X<span token="symbol">,</span> y_true<span token="symbol">)</span></div><div>cross_val_score<span token="symbol">(</span>model<span token="symbol">,</span> X<span token="symbol">,</span> y_true<span token="symbol">).</span>mean<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.8181818181818183</div>
</div>

<p>82% 的准确率看似不错，但是注意到准确率会存在以下问题：对于二分类问题，如果两个分类样本数相近，那么即便模型随便预测，总体的准确率也接近 50% ；如果两个分类样本数相差较大，那么模型只要倾向于预测样本数较多的那个分类，准确率就不会差。例如对于以上数据，假设某个模型均预测为蓝色类别，那么它的准确率为：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>metrics <span token="keyword">import</span> accuracy_score</div><div>accuracy_score<span token="symbol">(</span>y_true<span token="symbol">,</span> np<span token="symbol">.</span>zeros_like<span token="symbol">(</span>y_true<span token="symbol">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.8909090909090909</div>
</div>

<p>结果甚至比逻辑回归还要好，但这种模型肯定是完全没有研究和使用价值的。</p>

<p>对于二分类模型，只有预测正确(True)和错误(False)的可能。记两种类别为正类(Positive)和负类(Negative)，那么一个模型的预测结果只有以下四种情况：</p>

<table>
    <tr>
        <th></th>
        <th>Positive（预测真）</th>
        <th>Negative（预测假）</th>
    </tr>
    <tr>
        <th>True（实际真）</th>
        <td>True Positive(TF) 正确肯定</td>
        <td>False Negative(FN) 漏报</td>
    </tr>
    <tr>
        <th>False（实际假）</th>
        <td>False Positive(FP) 虚报</td>
        <td>True Negative(TN) 正确否定</td>
    </tr>
</table>

<p>所有的评估参数都由该表中的元素组成，该表也被称为<strong>混淆矩阵</strong>(confusion matrix)。在之前一直使用准确(accuracy)率衡量模型，它的公式如下：</p>

<div class="math">
\\[
    \text{accuracy} = \frac{\text{True}}{\text{All}} = \frac{\text{TP}+\text{TN}}{\text{TP}+\text{FN}+\text{TN}+\text{FP}}
\\]
</div>

<p>这个公式的问题就在于它同时考虑了正类和反类，但两者的重要性是不一样的：样本多的类别对准确率的影响更大，但并不意味着模型应该优先满足样本多的类别的准确率。如果模型更关心正类的分类质量，那么有两个指标可以说明正类的分类效果好坏：</p>

<p>精确(precision)率：<strong>精确率</strong>用于衡量预测为正类的样本预测对的概率，即：</p>

<div class="math">
\\[
    \text{precision} = \frac{\text{True}}{\text{Predicted Positive}} = \frac{\text{TP}}{\text{TP}+\text{FP}}
\\]
</div>

<p>如果模型的精确率高，说明预测的正类大多都预测对了。不过也不能一昧只提高精确率，那样的话模型为了确保预测的正类是对的，会倾向于减少预测为正类的样本数量。另一个指标<strong>召回率</strong>(recall)用于衡量实际为正类的样本预测对的概率，即：</p>

<div class="math">
\\[
    \text{recall} = \frac{\text{True}}{\text{Actual Positive}} = \frac{\text{TP}}{\text{TP}+\text{FP}}
\\]
</div>

<p>召回率高说明实际的正类大多都找出来了。同样，一昧提高召回率也会使得模型为了尽可能找出所有正类，倾向于增加预测为正类的样本数量。</p>

<p>容易看出，精确率和召回率之间具有互补关系：如果一个模型的精确率和召回率都很高，说明模型既能找出数据集中的正类，同时也能排除不属于正类的样本（找出所有的负类），那么这个模型的效果很好。通过组合精确率和召回率可以得到一个比较通用的指标，例如常用的 <span class="math">\\( F_1 \\)</span> 分数：</p>

<div class="math">
\\[
    F_1 = \frac{2}{ \displaystyle{\frac{1}{\text{precision}}} + \displaystyle{\frac{1}{\text{recall}}} }
\\]
</div>

<p><span class="math">\\( F_1 \\)</span> 分数使用调和平均数组合这两个指标。调和平均数是总体各统计变量倒数的算术平均数的倒数，由于不知道精确率和召回率哪个指标对总体的贡献更大，因此不能使用加权平均值，而调和平均数会赋予低值更高的权重，只有当召回率和精度都很高时才能得到较高的 <span class="math">\\( F_1 \\)</span> 分数。</p>

<p>在 Scikit-Learn 中，可以通过 <var type="module" class="code-font">metrics</var> 模块提供的工具计算 <span class="math">\\( F_1 \\)</span> 分数。</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>metrics <span token="keyword">import</span> f1_score</div><div>f1_score<span token="symbol">(</span>y_true<span token="symbol">,</span> model<span token="symbol">.</span>predict<span token="symbol">(</span>X<span token="symbol">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.4</div>
</div>

<p>计算得到模型的 <span class="math">\\( F_1 \\)</span> 分数只有 0.4 ，说明对正类的分类效果完全不像整体的准确率一样还算不错。</p>

<p>有时可能需要模型必须保证找到的正类都是对的，而允许模型存在一定的漏检（例如在登录时的用户面部识别，如果将错误的样本划归为正类会招致严重的损失）；有时可能需要确保模型没有漏检，而允许模型找到的正类不必都是对的（例如查找嫌疑人时的面部识别，如果遗漏一个正类会导致严重的后果）。这时可能会更关心精确率和召回率的其中一个，除了上文中见到的准确率计算，该模块也包含精确率和召回率的计算函数，可以组合它们拼凑一个需要的指标。</p>

<h3>评估曲线</h3>

<p>以上的准确率、精确度、<span class="math">\\( F_1 \\)</span> 值等都只是一个单一的数值指标，如果想观察分类算法在不同的参数下的表现情况，就可以使用一条曲线描述。</p>

<p>ROC(Receiver Operating Characteristic, 受试者工作特征)曲线是一种用于评估二元分类器性能的工具。它的横纵坐标都是来自混淆矩阵的组合指标：</p>

<ul>
    <li>横坐标为<strong>假正例率</strong>(False Positive Rate, FPR)，表示在所有真反例中，分类器错误识别为正例的比例 <span class="math">\\( \text{FPR} = \dfrac{\text{FP}}{\text{FP}+\text{TN}} \\)</span></li>
    <li>纵坐标为<strong>真正例率</strong>(True Positive Rate, TPR)，表示在所有真正例中，分类器正确识别为正例的比例 <span class="math">\\( \text{TPR} = \dfrac{\text{TP}}{\text{TP}+\text{FN}} \\)</span> ，就是刚才介绍的召回率</li>
</ul>

<p>ROC 曲线的特点是，它能够展示分类器在不同阈值下的性能表现。这里的阈值指的是分类器判断一个样本为正例的概率的截断值。一般情况下，当阈值设定为 0.5 时，分类器将所有概率大于 0.5 的样本判断为正例，而将所有概率小于等于 0.5 的样本判断为反例。</p>

<p>提高阈值会使预测为正类的样本数量减少，但预测的样本是正类的可能性都很高，因此可以提高模型的精确率。同样地，降低阈值会让模型将一些不太可能是正类的样本预测为正类，但也可能找出更多实际是正类的样本，因此可以提高模型的召回率。</p>

<p>ROC 曲线呈现了不同阈值下的假正例率和真正例率，如下图所示：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-ROC-curve-concept.png" alt="" width="320">
</figure>

<p>一个良好的模型应该拥有高真正例率(TPR)和低假正例率(FRP)，即尽可能找出属于该组的，但也要排除不属于该组的。一个完美的模型希望假警报率接近 0 ，命中率接近 1 ，即左上角顶点。一般的模型不可能达到该值，只能尽可能接近它，反应在图形上就是 ROC 曲线最接近左上角的一点，为模型的最优情况。</p>

<p>在 <span class="code-font">sklearn</span> 中，绝大多数分类器都有 <code>.predict_proba()</code> 方法，可以得到该模型判断样本为每个分类的概率：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>model<span token="symbol">.</span>predict_proba<span token="symbol">(</span>X<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[0.0925382 , 0.9074618 ],
       [0.24097764, 0.75902236],
       [0.05459936, 0.94540064],
       ...,
       [0.20851233, 0.79148767]])</div>
</div>

<p>对于二分类模型，判断样本为正例或反例的概率加起来应该等于 1.0 。</p>

<p>有了这些概率数据，就可以通过设置不同阈值来观察假正例率和真正例率的变化。<span class="code-font">sklearn</span> 提供了如下工具来计算 <span class="math">\\( \text{TPR} \\)</span> 和 <span class="math">\\( \text{FPR} \\)</span> 在不同阈值下的表现情况：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>metrics <span token="keyword">import</span> roc_curve</div><div>FPR<span token="symbol">,</span> TPR<span token="symbol">,</span> thres <span style="color: #7c4dff;">=</span> roc_curve<span token="symbol">(</span>y_true<span token="symbol">,</span> </div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; model<span token="symbol">.</span>predict_proba<span token="symbol">(</span>X<span token="symbol">)[:,</span> <span token="number">1</span><span token="symbol">])</span></div></div>
</div>

<p>这里采用类别 1 作为正类。计算得到的结果是排序后的，可以直接调用 <span class="code-font">matplotlib</span> 绘制曲线，得到的结果可能是这样的：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-ROC-curve-demo.png" alt="">
</figure>

<p>在数值上通常使用 <strong>AUC</strong>(Area Under the ROC Curve, ROC 曲线下面积)作为衡量分类器性能的指标，AUC 取值范围为 <span class="math">\\( (0.5,1) \\)</span> ，越接近 1 表示分类器的性能越好。通常达到 0.75 表示可以接受，0.85 表示非常不错。</p>

<p>如果不是为了可视化，一般可以使用以下工具直接计算 AUC 值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>metrics <span token="keyword">import</span> roc_auc_score</div><div>roc_auc_score<span token="symbol">(</span>y_true<span token="symbol">,</span> model<span token="symbol">.</span>predict_proba<span token="symbol">(</span>X<span token="symbol">)[:,</span> <span token="number">1</span><span token="symbol">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.8382</div>
</div>

<p>进一步地，通过绘制 K-S 曲线可以分析模型随阈值变化的特性。K-S(Kolmogorov-Smirnov)检验用于测量两个累积分布是否一致。在二分类问题中，K-S 检验用于度量正分布和负分布之间的分离程度。</p>

<p>随着阈值的上升，真正例率(TPR)可以理解为累积正样本率，假正例率(FPR)可以理解为累积负样本率，因此可以使用这两个指标绘制 <strong>K-S 曲线</strong>。绘制时一般将阈值作为横坐标，真正例率(TPR)和假正例率(FPR)之差作为纵坐标，如下图所示：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-KS-curve-explain.png" alt="" width="410">
</figure>

<p>K-S 曲线有助于调整模型的决策阈值。K-S 值是两个两个累积分布曲线的最大垂直距离。在二分类问题中，它是曲线的纵坐标最大值。K-S 值的取值范围为 0~1 ，较高的值表示正类和负类之间的分离更好，即模型的分类效果更好。不过应该注意的是，K-S 检验假设数据是独立同分布的，在实践中可能未必如此。</p>

<h2>参数选择方法</h2>

<p>在了解了如何评价一个模型以及阈值对模型的影响后，接下来的问题是如何才能得到最优的模型，这就涉及到为模型选择合适的参数。</p>

<h3>鸢尾花数据集</h3>

<p>接下来介绍著名的鸢尾花数据集，它是一个经典的多分类数据，经常用于检验新模型的分类效果。它是 <span class="code-font">sklearn</span> 内置的数据集之一，可以通过以下方法加载它：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">from</span> sklearn<span token="symbol">.</span>datasets <span token="keyword">import</span> load_iris</div><div>iris <span style="color: #7c4dff;">=</span> load_iris<span token="symbol">()</span></div></div>
</div>

<p>得到的是一个类似字典的对象，它有以下键：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>iris<span token="symbol">.</span>keys<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">dict_keys(['data', 'target', 'frame', 'target_names', 'DESCR', 'feature_names', 'filename', 'data_module'])</div>
</div>

<p>主要用到的键对应的值的含义为：</p>

<ul>
    <li><code>feature_names</code> ：特征名称</li>
    <li><code>data</code> ：特征数据，是一个二维数组对象</li>
    <li><code>target</code> ：目标数据</li>
    <li><code>target_names</code></li>
</ul>

<p>这些数据大致分布如下：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/04/06-iris-data.png" alt="" width="700">
</figure>

<p><code>iris['data']</code> 和 <code>iris['target']</code> 符合模型对特征矩阵 <code>X</code> 和目标数据 <code>y</code> 的要求，因此可以直接用于训练模型。</p>

<h3>网格搜索</h3>

<p>如果不确定某个参数要如何选择，需要多次调整参数并观察模型指标的变化，以此选择参数的最优值。而如果有多个参数需要选择，那么也需要调整参数的组合，并从中选择最优的结果。</p>

<p><strong>网格搜索</strong>是一种通过穷举搜索来选择最优参数组合的手段，它将使用所有候选参数的组合来循环建立模型，并选取表现最好的参数作为最终结果。</p>

<p>网格搜索的思路很简单，就是暴力穷举参数组合并观察效果。Scikit-Learn 提供了 <code>GridSearchCV</code> 工具来实现此过程的自动化。如果现在已经有了一个模型和一些候选参数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>clf_tree <span style="color: #7c4dff;">=</span> DecisionTreeClassifier<span token="symbol">()</span></div><div>params_tree <span style="color: #7c4dff;">=</span> <span token="symbol">{</span></div><div>&#160; &#160; <span token="string">'min_samples_split'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="number">2</span><span token="symbol">,</span> <span token="number">4</span><span token="symbol">,</span> <span token="number">6</span><span token="symbol">,</span> <span token="number">10</span><span token="symbol">],</span></div><div>&#160; &#160; <span token="string">'min_samples_leaf'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="number">1</span><span token="symbol">,</span> <span token="number">3</span><span token="symbol">,</span> <span token="number">6</span><span token="symbol">,</span> <span token="number">10</span><span token="symbol">]</span></div><div><span token="symbol">}</span></div></div>
</div>

<p>那么首先需要创建一个网格搜索器：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>grid_search <span style="color: #7c4dff;">=</span> GridSearchCV<span token="symbol">(</span>clf_tree, params_tree, </div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span style="color: #e53935;">scoring</span><span style="color: #7c4dff;">=</span><span token="string">'f1_weighted'</span><span token="symbol">,</span> <span style="color: #e53935;">cv</span><span style="color: #7c4dff;">=</span><span token="number">5</span><span token="symbol">)</span></div></div>
</div>

<p>这样，<code>GridSearchCV</code> 会使用 5 轮交叉验证评估每个参数组合的效果，防止过拟合的影响。这里的评估标准 <code>"f1_weighted"</code> 指的是加权 F1 分数(Weighted F1-Score)，加权 F1 分数是对每个类别的 F1 分数进行加权平均，权重为各类别的样本数量占总样本数量的比例。关于 <span class="code-font">sklearn</span> 提供的更多检验标准，可以参考<a href="https://scikit-learn.org/stable/modules/model_evaluation.html#common-cases-predefined-values" class="link-external">官方文档</a>。</p>

<p>有了评估器以后，就可以使用 <code>.fit()</code> 方法，表示<em>应用到数据</em>：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>grid_search.fit<span token="symbol">(</span>iris<span token="symbol">[</span><span token="string">'data'</span><span token="symbol">]</span>, iris<span token="symbol">[</span><span token="string">'target'</span><span token="symbol">])</span></div></div>
</div>

<p>应用数据之后，就可以获取最优的参数组合，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="number">print</span>(grid_search.best_params_, grid_search.best_score_)</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">{'min_samples_leaf': 1, 'min_samples_split': 6} 0.9664818612187034</div>
</div>

<p>如果只是想检查参数组合对模型分数的影响，也可以通过 <code>.cv_results_</code> 属性获取。它是一个很详细的数据，同时还记录了训练时间、验证时间等信息。</p>

<p><code>GridSearchCV</code> 的 <code><em>refit</em></code> 参数默认被设为 <code>True</code> ，这代表找到了最优的参数组合后，它将立刻被应用于训练模型，并且所有的数据都将作为训练集，这个完善的模型可以通过 <code>.best_estimator_</code> 获取，并直接参与 <code>.predict()</code> 的决策中。</p>

<p>最后要注意的是，如果这个模型是使用 <code>make_pipeline()</code> 与预处理结合得到的多个步骤，那么每个步骤的参数要用两个下划线区分，整个字典看起来类似这样：</p>

<div class="vscode-block"><div>params <span style="color: #7c4dff;">=</span> <span token="symbol">{</span></div><div>&#160; &#160; <span token="string">'logisticregression__penalty'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="string">'l1'</span><span token="symbol">,</span> <span token="string">'l2'</span><span token="symbol">,</span> <span token="string">'none'</span><span token="symbol">],</span></div><div>&#160; &#160; <span token="string">'logisticregression__C'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="number">0.2</span><span token="symbol">,</span> <span token="number">1.0</span><span token="symbol">,</span> <span token="number">4.0</span><span token="symbol">],</span> </div><div>&#160; &#160; <span token="string">'polynomialfeatures__degree'</span><span token="symbol">:</span> <span token="symbol">[</span><span token="number">3</span><span token="symbol">,</span> <span token="number">4</span><span token="symbol">,</span> <span token="number">5</span><span token="symbol">]</span></div><div><span token="symbol">}</span></div></div>

<h3>随机搜索</h3>

<p>网格搜索的缺点是如果参数列表很多，那么搜索范围会变得很大，再加上交叉验证会严重拖慢搜索进度。此时可以使用随机搜索 <code>RandomizedSearchCV</code> ，它只会挑选部分而不是全部的参数组合，再从这部分随机组合中挑选最优结果。这个类的用法与 <code>GridSearchCV</code> 大致相同。</p>

<p>随机搜索不仅速度更快，而且对是连续值的参数效果更好，因为随机搜索可以很方便地抽取大量参数用于检验，每个参数可能差别很小，完整训练的代价太大。</p>
<p><a rel="nofollow" href="/archives/1081">机器学习-参数选择与模型验证</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1081/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python面向对象编程04-类与实例的方法</title>
		<link>/archives/1059</link>
					<comments>/archives/1059#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 27 Mar 2023 01:08:07 +0000</pubDate>
				<category><![CDATA[Python]]></category>
		<category><![CDATA[面向对象编程]]></category>
		<guid isPermaLink="false">/?p=1059</guid>

					<description><![CDATA[<p>类方法和静态方法 实例方法 在第一节中，便已经介绍过&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1059">Python面向对象编程04-类与实例的方法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>类方法和静态方法</h2>

<h3>实例方法</h3>

<p>在<a href="/archives/442" class="link-internal">第一节</a>中，便已经介绍过实例方法。实例方法需要有一个实例才能调用，而这个实例是通过第一个通常名为 <code>self</code> 的参数表示的，因此借助该参数可以在定义方法时就去操作一个抽象的实例对象。例如，假设有一个这样的类和实例的定义：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">C</span>:</div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">method</span>(self, arg):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">print</span>(<span style="color: #268bd2;">self</span>, arg)</div><br><div><span style="color: #268bd2;">c</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">C</span>()</div></div>

<p>那么可以使用这样的方式通过实例调用该方法，实例对象将会自动作为第一个位置参数传入：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">c</span>.<span style="color: #268bd2;">method</span>(arg<span style="color: #859900;">=</span><span style="color: #cb4b16;">...</span>)</div></div>

<p>许多编程语言在方法内部，对实例的引用是通过 <code>this</code> 关键字完成的；而 Python 则与之不同，实例的引用是通过显式的参数传递的。这样做的好处在于，一是通过显式定义来强调默认定义的方法是实例方法，二是也可以把方法当做第一个参数是实例的函数一样调用：</p>

<div class="vscode-block"><div><span style="color: #cb4b16;">C</span>.<span style="color: #268bd2;">method</span>(<span style="color: #268bd2;">c</span>, arg<span style="color: #859900;">=</span><span style="color: #cb4b16;">...</span>)</div></div>

<p>例如，多个字符串连接默认是通过字符串的 <code>.join()</code> 方法实现，这里调用该方法的字符串实例将被插入被连接的字符串之间：</p>

<div class="vscode-block"><div><span style="color: #2aa198;">'||'</span>.<span style="color: #268bd2;">join</span>([<span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'c'</span>])</div><div><span style="color: #a8a8a8;"># 'a||b||c'</span></div></div>

<p>如果觉得用被插入的字符串去调用该方法比较奇怪，也可以通过 <code>str</code> 类调用该方法，并将被插入的字符串作为第一个位置参数主动传入：</p>

<div class="vscode-block"><div><span style="color: #cb4b16;">str</span>.<span style="color: #268bd2;">join</span>(<span style="color: #2aa198;">'||'</span>, [<span style="color: #2aa198;">'a'</span>, <span style="color: #2aa198;">'b'</span>, <span style="color: #2aa198;">'c'</span>])</div></div>

<!-- <div class="vscode-block"><div><span style="color: #cb4b16;">str</span>.<span style="color: #268bd2;">replace</span>(<span style="color: #2aa198;">'%time</span><span style="color: #cb4b16;">%-%</span><span style="color: #2aa198;">name%.jpg'</span>, <span style="color: #2aa198;">'%time%'</span>, <span style="color: #268bd2;">ctime</span>())</div></div> -->

<p>因此，实例方法的实质就是一个函数，只不过它的主要用途是处理实例。Python 允许实例方法可以直接由实例调用，使得调用的表示更加简洁。</p>

<h3>类方法</h3>

<p>与实例方法相对应的是<strong>类方法</strong>。类方法是类本身具有的方法，它可以在不需要实例的情况下使用类本身来调用。</p>

<p>Python 中类方法和实例方法相似，但是它需要传入一个名为 <code>cls</code> 的参数，用来代表这个类本身（同样，这个名字不必是 <code>cls</code> ，可以是 <code>typ</code> 或 <code>Lei</code> 等）。但是为了与实例方法区分，类方法在定义时需要使用 <code>@classmethod</code> 装饰器。</p>

<p>因此，一个完整的类方法的定义为：</p>

<div class="codeblock code-template">
    @classmethod<br>
    <strong>def</strong> <em>method_name</em>(cls, ...):<br>
    &nbsp; &nbsp; ...
</div>

<p>类方法有几种比较常见的应用场景。首先是构造前交互，有些时候需要在实例化前做一些准备，例如一个代表数据库的类，可以通过类方法读取配置文件并连接到数据库中，这样随后对实例的操作可以实时反映到对数据库的更新中。由于读取配置文件这种操作需要在得到任意一个实例之前完成，因此可以借助类方法实现。</p>

<p>类方法还可以用于以别的方式构建实例。例如，<code>datetime</code> 是一个用于处理日期与时间的标准库，其中 <code>date</code> 是一个用于表示日期的类。如果要通过该类生成一个具体的日期，在初始化时需要传入代表年、月、日的参数：</p>

<div class="codeblock code-console">>>> from datetime import date
>>> date(2023, 3, 19)
datetime.date(2023, 3, 19)</div>

<p>但有些时候，拿到的信息可能未必包含年月日，它可能是具有特定格式的表示时间的字符串，还有可能是浮点型的时间戳。此时，可以使用 <code>date</code> 类提供的类方法使用这几种信息构造一个日期实例：</p>

<div class="codeblock code-console">>>> date.fromisoformat('2023-03-19')  # python3.7+
datetime.date(2023, 3, 19)
>>> date.fromtimestamp(time.time())
datetime.date(2023, 3, 19)</div>

<p>仿照这种思路，可以为之前自定义的 <code>Point</code> 类编写一个类方法来通过格式字符串构造实例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Point</span>:</div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__init__</span>(self, x, y):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> x, y</div><div>&#160; &#160; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">classmethod</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">from_format</span>(cls, format):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">y</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">format</span>[<span style="color: #d33682;">1</span>:<span style="color: #859900;">-</span><span style="color: #d33682;">1</span>].split(<span style="color: #2aa198;">','</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">cls</span>(<span style="color: #cb4b16;">int</span>(<span style="color: #268bd2;">x</span>), <span style="color: #cb4b16;">int</span>(<span style="color: #268bd2;">y</span>)) &#160;<span style="color: #a8a8a8;"># same as Point(...)</span></div></div>

<p>注意，这里的参数 <code>cls</code> 在调用时会替换为 <code>Point</code> ，因此调用 <code>cls(...)</code> 等价于类的实例化 <code>Point(...)</code></p>

<p>使用这个类方法可以返回一个实例，就像正常方式得到的实例一样可以调用各种方法：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">p</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Point</span>.<span style="color: #268bd2;">from_format</span>(<span style="color: #2aa198;">'(10,40)'</span>)</div><div><span style="color: #268bd2;">p</span>.<span style="color: #268bd2;">distance_to_origin</span>() &#160;<span style="color: #a8a8a8;"># returns 41.23</span></div></div>

<p>从技术上说，也可以用一个普通函数来构造实例。但使用类方法的好处在于，一是使用者容易明白构造出的实例是属于哪个类的，二是当类被重命名后类方法无需跟着修改，降低了因为疏忽导致错误的可能性。</p>

<p>这里顺便说一下，既然实例可以调用类属性，那么实例也可以调用类方法，这等价于用它的类调用类方法。不过一般不推荐利用实例调用类方法，因为这样做可能有些奇怪。</p>

<h3>静态方法</h3>

<p>除了类方法和实例方法外，还有一个特殊的方法称为<strong>静态方法</strong>。静态方法不是类或实例所特有的，它可以被任意的类或实例调用。静态方法不涉及对类和实例的操作，因此被称为静态方法。</p>

<p>静态方法需要使用 <code>@staticmethod</code> 装饰器，并且不需要添加像 <code>self</code> 或 <code>cls</code> 这种特殊的参数，因此不参与对任意属性的修改。</p>

<p>一个静态方法的定义为：</p>

<div class="codeblock code-template">
    @staticmethod<br>
    <strong>def</strong> <em>method_name</em>(...):<br>
    &nbsp; &nbsp; ...
</div>

<p>不难看出，静态方法脱离了类和实例，表现得更像一个普通的函数。</p>

<hr>

<p>实际上，Python 中的方法和函数除了是否位于类的定义中外，并没有本质的区别。Python 中的类可以看作一个独立的<em>命名空间</em>。在 <code>class</code> 关键字引导的代码块中，可以包含各种语句，例如常见的 <code>for</code> 循环和 <code>with</code> 语句：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Type</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">s</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">i</span> <span style="color: #859900;font-weight: bold;">in</span> <span style="color: #cb4b16;">range</span>(<span style="color: #d33682;">10</span>):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">s</span> <span style="color: #859900;">+=</span> <span style="color: #268bd2;">i</span> <span style="color: #859900;">**</span> <span style="color: #d33682;">2</span></div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">with</span> <span style="color: #268bd2;">open</span>(<span style="color: #2aa198;">'settings.txt'</span>, <span style="color: #2aa198;">'r'</span>) <span style="color: #859900;font-weight: bold;">as</span> <span style="color: #268bd2;">f</span>:</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">settings</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">dict</span>([</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">kv</span>.<span style="color: #268bd2;">split</span>(<span style="color: #2aa198;">'='</span>) <span style="color: #859900;font-weight: bold;">for</span> <span style="color: #268bd2;">kv</span> <span style="color: #859900;font-weight: bold;">in</span> <span style="color: #268bd2;">f</span>.<span style="color: #268bd2;">read</span>().<span style="color: #268bd2;">split</span>(<span style="color: #2aa198;">'</span><span style="color: #cb4b16;">\n</span><span style="color: #2aa198;">'</span>)</div><div>&#160; &#160; &#160; &#160; ])</div><div>&#160; &#160; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #268bd2;">settings</span>.<span style="color: #268bd2;">get</span>(<span style="color: #2aa198;">'value'</span>):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">@</span><span style="color: #cb4b16;">property</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">value</span>(self):</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">self</span>.<span style="color: #268bd2;">settings</span>[<span style="color: #2aa198;">'value'</span>]</div></div>

<p>注意，这里使用 <code>if</code> 语句动态地定义了一个方法，这是完全可以的。除此之外，在类内定义另一个类也是很常见的情况，这个嵌套类一般用于提供基本的元信息。</p>

<p>在类之中这个独立的命名空间内，可以直接访问其中定义的变量（或者说属性）。而在类外部，访问这些变量需要通过类名来标识其所位于的命名空间：</p>

<div class="vscode-block"><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">Type</span>.<span style="color: #268bd2;">s</span>) &#160;<span style="color: #a8a8a8;"># 285</span></div><div><span style="color: #268bd2;">print</span>(<span style="color: #cb4b16;">Type</span>().<span style="color: #268bd2;">value</span>) &#160;<span style="color: #a8a8a8;"># 1</span></div></div>

<p>从这个角度上说，类和模块并没有太大的差别。实际上，当模块导入后，它就是一个普通的 Python 对象，只不过是 <code>&lt;class 'module'></code> 类型的对象。所以在 Python 中使用方法时，实际上就是使用一个函数，Python 解释器只是额外提供了一个语法糖，将调用方法的实例自动填写到函数的 <code>self</code> 参数上，仅此而已。</p>

<h2>特殊方法</h2>

<p>在<a href="" class="link-internal">第一节</a>介绍过实例方法时，同时介绍了一个特殊的实例方法 <code>.__init()__</code> ，它会在类初始化时自动调用，以此完成一些初始化工作。之前介绍时同时提及了类还有很多类似的特殊方法，它们都以双下划线开头结尾，有时也被称为双下方法。</p>

<p>Python 的特点是一切皆对象，任何 Python 的变量都是一个对象。而 Python 对这些变量的操作，例如构造、初始化、删除、获取属性，甚至比较、索引、和迭代，都是通过调用一些特殊的方法实现的，这些方法称为 Python 的<strong>特殊方法</strong>(special method)或<strong>魔法方法</strong>(magic method)，它们的名称以双下划线开始，以双下划线结束，代表着对象的一种特殊的操作。一般情况下，使用类方法或实例方法就可以完成类的功能；但在必要时，可以使用或者重写这些特殊方法，来为自己的类提供更加规范的接口。</p>

<p>在后续篇章中，对 Python 面向对象的介绍几乎都围绕这些特殊方法。通过对这些特殊方法的介绍，可以从根本上了解 Python 的运行机制，从而编写出更加优雅、更 Pythonic 的代码。</p>

<p>本节先介绍类的三个特殊方法：<code>.__init__()</code> 、<code>.__new__()</code> 和 <code>.__del__()</code> ，它们参与着实例的生命周期。</p>

<h3>初始化方法</h3>

<p>初始化方法 <code>.__init()__</code> 是第一个介绍的特殊方法，可能也是最常用的特殊方法。每当生成一个实例后，它便会调用该方法，以此完成一些初始化工作。</p>

<p>需要注意的是，<code>.__init__()</code> 方法不能有任何非 <code>None</code> 的返回值，否则就会引起 <code class="error">TypeError</code> ，错误内容将提示该方法应该返回 <code>None</code> 。</p>

<h3>构造方法</h3>

<p><code>.__new__()</code> 被称为构造方法，因为它负责创建一个新的实例。而 <code>.__init__()</code> 负责创建后的初始化，从中也可以明白它们的用途以及调用的先后顺序。</p>

<p><code>.__new__()</code> 负责创建类的实例，它的第一个位置通常名为 <code>cls</code> ，代表生成实例的类，其余参数应该是 <code>.__init__()</code> 方法的其余参数。虽然看起来很像一个类方法，但它却是一个静态方法，并且无需使用 <code>@staticmethod</code> 装饰器。这也是特殊方法和普通方法的根本区别：Python 解释器已经规定了如何使用特殊方法，因此没必要额外声明其它东西。</p>

<p>它的返回值是新的对象实例（通常是 <code>cls</code> 的实例）。例如以下类 <code>Card</code> ，它使用 <code>.__new__()</code> 方法，在每次生成一个实例时，便给予它唯一的一个 <code>.id_</code> 属性：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Card</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">id_</span> <span style="color: #859900;">=</span> <span style="color: #d33682;">0</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__new__</span>(cls, <span style="color: #859900;">*</span>args, <span style="color: #859900;">**</span>kwargs):</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__new__</span>(<span style="color: #268bd2;">cls</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">id_</span> <span style="color: #859900;">+=</span> <span style="color: #d33682;">1</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #268bd2;">instance</span>.<span style="color: #268bd2;">id_</span> <span style="color: #859900;">=</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">id_</span></div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">instance</span></div><br><div><span style="color: #268bd2;">c01</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c02</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c03</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Card</span>()</div><div><span style="color: #268bd2;">c03</span>.<span style="color: #268bd2;">id_</span> &#160;<span style="color: #a8a8a8;"># 3</span></div></div>

<p>注意，虽然它表现得很像一个类方法，但不能像之前介绍的类方法一样通过 <code>cls(...)</code> 来创建实例，因为这样做实质上就是在调用该方法，会陷入无限递归。一般来说对象的创建是底层 C 语言的任务，而 Python 中只需要使用 CPython 提供的接口即可，例如使用 <code>super().__new__(cls, ...)</code> 调用 <code>object</code> 类提供的基本 <code>.__new__()</code> 方法，然后在返回之前根据需要修改新创建的实例即可。</p>

<p>由于涉及到对类属性的修改，因此使用 <code>.__init__()</code> 方法不太好实现（当然不是不能实现，在后续会介绍）。同时使用 <code>.__new__()</code> 方法也方便了继承，子类可以正常编写 <code>.__init__()</code> 方法而不影响 <code>.id_</code> 的分配。</p>

<p>通过之前的介绍可以明白构造方法和初始化方法的执行顺序：<code>.__new__()</code> 方法会优先 <code>.__init__()</code> 初始化方法在生成实例前调用。执行了 <code>.__new__()</code> 并不一定会进入 <code>.__init__()</code> ；只有 <code>.__new__()</code> 返回了当前类的实例（即便是父类的实例也不行），才会进入 <code>.__init__()</code> 并为该实例做一定初始化，否则没有东西可以用于初始化。</p>

<p>利用这种特性，可以在 Python 中创建单例。单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。单例提供了创建与访问其唯一对象的方式。使用 <code>.__new__()</code> 方法可以自由控制创建的对象，从而比较方便地实现单例：</p>

<div class="vscode-block"><div><span style="color: #586e75;font-weight: bold;">class</span> <span style="color: #cb4b16;">Singleton</span>:</div><div>&#160; &#160; <span style="color: #268bd2;">_has_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">False</span></div><div>&#160; &#160; <span style="color: #268bd2;">__single_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">None</span></div><div>&#160; &#160; <span style="color: #586e75;font-weight: bold;">def</span> <span style="color: #268bd2;">__new__</span>(cls, <span style="color: #859900;">*</span>args, <span style="color: #859900;">**</span>kwargs):</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">if</span> <span style="color: #859900;">not</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">_has_instance</span>:</div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">_has_instance</span> <span style="color: #859900;">=</span> <span style="color: #b58900;">True</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">__single_instance</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">super</span>().<span style="color: #268bd2;">__new__</span>(<span style="color: #268bd2;">cls</span>)</div><div>&#160; &#160; &#160; &#160; <span style="color: #859900;font-weight: bold;">return</span> <span style="color: #268bd2;">cls</span>.<span style="color: #268bd2;">__single_instance</span></div><div>&#160; &#160; </div><div><span style="color: #268bd2;">one_task</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Singleton</span>()</div><div><span style="color: #268bd2;">another_task</span> <span style="color: #859900;">=</span> <span style="color: #cb4b16;">Singleton</span>(<span style="color: #d33682;">123</span>, name<span style="color: #859900;">=</span><span style="color: #2aa198;">'another'</span>)</div><div><span style="color: #268bd2;">one_task</span> <span style="color: #859900;">is</span> <span style="color: #268bd2;">another_task</span> <span style="color: #859900;">is</span> <span style="color: #cb4b16;">Singleton</span>(<span style="color: #2aa198;">'abs'</span>) &#160;<span style="color: #a8a8a8;"># True</span></div></div>

<p>可以看到，不管该类被实例化多少次，如何实例化，得到的都是唯一的实例。单例提供了一种共享数据的方式，并且方便使用 <code><strong>is</strong></code> 判断。但考虑到 Python 能使用全局变量完成相同的工作，因此一般来说在 Python 中没必要使用单例。</p>

<h3>析构方法</h3>

<p>与构造方法相反，析构方法 <code>.__del__()</code> 用于在销毁一个类实例时调用，它对应的是 Python 中的 <code>del</code> 语句。</p>

<p>当一个对象即将被销毁时，它便会调用 <code>.__del__()</code> 方法，通常该方法用于释放实例用到的一些额外的资源（如关闭已经打开的文件）。</p>

<p><code>.__del__()</code> 是实例相关的方法，因此第一个参数应该为 <code>self</code> 。注意区别于 <code>property</code> 的 <code>@.deleter</code> 装饰器，它装饰的方法在删除某个属性时调用，而不是整个实例。由于垃圾回收是后台处理的，且 <code>del</code> 是一个语句，因此 <code>.__del__()</code> 的返回值并没有任何意义。并且在该方法内引发任何异常也是没有作用的，它既不能被所处的 <code>try</code> 块捕获，也不会中断程序的运行。</p>

<p>注意，<code>del</code> 语句在调用时，并没有直接调用实例的 <code>.__del__()</code> 方法，这是因为如果变量仅仅是对实例的一个引用，那么 <code>del</code> 语句只会销毁这个引用的对象。只有当所有的引用都被销毁了，那么 <code>del</code> 语句才会调用 <code>.__del__()</code> 方法来清除这个实例。因此，通过在 <code>.__del__()</code> 中为对象添加一个引用可以暂时推迟对象的删除，但这是很不建议的做法。</p>

<p>通过 <code>.__del__()</code> 方法，可以研究 Python 的垃圾回收机制。例如，以下是在命令行中的一个小测试：</p>

<div class="codeblock code-console">>>> GCTest()
&lt;__main__.GCTest object at 0x00000282CE8907B8>
>>> t = GCTest()
>>> del t
object deleted
>>> 'now delete "_"'
object deleted
'now delete "_"'
</div>

<p>第一个实例被自动保存在 <code>_</code> 变量中，只有这个引用改变了，它才会被删除。</p>

<h2>参考资料/延伸阅读</h2>

<p>
    <a href="https://docs.python.org/3/reference/datamodel.html#basic-customization">https://docs.python.org/3/reference/datamodel.html#basic-customization</a><br>
    Python3 语言参考——数据模型部分，该部分介绍了绝大多数常用的特殊方法、特殊属性与 Python 的运行机制，是深入理解 Python 最好的文档。
</p>
<p><a rel="nofollow" href="/archives/1059">Python面向对象编程04-类与实例的方法</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1059/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-pandas04:索引与缺失值</title>
		<link>/archives/1054</link>
					<comments>/archives/1054#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 17 Mar 2023 09:55:47 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[pandas]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1054</guid>

					<description><![CDATA[<p>上一节介绍了 pandas 中的索引，本节补充关于索&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1054">Python数据分析-pandas04:索引与缺失值</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<p><a class="link-internal">上一节</a>介绍了 pandas 中的索引，本节补充关于索引对齐的更多内容。</p>

<p>在 <var type="module">numpy</var> 中对两个数组做运算，如果它们形状既不完全一致，也不满足广播规则，那么会产生错误：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a01 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div>a02 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>linspace<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">)</span></div><div><span style="color: #39adb5;font-weight: bold;">try</span><span style="color: #39adb5;">:</span></div><div>&#160; &#160; a01 <span style="color: #7c4dff;">+</span> a02</div><div><span style="color: #39adb5;font-weight: bold;">except</span> <span style="color: #8796b0;">ValueError</span> <span style="color: #39adb5;font-weight: bold;">as</span> e<span style="color: #39adb5;">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span style="color: #39adb5;">(</span>e<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">operands could not be broadcast together with shapes (4,) (5,) </div>
</div>

<p>但是对两个类似的 <code>Series</code> 对象做运算时，就不会产生这种错误：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">))</span></div><div>s02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>linspace<span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">))</span></div><div>s01 <span style="color: #7c4dff;">+</span> s02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    2.0
1    4.0
2    6.0
3    8.0
4    NaN
dtype: float64</div>
</div>

<p>虽然不会产生错误，但是注意到得到的 <code>Series</code> 包含 5 个元素，并且最后一个元素似乎不是数值数据。同时结果的类型由整数变为了浮点数。</p>

<p>这两个现象就包含了本节的内容。接下来逐一介绍。</p>

<h2>索引对齐</h2>

<p>当在两个 <code>Series</code> 或 <code>DataFrame</code> 对象上做计算时，<var type="module">pandas</var> 会按照索引值配对计算元素，而不是按位置配对：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>divide<span style="color: #39adb5;">(</span>pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">ABCD</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)),</span></div><div>&#160; &#160; &#160; &#160; &#160; pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">ACBD</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">A    1.000000
B    0.666667
C    1.500000
D    1.000000
dtype: float64</div>
</div>

<p>这实际上是由于 <var type="module">pandas</var> 会在计算过程中对齐两个对象的索引。索引对齐确保计算可以得到合理的结果，并且当处理不完整的数据时也更方便。</p>

<p>例如，以下根据现有的地区面积和人口数据，计算人口密度：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>territory <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">D0</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">1708</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D1</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">9403</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">3640</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D3</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">3360</span><span style="color: #39adb5;">},</span></div><div>&#160; &#160; <span style="color: #e53935;">name</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">territory</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>population <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">D0</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">14300</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">13900</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D3</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">33280</span><span style="color: #39adb5;">},</span></div><div>&#160; &#160; <span style="color: #e53935;">name</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">population</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>population <span style="color: #7c4dff;">/</span> territory</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">D0    8.372365
D1         NaN
D2    3.818681
D3    9.904762
dtype: float64</div>
</div>

<p>结果数组的索引是两个输入数组索引的并集，并用索引相同的元素做运算。这样一来不需要使两个 <code>Series</code> 都是完整且顺序一致的，也能根据索引完成配对元素的计算。</p>

<p>在计算两个 <code>DataFrame</code> 时，类似的索引对齐规则也同样会出现在列索引中：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;">(</span>pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">6</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">AB</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">))</span> <span style="color: #7c4dff;">+</span> </div><div>&#160;pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">9</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">list</span><span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">BAC</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>A</th><th>B</th><th>C</th>
        </tr>
        <tr>
            <td>0</td><td>1</td><td>1</td><td>NaN</td>
        </tr>
        <tr>
            <td>1</td><td>6</td><td>6</td><td>NaN</td>
        </tr>
        <tr>
            <td>2</td><td>11</td><td>11</td><td>NaN</td>
        </tr>
    </table></div>
</div>

<p>因此，索引对齐就是在计算时根据配对的索引完成元素的运算。如果有一个运算对象缺少该索引，该位置的数据会用 <code>NaN</code> 填充。这是 <var type="module">pandas</var> 表示缺失值的方法，接下来会介绍缺失值的处理方法。</p>

<h2>处理缺失值</h2>

<h3>认识缺失值</h3>

<p>在 Python 中，空值一般用 <code>None</code> 对象表示。它是一个特殊的 Python <code>object</code> 对象 ，由 Python 解释器提供并处理。</p>

<p><code>None</code> 作为一个 Python 对象，并不能兼容任何 <var type="module">numpy</var> 的原生类型。如果在创建数组时包含 <code>None</code> ，那么数组的类型会被强制提升为 <code>object</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a1 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">None</span><span style="color: #39adb5;">])</span></div><div>a1</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 1, 3, None], dtype=object)</div>
</div>

<p>然而，使用 <code>object</code> 作为数组类型会严重拖慢计算速度，因为它在底层不但占用更多空间，并且无法通过向量化加速运算：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a2 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">10000</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span>np<span style="color: #39adb5;">.</span>int32<span style="color: #39adb5;">)</span></div><div>a3 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">(</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">10000</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #8796b0;">object</span><span style="color: #39adb5;">)</span></div><div><span style="color: #7c4dff;">%</span>timeit a2 <span style="color: #7c4dff;">/</span> <span style="color: #f76d47;">2</span></div><div><span style="color: #7c4dff;">%</span>timeit a3 <span style="color: #7c4dff;">/</span> <span style="color: #f76d47;">2</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">9.99 µs ± 51.7 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)
199 µs ± 1.35 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)</div>
</div>

<p>可以看到即便对于简单的除法运算，两者都有 20 倍的速度差异。除此之外，数组中一旦包含 <code>None</code> 值，那么它就无法参与各种运算，因为 Python 并没有实现 <code>None</code> 和其它类型的运算方法。</p>

<p>不过好在 <var type="module">numpy</var> 提供了另一种缺失值：<code>NaN</code> 。它全称 Not a Number ，即非数字，是一种按照 IEEE 754 标准设计的特殊<em>浮点数</em>：（有关 <code>NaN</code> 与浮点数的更多底层设计可以参见<a href="https://en.wikipedia.org/wiki/NaN">维基百科</a>）</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([ 1., nan,  2.,  3.])</div>
</div>

<p><code>NaN</code> 作为一种浮点数，在大多数编程语言中都可以被处理。浮点类型使得含 <code>NaN</code> 的数组可以使用向量化计算，获得很快的运算速度。</p>

<p><code>NaN</code> 的一个特性是：它与任何数字的运算结果都是它本身。也就是说无论 <code>NaN</code> 参与何种运算，最终结果都是 <code>NaN</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>nan <span style="color: #7c4dff;">+</span> <span style="color: #f76d47;">1</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">nan</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>nan <span style="color: #7c4dff;">/</span> np<span style="color: #39adb5;">.</span>nan <span style="color: #7c4dff;">*</span> <span style="color: #f76d47;">0</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">nan</div>
</div>

<p>这种特性使得在对含有 <code>NaN</code> 的数组做聚合处理时，虽然不会引起异常，但结果不一定有效：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>a5 <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>array<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">])</span></div><div>a5<span style="color: #39adb5;">.</span>sum<span style="color: #39adb5;">(),</span> a5<span style="color: #39adb5;">.</span>max<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(nan, nan)</div>
</div>

<p>为此，<var type="module">numpy</var> 提供了一些以 <var>nan</var> 开头的特殊累计函数，它们可以忽略数组中的缺失值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>np<span style="color: #39adb5;">.</span>nansum<span style="color: #39adb5;">(</span>a5<span style="color: #39adb5;">),</span> np<span style="color: #39adb5;">.</span>nanmax<span style="color: #39adb5;">(</span>a5<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(6.0, 3.0)</div>
</div>

<h3>处理缺失值</h3>

<p><code>NaN</code> 虽然不像 <code>None</code> 的问题那么明显，但也容易出现奇怪的问题。接下来看看 <var type="module">pandas</var> 中对 <code>NaN</code> 的处理方式。</p>

<p>考虑到空值 <code>None</code> 的副作用太过明显，<var type="module">pandas</var> 会将空值自动转换为 <code>NaN</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">None</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">])</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
1    NaN
2    NaN
3    1.0
dtype: float64</div>
</div>

<p><code>Series</code> 和 <code>DataFrame</code> 均可以使用 <code>.isnull()</code> 和 <code>.notnull()</code> 方法来发现缺失值，它们像通用函数一样返回布尔数组，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">.</span>isnull<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    False
1     True
2     True
3    False
dtype: bool</div>
</div>

<p>这种布尔数组可以配合数组索引直接修改缺失值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">[</span>s03<span style="color: #39adb5;">.</span>isnull<span style="color: #39adb5;">()]</span> <span style="color: #7c4dff;">=</span> <span style="color: #f76d47;">2</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
1    2.0
2    2.0
3    1.0
dtype: float64</div>
</div>

<p><var type="module">pandas</var> 还提供了两种很好用的缺失值处理方式，分别是 <code>.dropna()</code> 和 <code>.fillna()</code> 方法，分别用于剔除缺失值和填充缺失值。在 <code>Series</code> 上使用这些方法比较易懂：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">.</span>dropna<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
3    1.0
dtype: float64</div>
</div>

<p>更复杂的情况涉及对 <code>DataFrame</code> 的缺失值处理，因为 <code>DataFrame</code> 增删的最小单元是一行或一列。默认情况下，<code>DataFrame.dropna()</code> 会剔除任何包含缺失值的整行数据。可以设置按不同的坐标轴剔除缺失值，比如 <code>axis=1</code>（或 <code>axis='columns'</code> ）会剔除任何包含缺失值的整列数据：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">([[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">],</span> <span style="color: #39adb5;">[</span>np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">]])</span></div><div>df01<span style="color: #39adb5;">.</span>dropna<span style="color: #39adb5;">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th><th>1</th><th>2</th>
        </tr>
        <tr>
            <td>1</td><td>2.0</td><td>3.0</td><td>5</td>
        </tr>
    </table></div>
</div>

<p>这种做法会把非缺失值一并剔除。有时候可能只需要剔除缺失值较多的行或列，这种需求可以通过以下两个参数来满足：</p>

<ul>
    <li><code><em>how</em></code> 参数的默认值是 <code>'any'</code> ，表示只要有缺失值就剔除整行或整列。还可以传入 <code>'all'</code> ，从而剔除全部是缺失值的行或列</li>
    <li><code><em>thresh</em></code> 参数用于设置需要保留的行或列中非缺失值的最小数量</li>
</ul>

<p>剔除缺失值时只关注特定的列也是一种常见的需求，因为有时 <code>DataFrame</code> 只有部分列会参与运算，而其它列无论是否包含缺失值都想保留下了。这时可以通过向 <code><em>subset</em></code> 参数传入包含列名的列表来指定剔除缺失值时只关注表的哪些部分。</p>

<p>除此之外，<code><em>inplace</em></code> 当然也是 <code>.dropna()</code> 方法具有的参数，说明该方法默认情况下也不修改原有表，而是得到一个剔除缺失值后的副本。</p>

<p><code>.fillna()</code> 方法用于填充缺失值。对于 <code>Series</code> 而言，该方法就是一个简单的替换：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">.</span>fillna<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    0.0
1    3.0
2    3.0
3    1.0
dtype: float64</div>
</div>

<p>对于 <code>DataFrame</code> 而言，除了用单个值填充所有的缺失位置外，还可以使用字典为不同列指定不同的填充值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span style="color: #39adb5;">.</span>fillna<span style="color: #39adb5;">({</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">20</span><span style="color: #39adb5;">})</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th><th>1</th><th>2</th>
        </tr>
        <tr>
            <td>0</td><td>1.0</td><td>20.0</td><td>2</td>
        </tr>
        <tr>
            <td>1</td><td>2.0</td><td>3.0</td><td>5</td>
        </tr>
        <tr>
            <td>2</td><td>10.0</td><td>4.0</td><td>6</td>
        </tr>
    </table></div>
</div>

<p><code>.fillna()</code> 方法还有以下两个常用参数：</p>

<ul>
    <li><code><em>method</em></code> ：参数指定填充的方法，例如 <code>"pad"</code> 或 <code>"ffill"</code> 用缺失值前或上面的有效值填充；<code>"bfill"</code> 或 <code>"backfill"</code> 用缺失值后或下面的有效值填充。默认用自定义行为填充</li>
    <li><code><em>limit</em></code> ：填充的最大数量</li>
</ul>

<!-- 可以用适当的对象方法代替运算符，并使用参数 <code><em>fill_value</em></code> 填充缺失的数据后再参与运算。 -->

<h3>可空类型</h3>

<p>最后要说明的是，尽管 <var type="module">pandas</var> 为处理 <code>NaN</code> 提供了很多便利的工具，但是尽可能不要向表中引入 <code>NaN</code> 。因为一旦表中出现一个 <code>NaN</code> ，会使得一列的数据类型都变成浮点数：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">(</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">),</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">int32</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>df02<span style="color: #39adb5;">.</span>iloc<span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> np<span style="color: #39adb5;">.</span>nan</div><div>df02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th><th>1</th><th>2</th><th>3</th>
        </tr>
        <tr>
            <td>0</td><td>0</td><td>1.0</td><td>2</td><td>3</td>
        </tr>
        <tr>
            <td>1</td><td>4</td><td>5.0</td><td>6</td><td>7</td>
        </tr>
        <tr>
            <td>2</td><td>8</td><td>NaN</td><td>10</td><td>11</td>
        </tr>
    </table></div>
</div>

<p>浮点数可能使得表在处理时出现问题。例如，如果一个整型或布尔数组出现了一个浮点数，那么它便无法用于索引。</p>

<p>为此，<var type="module">pandas</var> 提供了一类特别的可空类型，向可空类型中引入空值并不会使 <code>Series</code> 变为浮点数。目前 <var type="module">pandas</var> 具有的可空类型包括各种长度的 <code>Int</code> 和 <code>Float</code> 类型（注意首字母大写）、<code>string</code> 类型和 <code>boolean</code> 类型。</p>

<p>如果在创建 <code>Series</code> 时使用 <code><em>dtype</em></code> 参数指定类型为以上这些可空类型，那么其中的缺失值便会使用特别的缺失值指示器 <code>pd.NA</code> 代替：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s04 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">None</span><span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>nan<span style="color: #39adb5;">,</span> pd<span style="color: #39adb5;">.</span>NA<span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">],</span> </div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">Int32</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div>s04</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0       0
1    &lt;NA&gt;
2    &lt;NA&gt;
3    &lt;NA&gt;
4       1
dtype: Int32</div>
</div>

<p><code>pd.NA</code> 不代表任何实际的值，因此可以用在任何数组中而不会改变其原有类型。例如，如果创建一个类型为 <code>boolean</code> 的可空布尔数组，那么它便可用于索引，并且其中的 <code>pd.NA</code> 会被当做 <code>False</code> 用于索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">s05 </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> pd</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">Series</span><span style="color: #39adb5;">([</span><span style="color: #f76d47;">True</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">None</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">nan</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">False</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">boolean</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">[</span>s05<span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    1
dtype: int32</div>
</div>

<p>但截至 pandas 1.5 ，该功能似乎仍然处于实验阶段。</p>
<p><a rel="nofollow" href="/archives/1054">Python数据分析-pandas04:索引与缺失值</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1054/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-pandas03:深入认识索引</title>
		<link>/archives/1048</link>
					<comments>/archives/1048#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 06 Mar 2023 09:35:45 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[pandas]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1048</guid>

					<description><![CDATA[<p>Pandas索引机制 pandas 相比 numpy&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1048">Python数据分析-pandas03:深入认识索引</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>Pandas索引机制</h2>

<p><var type="module">pandas</var> 相比 <var type="module">numpy</var> ，一个很重要的特点就在于它引入了显式的索引机制。显式的索引在方便数据获取的同时，也可能造成学习上的困惑。接下来首先详细介绍 <var type="module">pandas</var> 的索引机制。</p>

<h3>Series与索引</h3>

<p>之前说过，<code>Series</code> 对象可以看作一种字典，它提供了索引与值对的映射，因此可以使用字典一样的方式获取值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">4</span><span token="symbol">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">c</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">])</span></div><div>s01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1</div>
</div>

<p><code>Series</code> 的许多操作都和 Python 字典很像，例如可以通过 item assignment 增加新的索引-值对，这等价于向 <code>Series</code> 添加新的一项：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">e</span><span token="symbol">'</span><span token="symbol">]</span> <span style="color: #7c4dff;">=</span> <span token="number">10</span></div></div>
</div>

<p>这种自定义的索引是显式的，它是真实存在的，因此可以向字典一样获取所有的索引-值对：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #8796b0;">list</span><span token="symbol">(</span>s01<span token="symbol">.</span>items<span token="symbol">())</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">[('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 10)]</div>
</div>

<p><code>Series</code> 不仅有着和字典一样的索引操作，还具备和 <var type="module">numpy</var> 数组一样的数组数据选择功能，例如数组索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
d    3
dtype: int32</div>
</div>

<p>这么看来，<code>Series</code> 的索引除了允许自定义外，和 <code>ndarray</code> 的索引好像没什么区别。不过注意，<code>Series</code> 的索引是允许重复的，这可能会导致一次性获取到多个值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s02 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">5</span><span token="symbol">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">])</span></div><div>s02<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
b    2
b    4
dtype: int32</div>
</div>

<p>此外，这种索引在用作切片时，得到的结果将包含后端的值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">:</span><span token="symbol">'</span><span style="color: #91b859;">d</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
c    2
d    3
dtype: int32</div>
</div>

<p>这样做的好处是不用明白它后一项的索引是什么。但如果索引有重复的话，将不能用于切片操作：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s02<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">:</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">Exception</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span><span style="color: #8796b0;">type</span><span token="symbol">(</span>e<span token="symbol">),</span> e<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'KeyError'> "Cannot get right slice bound for non-unique label: 'b'"</div>
</div>

<p>这种索引机制可能会导致数据获取的不便。但实际上，<code>Series</code> 依然保留了 <var type="module">numpy</var> 数组从零开始、切片时前闭后开的隐式索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="number">1</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">[</span><span token="number">1</span><span token="symbol">:</span><span token="number">3</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">b    1
c    2
dtype: int32</div>
</div>

<p>这两种索引方式很容易造成混淆，尤其是使用自定义整数作索引时，它可能会覆盖隐式索引，使得某些操作失效：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">4</span><span token="symbol">),</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>np<span token="symbol">.</span>arange<span token="symbol">(</span><span token="number">1</span><span token="symbol">,</span> <span token="number">5</span><span token="symbol">))</span></div><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s03<span token="symbol">[</span>s03<span token="symbol">.</span>argmin<span token="symbol">()]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">Exception</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span><span style="color: #8796b0;">type</span><span token="symbol">(</span>e<span token="symbol">),</span> e<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'KeyError'> 0</div>
</div>

<p>因此 <var type="module">pandas</var> 提供了一些<strong>索引器</strong>作为取值的方法，它们是 <code>Series</code> 对象暴露取值与切片接口的属性。</p>

<p>第一种索引器是 <code>.loc</code> 属性，表示用的是自定义、可重复、类型不限、切片时包含两端的显式索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span token="symbol">.</span>loc<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">a</span><span token="symbol">'</span><span token="symbol">:</span><span token="symbol">'</span><span style="color: #91b859;">b</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">a    0
b    1
dtype: int32</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s01<span token="symbol">.</span>loc<span token="symbol">[</span><span token="number">1</span><span token="symbol">]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">KeyError</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span>e<span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1</div>
</div>

<p>第二种索引器是 <code>.iloc</code> 属性，表示用的是从 0 开始、切片前闭后开的整数隐式(<span style="font-weight: bold;">i</span>mplicit)索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>iloc<span token="symbol">[</span>s03<span token="symbol">.</span>argmin<span token="symbol">()]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0</div>
</div>

<p>这两种索引器独立工作，不能混用，因此可以各自用于需要的场景中。</p>

<h3>DataFrame与索引</h3>

<p>之前说过 <code>DataFrame</code> 也可以看作一种字典，它提供了列索引与 <code>Series</code> 对的映射，因此可以使用字典一样的方式由列索引获取一个 <code>Series</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>DataFrame<span token="symbol">(</span></div><div>&#160; &#160; <span token="symbol">{</span><span token="symbol">'</span><span style="color: #91b859;">units</span><span token="symbol">'</span><span token="symbol">:</span> <span token="symbol">{</span><span token="symbol">'</span><span style="color: #91b859;">pencil</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">95</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">binder</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">30</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">paperclip</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">81</span><span token="symbol">},</span></div><div>&#160; &#160; &#160;<span token="symbol">'</span><span style="color: #91b859;">unitcost</span><span token="symbol">'</span><span token="symbol">:</span> <span token="symbol">{</span><span token="symbol">'</span><span style="color: #91b859;">pencil</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">1.99</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">binder</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">19.99</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">paperclip</span><span token="symbol">'</span><span token="symbol">:</span> <span token="number">4.99</span><span token="symbol">}})</span></div><div>df01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td>
        </tr>
        <tr>
            <td>binder</td><td>30</td><td>19.99</td>
        </tr>
        <tr>
            <td>paperclip</td><td>81</td><td>4.99</td>
        </tr>
    </table></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">unitcost</span><span token="symbol">'</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">pencil        1.99
binder       19.99
paperclip     4.99
Name: unitcost, dtype: float64</div>
</div>

<p>和前面介绍的 <code>Series</code> 对象一样，也可以用 item assignment 增加一列：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">total</span><span token="symbol">'</span><span token="symbol">]</span> <span style="color: #7c4dff;">=</span> df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">units</span><span token="symbol">'</span><span token="symbol">]</span> <span style="color: #7c4dff;">*</span> df01<span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">unitcost</span><span token="symbol">'</span><span token="symbol">]</span></div><div>df01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th><th>total</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td><td>189.05</td>
        </tr>
        <tr>
            <td>binder</td><td>30</td><td>19.99</td><td>599.70</td>
        </tr>
        <tr>
            <td>paperclip</td><td>81</td><td>4.99</td><td>404.19</td>
        </tr>
    </table></div>
</div>

<p>因此对列索引而言，它和 <code>Series</code> 的索引机制比较像。但是由于 <code>DataFrame</code> 行列都有索引，因此单级的显式索引只能作用于列，否则操作很容易引起歧义。</p>

<p>除此之外，直接对行或列应用隐式索引会引起错误。从概念上来说，对行和列的隐式索引容易存在误解：如果将 <code>DataFrame</code> 看作结构数组，那么一列就代表一个结构成员，列与列之间并没有严格的先后关系，直接取第几列这种操作无法让人明白其意图。而行虽然没有这种误解，但是会产生一个更关键的问题：直接取某一行使得行索引不再被用到而丢弃，返回一个 <code>Series</code> ，但是 <code>Series</code> 要求所有元素的类型一致，而一个结构各成员间往往有着各自各样的类型，强行统一它们的类型会造成类型提升，为后续操作带来更多问题。</p>

<p>一种特殊的情况是切片。切片将会保留行索引，得到的仍然是一个 <code>DataFrame</code> 。如果切片涉及的范围只有一行，那么就基本等价于获取 <code>DataFrame</code> 的某一行（虽然得到的仍然是一个二维数组）：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">[</span><span token="number">0</span><span token="symbol">:</span><span token="number">1</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th><th>total</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td><td>189.05</td>
        </tr>
    </table></div>
</div>

<p>因此，除了对列应用显式索引外，其它形式的索引不仅应该使用索引器，而且应该使用 <var type="module">numpy</var> 高维数组的索引方式。</p>

<p>例如，以下使用隐式索引器获取 <code>DataFrame</code> 的元素。这里在代表取值的方括号内传入了一个元组，第一个元素指代行的隐式索引，第二个元素指代列的隐式索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">.</span>iloc<span token="symbol">[</span><span token="number">2</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">4.99</div>
</div>

<p>根据隐式索引的规则，获取的应该是第 3 行第 2 列位置的元素。</p>

<p>再如，以下使用显式索引器得到指定几行的元素。这里对行应用数组索引，对列使用单个冒号 <code>:</code> 表示全部切片：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span token="symbol">.</span>loc<span token="symbol">[[</span><span token="symbol">'</span><span style="color: #91b859;">pencil</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">paperclip</span><span token="symbol">'</span><span token="symbol">],</span> <span token="symbol">:]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>units</th><th>unitcost</th><th>total</th>
        </tr>
        <tr>
            <td>pencil</td><td>95</td><td>1.99</td><td>189.05</td>
        </tr>
        <tr>
            <td>paperclip</td><td>81</td><td>4.99</td><td>404.19</td>
        </tr>
    </table></div>
</div>

<p>最后，下图总结了 <code>DataFrame</code> 的索引：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/03/09-dataframe-indexes.png" alt="" width="520">
</figure>

<h2>层级索引</h2>

<h3>层级索引的概念</h3>

通过之前的介绍可以认识到，<code>DataFrame</code> 是一种二维的结构。但有些时候，处理的数据可能不止两个维度。例如，在操作 Excel 时，经常可以看到这样的表格：

<table>
    <tr>
        <th></th><th></th>
        <th colspan="2">2021</th><th colspan="2">2022</th>
    </tr>
    <tr>
        <th></th><th></th>
        <th>mid term</th><th>end of term</th>
        <th>mid term</th><th>end of term</th>
    </tr>
    <tr>
        <td rowspan="3">grade 1</td>
        <td>class 1</td>
        <td>86</td><td>88</td>
        <td>89</td><td>90</td>
    </tr>
    <tr>
        <td>class 2</td>
        <td>88</td><td>87</td>
        <td>91</td><td>89</td>
    </tr>
    <tr>
        <td>class 3</td>
        <td>84</td><td>86</td>
        <td>86</td><td>85</td>
    </tr>
    <tr>
        <td rowspan="3">grade 2</td>
        <td>class 1</td>
        <td>86</td><td>94</td>
        <td>90</td><td>91</td>
    </tr>
    <tr>
        <td>class 2</td>
        <td>85</td><td>84</td>
        <td>87</td><td>91</td>
    </tr>
    <tr>
        <td>class 3</td>
        <td>87</td><td>91</td>
        <td>90</td><td>90</td>
    </tr>
</table>

<p>这种数据可以从四个维度聚合：对列来说，可以得出每个年度的得分平均值，也可以得出历年期中和期末的得分平均值；对行也是同理。只凭借二维数据无法实现这样的关系，这时就需要使用层级索引。层级索引可以从多个角度来描述数据的分组。</p>

<p><var type="module">pandas</var> 中的索引类型不仅限于数值和字符串，甚至还能使用元组，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01 <span style="color: #7c4dff;">=</span> <span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">3</span><span token="symbol">),</span></div><div>&#160; &#160; &#160; &#160;<span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">3</span><span token="symbol">)]</span></div><div>s03 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">([</span><span token="number">1341</span><span token="symbol">,</span> <span token="number">1412</span><span token="symbol">,</span> <span token="number">1263</span><span token="symbol">,</span> <span token="number">643</span><span token="symbol">,</span> <span token="number">632</span><span token="symbol">,</span> <span token="number">685</span><span token="symbol">],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>i01<span token="symbol">)</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">(A, 1)    1341
(A, 2)    1412
(A, 3)    1263
(B, 1)     643
(B, 2)     632
(B, 3)     685
dtype: int64</div>
</div>

<p>元组表示存储了多个值，是多级索引的基础。<var type="module">pandas</var> 的 <code>MultiIndex</code> 类提供了更丰富的操作方法。可以用它的类方法从元组创建一个多级索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i02 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_tuples<span token="symbol">(</span>i01<span token="symbol">,</span> <span style="color: #e53935;">names</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">class</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">group</span><span token="symbol">'</span><span token="symbol">])</span></div></div>
</div>

<p>通过 <code><em>names</em></code> 参数可以为这两个层级指定名称，方面区分各索引层。层级名称会保存到索引对象的 <code>.names</code> 属性中。</p>

<p>如果将前面创建的 <code>Series</code> 对象使用 <code>.reindex()</code> 方法将它的索引重置为 <code>MultiIndex</code> 对象，就会看到一个层级索引结构：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> s03<span token="symbol">.</span>reindex<span token="symbol">(</span><span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>i02<span token="symbol">)</span></div><div>s03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">class  group
A      1        1341
       2        1412
       3        1263
B      1         643
       2         632
       3         685
dtype: int64</div>
</div>

<p>关于层级索引，需要记住的是：层级索引可以看作一个元素对应多个索引，或者说一个索引元组。如果检查层级索引的 <code>.values</code> 属性，会发现每个索引都使用多个值来描述：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>index<span token="symbol">.</span>values</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([('A', 1), ('A', 2), ('A', 3), ('B', 1), ('B', 2), ('B', 3)],
      dtype=object)</div>
</div>

<p>因此在获取元素的时候，也需要通过多个值，或者说一个元组来获取：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1412</div>
</div>

<p>多个值或一个元组构成的索引也可以用于切片。除了索引由一个值变成一个元组外，均遵循一维 <code>Series</code> 的切片规则，例如可以使用显式索引器 <code>.loc</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">):(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">class  group
A      2        1412
       3        1263
B      1         643
dtype: int64</div>
</div>

<p>显式索引器使切片包含两端的元素。返回检查层级索引的 <code>.values</code> 属性可以发现，包含两端的元素确实是 3 个。</p>

<p>这里需要注意，如果层级索引不是有序的，那么大多数切片操作都会失败。以下演示一种会导致错误的操作：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>rand <span style="color: #7c4dff;">=</span> np<span token="symbol">.</span>random<span token="symbol">.</span>RandomState<span token="symbol">(</span><span token="number">3</span><span token="symbol">)</span></div><div>s04 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>Series<span token="symbol">(</span>rand<span token="symbol">.</span>rand<span token="symbol">(</span><span token="number">6</span><span token="symbol">),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_product<span token="symbol">([[</span><span token="symbol">'</span><span style="color: #91b859;">C</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="symbol">[</span><span token="number">1</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">]]))</span></div></div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span token="keyword">try</span><span token="symbol">:</span></div><div>&#160; &#160; s04<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">C</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">):(</span><span token="symbol">'</span><span style="color: #91b859;">A</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">)]</span></div><div><span token="keyword">except</span> <span style="color: #8796b0;">Exception</span> <span token="keyword">as</span> e<span token="symbol">:</span></div><div>&#160; &#160; <span style="color: #6182b8;">print</span><span token="symbol">(</span><span style="color: #8796b0;">type</span><span token="symbol">(</span>e<span token="symbol">))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">&lt;class 'pandas.errors.UnsortedIndexError'></div>
</div>

<p>问题出在切片和许多其它相似的操作都要求 <code>MultiIndex</code> 的各级索引是有序的。为此，<var type="module">pandas</var> 提供了一些操作可以实现对索引的排序，最简单的方法是 <code>.sort_index()</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s04<span token="symbol">.</span>sort_index<span token="symbol">(</span><span style="color: #e53935;">inplace</span><span style="color: #7c4dff;">=</span><span token="number">True</span><span token="symbol">)</span></div><div>s04<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">B</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">):(</span><span token="symbol">'</span><span style="color: #91b859;">C</span><span token="symbol">'</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">B  2    0.510828
C  1    0.550798
   2    0.708148
dtype: float64</div>
</div>

<p>经过索引排序后的切片结果就正常了。这里再次使用 <code><em>inplace</em></code> 参数来提醒默认情况下排序后得到的是一个新的对象，而不是在原有对象的基础上做修改。</p>

<p>层级索引相比普通的索引，索引类型由一个值变为多个值（或者说一个元组）。这看似多此一举，但是它允许从不同层面来处理一维的数据。如果访问层级索引的 <code>.level</code> 属性，可以得到：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>index<span token="symbol">.</span>levels</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">FrozenList([['A', 'B'], [1, 2, 3]])</div>
</div>

<p>这说明该层级索引有两层：从索引的角度看，第一层有 2 种不同的索引，第二层有 3 种不同的索引；从数据的角度看，根据第一层索引可以将数据分为 2 类，根据第二层可以将数据分为 3 类。因此数据在聚合、变换时，可以根据不同的索引层级，从不同的<em>角度</em>处理。例如，对于以上具有层级索引的 <code>Series</code> ，可以统计每个 <code>"class"</code> 的数值平均值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>sum<span token="symbol">(</span><span style="color: #e53935;">level</span><span style="color: #7c4dff;">=</span><span token="symbol">'</span><span style="color: #91b859;">class</span><span token="symbol">'</span><span token="symbol">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">class
A    4016
B    1960
dtype: int64</div>
</div>

<p>新版本的 <var type="module">pandas</var> 可能已经弃用了这种使用方式，或者抛出 <code>FutureWarning</code> ，提示说应该使用对表作分组计算后再合并，这就是以后介绍的内容了。</p>

<p>具有层级索引的 <code>Series</code> 很像一个 <code>DataFrame</code> 。事实上，使用对象的 <code>.unstack()</code> 方法可以将一个多级索引的 <code>Series</code> 转化为普通索引的 <code>DataFrame</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span token="symbol">.</span>unstack<span token="symbol">()</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>group</th><th>1</th><th>2</th><th>3</th>
        </tr>
        <tr>
            <td>class</td><td></td><td></td><td></td>
        </tr>
        <tr>
            <td>A</td><td>1341</td><td>1412</td><td>1263</td>
        </tr>
        <tr>
            <td>B</td><td>643</td><td>632</td><td>685</td>
        </tr>
    </table></div>
</div>

<p>或者使用 <code>.stack()</code> 方法实现相反的效果，将一个 <code>DataFrame</code> 变成具有多级索引的 <code>Series</code> 。 既然可以用含多级索引的一维 <code>Series</code> 数据表示二维数据，那么就可以用 <code>Series</code> 或 <code>DataFrame</code> 表示三维甚至更高维度的数据。借助多级索引，可以使三维及以上的数据以一种较为易读的形式表示出来。层级索引每增加一层，就表示数据增加一维，使得 <code>DataFrame</code> 可以表示任意维度的数据。因此 <var type="module">pandas</var> 并没有提供三维及以上的数量类型。</p>

<h3>DataFrame与层级索引</h3>

<p>在 <code>DataFrame</code> 使用层级索引和在 <code>Series</code> 上使用层级索引是一致的，只不过列索引和行索引都可以设置为层级索引。</p>

<p>以下创建一个较为复杂的、行列都具有两级索引的 <code>DataFrame</code> 用于演示：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03 <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>DataFrame<span token="symbol">(</span>rand<span token="symbol">.</span>randint<span token="symbol">(</span><span token="number">50</span><span token="symbol">,</span> <span token="number">95</span><span token="symbol">,</span> <span style="color: #e53935;">size</span><span style="color: #7c4dff;">=</span><span token="symbol">(</span><span token="number">4</span><span token="symbol">,</span> <span token="number">6</span><span token="symbol">)),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span>pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_product<span token="symbol">([[</span><span token="number">2020</span><span token="symbol">,</span> <span token="number">2021</span><span token="symbol">],</span> <span token="symbol">[</span><span token="number">1</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">]],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span style="color: #e53935;">names</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">year</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">term</span><span token="symbol">'</span><span token="symbol">]),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span>pd<span token="symbol">.</span>MultiIndex<span token="symbol">.</span>from_product<span token="symbol">([[</span><span token="symbol">'</span><span style="color: #91b859;">Tim</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">Mary</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">John</span><span token="symbol">'</span><span token="symbol">],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">physics</span><span token="symbol">'</span><span token="symbol">]],</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;<span style="color: #e53935;">names</span><span style="color: #7c4dff;">=</span><span token="symbol">[</span><span token="symbol">'</span><span style="color: #91b859;">name</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">subject</span><span token="symbol">'</span><span token="symbol">])</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; <span token="symbol">)</span></div><div>df03</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>name</th><th colspan="2">Tim</th><th colspan="2">Mary</th><th colspan="2">John</th>
        </tr>
        <tr>
            <th></th><th>subject</th><th>math</th><th>physics</th><th>math</th><th>physics</th><th>math</th><th>physics</th>
        </tr>
        <tr>
            <th>year</th><th>term</th><td></td><td></td><td></td><td></td><td></td><td></td>
        </tr>
        <tr>
            <td rowspan="2">2020</td><td>1</td><td>92</td><td>74</td><td>53</td><td>58</td><td>50</td><td>71</td>
        </tr>
        <tr>
            <td>2</td><td>69</td><td>60</td><td>93</td><td>91</td><td>60</td><td>71</td>
        </tr>
        <tr>
            <td rowspan="2">2021</td><td>1</td><td>88</td><td>82</td><td>70</td><td>94</td><td>79</td><td>89</td>
        </tr>
        <tr>
            <td>2</td><td>64</td><td>76</td><td>67</td><td>76</td><td>72</td><td>52</td>
        </tr>
    </table></div>
</div>

<p>对 <code>DataFrame</code> 索引和 <code>Series</code> 基本一致，需要通过元组形式的索引来获取一个 <code>Series</code> ，并会保留行的层级索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03<span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">John</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">year  term
2020  1       50
      2       60
2021  1       79
      2       72
Name: (John, math), dtype: int32</div>
</div>

<p>索引器和切片的用法都是一致的：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03<span token="symbol">.</span>loc<span token="symbol">[(</span><span token="number">2020</span><span token="symbol">,</span> <span token="number">1</span><span token="symbol">):(</span><span token="number">2020</span><span token="symbol">,</span> <span token="number">2</span><span token="symbol">),</span> <span token="symbol">[(</span><span token="symbol">'</span><span style="color: #91b859;">John</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">),</span> <span token="symbol">(</span><span token="symbol">'</span><span style="color: #91b859;">Mary</span><span token="symbol">'</span><span token="symbol">,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">)]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>name</th><th>John</th><th>Mary</th>
        </tr>
        <tr>
            <th>subject</th><th>math</th><th>math</th>
        </tr>
        <tr>
            <th>year</th><th>term</th><th></th><td></td>
        </tr>
        <tr>
            <td>2020</td><td>1</td><td>50</td><td>53</td><td></td>
        </tr>
        <tr>
            <td></td><td>2</td><td>60</td><td>93</td>
        </tr>
    </table></div>
</div>

<p>不过这种索引元组的用法不是很方便，因为这个 <code>DataFrame</code> 实际上可以看作四维数据，但是只能在两个维度上切片。如果想获取所有人在第 1 学期的数学成绩，那么可能需要这样的索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df03<span token="symbol">.</span>loc<span token="symbol">[(:,</span> <span token="number">1</span><span token="symbol">),</span> <span token="symbol">(:,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">)]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">  Cell In [35], line 1
        df03.loc[(:, 1), (:, 'math')]
                  ^
<span style="color: red;">SyntaxError</span>: invalid syntax</div>
</div>

<p>这是错误的用法，它会直接导致解释出错。为此，<var type="module">pandas</var> 提供了 <code>IndexSlice</code> 对象，专门用来解决高维 <code>DataFrame</code> 的切片问题，例如：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>Idx <span style="color: #7c4dff;">=</span> pd<span token="symbol">.</span>IndexSlice</div><div>df03<span token="symbol">.</span>loc<span token="symbol">[</span>Idx<span token="symbol">[:,</span> <span token="number">1</span><span token="symbol">],</span> Idx<span token="symbol">[:,</span> <span token="symbol">'</span><span style="color: #91b859;">math</span><span token="symbol">'</span><span token="symbol">]]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>name</th><th>Tim</th><th>Mary</th><th>John</th>
        </tr>
        <tr>
            <th></th><th>subject</th><th>math</th><th>math</th><th>math</th>
        </tr>
        <tr>
            <td>year</td><td>term</td><td></td><td></td><td></td>
        </tr>
        <tr>
            <td>2020</td><td>1</td><td>92</td><td>53</td><td>50</td>
        </tr>
        <tr>
            <td>2021</td><td>1</td><td>88</td><td>70</td><td>79</td>
        </tr>
    </table></div>
</div>

<p>下图总结了 <code>DataFrame</code> 的层级索引：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/03/09-dataframe-multi-indexes.png" alt="" width="720">
</figure>
<p><a rel="nofollow" href="/archives/1048">Python数据分析-pandas03:深入认识索引</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1048/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Python数据分析-pandas01:基本数据类型</title>
		<link>/archives/1041</link>
					<comments>/archives/1041#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Mon, 27 Feb 2023 07:03:43 +0000</pubDate>
				<category><![CDATA[数据处理]]></category>
		<category><![CDATA[pandas]]></category>
		<category><![CDATA[Python]]></category>
		<guid isPermaLink="false">/?p=1041</guid>

					<description><![CDATA[<p>Pandas简介 之前详细介绍了 NumPy 和它的&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1041">Python数据分析-pandas01:基本数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>Pandas简介</h2>

<p><a href="/all/data-science">之前</a>详细介绍了 <var type="module">NumPy</var> 和它的 <code>ndarray</code> 多维数组对象，为 Python 多维数组提供了高效的存储和处理方法。</p>

<p>本章基于前面的知识，继续学习 <a href="https://pandas.pydata.org/">Pandas</a> 库提供的数据操作方法。<code>Pandas</code> 是在 <code>NumPy</code> 基础上建立的另一个第三方库，提供了一种高效的 <code>DataFrame</code> 数据结构。<code>DataFrame</code> 本质上是一种带行标签和列标签、支持相同类型数据和缺失值的多维数组。<code>Pandas</code> 不仅为带各种标签的数据提供了便利的存储与展示接口，还实现了许多强大的计算、查找和分类等操作。</p>

<p><var type="module">pandas</var> 在底层存储时使用的是 <var type="module">numpy</var> 的数组，因此在安装 <var type="module">pandas</var> 之前，需要确保已经安装了 <var type="module">numpy</var> 。</p>

<p>在安装完成 <code>pandas</code> 之后，可以导入它检查一下版本号：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">import</span> pandas</div><div>pandas.__version__</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">'1.3.1'</div>
</div>

<p>和之前导入 <var type="module">numpy</var> 并使用别名 <code>np</code> 一样，之后将导入 <var type="module">pandas</var> 并使用别名 <code>pd</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">import</span> pandas <span style="color: #f76d47;">as</span> pd</div></div>
</div>

<h2>Pandas的数据对象</h2>

<h3>Series对象</h3>

<p><var type="module">pandas</var> 最简单的数据类型是 <code>Series</code> 。<code>Series</code> 对象是一个带索引数据构成的一维数组。可以用一个数组创建 <code>Series</code> 对象，如下所示：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">])</span></div><div>s01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0    1
1    2
2    3
3    4
dtype: int64</div>
</div>

<p><code>Series</code> 对象将一组数据和一组索引绑定在一起，可以通过 <code>.values</code> 属性获取数据，通过 <code>.index</code> 属性获取索引。<code>.values</code> 属性返回的结果就是底层的 <var type="module">numpy</var> 数组：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">.</span>values</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([1, 2, 3, 4], dtype=int64)</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #6182b8;">isinstance</span><span style="color: #39adb5;">(</span>s01<span style="color: #39adb5;">.</span>values<span style="color: #39adb5;">,</span> np<span style="color: #39adb5;">.</span>ndarray<span style="color: #39adb5;">)</span></div></div>    
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">True</div>
</div>

<p><code>.index</code> 属性返回的结果是一个类型为 <code>Index</code> 的索引对象。索引是 <var type="module">pandas</var> 的特点之一，将在后面的内容里详细介绍它。</p>

<p>和 <var type="module">numpy</var> 数组一样，可以通过中括号实现索引或切片：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">[</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">3</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s01<span style="color: #39adb5;">[</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1    2
2    3
3    4
dtype: int64</div>
</div>

<p>这么看来，<var type="module">pandas</var> 的 <code>Series</code> 与 <var type="module">numpy</var> 的一维数组很类似。但 <code>Series</code> 为数组提供了一种更加强大的索引系统：<var type="module">numpy</var> 数组通过隐式定义的整数索引获取数值，而 <var type="module">pandas</var> 的 <code>Series</code> 对象用可以手动指定索引与数值关联。</p>

<p>显式索引的定义让 <code>Series</code> 拥有了更好的可读性。例如，索引不再仅仅是整数，还可以是任意想要的类型。如果需要，完全可以用字符串定义索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">([</span><span style="color: #f76d47;">0.25</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">0.5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">0.75</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1.0</span><span style="color: #39adb5;">],</span> <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">a</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">b</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">c</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">d</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">])</span></div><div>s02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">a    0.25
b    0.50
c    0.75
d    1.00
dtype: float64</div>
</div>

<p>在使用索引访问元素时，可以通过之前定义的字符索引获取数值：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">b</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">0.5</div>
</div>

<p>这种数值的访问形式很像 Python 字典，可以将每个索引作为键映射到一个值。因此可以直接使用 Python 的字典创建一个 <code>Series</code> 对象，让两者的类比更加清晰：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">({</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">key1</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">key2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">keyi</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span></div><div>&#160; &#160; <span style="color: #39adb5;">'</span><span style="color: #91b859;">keyn</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">10</span></div><div><span style="color: #39adb5;">})</span></div></div>
</div>

<p>由于 Python3.6+ 的字典是有序的，因此创建的 <code>Series</code> 对象索引也默认按照顺序排列。</p>

<p>除了可以使用像字典一样按键获取数值外，<code>Series</code> 的索引还可以用于切片操作：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>s03<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">key2</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">keyn</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">key2     2
keyi     5
keyn    10
dtype: int64</div>
</div>

<p>这种切片是包括终点位置的元素的，这和普通的索引形式不同。后续会详细介绍这种索引规则。</p>

<h3>DataFrame对象</h3>

<p><var type="module">pandas</var> 的另一个基础数据结构是 <code>DataFrame</code> 。<code>DataFrame</code> 可以看作是一种二维数组，但它既有行索引，又有列索引，因此它经常被当做一个表格使用。注意，<code>DataFrame</code> 是 <var type="module">pandas</var> 的非常重要的一个数据类型，因为它可以很好地表达日常生活中处理的各种表格结构。<code>DataFrame</code> 与 Excel 中表格或 SQL 中表的概念非常相似，可以实现大多数 Excel 或 SQL 的表操作。</p>

<p><code>DataFrame</code> 有许多创建方式，每种创建方式都代表着对它的理解。例如，和 <code>Series</code> 对象一样，<code>DataFrame</code> 可以看作一个更灵活的 <var type="module">numpy</var> 二维数组。因此可以直接使用二维数据创建 <code>DataFrame</code> ，只要手动指定符合形状的行列索引即可：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>arange<span style="color: #39adb5;">(</span><span style="color: #f76d47;">12</span><span style="color: #39adb5;">).</span>reshape<span style="color: #39adb5;">((</span><span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">)),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">index</span><span style="color: #7c4dff;">=</span><span style="color: #6182b8;">range</span><span style="color: #39adb5;">(</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">4</span><span style="color: #39adb5;">),</span></div><div>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; <span style="color: #e53935;">columns</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">A</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">B</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">C</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">D</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">])</span></div><div>df01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>A</th><th>B</th><th>C</th><th>D</th>
        </tr>
        <tr>
            <td>1</td><td>0</td><td>1</td><td>2</td><td>3</td>
        </tr>
        <tr>
            <td>2</td><td>4</td><td>5</td><td>6</td><td>7</td>
        </tr>
        <tr>
            <td>3</td><td>8</td><td>9</td><td>10</td><td>11</td>
        </tr>
    </table></div>
</div>

<p>也可以把 <code>DataFrame</code> 看成是一种结构数组，每行表示一个结构元素，行索引表示每个结构元素的索引，列索引则表示的是结构的字段名。因此，当然可以使用 <var type="module">numpy</var> 的结构数组来创建 <code>DataFrame</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>np<span style="color: #39adb5;">.</span>zeros<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #e53935;">dtype</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">[(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">A</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">i8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">),</span> <span style="color: #39adb5;">(</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">B</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">f8</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)]))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>A</th><th>B</th>
        </tr>
        <tr>
            <td>0</td><td>0</td><td>0.0</td>
        </tr>
        <tr>
            <td>1</td><td>0</td><td>0.0</td>
        </tr>
        <tr>
            <td>2</td><td>0</td><td>0.0</td>
        </tr>
    </table></div>
</div>

<p>结构数组的表述便于理解，但实际上可能会带来一些误解。例如，<code>DataFrame</code> 的索引和 <var type="module">numpy</var> 的二维数组索引不太一样：在 <var type="module">numpy</var> 的二维数组里，<code>arr[0]</code> 被认为是一个嵌套数组返回包含的第一个子数组；而在 <var type="module">pandas</var> 中，第一层索引得到的结果是一个列的数据：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df01<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">A</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">1    0
2    4
3    8
Name: A, dtype: int32</div>
</div>

<p>对 <code>DataFrame</code> 一种更好的理解方式是看作一个数组字典，每一个索引都可以看作是字典的一个键，对应一个列的数据；这些数据是一系列同种类型的数值，或者说一个 <code>Series</code> 。也就是说，<code>DataFrame</code> 是具有共同索引的若干 <code>Series</code> 对象组合。</p>

<p>因此，使用单个 <code>Series</code> 创建的是一个单列的 <code>DataFrame</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">(</span>pd<span style="color: #39adb5;">.</span>Series<span style="color: #39adb5;">(</span></div><div>&#160; &#160; <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">bread</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">279</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">biscuit</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">78</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">strawberry</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">26</span><span style="color: #39adb5;">}))</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>0</th>
        </tr>
        <tr>
            <td>bread</td><td>279</td>
        </tr>
        <tr>
            <td>biscuit</td><td>78</td>
        </tr>
        <tr>
            <td>strawberry</td><td>26</td>
        </tr>
    </table></div>
</div>

<p>如果能接受这种 <code>DataFrame</code> 的理解方式，不仅容易记住它的创建方式，也有助于明白对它的操作会得到什么样的结果。</p>

<p>创建 <code>DataFrame</code> 的方式非常丰富，只要能表达出这种二维的 <span class="code-font">{column: series}</span> 的映射关系基本都可以用于创建它。例如，可以使用一组具有<em>相同索引</em>的 <code>Series</code> 对象创建它；由于 <code>Series</code> 可以被看作特殊的字典，因此也可以使用一个二维字典来创建一个 <code>DataFrame</code> 对象：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>price <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">cake</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">23</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">cookie</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">bread</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">10</span><span style="color: #39adb5;">}</span></div><div>sales <span style="color: #7c4dff;">=</span> <span style="color: #39adb5;">{</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">cake</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">cookie</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">14</span><span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">bread</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> <span style="color: #f76d47;">23</span><span style="color: #39adb5;">}</span></div><div>df02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>DataFrame<span style="color: #39adb5;">({</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">price</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> price<span style="color: #39adb5;">,</span> <span style="color: #39adb5;">'</span><span style="color: #91b859;">sales</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">:</span> sales<span style="color: #39adb5;">})</span></div><div>df02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>price</th><th>sales</th>
        </tr>
        <tr>
            <td>cake</td><td>23</td><td>5</td>
        </tr>
        <tr>
            <td>cookie</td><td>6</td><td>14</td>
        </tr>
        <tr>
            <td>bread</td><td>10</td><td>23</td>
        </tr>
    </table></div>
</div>

<p>如果明白“<code>DataFrame</code> 是一组具有<em>相同索引</em>的 <code>Series</code> 对象组合”，就会知道字典的嵌套与被嵌套的关系：内层的字典应该要具有相同的键。</p>

<p>如果能理解这种嵌套关系，那么就可以很自然地明白数据获取方式：第一次索引将以列索引值为键，得到一个列作为字典；第二次索引将以行索引值为键，从得到字典中获取相应的元素：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">price</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">][</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">cookie</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">6</div>
</div>

<p>和 Python 字典一样，<code>Series</code> 和 <code>DataFrame</code> 还支持 item assignment ，对 <code>Series</code> 的操作结果是更新项或添加项，对 <code>DataFrame</code> 的操作结果是更新列或添加列：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">sum</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">=</span> df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">price</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span> <span style="color: #7c4dff;">*</span> df02<span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">sales</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]</span></div><div>df02</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><table class="pandas-dataframe">
        <tr>
            <th></th><th>price</th><th>sales</th><th>sum</th>
        </tr>
        <tr>
            <td>cake</td><td>23</td><td>5</td><td>115</td>
        </tr>
        <tr>
            <td>cookie</td><td>6</td><td>14</td><td>84</td>
        </tr>
        <tr>
            <td>bread</td><td>10</td><td>23</td><td>230</td>
        </tr>
    </table></div>
</div>

<h3>Index对象</h3>

<p><var type="module">pandas</var> 的 <code>Index</code> 对象是构成 <code>Series</code> 和 <code>DataFrame</code> 显式索引的基础。</p>

<p><code>Series</code> 是一维的数据，因此需要一个 <code>Index</code> 对象用于获取数据，这个对象被保存在它的 <code>.index</code> 属性中。而二维的 <code>DataFrame</code> 需要两个 <code>Index</code> 对象来定位数据，它们分别是代表行的 <code>.index</code> 属性和代表列的 <code>.columns</code> 属性：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">.</span>index</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Index(['cake', 'cookie', 'bread'], dtype='object')</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>df02<span style="color: #39adb5;">.</span>columns</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Index(['price', 'sales'], dtype='object')</div>
</div>

<p><code>Index</code> 对象可以看作是一个不可变数组，因此可以像创建数组一样创建 <code>Index</code> 对象：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Index<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">6</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">])</span></div><div>i01</div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 3, 5, 6, 7], dtype='int64')</div>
</div>

<p>除了没有那么丰富的创建方法外，<code>Index</code> 对象的许多属性与操作都像数组，例如索引与切片：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01<span style="color: #39adb5;">[[</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">2</span><span style="color: #39adb5;">]]</span> &#160;<span style="color: #a8a8a8;"># array indexing</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 3, 5], dtype='int64')</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i01<span style="color: #39adb5;">[:</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">:</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">]</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 5], dtype='int64')</div>
</div>

<p>两者之间的不同在于 <code>Index</code> 对象是不可变的，这种特征使得多个 <code>DataFrame</code> 等类型之间共享索引时更加安全，可以避免修改索引而破坏表的结构。</p>

<p>一种对 <code>Index</code> 更精确的描述是<em>有序集合</em>。<var type="module">pandas</var> 对象被设计用于实现许多操作，如合并数据集，这就要求相同列之间需要合并。<code>Index</code> 对象遵循 Python 标准库的集合 <code>set</code> 数据结构的许多习惯用法，包括并集、交集、差集等：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i02 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Index<span style="color: #39adb5;">([</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">9</span><span style="color: #39adb5;">])</span></div><div>i03 <span style="color: #7c4dff;">=</span> pd<span style="color: #39adb5;">.</span>Index<span style="color: #39adb5;">([</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">3</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">5</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">7</span><span style="color: #39adb5;">,</span> <span style="color: #f76d47;">11</span><span style="color: #39adb5;">])</span></div><div>i02 <span style="color: #7c4dff;">&amp;</span> i03 &#160;<span style="color: #a8a8a8;"># intersection</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([3, 5, 7], dtype='int64')</div>

    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div>i02<span style="color: #39adb5;">.</span>union<span style="color: #39adb5;">(</span>i03<span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">Int64Index([1, 2, 3, 5, 7, 9, 11], dtype='int64')</div>
</div>

<p>高版本的 <var type="module">pandas</var> 可能已经弃用了运算符重载的形式，或对其抛出警告，因此一般更推荐直接调用对象的方法实现这些运算。</p>
<p><a rel="nofollow" href="/archives/1041">Python数据分析-pandas01:基本数据类型</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1041/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>机器学习-决策树</title>
		<link>/archives/1020</link>
					<comments>/archives/1020#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Wed, 08 Feb 2023 15:46:24 +0000</pubDate>
				<category><![CDATA[机器学习]]></category>
		<guid isPermaLink="false">/?p=1020</guid>

					<description><![CDATA[<p>决策树 决策树简介 和朴素贝叶斯一样，决策树(dec&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/1020">机器学习-决策树</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>决策树</h2>

<h3>决策树简介</h3>

<p>和<a href="/archives/953">朴素贝叶斯</a>一样，决策树(decision tree)也是一种简单但有效的分类算法。决策树的原理是将数据的分布规律表达为一系列的条件判断，从而在引入新样本时通过一系列条件判断将其分到合理的类别中。这一系列条件判断会形成一个树形的结构，每个节点都是一次判断过程：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-decision-tree-concept.png" alt="" width="400">
    <figcaption>根据网图改的</figcaption>
</figure>

<p>接下来看一个实际的示例。对于以下数据：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-output-decision-step-0.png" alt="" width="340">
</figure>

<p>显然靠左侧位置分布的都是红色的样本，因此第一次可以将这些样本划分出来：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-output-decision-step-1.png" alt="" width="340">
</figure>

<p>而靠右侧位置分布的都是蓝色的样本，接下来将这些样本划分出来：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-output-decision-step-2.png" alt="" width="340">
</figure>

<p>对于中间位置的样本，靠上方的是蓝色位置的样本：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-output-decision-step-3.png" alt="" width="340">
</figure>

<p>靠下方的是红色位置的样本：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-output-decision-step-4.png" alt="" width="340">
</figure>

<p>这几个决策过程就构成了完整的分类依据。</p>

<p>在 Scikit-Learn 中，可以从以下位置导入决策树：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">from</span><span style="color: #90a4ae;"> sklearn</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">tree </span><span style="color: #39adb5;font-weight: bold;">import</span><span style="color: #90a4ae;"> DecisionTreeClassifier</span></div><br><div><span style="color: #90a4ae;">model </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> DecisionTreeClassifier</span><span style="color: #39adb5;">().</span><span style="color: #90a4ae;">fit</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">X</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> y</span><span style="color: #39adb5;">)</span></div></div>
</div>

<p>下图展示了 Scikit-Learn 中决策树的分类边界：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-output-decision-step-std.png" alt="" width="420">
</figure>

<p>可以看到 Scikit-Learn 中的决策树似乎找到了一个更好的规律，使得只需要两次判断就能完成分类。不过相应的决策边界更靠近样本，过拟合的可能性增大。</p>

<p>既然一个数据集的决策树不是唯一的，那么就需要有一种指标来衡量哪些是好的决策树，或者说如何建立一棵决策树。决策树的建树依据主要是<strong>基尼系数</strong>(gini)和<strong>信息熵</strong>(Entropy)，它们的本质都是一样的，用于度量一个系统中的失序程序。建立决策树的思路就是使每一次决策后系统的混乱程度降低，从而得到有序的决策结果。</p>

<blockquote>
    <h4>什么是基尼系数</h4>

    <p>数据集 <span class="math">\\( D \\)</span> 的基尼系数 <span class="math">\\( \text{Gini}(D) \\)</span> 反映了从数据集 <span class="math">\\( D \\)</span> 中随机抽取两个样本，它们的类别不一致的概率。因此，如果数据有 <span class="math">\\( k \\)</span> 个类别，则基尼系数的计算公式为：</p>

    <div class="math">
    \\[
        \text{Gini}(D) = \sum_{i=1}^{k} p_i(1-p_i) = 1 - \sum_{i=1}^{k} p_i^2
    \\]
    </div>

    <p>基尼系数用于衡量一个系统的不确定性，系统的基尼系数越大，表示系统不确定性越高，系统的混乱程度越高，分类效果越差。</p>
    
    <p>接下来看一个具体示例。假设某个数据集中有 300 个数据，形成 3 个分类，每个分类数据个数相同，那么数据集的基尼系数为：</p>

    <div class="math">
    \\[
        \begin{align}
            \text{Gini}(D) &= 1 - (\frac 1 3)^2 - (\frac 1 3)^2 - (\frac 1 3)^2 \\
            &= \frac 2 3 \approx 0.67
        \end{align}
    \\]
    </div>

    <p>经过决策树的一次分类，将 <span class="math">\\( S_1=100 \\)</span> 个数据划分成一个子数据集，该数据集分别包含每个分类的样本 10 、20 、70 个，那么该子数据集的基尼系数为：</p>

    <div class="math">
        \\[
            \begin{align}
                \text{Gini}(D_1) &= 1 - (\frac 1 {10})^2 - (\frac 2 {10})^2 - (\frac 7 {10})^2 \\
                &= 0.46
            \end{align}
        \\]
    </div>

    <p>而另一部分子数据集的基尼系数为：</p>

    <div class="math">
        \\[
            \begin{align}
                \text{Gini}(D_2) &= 1 - (\frac 9 {20})^2 - (\frac 8 {20})^2 - (\frac 3 {20})^2 \\
                &= 0.615
            \end{align}
        \\]
    </div>

    <p>分类后，整个数据集的基尼系数需要考虑各自的样本量：</p>

    <div class="math">
    \\[
        \begin{align}
            \text{Gini}(D) &= \frac{S_1}{S_1 + S_2}\text{Gini}(D_1) + \frac{S_2}{S_1 + S_2}\text{Gini}(D_2) \\
            &\approx 0.563
        \end{align}
    \\]
    </div>

    <p>划分后，系统的基尼系数降低，说明该划分有效。从直观上看，每个子数据集的样本更容易确定属于哪个类别，样本的纯度更高。因此基尼系数也称<strong>基尼不纯度</strong>(gini impurity)</p>
    
    <p>如果经过若干次划分后，每个数据集中所有的样本都属于同一个类别，那么此时每个数据集的基尼系数为 0 ，总的基尼系数也为 0 ，得到了最好的划分结果。决策树的目的就是得到这样的结果。</p>
</blockquote>

<p>除了基尼系数外，还可以使用信息熵作为评估方式，它的含义是类似的。具体使用哪种评估方式通过超参数 <code><em>criterion</em></code> 设置，默认的标准是基尼系数。</p>

<p>决策树的一个特点是它天然支持多分类，而不需要使用一对多方法实现。下图展示了一棵多分类决策树的决策边界：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-tree-multi-classification.png" alt="" width="450">
</figure>

<p>对于连续数据，Scikit-Learn 使用<strong>分类和回归树</strong>(Classification and Regression Tree, CART)算法来建立一棵决策树，该算法找到某个特征变量合适的切分点，使得切分后左右两侧数据总体的基尼系数发生下降，那么说明这是一次合理的切分，可以作为一次决策过程。而左右两侧数据可以使用相同的逻辑递归切分，直到总的基尼系数降为 0 或达到停止条件为止。可以看出该算法仅生成二叉树，即它是一种 <code>if ... else</code> 形式的决策。而其它算法（例如 ID3 算法和它的改进版 C4.5 算法）可能找到多个切分点，形成类似 <code>elif</code> 的决策。</p>

<p>CART 是一种贪婪算法，因为每次切分只能得到一个局部较优解，但不能确定是否是全局最优解。而寻找全局最优解是一个很复杂的问题，当前的算法需要采用指数级的时间复杂度才能给出解，显然是不实际的。</p>

<p>CART 算法的这种性质还会带来另一个问题：由于每次被切分的维度是任意的，因此同一个模型多次调用决策树得到的决策边界往往不会完全相同。下图展示了相同的数据集使用不同随机种子生成的决策树，由于每次选择不同的维度划分数据而导致不同的结果：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-tree-param-randseed.png" alt="" width="500">
</figure>

<p>除此之外，由于 CART 算法每次都只从一个维度上切分，因此得到的决策边界由垂直于坐标轴的直线构成。如果数据集的边界是倾斜的，那么决策树只能通过锯齿状的边界来模拟它，这既会导致不必要的多次判断，也容易使决策树发生过拟合：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-output-tree-rotate.png" alt="" width="500">
    <figcaption>一个简单的数据集旋转后划分效果变得更糟</figcaption>
</figure>

<h3>正则化与决策树剪枝</h3>

<p>以上多分类的决策树看似表现良好，但注意到其中出现了一些不合常理的细长边界，这说明决策树可能已经出现了过拟合。</p>

<p>解决过拟合的方式是约束模型的某些参数不要过大，而约束决策树的方式是让它不要过度生长，导致决策太详细而出现过拟合。<strong>剪枝</strong>(pruning)是常见的约束方式，用于缩小决策树的规模，在防止决策树出现过拟合的同时还能提高分类速度。</p>

<p>决策树的剪枝方式主要分为以下两种：</p>

<ul>
    <li><strong>前剪枝</strong>(Pre-Pruning)</li>
</ul>

<p>前剪枝的思路是设置一个生长阈值，使决策树在生长完成前如果达到阈值就停止生长。</p>

<p>最简单的约束条件就是约束决策树的深度（根到树叶的路径长），在 Scikit-Learn 中由超参数 <code><em>max_depth</em></code> 控制。一旦达到最大深度，则决策树停止生长。</p>

<p>除了最大深度外，Scikit-Learn 还提供了一些其它前剪枝参数，如下：</p>

<table>
    <tr>
        <th>参数</th>
        <th>说明</th>
    </tr>
    <tr>
        <td class="code-font">min_samples_split</td>
        <td>节点继续划分（生长）所需的最小样本数，默认值为 2 ，因此只要可以都会继续划分</td>
    </tr>
    <tr>
        <td class="code-font">min_samples_leaf</td>
        <td>叶节点需要包含的最小样本数，默认值为 1 ，因此可能出现单个异常样本被划到一组的情况</td>
    </tr>
    <tr>
        <td class="code-font">max_leaf_nodes</td>
        <td>最大叶节点数，默认值 <code>None</code> 代表不限制，因此形成的决策边界可以无限复杂</td>
    </tr>
    <tr>
        <td class="code-font">min_impurity_decrease</td>
        <td>如果继续划分能使基尼不纯度的下降大于该值，那么便继续划分。默认值 0.0 代表只要能使不纯度下降就继续划分</td>
    </tr>
</table>

<p>可以看出决策树的默认参数并没有限制决策树的增长，适当增加最小值与约束最大值可以防止异常值的影响，并增强决策树的泛化能力。下图展示了一棵没有约束的决策树和加上不同约束条件后的决策边界：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-tree-param-pre-pruning.png" alt="" width="540">
</figure>

<ul>
    <li><strong>后剪枝</strong>(Post-Pruning)</li>
</ul>

<p>相比前剪枝，后剪枝的处理方式更复杂但也更有效。后的思路是先让决策树完全生长，再将其中不必要的分支去除（通常去除某个节点的子树或在结果中合并相近的类别）。后剪枝有许多算法，其中比较常用的是<strong>代价复杂度剪枝</strong>(Cost Complexity Pruning, CCP)。</p>

<p>剪枝用于平衡决策树的规模和正确率，代价复杂度剪枝中<em>代价</em>表示因剪枝而增加的错分样本，<em>复杂度</em>表示因剪枝而缩减的树的规模。代价复杂度剪枝使用以下公式衡量某个节点子树的代价复杂度：</p>

<div class="math">
\\[
    \alpha = \frac{R(t) - R(T)}{N(T)-1}
\\]
</div>

<p>其中 <span class="math">\\( R(T) \\)</span> 表示该节点未剪枝时的误差，<span class="math">\\( R(t) \\)</span> 表示剪枝后的误差，那么分母就表示由于剪枝增加的误差（代价）；<span class="math">\\( N(T) \\)</span> 表示该节点所有子树的树叶个数，那么分子可以反映子树的规模（复杂度）；因此 <span class="math">\\( \alpha \\)</span> 代表总体的代价复杂度，如果 <span class="math">\\( \alpha \\)</span> 很小，代表剪除某个节点的子树增加的误差不大且能去除较大规模的枝叶，那么这就是一次好的剪枝。</p>

<p>在实际剪枝中，一般先计算决策树每个非叶节点的 <span class="math">\\( \alpha \\)</span> ，并按 <span class="math">\\( \alpha \\)</span> 由小到大的顺序剪除对应节点的子树，直到设定的 <span class="math">\\( \alpha \\)</span> 阈值为止。也可以从每次剪枝都得到的决策树中选择最好的一棵。</p>

<!-- 
<blockquote>
    <figure>
        <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-CCP-example.png" alt="" width="390">
    </figure>

    <div class="math">
    \\[
        R(t) = r(t) \, p(t)
    \\]
    </div>

    <p>其中 <span class="math">\\( r(t) \\)</span> 为节点样本错误分类的比例，<span class="math">\\( p(t) \\)</span> 为节点包含样本占所有样本的比例。</p>

    <div class="math">
    \\[
        R(T) = \sum_i^{m}r_i(t) p_i(t)
    \\]
    </div>

    <p><code>#5</code> 节点的 <span class="math">\\( \alpha \\)</span></p> 
</blockquote> 
-->

<p>在 Scikit-Learn 中，可以通过 <code>.cost_complexity_pruning_path(<em>X</em>, <em>y</em>)</code> 方法获取决策树每一次 CCP 剪枝后的 <span class="math">\\( \alpha \\)</span> 值（按 <span class="math">\\( \alpha \\)</span> 由小到大剪枝）和不纯度：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">model</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">cost_complexity_pruning_path</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">X</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> y_true</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">{'ccp_alphas': array([0.        , 0.00416667, 0.00485577, 0.00488095, ...]),
 'impurities': array([0.        , 0.00833333, 0.02775641, 0.03751832, ...])}</div>
</div>

<p>再次生成决策树时，通过 <code><em>ccp_alpha</em></code> 超参数可以控制决策树生长的阈值，这样就实现了后剪枝。</p>

<h3>决策树与模型可视化</h3>

<p>决策树的一个优点是每一步的决策过程都是透明的，如果有需要的话甚至可以检查决策树的每一步细节。</p>

<p>Scikit-Learn 提供了决策树与 Graphviz 交互的接口。Graphviz 是一个开源的可视化工具包，它可以绘制使用 <code>dot</code> 标记语言描述的包括流程图、关系图在内的各种图表。</p>

<p>可以在 https://graphviz.gitlab.io/download/ 里下载该软件。下载完成后安装到本地，安装时注意要将其添加到系统的环境变量中，这一步的目的是使用它提供的 dot 命令行工具完成文本到图片的编译。</p>

<p>可以使用 Scikit-Learn 提供的工具将模型导出为 <code>.dot</code> 文件：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">from</span><span style="color: #90a4ae;"> sklearn</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">tree </span><span style="color: #39adb5;font-weight: bold;">import</span><span style="color: #90a4ae;"> export_graphviz</span></div><br><div><span style="color: #90a4ae;">export_graphviz</span><span style="color: #39adb5;">(</span></div><div><span style="color: #90a4ae;">&#160; &#160; model</span><span style="color: #39adb5;">,</span></div><div><span style="color: #90a4ae;">&#160; &#160; </span><span style="color: #e53935;">out_file</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">tree.dot</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span></div><div><span style="color: #90a4ae;">&#160; &#160; </span><span style="color: #e53935;">rounded</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">True</span></div><div><span style="color: #39adb5;">)</span></div></div>
</div>

<p>然后在命令行中使用 dot 工具完成图片的输出。可以输出的图片格式有许多种，包括常见的 PNG 、PDF 和 SVG 等：</p>

<div class="codeblock code-console">$ dot -Tpng tree.dot -o tree.png
</div>

<p>输出的决策过程如下：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-graphviz-export-tree.png" alt="" width="610">
</figure>

<p>其中 <code>X[0]</code> 表示样本的第一个特征变量（本例中为横坐标的值）；<code>gini</code> 表示该节点的基尼系数；<code>samples</code> 表示该节点包含的样本数；<code>value</code> 表示该节点中各类别样本的数量。根据这些提供的信息，就能清楚地了解到决策树运作的过程。下图是该决策树最终形成的决策边界：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-graphviz-source-tree.png" alt="" width="420">
</figure>

<h3>决策树回归</h3>

<p>决策树也可以用作回归。这种情况下，每个树叶节点不再预测离散的类别，而是一个连续的值，就像这样：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-tree-regression.png" alt="" width="440">
</figure>

<p>决策树回归与分类的原理是类似的，只不过不再采用基尼系数或熵作为划分的依据，而是均方误差 <span class="math">\\( \text{MSE} \\)</span> 。具体来说，就是在每一次分裂时试图使以下结果最小：</p>

<div class="math">
\\[
    \text{MSE} = \frac{n_{\text{left}}}{n} \text{MSE}_{\text{left}} + \frac{n_{\text{right}}}{n} \text{MSE}_{\text{right}}
\\]
</div>

<p><span class="math">\\( \text{MSE} \\)</span> 是节点中包含的所有样本真实值和预测值差值的和，预测值可以用所有样本的均值来描述。</p>

<p>决策树回归的优点是不用添加额外特征也能拟合曲线数据，但是拟合结果也不是曲线，而是阶跃的直线，并且和分类一样也有着严重的过拟合问题：如果不加约束地生长，决策的最终结果会落到每个值上：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/02/05-tree-regression-overfit.png" alt="" width="660">
</figure>

<p>可以用相同的方式对回归决策树剪枝，或者使用 Graphviz 导出为可视化图片。</p>

<p>总的来说，决策树是一种简单且直观的算法，它只求能够将两类样本分开，而不考虑分类的质量如何。除了容易导致过拟合外，决策树的分类边界也不够理想，不仅均垂直于坐标轴，而且完全没有考虑远离样本的问题，因此对异常值较为敏感。</p>

<p><a rel="nofollow" href="/archives/1020">机器学习-决策树</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/1020/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>机器学习-支持向量机</title>
		<link>/archives/993</link>
					<comments>/archives/993#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 20 Jan 2023 03:41:31 +0000</pubDate>
				<category><![CDATA[机器学习]]></category>
		<guid isPermaLink="false">/?p=993</guid>

					<description><![CDATA[<p>支持向量机的概念 边界问题 在逻辑回归模型中介绍了决&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/993">机器学习-支持向量机</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>支持向量机的概念</h2>

<h3>边界问题</h3>

<p>在<a href="/archives/966">逻辑回归模型</a>中介绍了决策边界的概念，一个好的模型决策边界要将两个类别完全区分开，例如以下这些决策边界都是合理的：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-about-boundary.png" alt="" width="250">
</figure>

<p>那么这就引出了一个问题，即如何在其中选择最佳的决策边界。在逻辑回归中，这条边界线的参数是通过求代价函数的最小值得到的。但直观上理解，一个好的决策边界应该离每个分类群体都尽可能远，这样在引入新的样本时不至于轻易地落到决策边界的另一边。</p>

<p><strong>支持向量机</strong>(support vector machine)使用了一种<em>边界(margin)最大化</em>的思路来解决这个问题，具体来说就是确定这样一条决策边界线，使它到两个分类的距离最远，那么它应该落在两个分类最中间的位置，因此这样的决策边界可以很好地分隔开两个分类，就像这样：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-boundary-margin.png" alt="" width="250">
</figure>

<h3>支持向量机的参数确定</h3>

<p>接下来介绍支持向量机的数学原理，这样可以明确模型到底需要求解什么。支持向量机的原理是让边界最大化，因此优化的最终目标就是求解最大的间距：</p>

<div class="math">
\\[
    \max \quad \text{margin} 
\\]
</div>

<p>这就需要从距离的角度建立模型。在平面中，点到一条直线的距离可以使用公式 <span class="math">\\( \displaystyle{d=\frac{|Ax_0+By_0+C|}{\sqrt{A^2+B^2} }} \\)</span> 计算。该公式可以推广到 3 维及更高维空间中，即点到 n 维度超平面的距离的计算公式为：</p>

<div class="math">
\\[
\begin{align}
    d &= \frac{|w_nx_n+\cdots+w_2x_2+w_1x_1+b|}{\sqrt{w_n^2+\cdots+w_2^2+w_1^2}}\\
      &= \frac{|\boldsymbol{w}^T\boldsymbol{x}+b|}{\|\boldsymbol{w}\|}
\end{align}
\\]
</div>

<p>在 SVM 中，需要确定这样一个直线或平面 <span class="math">\\( \boldsymbol{w}^T\boldsymbol{x}+b=0 \\)</span> ，使得它到两类样本的间距相同且最大，那么间距的计算公式为：</p>

<div class="math">
\\[
    \text{margin} = \underset{i}{\min} \frac{|\boldsymbol{w}^T\boldsymbol{x}_i+b|}{\|\boldsymbol{w}\|} > 0
\\]
</div>

<p>这里最小的意思是间距只取决于离决策边界最近点的计算结果。然后需要找出具有最大边界时的参数 <span class="math">\\( \boldsymbol{w}, b \\)</span> ，那么就需要求解以下目标：</p>

<div class="math">
\\[
    \underset{\boldsymbol{w}, b}{\mathrm{argmax}} \quad \text{margin} \quad \Rightarrow \quad
    \underset{\boldsymbol{w}, b}{\mathrm{argmax}}\frac{1}{\|\boldsymbol{w}\|}(\underset{i}{\min} |\boldsymbol{w}^T\boldsymbol{x}_i+b|)
\\]
</div>

<p>计算最小值时参数向量已经确定了，不影响最小值的计算结果，因此可以将其移到外面处理。因此 SVM 的优化目标为：</p>

<div class="math">
    \\[
        \underset{\boldsymbol{w}, b}{\mathrm{argmax}} \frac{1}{\|\boldsymbol{w}\|}
    \\]
</div>

<blockquote>
    <h4>SVM的优化目标是如何得到的</h4>

    <p>为了明白 SVM 的优化目标为什么是这个，需要弄清到底在求什么。求解的目标就是最大间距，但是间距有两个约束条件：</p>

    <ol>
        <li>所有样本都在间距外，即样本离决策边界最近的距离不小于间距</li>
        <li>决策平面需要落在两类样本之间，能将两类样本区分开</li>
    </ol>

    <p>因此有如下公式及约束条件：</p>

    <div class="math">
    \\[
    \begin{align}
        & \underset{\boldsymbol{w}, b}{\mathrm{argmax}} \quad d \\
        & \text{s.t.} \quad \frac{|\boldsymbol{w}^T\boldsymbol{x}_i+b|}{\|\boldsymbol{w}\|} \geq d > 0 \quad \text{and} \quad
        \begin{cases}
            \boldsymbol{w}^T\boldsymbol{x}_i+b > 0 \quad y_i = +1 \\
            \boldsymbol{w}^T\boldsymbol{x}_i+b < 0 \quad y_i = -1
        \end{cases}
    \end{align}
    \\]
    </div>

    <p>这里将两个分类记作 +1 和 -1，因为分类代表的数字只是一个记号而已，并且这样做可以将第二个约束条件改写为：</p>

    <div class="math">
    \\[
        y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b) > 0
    \\]
    </div>

    <p>这样就可以将约束条件合并为一个：</p>

    <div class="math">
    \\[
        \text{s.t.} \quad \frac{y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b)}{\|\boldsymbol{w}\|} \geq d
    \\]
    </div>

    <p>如果令 <span class="math">\\( k=d \|\boldsymbol{w} \| \\)</span> ，那么有：</p>

    <div class="math">
        \\[
        \begin{align}
            & \underset{\boldsymbol{w}, b}{\mathrm{argmax}} \quad \frac{k}{\|\boldsymbol{w}\|} \\
            & \text{s.t.} \quad y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b) \geq k
        \end{align}
        \\]
    </div>

    <p>可以给参数 <span class="math">\\( \boldsymbol{w}, b \\)</span> 同时乘上 <span class="math">\\( k \\)</span> 从而消去该参数，这样就得到了以上的优化目标。而对参数 <span class="math">\\( \boldsymbol{w}, b \\)</span> 的同步放缩并不会改变优化目标，因为放缩后 <span class="math">\\( \displaystyle{k\boldsymbol{w}^T\boldsymbol{x}_i+kb = 0} \\)</span> 代表的是相同的决策边界，就像 <span class="math">\\( x+2y-3=0 \\)</span> 和 <span class="math">\\( 2x+4y-6=0 \\)</span> 代表的是同一条直线一样。</p>
</blockquote>

<p>就像代价函数一样，一般来说都将最大值问题转换为最小值问题分析，因此最终的目标就是解决以下问题：</p>

<div class="math">
\\[
    \begin{align}
        & \underset{\boldsymbol{w}, b}{\mathrm{argmin}} \, \|\boldsymbol{w}\| \\
        & \text{s.t.} \quad y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b) \geq 1
    \end{align}
\\]
</div>

<p>解决带约束的最值问题一般使用的方法是拉格朗日乘子法。在<a href="#refrence">附录</a>中列出几篇文章，里面有更详细的证明。</p>

<h3>使用SVM</h3>

<p>在 Scikit-Learn 中，支持向量机模型位于 <code>svm</code> 模块中：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">from</span><span style="color: #90a4ae;"> sklearn</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">svm </span><span style="color: #39adb5;font-weight: bold;">import</span><span style="color: #90a4ae;"> SVC</span></div></div>
</div>

<p><code>SVC</code> 即支持向量分类器(classifier)，如果要让它产生线性的决策边界，需要指定参数 <code><em>kernel</em></code> 为 <code>"linear"</code> ：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">model </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> SVC</span><span style="color: #39adb5;">(</span><span style="color: #e53935;">kernel</span><span style="color: #7c4dff;">=</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">linear</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">)</span></div><div><span style="color: #90a4ae;">model</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">fit</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">data</span><span style="color: #39adb5;">[[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">x</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">'</span><span style="color: #91b859;">y</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">]]</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> data</span><span style="color: #39adb5;">[</span><span style="color: #39adb5;">'</span><span style="color: #91b859;">label</span><span style="color: #39adb5;">'</span><span style="color: #39adb5;">])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><div class="sklearn-model"><p>SVC(kernel='linear')</p></div></div>
</div>

<p>之后还会遇到非线性的决策边界。除了 <code>SVC</code> 外，Scikit-Learn 中还提供了 <code>LinearSVC</code> 类，它是专用于线性边界的支持向量分类器，并且带有正则化惩罚项，计算效率比 <code>SVC(<em>kernel</em>="linear")</code> 更快。</p>

<p>之前在介绍模型的原理时介绍过，间距是根据离决策边界最近的样本确定的，这些离决策边界最近的样本称为<strong>支持向量</strong>(support vectors)，所有的支持向量决定了支持向量机所具有的参数。至此可以明白支持向量机的名称由来，这些支持向量一起<em>支撑</em>起了分隔超平面的参数<em>向量</em>。不管模型的样本有多少，只要支持向量不变，那么模型便不发生改变：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-support-vectors.png" alt="" width="640">
    <figcaption>支持向量决定了模型的特点</figcaption>
</figure>

<p>在 Scikit-Learn 中，可以通过 <code>.support_vectors_</code> 参数得到建立模型的所有支持向量，或者通过 <code>.support_</code> 参数得到支持向量在样本中的索引：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">vects </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> model</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">support_vectors_</span></div><div><span style="color: #90a4ae;">vects</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[4.11666667, 0.21666667],
       [2.61666667, 4.7       ],
       [6.18333333, 0.03333333]])</div>
</div>

<h2>支持向量机的注意事项</h2>

<p>支持向量机的原理较为简单，但在使用时也有一些问题需要注意。</p>

<h3>数据标准化</h3>

<p>支持向量机作为一种需要计算距离的模型，可能发生不同特征变量因为量纲级别相差过大导致的问题。为了更好地说明这个问题，以下是一个这样的示例：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-scale-affect.jpg" alt="" width="330">
</figure>

<p>直观上看，深绿色的边界应该能更好地区分两组样本，但计算结果却显示紫色是最好的边界。这是由于纵坐标的量纲明显远大于横坐标的量纲，对距离的影响权重也更大。因此在使用 SVM 之前，需要做<strong>数据标准化</strong>处理，主要目的是使不同特征的量纲级别统一，计算距离时拥有相同的权重。</p>

<p>常用的数据标准化方法有以下两个：</p>

<ol>
    <li>min-max 标准化</li>
</ol>

<p>min-max 标准化也称<strong>离差标准化</strong>，它利用原始数据的最大值和最小值把原始数据转换到 <span class="math">\\( [0,1] \\)</span> 区间内，具体的转换公式为：</p>

<div class="math">
\\[
    x^*=\frac {x-\min}{\max-\min}
\\]
</div>

<p>其中 <span class="math">\\( \max \\)</span> 和 <span class="math">\\( \min \\)</span> 分别为原始数据的最大值和最小值。</p>

<ol start="2">
    <li>z-score 标准化</li>
</ol>

<p>min-max 标准化处理方便，但有一个关键的缺点：如果数据中有远超正常数据取值范围的异常数据的话，那么会使得其它的正常数据被压缩在一个更小的区间内，反而不利于处理。z-score 标准化也称<strong>标准差标准化</strong>，通过原始数据的均值和标准差对数据执行标准化处理。</p>

<p>z-score 标准化后的数据符合标准正态分布，即均值为 0 ，标准差为 1 。它所使用的转换公式如下：</p>

<div class="math">
\\[
    x^* = \frac {x-\text{mean}}{\text{std}}
\\]
</div>

<p>其中 <span class="math">\\( \text{mean} \\)</span> 和 <span class="math">\\( \text{std} \\)</span> 分别为原始数据的均值和标准差。</p>

<p>使用代码对数据做标准化处理的步骤与为数据添加多项式特征的步骤一致：（ min-max 标准化也是一样的，只不过需要用到 <code>MinMaxScaler</code> 类）</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">from</span><span style="color: #90a4ae;"> sklearn</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">preprocessing </span><span style="color: #39adb5;font-weight: bold;">import</span><span style="color: #90a4ae;"> StandardScaler</span></div><br><div><span style="color: #90a4ae;">scalar </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> StandardScaler</span><span style="color: #39adb5;">()</span></div><div><span style="color: #90a4ae;">X_standard </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> scalar</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">fit_transform</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">X</span><span style="color: #39adb5;">)</span></div></div>
</div>

<p>经过标准化处理得到的数据可以被 SVM 更好地划分了：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-standard-scaled-1.png" alt="" width="360">
</figure>

<h3>软间隔</h3>

<p>以上介绍的支持向量机要求两个类别能够被直线分开（线性可分），但有的时候样本未必能被直线完全分开，或者分开的效果并不好。</p>

<p>下图展示了两种这样的情况：左图中由于一个异常样本使得决策边界被大幅改变，而右图中的异常点使得根本不存在这样一个边界能将两类样本完美区分：</p>

<figure class="parallel">
    <div>
        <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-worse-situation.png" alt="" width="340">
        <figcaption>异常样本使边界被不合理地改变</figcaption>
    </div>
    <div>
        <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-worst-situation.png" alt="" width="370">
        <figcaption>异常样本使边界不存在</figcaption>
    </div>
</figure>

<p>相比让间隔完全分开两个类别（硬间隔），适当允许一些样本存在间隔中甚至另一边可以缓解由异常值导致的问题。这种情况下，模型的间隔不再要求一定要硬性分隔两个类别，因此称为软间隔。</p>

<p>为了衡量一个样本与正常分类间隔的偏离程度，需要引入了松弛变量 <span class="math">\\( \xi \\)</span> 。一个样本离它应在的区域越远，则对应的 <span class="math">\\( \xi \\)</span> 也就越大：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-soft-margin-xi.jpg" alt="" width="360">
</figure>

<p>引入松弛变量后，模型的参数需要重新确定，软间隔 SVM 的基本数学形式如下：</p>

<div class="math">
    \\[
        \begin{align}
            & \underset{\boldsymbol{w}, b, \xi}{\mathrm{argmin}} \, \|\boldsymbol{w}\| + C \sum_{i=1}^{n}\xi_i \\
            & \text{s.t.} \quad y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b) \geq 1 - \xi_i , \quad \xi_i \geq 0
        \end{align}
    \\]
</div>

<p>参数 <span class="math">\\( C \\)</span> 用于控制模型的软硬程度：越大的 <span class="math">\\( C \\)</span> 值会使模型的约束更大，<span class="math">\\( \xi_i \\)</span> 也需要更小一些，样本不能超过间隔太多；若 <span class="math">\\( C \\)</span> 为无穷大，则 <span class="math">\\( \xi_i \\)</span> 只能无限接近于 0 ，样本只能在间隔的两边，此时 SVM 变回了硬间隔 SVM 。</p>

<p>在 Scikit-Learn 中，同名超参数 <code><em>C</em></code> 用于控制模型的软硬程度：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-parameter-C.jpg" alt="" width="600">
    <figcaption>超参数 C 用于控制模型的软硬程度</figcaption>
</figure>

<p>通过设置一定的 <code><em>C</em></code> 值，可以使模型更加灵活，避免异常数据带来的不利影响。</p>

<h3>核化SVM</h3>

<p>之前介绍的 SVM 都具有线性边界，但有些时候样本并不能用直线分开，例如：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-poly-boundary-1.png" alt="" width="400">
</figure>

<p>即使将模型设置得足够软，使用直线也无法完全分开两个类别。这时，可以使用在<a href="/archives/966">逻辑回归</a>中提及的方法，为模型添加上非线性特征项，例如多项式特征项：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">model </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> make_pipeline</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">PolynomialFeatures</span><span style="color: #39adb5;">(</span><span style="color: #e53935;">degree</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">),</span></div><div><span style="color: #90a4ae;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; StandardScaler</span><span style="color: #39adb5;">(),</span><span style="color: #90a4ae;"> </span></div><div><span style="color: #90a4ae;">&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; SVC</span><span style="color: #39adb5;">(</span><span style="color: #e53935;">C</span><span style="color: #7c4dff;">=</span><span style="color: #f76d47;">6</span><span style="color: #39adb5;">))</span></div></div>
</div>

<p>此时模型的划分效果为：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-poly-boundary-3.jpg" alt="" width="400">
</figure>

<p>添加非线性特征实现简单，但如果添加的特征较多，会在计算 <span class="math">\\( \boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}_j \\)</span>（参见附录 SVM 的求解）向量内积时速度变慢。</p>

<p>因此这种变换并不是任意的，通过特定的<strong>核函数</strong>(kernel function)可以在为数据添加许多特征后，并没有引入额外特征的计算。具体而言，就是找出这样的函数 <span class="math">\\( k(\boldsymbol{x}, \boldsymbol{y}) = \phi(\boldsymbol{x})^\mathrm{T}\phi(\boldsymbol{y}) \\)</span> ，使得数据由 <span class="math">\\( \boldsymbol{x} \\)</span> 变为 <span class="math">\\( \phi(\boldsymbol{x}) \\)</span> 后，计算 <span class="math">\\( \phi(\boldsymbol{x})^\mathrm{T}\phi(\boldsymbol{y}) \\)</span> 可以化简为计算 <span class="math">\\( \boldsymbol{x}^\mathrm{T}\boldsymbol{y} \\)</span> ，从而使复杂度相同或相近。在使用时只需要定义具体的核函数，这样就不需要定义映射函数 <span class="math">\\( \phi(\boldsymbol{x}) \\)</span> ，从而只需要计算变换后的向量内积，省去了变换过程的开销。</p>

<p>在之前的线性 SVM 中，使用参数 <code><em>kernel</em>="linear"</code> 表示使用线性核函数 <span class="math">\\( k(\boldsymbol{x}, \boldsymbol{y}) = \boldsymbol{x}^\mathrm{T} \boldsymbol{y} \\)</span> ，即不添加任何特征。线性核函数计算速度快，且还存在许多优化算法（例如 <code>LinearSVC</code> 使用的算法），是初次处理数据的首选算法。</p>

<p>除了线性核函数，对于之前的非线性数据可以使用多项式核函数 <span class="math">\\( k(\boldsymbol{x}, \boldsymbol{y}) = (\gamma\boldsymbol{x}^\mathrm{T} \boldsymbol{y} + c)^d \\)</span> 。多项式核函数的特点是可以通过使用不同的 <span class="math">\\( d \\)</span> 控制最高项的次数，从而控制特征映射的复杂度。但一般不建议使用过高的次数，因为这可能使核函数的结果太大或太小。</p>

<p>在 <code>SVC</code> 中，通过指定超参数 <code><em>kernel</em></code> 为 <code>"poly"</code> 可以使用多项式核函数。如果使用多项式核函数，通过超参数 <code><em>degree</em></code> 可以控制最高项的次数（默认为三次）；通过超参数 <code><em>gamma</em></code> 可以控制同名系数；通过超参数 <code><em>coef0</em></code> 可以控制常数项。例如，以下是最高项次数为二次的多项式 <code>SVC</code> 分类边界：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-poly-boundary-2.png" alt="" width="400">
</figure>

<p>要注意的是，为数据引入非线性特征的目的并不是为了得到非线性的分隔面，因为点到曲面的距离难以求得。引入非线性特征的实质是将数据变换到高维空间中，使得变换后的数据在高维空间中线性可分。</p>

<p>为了更好地说明这个问题，接下来看一组示例数据：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-kernelize-explain-1.jpg" alt="" width="400">
</figure>

<p>对于这样的数据，可以采用径向基函数核(Radial Basis Function, RBF，也称高斯核) <span class="math">\\( k(\boldsymbol{x}, \boldsymbol{y}) = \exp(-\gamma\|\boldsymbol{x}-\boldsymbol{y}\|^2) \\)</span> 将其变换到高维空间。高斯核函数的特点是可以映射到无限维的空间中，因此具有很强的表示能力，但是相应的计算速度更慢，也更容易出现过拟合现象。</p>

<p>通过指定超参数 <code><em>kernel</em></code> 为 <code>"rbf"</code> 可以使用高斯核函数，这也是 <code>SVC</code> 默认采用的核函数。采用高斯核函数将原有数据映射到三维空间中，便可以在三维空间中看到数据可以由平面分隔开了：</p>

<figure class="parallel">
    <div>
        <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-kernelize-explain-2.jpg" alt="" width="370">
        <figcaption>将数据用径向基函数核映射到三维使其线性可分</figcaption>
    </div>
    <div>
        <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-kernelize-explain-3.png" alt="" width="370">
        <figcaption>一个更好的视角说明两类样本是如何被线性划分的</figcaption>
    </div>
</figure>

<p>对于更高维的情况也是同理，因为实际数据的维度总是有限的，那么就肯定存在更高维的映射，使数据在更高维的空间中可以被超平面合理地分开。</p>

<p>高斯核函数的另一个优点是可供调节的参数相比多项式核函数更少。唯一的参数 <span class="math">\\( \gamma \\)</span> 用于控制高斯核的平滑程度：越大的 <span class="math">\\( \gamma \\)</span> 将会使高斯核函数变化更剧烈，虽然能更好的拟合数据但会使过拟合风险增大。这对应于 <code>SVC</code> 的 <code><em>gamma</em></code> 参数，下图展示了不同参数取值情况下的分类边界：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-parameter-gamma.jpg" alt="" width="680">
</figure>

<h3>支持向量回归</h3>

<p>支持向量机不仅可以用作分类，还可以用于回归。在用作分类任务时，要求支持向量机规划一条最好的分类边界，使得它尽可能分开两类样本。而用作回归分析时，工作原理则相反：这时要求支持向量机规划一条最好的拟合边界，使得它尽可能包括所有的样本，就像这样：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-svr-concept.png" alt="" width="400">
</figure>

<p>但通过包括所有样本来确定回归直线显然是不合理的，因为受到异常数据的影响很大。为了防止异常值的影响，要求边界不需要包含所有的样本，而是让所有样本都不要偏移边界内太多。</p>

<p>假设分隔面与两边界面的常数项相差 <span class="math">\\( \epsilon \\)</span> ，那么一个样本与边界的偏离程度可以使用以下公式衡量：</p>

<div class="math">
\\[
    \xi_i = \max(|\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i+b-y|-\epsilon, 0)
\\]
</div>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-svr-cost.png" alt="" width="310">
</figure>

<p>如果样本位于边界以内，那么就不算偏离。总的代价函数每一个样本偏离程度的和，再包括正则项：</p>

<div class="math">
    \\[
        \underset{\boldsymbol{w}, b}{\mathrm{argmin}} \quad C \sum_{i=1}^{n} \max(|\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i+b-y|-\epsilon, 0) + \frac 1 2 \|\boldsymbol{w}\|^2
    \\]
</div>

<p>包含正则项后的 SVR 代价函数和 SVC 的代价函数较为相似，可以使用类似的方式求解。</p>

<p>在 Scikit-Learn 中，<code>SVR</code> 和 <code>LinearSVR</code> 是支持向量机的回归版本，后者针对线性模型做了额外的优化。从上文介绍中可以看出，它们有两个较为重要的超参数：</p>

<ul>
    <li><code><em>epsilon</em></code> ：分隔面与两边界的距离（实际上不是距离，而是常数项的差值）</li>
</ul>

<p>由于落在两边界之内的样本不算偏离，对代价函数没有作用，因此 SVR 的支持向量是落在边界之外的样本，所有边界之外的样本才决定了边界的参数。参数 <code><em>epsilon</em></code> 可以看作模型对偏离数据的容忍程度，越大的参数值将会使边界内包含更偏离的数据，但这些不好的数据也会影响回归直线，使其对数据的拟合程度下降。</p>

<p>下图展示了不同 <code><em>epsilon</em></code> 取值下对数据的拟合程度：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-svr-parameter-epsilon.jpg" alt="" width="610">
</figure>

<p>因此一般来说应选用尽量小的 <code><em>epsilon</em></code> 值。<code>SVR</code> 给出的默认值为 0.1 ；而 <code>LinearSVR</code> 给出的默认值为 0.0 ，这时所有数据的偏离程度都需要考虑，支持向量回归退化为和线型回归很相似的模型了。</p>

<ul>
    <li><code><em>C</em></code> ：模型的正则化强度。注意公式中的 <span class="math">\\( C \\)</span> 不是正则项的系数，因此它的值越大正则化程度越低</li>
</ul>

<p>下图展示了不同 <code><em>C</em></code> 取值下对数据的拟合程度：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2023/01/04-output-svr-parameter-C.jpg" alt="" width="610">
</figure>

<p>取值过小时正则化太强，容易发生欠拟合；反之容易发生过拟合。</p>

<p>总的来说，支持向量机是一种可解释性强的分类模型，并可以用作回归。尽管没有用到统计方法，但它有严格的数学理论支撑，在实践中表现良好。支持向量机只取决于是它的少数支持向量，因此占用内存较少，预测新样本的速度也较快。核函数的引入使其不但可以处理各种类型的非线性数据，也可以很好地处理高维数据。</p>

<p>不过支持向量机也有训练时间长，对参数选择依赖较大等缺点，因此一般只在小批量样本上使用它。</p>

<h2 id="appendix">附录</h2>

<h3>SVM求解</h3>

<p>本节简单介绍 SVM 目标问题的求解方法。在<a href="#refrence">参考文献</a>中列出几篇文章，里面有更详细的证明。</p>

<p>首先回顾优化目标：</p>

<div class="math">
\\[
    \begin{align}
        & \underset{\boldsymbol{w}, b}{\mathrm{min}} \, \frac 1 2 \boldsymbol{w}^\mathrm{T}\boldsymbol{w} \\
        & \text{s.t.} \quad 1 - y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b) \leq 0
    \end{align}
\\]
</div>

<p>这是一个有约束条件的最值问题，一般使用拉格朗日乘子法处理这种问题，拉格朗日函数如下：</p>

<div class="math">
\\[
    L(\boldsymbol{w}, b, \lambda) = \frac 1 2 \boldsymbol{w}^\mathrm{T}\boldsymbol{w} + \sum_{i=1}^{n} \lambda_i(1 - y_i(\boldsymbol{w}^T\boldsymbol{x}_i+b))
\\]
</div>

<p>问题转换为求解 <span class="math">\\( \underset{\boldsymbol{w}, b}{\min} \underset{\lambda}{\max} L(\boldsymbol{w}, b, \lambda) \\)</span> 。由于 SVM 满足 KKT 条件，因此它的对偶问题与原问题等价，也就是说可以交换里外的求最值顺序：</p>

<div class="math">
\\[
    \underset{\boldsymbol{w}, b}{\min} \underset{\lambda}{\max} L(\boldsymbol{w}, b, \lambda)
    \Rightarrow
    \underset{\lambda}{\max} \underset{\boldsymbol{w}, b}{\min} L(\boldsymbol{w}, b, \lambda)
\\]
</div>

<p>交换后内侧的最小值问题是对 <span class="math">\\( \boldsymbol{w}, b \\)</span> 的无约束优化问题，可以通过令偏导为零的方式得到：</p>

<div class="math">
\\[
    \begin{align}
        \frac {\partial L}{\partial w} &= 0 \Rightarrow w = \sum_{i=1}^{n} \lambda_i y_i \boldsymbol{x_i} \\
        \frac {\partial L}{\partial b} &= 0 \Rightarrow 0 = \sum_{i=1}^{n} \lambda_i y_i
    \end{align}
\\]
</div>

<p>这时将求解 <span class="math">\\( \boldsymbol{w}, b \\)</span> 的过程转换成与 <span class="math">\\( \lambda \\)</span> 相关的问题，虽然没有得到 <span class="math">\\( b \\)</span> 和 <span class="math">\\( \lambda \\)</span> 的关系，但是可以将该等于作为约束项求解问题。</p>

<p>接下来将结果代入拉格朗日函数中，化简可得优化问题的最终形式：</p>

<div class="math">
\\[
    \begin{align}
        & \underset{\lambda}{\max} \quad L(\boldsymbol{w}, b, \lambda) = \sum_{i=1}^{n}\lambda_i - \frac 1 2 \sum_{i=1}^{n} \sum_{j=1}^{n} \lambda_i \lambda_j y_i y_j \boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}_j \\
        & \text{s.t.} \quad \sum_{i=1}^{n} \lambda_i y_i = 0 \quad \text{and} \quad \lambda_i \geq 0
    \end{align}
\\]
</div>

<p>得到最终结果后，只需将 <span class="math">\\( \boldsymbol{x} \\)</span> 代入，即可得到有关 <span class="math">\\( \lambda_i \\)</span> 的公式。要得到最大的结果，只需要对每个 <span class="math">\\( \lambda_i \\)</span> 求偏导，并令结果等于 0 ，借助约束条件 <span class="math">\\( \displaystyle{\sum_{i=1}^{n} \lambda_i y_i = 0} \\)</span> 就可以得到合适的 <span class="math">\\( \lambda_i \\)</span> 值。从公式中也可以看出，主要的计算量在 <span class="math">\\( \boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}_j \\)</span> 上。</p>

<p>根据得到的 <span class="math">\\( \lambda_i \\)</span> ，代入之前公式就可以计算 <span class="math">\\( \boldsymbol{w} \\)</span> ，而再利用一个支持向量就可以计算参数 <span class="math">\\( b \\)</span> 。</p>

<h3 id="refrence">参考资料/延伸阅读</h3>

<p>
    <a href="https://zhuanlan.zhihu.com/p/480302399">https://zhuanlan.zhihu.com/p/480302399</a><br>
    一份非常非常详细的 SVM 从零推导过程
</p>

<p>
    <a href="https://zhuanlan.zhihu.com/p/24638007">https://zhuanlan.zhihu.com/p/24638007</a><br>
    一篇不错的关于 SVM 原理推导的文章
</p>
<p><a rel="nofollow" href="/archives/993">机器学习-支持向量机</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/993/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>机器学习-逻辑回归</title>
		<link>/archives/966</link>
					<comments>/archives/966#respond</comments>
		
		<dc:creator><![CDATA[Hello]]></dc:creator>
		<pubDate>Fri, 23 Dec 2022 02:51:10 +0000</pubDate>
				<category><![CDATA[机器学习]]></category>
		<guid isPermaLink="false">/?p=966</guid>

					<description><![CDATA[<p>分类算法 上一节介绍了线性回归，线性回归是一种经典的&#46;&#46;&#46;</p>
<p><a rel="nofollow" href="/archives/966">机器学习-逻辑回归</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></description>
										<content:encoded><![CDATA[
<h2>分类算法</h2>

<p><a href="/archives/880">上一节</a>介绍了线性回归，线性回归是一种经典的<em>回归</em>算法，它可以根据一系列自变量来预测因变量的值。</p>

<p><strong>分类</strong>(classification)也是一种常见的需求。分类问题并不要求预测具体的值，而是需要判断样本属于的类别。例如分析一株植物属于哪个物种，或者判断一封邮件是否是垃圾邮件等。分类问题的因变量是离散的，因此无法通过简单的计算阐述结果。</p>

<p>二分类是比较常见的一种分类情况，二分类下每个样本只有两种分类情况（例如某件事是否会发生），因此可以使用布尔值 0 和 1 来描述分类。类似地有多分类，每个样本有多种分类情况。</p>

<p>有许多经典的算法都可以处理分类问题，本节介绍最简单的分类算法之一：逻辑回归。</p>

<h2>逻辑回归</h2>

<h3>逻辑回归的概念</h3>

<p>首先先看一个典型的分类场景。假设有如下的一系列数据，横坐标代表样本某个特征的值，纵坐标代表样本的分类，并且是离散的：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-logistic-intro-1.png" alt="" width="260">
</figure>

<p>在以上示例中，可以很明显看到分类为“ 0 ”的样本特征变量的值都小于 300 ，而分类为“ 1 ”的样本特征变量的都大于 300 。那么就可以用特征变量的值是否大于 300 作为样本分类的依据。</p>

<p>但在稍微复杂一点的场景中，这种简单的逻辑就会失效。例如，考虑以下数据：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-logistic-intro-2.png" alt="" width="260">
</figure>

<p>在 300 附近，样本可能属于分类“ 0 ”也可能属于分类“ 1 ”。但是数据仍然具有这样的规律：当特征变量的值小于 300 较多时，该样本属于分类“ 0 ”；当特征变量的值大于 300 较多时，它属于分类“ 1 ”；但特征变量的值在 300 附近时，它同时可能属于其中的任何一个分类。</p>

<p>那么此时就无法直接确定某些范围样本的分类了。相比起死板地直接分为两类（硬分类），可以使用另一种思路解决这个问题：确定样本属于分类的概率（软分类）。显然，远大于 300 的样本属于分类“ 1 ”的概率更大，远小于 300 的样本属于分类“ 0 ”的概率更大，而接近 300 的样本属于两个样本的概率相差不大。</p>

<p>这就是<strong>逻辑回归</strong>(logistic regression)的基本思路。逻辑回归通过建立一条 <span class="math">\\( y \\)</span> 值分布在 0~1 之间的函数来计算样本的分类概率：<span class="math">\\( y \\)</span> 值表示样本属于分类“ 1 ”的概率，那么 <span class="math">\\( 1-y \\)</span> 就表示样本属于分类“ 0 ”的概率，从而将分类问题转换为回归问题。最终样本的分类也容易确定：如果 <span class="math">\\( y > 0.5 \\)</span> ，那么说明样本更可能属于分类“ 1 ”，反之说明样本更可能属于分类“ 0 ”。</p>

<p>可以使用线性回归拟合一条范围在 0~1 内的直线作为概率函数，类似这样：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-logistic-intro-3.png" alt="" width="260">
</figure>

<p>但是直线比较僵硬，不但不能表示在分界区域概率密度的变化过程，还要在两端将其约束到 0~1 的范围内。一般来说，逻辑回归最常用的概率函数为 sigmoid 函数，这个函数的表达式为：</p>

<div class="math">
\\[
    f(y) = \frac{1}{1 + e^{-y}}
\\]
</div>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-sigmoid-function.png" alt="" width="380">
</figure>

<p>该函数的特点是当 <span class="math">\\( y \\)</span> 离 0 较远时，<span class="math">\\( f(y) \\)</span> 值十分趋近 0 或 1 ；而当 <span class="math">\\( y \\)</span> 接近 0 时，函数由 0 到 1 有一个较为平缓的过渡。并且该函数是中心对称的，因此比较贴近真实情况下的概率分布。</p>

<blockquote>
    <p>逻辑回归使用 sigmoid 函数是经过严格推导后得到的结果，这个 <a href="https://www.quora.com/Logistic-Regression-Why-sigmoid-function/answer/Roi-Yehoshua?target_type=answer">Quora 上的回答</a>从概率分布的角度解释了为什么。</p>
</blockquote>

<h3>决策边界</h3>

<p>注意到 sigmoid 函数在 <span class="math">\\( y=0 \\)</span> 处取得概率 0.5 ，而在两端概率分别小于 0.5 和大于 0.5 ，因此可以说 <span class="math">\\( y=0 \\)</span> 是一个<strong>决策边界</strong>(decision boundary)，位于边界两端的样本将会被分到不同的类别。</p>

<p>在实际应用中，<span class="math">\\( y=0 \\)</span> 并不一定就是区分两个类别的边界条件，而且特征变量的个数也不止一个。这个时候可以使用换元法将自变量变换到实际模型中，由实际情况下的特征变量及其参数组合确定：</p>

<div class="math">
\\[
    y = \theta_n x^n + \theta_{n-1} x^{n-1} + \cdots + \theta_1 x + \theta_0
\\]
</div>

<p>那么实际情况下的概率 <span class="math">\\( h_\theta(y) \\)</span> 将由以下公式确定：</p>

<div class="math">
\\[
\begin{align}
    h_\theta(y) &= \frac{1}{1 + {\large e}^{\displaystyle{-(\theta_n x^n + \theta_{n-1} x^{n-1} + \cdots + \theta_1 x + \theta_0)}}}\\
                &= \frac{1}{1 + {\large e}^{\displaystyle{-\boldsymbol{\theta}^T \boldsymbol{x}}}}
\end{align}
\\]
</div>

<p>此时 <span class="math">\\( \boldsymbol{\theta}^T \boldsymbol{x} = 0 \\)</span> 就是实际情况的一个决策边界：当 <span class="math">\\( \boldsymbol{\theta}^T \boldsymbol{x} > 0 \\)</span> 时，可以预测样本属于类别“ 1 ”；当 <span class="math">\\( \boldsymbol{\theta}^T \boldsymbol{x} < 0 \\)</span> 时，则可以预测样本属于类别“ 0 ”。</p>

<p>通过取用合适的参数 <span class="math">\\( \boldsymbol{\theta} \\)</span> ，可以得到不同的决策边界，从而适应不同的实际情况。例如，对于以下具有两个特征的数据集：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-decision-boundary-intro-1.png" alt="" width="260">
</figure>

<p>可以看出，在这个二维平面上可以作出这样一条直线 <span class="math">\\( \theta_2x_2+\theta_1x_1+\theta_0=0 \\)</span> ，将两种类别的样本分隔在直线两侧，就像这样：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-decision-boundary-intro-2.png" alt="" width="260">
</figure>

<p>但有时候边界可能比较复杂，并不能用直线描述，例如：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-decision-boundary-intro-3.png" alt="" width="260">
</figure>

<p>那么这个时候，可以像在线性回归中处理非线性数据一样，通过引入非线性特征项，在平面上使用曲线例如二次多项式曲线 <span class="math">\\( \theta_2x_2+\theta_{12}x_1^2+\theta_{11}x_1+\theta_0=0 \\)</span> 作为决策边界，将两种类别的样本分隔在曲线两侧，就像这样：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-decision-boundary-intro-4.png" alt="" width="260">
</figure>

<p>这也就说明了线性回归和逻辑回归之间的联系：线性回归主要是拟合实际的数据，而逻辑回归主要是拟合实际的决策边界。逻辑回归模型可以通过设计复杂的曲线，来表达复杂的决策边界，从而适应各种复杂的模型。</p>

<h2>代价函数</h2>

<h3>代价函数的概念</h3>

<p>以上基本已经介绍了逻辑回归模型的基本概念，但是目前还有一个问题没有解决，那就是参数 <span class="math">\\( \boldsymbol{\theta} \\)</span> 还没有确定。</p>

<p>在线性回归中，确定参数的方式是让拟合的直线最贴近原始的数据，使预测值和真实值的差异（即<em>残差</em>）平方和最小。之所以要附加一个平方，是因为残差可正可负，通过平方可以消除符号带来的影响。</p>

<p>使用残差平方和，可以建立一个具体的指标来描述数据和模型的拟合程度：当残差平方和最小，说明预测值和真实值的差异最小，回归直线的拟合更好。并且这个指标是具体的，易于通过程序计算最小值。</p>

<p>这种衡量模型与实际样本误差指标的函数称为成本函数或<strong>代价函数</strong>(cost function)，当代价函数取值最小时，说明模型与实际值的误差就最小，那么模型拟合效果就最好。</p>

<p>为了确定最好的逻辑回归模型，也需要一个类似的代价函数去描述它的误差。类似线性回归，同样可以使用预测值和真实值的差值作为样本的误差，只不过预测值是连续的概率，而真实值是连续的类型。这样，每个样本的代价函数定义为：</p>

<div class="math">
\\[
    \mathrm{cost}(h_\theta (\boldsymbol{x}), y) = \begin{cases}
        -\log(h_\theta (\boldsymbol{x})) & \text{if} \quad y = 1 \\
        -\log(1 - h_\theta (\boldsymbol{x})) & \text{if} \quad y = 0
    \end{cases}
\\]
</div>

<p>逻辑回归计算的概率是相对类型“ 1 ”而言的，因此对于类型“ 0 ”的概率要用 1 减去该值。取对数的原因是为了让概率接近 1（与实际分类结果接近）时，误差将变得很小；而概率接近 0（完全分错类了）时，误差将变得非常大，从而防止为了让边界上的一些样本取得更大的概率错误地挪动边界，而将某个样本置于明显错误的位置的情况。最后考虑到误差越小，代价函数也应该越小，再给对数结果取相反值。</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-cost-function-why-log.png" alt="" width="440">
    <figcaption>为什么要取对数：严格的计算表明不取对数时会使用不好的决策边界</figcaption>
</figure>

<p>最终整个模型的代价函数是每个样本代价函数的和，有时再除去样本个数：</p>

<div class="math">
\\[
    J(\boldsymbol{\theta}) = \frac 1 n \sum_{i=1}^{n} \mathrm{cost}(h_\theta (\boldsymbol{x_i}), y_i)
\\]
</div>

<p>为了让模型最贴近实际样本，需要让代价函数最小，也就是让代价函数的导数等于 0 。但是没有直接得出结果的公式（闭式解），因此需要别的方法来得出最小值。下面介绍一个使用最广泛的方法：梯度下降法。</p>

<h3>梯度下降</h3>

<p>假设一个人被困在遍布密林的深山中，无法判断当前所处的位置，那么快速下山的一种策略就是沿着最陡的方向下坡。这就是<strong>梯度下降</strong>(gradient descent)法的基本原理：通过计算当前参数 <span class="math">\\( \boldsymbol{\theta} \\)</span> 下代价函数的局部梯度，并不断沿着降低梯度的方向调整参数 <span class="math">\\( \boldsymbol{\theta} \\)</span> ，直到梯度降为 0 ，说明代价函数取得极小值：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-gradient-descent.png" alt="" width="440">
    <figcaption>图片来源于网络</figcaption>
</figure>

<p>第一个 <span class="math">\\( \boldsymbol{\theta} \\)</span> 值可以随机选择，每次执行梯度下降都会使代价函数降低一些。最终收敛得到一个极小值：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-gradient-descent-steps.png" alt="" width="300">
</figure>

<p>不同的梯度下，参数沿着能让代价函数下降方向改变的步长也不一样：如果梯度较平缓，那么步长应该小一些，以免错过了极小值。步长的改变量取决于<strong>学习率</strong>(learning rate)，学习率越高则参数的改变程度也越大，具体由以下公式确定：</p>

<div class="math">
    \\[
        \theta_j \Leftarrow \theta_j - \alpha \frac{\partial}{\partial \theta_j}J(\theta)
    \\]
</div>

<p>可以看出，学习率对梯度下降结果很重要：低下的学习率将会使算法需要太多次迭代才能达到极值点，而过高的学习率则可能使算法直接越过极值点到达对坡面，甚至在这一过程中发散而永远无法到达极值点：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-gradient-descent-steps-bad-1.png" alt="" width="540">
</figure>

<p>并且梯度下降得到的是极值点，但未必是最值点，下图展示了这种情况：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-gradient-descent-steps-bad-2.png" alt="" width="320">
</figure>

<p>这就要求代价函数尽量是一个凸(convex)函数，它的极值就是最值。凸函数也便于自动计算合适的学习率。可以证明逻辑回归的代价函数是一个凸函数，它求偏导的结果如下：（省略过程）</p>

<div class="math">
\\[
    \frac{\partial}{\partial \theta_j}J(\theta)=\frac 1 n \sum_{i=1}^{n}[h_\theta(x_i)-y_i]x_{i(j)}
\\]
</div>

<p>因此逻辑回归可以很好地使用梯度下降算法得到具有最小误差的最好模型。下图展示了一个逻辑回归模型是如何从最开始的随机参数，经由梯度下降收敛到最优参数的：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-output-gradient-descent-steps.png" alt="" width="380">
</figure>

<p>总的来说，梯度下降是一种非常通用的优化算法，适用于很多找最优解的问题中。梯度下降也有许多改进版本，进一步拓宽了它的适用范围。</p>

<h3>正则化下的逻辑回归模型</h3>

<p>在线性回归模型中介绍过在拟合现有数据时可能因为设置太高次项而导致的过拟合问题，在逻辑回归中也可能存在这种情况。例如，以下是某个逻辑回归模型中因为异常数据而带来的过拟合：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-logistic-overfitting.jpg" alt="" width="390">
</figure>

<p>这个决策边界显然是不合理的。可以像线性回归一样给代价函数加上正则化约束项，从而防止决策边界取得过大的参数而过于复杂。</p>

<p>具体来说，常用的正则化项有如下两个：</p>

<ol>
    <li>L1 正则化项：<span class="math">\\( \displaystyle{\frac{\alpha}{2n}\sum_{j=0}^{n}\theta_j^2} \\)</span></li>
    <li>L2 正则化项：<span class="math">\\( \displaystyle{\frac{\alpha}{2n}\sum_{j=0}^{n}|\theta_j|} \\)</span></li>
</ol>

<p>这实际上就是线性回归中介绍的岭回归和 LASSO 回归使用的正则化项。以下是使用正则化项后的模型，可以看到过拟合的情况明显改善了很多：</p>

<figure>
    <img decoding="async" src="/wordpress/wp-content/uploads/2022/12/02-logistic-overfitting-prevent.jpg" alt="" width="390">
</figure>

<h3>Scikit-Learn中的逻辑回归模型</h3>

<p>最后简单介绍使用 Scikit-Learn 建立逻辑回归模型的方法，它和线型回归模型遵循同样的接口，例如建立模型：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #39adb5;font-weight: bold;">from</span><span style="color: #90a4ae;"> sklearn</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">linear_model </span><span style="color: #39adb5;font-weight: bold;">import</span><span style="color: #90a4ae;"> LogisticRegression</span></div><br><div><span style="color: #90a4ae;">model </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> LogisticRegression</span><span style="color: #39adb5;">()</span></div><div><span style="color: #90a4ae;">model</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">fit</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">X</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> y</span><span style="color: #39adb5;">)</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output"><div class="sklearn-model"><p>LogisticRegression()</p></div></div>
</div>

<p>以及对新的样本作出预测，由于逻辑回归是解决分类问题，因此预测得到的是一个离散的结果：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">model</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">predict</span><span style="color: #39adb5;">([[</span><span style="color: #f76d47;">270</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">295</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">305</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">320</span><span style="color: #39adb5;">]])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 0, 1, 1])</div>
</div>

<p>逻辑回归的特点就是使用概率确定所属的分类，在代码中可以使用 <code>.predict_proba()</code> 方法来获取这个概率：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">model</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">predict_proba</span><span style="color: #39adb5;">([[</span><span style="color: #f76d47;">270</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">297</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">300</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">320</span><span style="color: #39adb5;">]])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([[9.99411784e-01, 5.88216310e-04],
       [6.59217705e-01, 3.40782295e-01],
       [4.76691144e-01, 5.23308856e-01],
       [5.97572205e-03, 9.94024278e-01]])</div>
</div>

<p>相比线性回归，逻辑回归模型多了很多超参数，其中许多参数都涉及本文介绍的内容，接下来介绍其中的一部分：</p>

<div class="codeblock code-template">
LogisticRegression(<br>
&nbsp; &nbsp; <em>penalty</em>="l2",<br>
&nbsp; &nbsp; <em>l1_ratio</em>=None,<br>
&nbsp; &nbsp; <em>C</em>=1.0,<br>
&nbsp; &nbsp; <em>tol</em>=1e-4,<br>
&nbsp; &nbsp; <em>max_iter</em>=100,<br>
&nbsp; &nbsp; <em>verbose</em>=0,<br>
&nbsp; &nbsp; <em>multi_class</em>="auto"<br>
)
</div>

<p>参数 <code><em>penalty</em></code> 指定使用的正则化项，如果设置为 <code>"none"</code> 代表不使用正则化。除了前面介绍的 <code>"l1"</code> 和 <code>"l2"</code> 两种正则化之外，还可以使用一种称为“弹性网络” <code>"elasticnet"</code> 的正则化项，它是 L1 和 L2 的混合形式，参数 <code><em>l1_ratio</em></code> 就控制着这种混合比例。参数 <code><em>C</em></code> 是大于 0 的正则化强度，但注意它不是系数，在这里值越小代表正则化效果越强。</p>

<p>前文介绍了逻辑回归使用梯度下降的方式优化系数。但浮点运算并不是完全精确的，往往不会出现导数正好为 0 的情况。参数 <code><em>tol</em></code> 决定了它的收敛条件：如果相邻两次计算的步长小于这个值，说明结果已经足够精确，可以不继续算下去。如果达到了 <code><em>max_iter</em></code> 代表的最大迭代次数还是无法找到这样一个收敛条件，那么说明模型可能存在问题，则停止继续计算。</p>

<p><code><em>verbose</em></code> 是一个较为通用的参数，启用后会输出一些运算过程信息，并且数字越大，信息也越多。</p>

<p>以上介绍的逻辑回归只能处理二分类问题，但无法解决多个分类的情况，原因在于所使用的概率函数不能同时描述多个分类的概率。如果尝试使用 Scikit-Learn 中的逻辑回归模型处理多分类问题，会发现它仍然可以正常工作并得到较为正确的结果：</p>

<div class="jupyter codeblock">
    <div class="jupyter-mark-in"></div>
    <div class="vscode-block"><div><span style="color: #90a4ae;">X </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">array</span><span style="color: #39adb5;">([</span><span style="color: #f76d47;">267</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">273</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">278</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">319</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">325</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">333</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">435</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">447</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">456</span><span style="color: #39adb5;">]).</span><span style="color: #90a4ae;">reshape</span><span style="color: #39adb5;">(</span><span style="color: #7c4dff;">-</span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">)</span></div><div><span style="color: #90a4ae;">y </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> np</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">array</span><span style="color: #39adb5;">([</span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">0</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">1</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> </span><span style="color: #f76d47;">2</span><span style="color: #39adb5;">])</span></div><div><span style="color: #90a4ae;">model </span><span style="color: #7c4dff;">=</span><span style="color: #90a4ae;"> LogisticRegression</span><span style="color: #39adb5;">().</span><span style="color: #90a4ae;">fit</span><span style="color: #39adb5;">(</span><span style="color: #90a4ae;">X</span><span style="color: #39adb5;">,</span><span style="color: #90a4ae;"> y</span><span style="color: #39adb5;">)</span></div><div><span style="color: #90a4ae;">model</span><span style="color: #39adb5;">.</span><span style="color: #90a4ae;">predict</span><span style="color: #39adb5;">([[</span><span style="color: #f76d47;">270</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">320</span><span style="color: #39adb5;">],</span><span style="color: #90a4ae;"> </span><span style="color: #39adb5;">[</span><span style="color: #f76d47;">440</span><span style="color: #39adb5;">]])</span></div></div>
    <div class="jupyter-mark-out"></div>
    <div class="jupyter-output">array([0, 1, 2])</div>
</div>

<p>参数 <code><em>multi_class</em></code> 就是为了解决多分类问题而设置的。接下来介绍如何使用逻辑回归处理多分类问题。</p>

<h2>多分类下的逻辑回归</h2>

<h3>一对多方法</h3>

<p>为了实现多分类，可以使用一种简单的变换方法：将多分类模型转换为多个二分类模型。具体来说，假设有 A 、B 、C 三个分类，那么可以使用以下三个模型描述它：</p>

<ol>
    <li>属于(1)和不属于(0)分类 A</li>
    <li>属于(1)和不属于(0)分类 B</li>
    <li>属于(1)和不属于(0)分类 C</li>
</ol>

<p>可以单独建立这几个二分类模型，对于每个模型都将另外两类看成一个整体，然后组合它们得到的结果：如果在模型 1 中“属于(1)”的分数比模型 2 和 3 的“属于(1)”都高，那么说明更可能属于分类 A 。</p>

<p>这等价于参数 <code><em>multi_class</em>="ovr"</code> 。</p>

<h3>softmax回归</h3>

<p>还有一种方法也可以处理多分类情况：既然之前使用的概率函数不能同时描述多个分类的概率，那么也可以更换一个概率函数。具体说来，可以将概率函数转换为更贴近概率定义的分数形式：</p>

<div class="math">
\\[
    P(y=k)=\frac{\displaystyle{{\Large e}^{\displaystyle{s_k(\boldsymbol{x})}}}}{\displaystyle{\sum_{j=1}^{K} {\Large e}^{\displaystyle{s_j(\boldsymbol{x})}}}}
\\]
</div>

<p>这种形式的逻辑回归称为 softmax 回归，它本质上是逻辑回归的推广形式。对于每一个类别，softmax 回归都使用不同的参数去表示它的概率形式：</p>

<div class="math">
\\[
    s_k(\boldsymbol{x}) = \boldsymbol{x}^T\boldsymbol{\theta}_k
\\]
</div>

<p>这等价于参数 <code><em>multi_class</em>="multinomial"</code> 。但很明显，这种新的概率函数不能再用之前的代价函数去描述它的误差了，并且新的代价函数也不能像之前的函数那么定义：概率最多就为 1 ，根据无法表达与类别“ 2 ”的误差。一般来说，softmax 回归使用交叉熵作为它的代价函数，其公式如下：</p>

<div class="math">
\\[
    J(\boldsymbol{\Theta}) = - \frac 1 n \sum_{i=1}^{n}\sum_{k=1}^{K} y_k^{(i)}\log (P(y^{(i)} = k))
\\]
</div>

<p>注意这里使用参数矩阵 <span class="math">\\( \boldsymbol{\Theta} \\)</span> 来存储每个类别的参数向量 <span class="math">\\( \boldsymbol{\theta} \\)</span> 。</p>

<!--如果想知道为什么 softmax 回归这样定义以及为什么使用交叉熵作为代价函数，请参阅相关资料。-->

<p>总的来说，逻辑回归作为一种简单的分类算法，模型简单且数学上易于分析，具有运算速度快，对预处理要求少，可以得出概率便于进一步分析等优点。不过逻辑回归的实际分类准确率并不高，特别是可能无法处理一个分类形成多个群落的情况，因此一般只用于处理简单的分类问题。</p>
<p><a rel="nofollow" href="/archives/966">机器学习-逻辑回归</a>最先出现在<a rel="nofollow" href="">冰封残烛的个人小站</a>。</p>
]]></content:encoded>
					
					<wfw:commentRss>/archives/966/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
